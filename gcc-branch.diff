Index: configure
===================================================================
--- configure	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ configure	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -5117,7 +5117,7 @@
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $acx_cv_cc_gcc_supports_ada" >&5
 $as_echo "$acx_cv_cc_gcc_supports_ada" >&6; }
 
-if test x$GNATBIND != xno && test x$GNATMAKE != xno && test x$acx_cv_cc_gcc_supports_ada != xno; then
+if test "x$GNATBIND" != xno && test "x$GNATMAKE" != xno && test x$acx_cv_cc_gcc_supports_ada != xno; then
   have_gnat=yes
 else
   have_gnat=no
@@ -6944,10 +6944,6 @@
     extra_arflags_for_target=" -X32_64"
     extra_nmflags_for_target=" -B -X32_64"
     ;;
-  *-*-darwin[3-9]*)
-    # ranlib before Darwin10 requires the -c flag to look at common symbols.
-    extra_ranlibflags_for_target=" -c"
-    ;;
   mips*-*-pe | sh*-*-pe | *arm-wince-pe)
     target_makefile_frag="config/mt-wince"
     ;;
Index: Makefile.in
===================================================================
--- Makefile.in	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ Makefile.in	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -60017,6 +60017,7 @@
 install-gcc: maybe-install-fixincludes
 install-gcc: maybe-install-lto-plugin
 install-strip-gcc: maybe-install-strip-fixincludes
+install-strip-gcc: maybe-install-strip-lto-plugin
 configure-libcpp: configure-libiberty
 
 configure-stage1-libcpp: configure-stage1-libiberty
Index: libgcc/config.host
===================================================================
--- libgcc/config.host	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libgcc/config.host	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -145,15 +145,6 @@
   asm_hidden_op=.private_extern
   tmake_file="t-darwin ${cpu_type}/t-darwin t-slibgcc-darwin"
   ;;
-*-*-freebsd[12] | *-*-freebsd[12].* | *-*-freebsd*aout*)
-  # This is the place-holder for the generic a.out configuration
-  # of FreeBSD.  No actual configuration resides here since
-  # there was only ever a bare-bones ix86 configuration for
-  # a.out and it exists solely in the machine-specific section.
-  # This place-holder must exist to avoid dropping into
-  # the generic ELF configuration of FreeBSD (i.e. it must be
-  # ordered before that section).
-  ;;
 *-*-freebsd*)
   # This is the generic ELF configuration of FreeBSD.  Later
   # machine-specific sections may refine and add to this
Index: libgcc/generic-morestack.c
===================================================================
--- libgcc/generic-morestack.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libgcc/generic-morestack.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -459,8 +459,8 @@
   sigemptyset (&__morestack_initial_sp.mask);
 
   sigfillset (&__morestack_fullmask);
-#ifdef __linux__
-  /* On Linux, the first two real time signals are used by the NPTL
+#ifdef __GLIBC__
+  /* In glibc, the first two real time signals are used by the NPTL
      threading library.  By taking them out of the set of signals, we
      avoiding copying the signal mask in pthread_sigmask.  More
      importantly, pthread_sigmask uses less stack space on x86_64.  */
Index: libgcc/ChangeLog
===================================================================
--- libgcc/ChangeLog	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libgcc/ChangeLog	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1,3 +1,16 @@
+2011-12-15  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2011-12-14  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* generic-morestack.c (__generic_morestack_set_initial_sp): Check
+	__GLIBC__ instead of __linux__ when using __SIGRTMIN.
+
+2011-11-23  Gerald Pfeifer  <gerald@pfeifer.com>
+
+	* config.host (*-*-freebsd[12], *-*-freebsd[12].*,
+	*-*-freebsd*aout*): Remove.
+
 2011-10-26  Release Manager
 
 	* GCC 4.6.2 released.
Index: libtool.m4
===================================================================
--- libtool.m4	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libtool.m4	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -2273,7 +2273,7 @@
     objformat=`/usr/bin/objformat`
   else
     case $host_os in
-    freebsd[[123]]*) objformat=aout ;;
+    freebsd[[23]].*) objformat=aout ;;
     *) objformat=elf ;;
     esac
   fi
@@ -2291,7 +2291,7 @@
   esac
   shlibpath_var=LD_LIBRARY_PATH
   case $host_os in
-  freebsd2*)
+  freebsd2.*)
     shlibpath_overrides_runpath=yes
     ;;
   freebsd3.[[01]]* | freebsdelf3.[[01]]*)
@@ -4804,7 +4804,7 @@
       ;;
 
     # Unfortunately, older versions of FreeBSD 2 do not have this feature.
-    freebsd2*)
+    freebsd2.*)
       _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
       _LT_TAGVAR(hardcode_direct, $1)=yes
       _LT_TAGVAR(hardcode_minus_L, $1)=yes
@@ -5751,7 +5751,7 @@
         esac
         ;;
 
-      freebsd[[12]]*)
+      freebsd2.*)
         # C++ shared libraries reported to be fairly broken before
 	# switch to ELF
         _LT_TAGVAR(ld_shlibs, $1)=no
Index: libgomp/configure
===================================================================
--- libgomp/configure	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libgomp/configure	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -9317,7 +9317,7 @@
       ;;
 
     # Unfortunately, older versions of FreeBSD 2 do not have this feature.
-    freebsd2*)
+    freebsd2.*)
       archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
       hardcode_direct=yes
       hardcode_minus_L=yes
@@ -10230,7 +10230,7 @@
     objformat=`/usr/bin/objformat`
   else
     case $host_os in
-    freebsd[123]*) objformat=aout ;;
+    freebsd[23].*) objformat=aout ;;
     *) objformat=elf ;;
     esac
   fi
@@ -10248,7 +10248,7 @@
   esac
   shlibpath_var=LD_LIBRARY_PATH
   case $host_os in
-  freebsd2*)
+  freebsd2.*)
     shlibpath_overrides_runpath=yes
     ;;
   freebsd3.[01]* | freebsdelf3.[01]*)
@@ -13164,7 +13164,7 @@
       ;;
 
     # Unfortunately, older versions of FreeBSD 2 do not have this feature.
-    freebsd2*)
+    freebsd2.*)
       archive_cmds_FC='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
       hardcode_direct_FC=yes
       hardcode_minus_L_FC=yes
@@ -13869,7 +13869,7 @@
     objformat=`/usr/bin/objformat`
   else
     case $host_os in
-    freebsd[123]*) objformat=aout ;;
+    freebsd[23].*) objformat=aout ;;
     *) objformat=elf ;;
     esac
   fi
@@ -13887,7 +13887,7 @@
   esac
   shlibpath_var=LD_LIBRARY_PATH
   case $host_os in
-  freebsd2*)
+  freebsd2.*)
     shlibpath_overrides_runpath=yes
     ;;
   freebsd3.[01]* | freebsdelf3.[01]*)
Index: libgomp/ChangeLog
===================================================================
--- libgomp/ChangeLog	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libgomp/ChangeLog	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1,3 +1,7 @@
+2011-11-20  Andreas Tobler  <andreast@fgznet.ch>
+
+	* configure: Regenerate.
+
 2011-10-26  Release Manager
 
 	* GCC 4.6.2 released.
Index: libquadmath/configure
===================================================================
--- libquadmath/configure	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libquadmath/configure	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -8727,7 +8727,7 @@
       ;;
 
     # Unfortunately, older versions of FreeBSD 2 do not have this feature.
-    freebsd2*)
+    freebsd2.*)
       archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
       hardcode_direct=yes
       hardcode_minus_L=yes
@@ -9643,7 +9643,7 @@
     objformat=`/usr/bin/objformat`
   else
     case $host_os in
-    freebsd[123]*) objformat=aout ;;
+    freebsd[23].*) objformat=aout ;;
     *) objformat=elf ;;
     esac
   fi
@@ -9661,7 +9661,7 @@
   esac
   shlibpath_var=LD_LIBRARY_PATH
   case $host_os in
-  freebsd2*)
+  freebsd2.*)
     shlibpath_overrides_runpath=yes
     ;;
   freebsd3.[01]* | freebsdelf3.[01]*)
Index: libquadmath/ChangeLog
===================================================================
--- libquadmath/ChangeLog	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libquadmath/ChangeLog	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1,3 +1,7 @@
+2011-11-20  Andreas Tobler  <andreast@fgznet.ch>
+
+	* configure: Regenerate.
+
 2011-10-26  Release Manager
 
 	* GCC 4.6.2 released.
Index: gcc/doc/invoke.texi
===================================================================
--- gcc/doc/invoke.texi	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/doc/invoke.texi	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -7527,8 +7527,8 @@
 bodies are read from these ELF sections and instantiated as if they
 had been part of the same translation unit.
 
-To use the link-timer optimizer, @option{-flto} needs to be specified at
-compile time and during the final link.  For example,
+To use the link-time optimizer, @option{-flto} needs to be specified at
+compile time and during the final link.  For example:
 
 @smallexample
 gcc -c -O2 -flto foo.c
@@ -7536,25 +7536,25 @@
 gcc -o myprog -flto -O2 foo.o bar.o
 @end smallexample
 
-The first two invocations to GCC will save a bytecode representation
+The first two invocations to GCC save a bytecode representation
 of GIMPLE into special ELF sections inside @file{foo.o} and
-@file{bar.o}.  The final invocation will read the GIMPLE bytecode from
-@file{foo.o} and @file{bar.o}, merge the two files into a single
-internal image, and compile the result as usual.  Since both
+@file{bar.o}.  The final invocation reads the GIMPLE bytecode from
+@file{foo.o} and @file{bar.o}, merges the two files into a single
+internal image, and compiles the result as usual.  Since both
 @file{foo.o} and @file{bar.o} are merged into a single image, this
-causes all the inter-procedural analyses and optimizations in GCC to
+causes all the interprocedural analyses and optimizations in GCC to
 work across the two files as if they were a single one.  This means,
-for example, that the inliner will be able to inline functions in
+for example, that the inliner is able to inline functions in
 @file{bar.o} into functions in @file{foo.o} and vice-versa.
 
-Another (simpler) way to enable link-time optimization is,
+Another (simpler) way to enable link-time optimization is:
 
 @smallexample
 gcc -o myprog -flto -O2 foo.c bar.c
 @end smallexample
 
-The above will generate bytecode for @file{foo.c} and @file{bar.c},
-merge them together into a single GIMPLE representation and optimize
+The above generates bytecode for @file{foo.c} and @file{bar.c},
+merges them together into a single GIMPLE representation and optimizes
 them as usual to produce @file{myprog}.
 
 The only important thing to keep in mind is that to enable link-time
@@ -7564,30 +7564,22 @@
 To make whole program optimization effective, it is necessary to make
 certain whole program assumptions.  The compiler needs to know
 what functions and variables can be accessed by libraries and runtime
-outside of the link time optimized unit.  When supported by the linker,
-the linker plugin (see @option{-fuse-linker-plugin}) passes to the
-compiler information about used and externally visible symbols.  When
+outside of the link-time optimized unit.  When supported by the linker,
+the linker plugin (see @option{-fuse-linker-plugin}) passes information
+to the compiler about used and externally visible symbols.  When
 the linker plugin is not available, @option{-fwhole-program} should be
-used to allow the compiler to make these assumptions, which will lead
+used to allow the compiler to make these assumptions, which leads
 to more aggressive optimization decisions.
 
 Note that when a file is compiled with @option{-flto}, the generated
-object file will be larger than a regular object file because it will
-contain GIMPLE bytecodes and the usual final code.  This means that
-object files with LTO information can be linked as a normal object
-file.  So, in the previous example, if the final link is done with
+object file is larger than a regular object file because it 
+contains GIMPLE bytecodes and the usual final code.  This means that
+object files with LTO information can be linked as normal object
+files; if @option{-flto} is not passed to the linker, no
+interprocedural optimizations are applied.
 
-@smallexample
-gcc -o myprog foo.o bar.o
-@end smallexample
-
-The only difference will be that no inter-procedural optimizations
-will be applied to produce @file{myprog}.  The two object files
-@file{foo.o} and @file{bar.o} will be simply sent to the regular
-linker.
-
 Additionally, the optimization flags used to compile individual files
-are not necessarily related to those used at link-time.  For instance,
+are not necessarily related to those used at link time.  For instance,
 
 @smallexample
 gcc -c -O0 -flto foo.c
@@ -7595,37 +7587,42 @@
 gcc -o myprog -flto -O3 foo.o bar.o
 @end smallexample
 
-This will produce individual object files with unoptimized assembler
-code, but the resulting binary @file{myprog} will be optimized at
-@option{-O3}.  Now, if the final binary is generated without
-@option{-flto}, then @file{myprog} will not be optimized.
+This produces individual object files with unoptimized assembler
+code, but the resulting binary @file{myprog} is optimized at
+@option{-O3}.  If, instead, the final binary is generated without
+@option{-flto}, then @file{myprog} is not optimized.
 
-When producing the final binary with @option{-flto}, GCC will only
-apply link-time optimizations to those files that contain bytecode.
+When producing the final binary with @option{-flto}, GCC only
+applies link-time optimizations to those files that contain bytecode.
 Therefore, you can mix and match object files and libraries with
-GIMPLE bytecodes and final object code.  GCC will automatically select
+GIMPLE bytecodes and final object code.  GCC automatically selects
 which files to optimize in LTO mode and which files to link without
 further processing.
 
-There are some code generation flags that GCC will preserve when
+There are some code generation flags that GCC preserves when
 generating bytecodes, as they need to be used during the final link
 stage.  Currently, the following options are saved into the GIMPLE
 bytecode files: @option{-fPIC}, @option{-fcommon} and all the
 @option{-m} target flags.
 
-At link time, these options are read-in and reapplied.  Note that the
-current implementation makes no attempt at recognizing conflicting
-values for these options.  If two or more files have a conflicting
-value (e.g., one file is compiled with @option{-fPIC} and another
-isn't), the compiler will simply use the last value read from the
-bytecode files.  It is recommended, then, that all the files
-participating in the same link be compiled with the same options.
+At link time, these options are read in and reapplied.  Note that the
+current implementation makes no attempt to recognize conflicting
+values for these options.  If different files have conflicting option
+values (e.g., one file is compiled with @option{-fPIC} and another
+isn't), the compiler simply uses the last value read from the
+bytecode files.  It is recommended, then, that you compile all the files
+participating in the same link with the same options.
 
+If LTO encounters objects with C linkage declared with incompatible
+types in separate translation units to be linked together (undefined
+behavior according to ISO C99 6.2.7), a non-fatal diagnostic may be
+issued.  The behavior is still undefined at runtime.
+
 Another feature of LTO is that it is possible to apply interprocedural
 optimizations on files written in different languages.  This requires
-some support in the language front end.  Currently, the C, C++ and
+support in the language front end.  Currently, the C, C++ and
 Fortran front ends are capable of emitting GIMPLE bytecodes, so
-something like this should work
+something like this should work:
 
 @smallexample
 gcc -c -flto foo.c
@@ -7637,49 +7634,43 @@
 Notice that the final link is done with @command{g++} to get the C++
 runtime libraries and @option{-lgfortran} is added to get the Fortran
 runtime libraries.  In general, when mixing languages in LTO mode, you
-should use the same link command used when mixing languages in a
-regular (non-LTO) compilation.  This means that if your build process
-was mixing languages before, all you need to add is @option{-flto} to
+should use the same link command options as when mixing languages in a
+regular (non-LTO) compilation; all you need to add is @option{-flto} to
 all the compile and link commands.
 
-If LTO encounters objects with C linkage declared with incompatible
-types in separate translation units to be linked together (undefined
-behavior according to ISO C99 6.2.7), a non-fatal diagnostic may be
-issued.  The behavior is still undefined at runtime.
-
 If object files containing GIMPLE bytecode are stored in a library archive, say
 @file{libfoo.a}, it is possible to extract and use them in an LTO link if you
-are using a linker with linker plugin support.  To enable this feature, use
-the flag @option{-fuse-linker-plugin} at link-time:
+are using a linker with plugin support.  To enable this feature, use
+the flag @option{-fuse-linker-plugin} at link time:
 
 @smallexample
 gcc -o myprog -O2 -flto -fuse-linker-plugin a.o b.o -lfoo
 @end smallexample
 
-With the linker plugin enabled, the linker will extract the needed
-GIMPLE files from @file{libfoo.a} and pass them on to the running GCC
+With the linker plugin enabled, the linker extracts the needed
+GIMPLE files from @file{libfoo.a} and passes them on to the running GCC
 to make them part of the aggregated GIMPLE image to be optimized.
 
-If you are not using a linker with linker plugin support and/or do not 
-enable linker plugin then the objects inside @file{libfoo.a}
-will be extracted and linked as usual, but they will not participate
+If you are not using a linker with plugin support and/or do not
+enable the linker plugin, then the objects inside @file{libfoo.a}
+are extracted and linked as usual, but they do not participate
 in the LTO optimization process.
 
-Link time optimizations do not require the presence of the whole program to
+Link-time optimizations do not require the presence of the whole program to
 operate.  If the program does not require any symbols to be exported, it is
-possible to combine @option{-flto} and with @option{-fwhole-program} to allow
+possible to combine @option{-flto} and @option{-fwhole-program} to allow
 the interprocedural optimizers to use more aggressive assumptions which may
 lead to improved optimization opportunities. 
 Use of @option{-fwhole-program} is not needed when linker plugin is
 active (see @option{-fuse-linker-plugin}).
 
-Regarding portability: the current implementation of LTO makes no
-attempt at generating bytecode that can be ported between different
+The current implementation of LTO makes no
+attempt to generate bytecode that is portable between different
 types of hosts.  The bytecode files are versioned and there is a
 strict version check, so bytecode files generated in one version of
 GCC will not work with an older/newer version of GCC.
 
-Link time optimization does not play well with generating debugging
+Link-time optimization does not work well with generation of debugging
 information.  Combining @option{-flto} with
 @option{-g} is currently experimental and expected to produce wrong
 results.
@@ -7693,15 +7684,15 @@
 You can also specify @option{-flto=jobserver} to use GNU make's 
 job server mode to determine the number of parallel jobs. This 
 is useful when the Makefile calling GCC is already executing in parallel.
-The parent Makefile will need a @samp{+} prepended to the command recipe
-for this to work. This will likely only work if @env{MAKE} is 
+You must prepend a @samp{+} to the command recipe in the parent Makefile
+for this to work.  This option likely only works if @env{MAKE} is
 GNU make.
 
 This option is disabled by default.
 
 @item -flto-partition=@var{alg}
 @opindex flto-partition
-Specify the partitioning algorithm used by the link time optimizer.
+Specify the partitioning algorithm used by the link-time optimizer.
 The value is either @code{1to1} to specify a partitioning mirroring
 the original source files or @code{balanced} to specify partitioning
 into equally sized chunks (whenever possible).  Specifying @code{none}
@@ -7718,27 +7709,29 @@
 
 @item -flto-report
 Prints a report with internal details on the workings of the link-time
-optimizer.  The contents of this report vary from version to version,
-it is meant to be useful to GCC developers when processing object
+optimizer.  The contents of this report vary from version to version.
+It is meant to be useful to GCC developers when processing object
 files in LTO mode (via @option{-flto}).
 
 Disabled by default.
 
 @item -fuse-linker-plugin
-Enables the use of linker plugin during link time optimization.  This option
-relies on the linker plugin support in linker that is available in gold
+Enables the use of a linker plugin during link-time optimization.  This
+option relies on the linker plugin support in linker that is available in gold
 or in GNU ld 2.21 or newer.
 
-This option enables the extraction of object files with GIMPLE bytecode out of
-library archives. This improves the quality of optimization by exposing more
-code the the link time optimizer.  This information specify what symbols 
-can be accessed externally (by non-LTO object or during dynamic linking).
-Resulting code quality improvements on binaries (and shared libraries that do
-use hidden visibility) is similar to @code{-fwhole-program}.  See
-@option{-flto} for a description on the effect of this flag and how to use it.
+This option enables the extraction of object files with GIMPLE bytecode out
+of library archives. This improves the quality of optimization by exposing
+more code to the link-time optimizer.  This information specifies what
+symbols can be accessed externally (by non-LTO object or during dynamic
+linking).  Resulting code quality improvements on binaries (and shared
+libraries that use hidden visibility) are similar to @code{-fwhole-program}.
+See @option{-flto} for a description of the effect of this flag and how to
+use it.
 
-Enabled by default when LTO support in GCC is enabled and GCC was compiled
-with a linker supporting plugins (GNU ld 2.21 or newer or gold).
+This option is enabled by default when LTO support in GCC is enabled
+and GCC was configured for use with
+a linker supporting plugins (GNU ld 2.21 or newer or gold).
 
 @item -fcompare-elim
 @opindex fcompare-elim
Index: gcc/c-family/ChangeLog
===================================================================
--- gcc/c-family/ChangeLog	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/c-family/ChangeLog	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1,3 +1,15 @@
+2011-11-04  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR c++/50608
+	* c-common.c (c_fully_fold_internal) <ADDR_EXPR>: Call fold_offsetof_1.
+	(fold_offsetof_1): Make global.  Remove STOP_REF argument and adjust.
+	<INDIRECT_REF>: Return the argument.
+	<ARRAY_REF>: Remove special code for negative offset.
+	Call fold_build_pointer_plus instead of size_binop.
+	(fold_offsetof): Remove STOP_REF argument and adjust.
+	* c-common.h (fold_offsetof_1): Declare.
+	(fold_offsetof): Remove STOP_REF argument.
+
 2011-10-26  Release Manager
 
 	* GCC 4.6.2 released.
Index: gcc/c-family/c-common.c
===================================================================
--- gcc/c-family/c-common.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/c-family/c-common.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1236,13 +1236,7 @@
 	  && (op1 = get_base_address (op0)) != NULL_TREE
 	  && TREE_CODE (op1) == INDIRECT_REF
 	  && TREE_CONSTANT (TREE_OPERAND (op1, 0)))
-	{
-	  tree offset = fold_offsetof (op0, op1);
-	  op1
-	    = fold_convert_loc (loc, TREE_TYPE (expr), TREE_OPERAND (op1, 0));
-	  ret = fold_build2_loc (loc, POINTER_PLUS_EXPR, TREE_TYPE (expr), op1,
-				 offset);
-	}
+	ret = fold_convert_loc (loc, TREE_TYPE (expr), fold_offsetof_1 (op0));
       else if (op0 != orig_op0 || in_init)
 	ret = in_init
 	  ? fold_build1_initializer_loc (loc, code, TREE_TYPE (expr), op0)
@@ -8459,20 +8453,15 @@
     return uc;
 }
 
-/* Build the result of __builtin_offsetof.  EXPR is a nested sequence of
-   component references, with STOP_REF, or alternatively an INDIRECT_REF of
-   NULL, at the bottom; much like the traditional rendering of offsetof as a
-   macro.  Returns the folded and properly cast result.  */
+/* Fold an offsetof-like expression.  EXPR is a nested sequence of component
+   references with an INDIRECT_REF of a constant at the bottom; much like the
+   traditional rendering of offsetof as a macro.  Return the folded result.  */
 
-static tree
-fold_offsetof_1 (tree expr, tree stop_ref)
+tree
+fold_offsetof_1 (tree expr)
 {
-  enum tree_code code = PLUS_EXPR;
   tree base, off, t;
 
-  if (expr == stop_ref && TREE_CODE (expr) != ERROR_MARK)
-    return size_zero_node;
-
   switch (TREE_CODE (expr))
     {
     case ERROR_MARK:
@@ -8489,15 +8478,15 @@
 
     case NOP_EXPR:
     case INDIRECT_REF:
-      if (!integer_zerop (TREE_OPERAND (expr, 0)))
+      if (!TREE_CONSTANT (TREE_OPERAND (expr, 0)))
 	{
 	  error ("cannot apply %<offsetof%> to a non constant address");
 	  return error_mark_node;
 	}
-      return size_zero_node;
+      return TREE_OPERAND (expr, 0);
 
     case COMPONENT_REF:
-      base = fold_offsetof_1 (TREE_OPERAND (expr, 0), stop_ref);
+      base = fold_offsetof_1 (TREE_OPERAND (expr, 0));
       if (base == error_mark_node)
 	return base;
 
@@ -8515,21 +8504,14 @@
       break;
 
     case ARRAY_REF:
-      base = fold_offsetof_1 (TREE_OPERAND (expr, 0), stop_ref);
+      base = fold_offsetof_1 (TREE_OPERAND (expr, 0));
       if (base == error_mark_node)
 	return base;
 
       t = TREE_OPERAND (expr, 1);
-      if (TREE_CODE (t) == INTEGER_CST && tree_int_cst_sgn (t) < 0)
-	{
-	  code = MINUS_EXPR;
-	  t = fold_build1_loc (input_location, NEGATE_EXPR, TREE_TYPE (t), t);
-	}
-      t = convert (sizetype, t);
-      off = size_binop (MULT_EXPR, TYPE_SIZE_UNIT (TREE_TYPE (expr)), t);
 
       /* Check if the offset goes beyond the upper bound of the array.  */
-      if (code == PLUS_EXPR && TREE_CODE (t) == INTEGER_CST)
+      if (TREE_CODE (t) == INTEGER_CST && tree_int_cst_sgn (t) >= 0)
 	{
 	  tree upbound = array_ref_up_bound (expr);
 	  if (upbound != NULL_TREE
@@ -8569,26 +8551,30 @@
 		}
 	    }
 	}
+
+      t = convert (sizetype, t);
+      off = size_binop (MULT_EXPR, TYPE_SIZE_UNIT (TREE_TYPE (expr)), t);
       break;
 
     case COMPOUND_EXPR:
       /* Handle static members of volatile structs.  */
       t = TREE_OPERAND (expr, 1);
       gcc_assert (TREE_CODE (t) == VAR_DECL);
-      return fold_offsetof_1 (t, stop_ref);
+      return fold_offsetof_1 (t);
 
     default:
       gcc_unreachable ();
     }
 
-  return size_binop (code, base, off);
+  return fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (base), base, off);
 }
 
+/* Likewise, but convert it to the return type of offsetof.  */
+
 tree
-fold_offsetof (tree expr, tree stop_ref)
+fold_offsetof (tree expr)
 {
-  /* Convert back from the internal sizetype to size_t.  */
-  return convert (size_type_node, fold_offsetof_1 (expr, stop_ref));
+  return convert (size_type_node, fold_offsetof_1 (expr));
 }
 
 /* Warn for A ?: C expressions (with B omitted) where A is a boolean 
Index: gcc/c-family/c-common.h
===================================================================
--- gcc/c-family/c-common.h	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/c-family/c-common.h	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -916,7 +916,8 @@
 
 extern void verify_sequence_points (tree);
 
-extern tree fold_offsetof (tree, tree);
+extern tree fold_offsetof_1 (tree);
+extern tree fold_offsetof (tree);
 
 /* Places where an lvalue, or modifiable lvalue, may be required.
    Used to select diagnostic messages in lvalue_error and
Index: gcc/tree-loop-distribution.c
===================================================================
--- gcc/tree-loop-distribution.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/tree-loop-distribution.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -63,6 +63,51 @@
    predecessor a node that writes to memory.  */
 static bitmap upstream_mem_writes;
 
+/* Returns true when DEF is an SSA_NAME defined in LOOP and used after
+   the LOOP.  */
+
+static bool
+ssa_name_has_uses_outside_loop_p (tree def, loop_p loop)
+{
+  imm_use_iterator imm_iter;
+  use_operand_p use_p;
+
+  FOR_EACH_IMM_USE_FAST (use_p, imm_iter, def)
+    if (loop != loop_containing_stmt (USE_STMT (use_p)))
+      return true;
+
+  return false;
+}
+
+/* Returns true when STMT defines a scalar variable used after the
+   loop.  */
+
+static bool
+stmt_has_scalar_dependences_outside_loop (gimple stmt)
+{
+  tree name;
+
+  switch (gimple_code (stmt))
+    {
+    case GIMPLE_CALL:
+    case GIMPLE_ASSIGN:
+      name = gimple_get_lhs (stmt);
+      break;
+
+    case GIMPLE_PHI:
+      name = gimple_phi_result (stmt);
+      break;
+
+    default:
+      return false;
+    }
+
+  return (name
+	  && TREE_CODE (name) == SSA_NAME
+	  && ssa_name_has_uses_outside_loop_p (name,
+					       loop_containing_stmt (stmt)));
+}
+
 /* Update the PHI nodes of NEW_LOOP.  NEW_LOOP is a duplicate of
    ORIG_LOOP.  */
 
@@ -332,10 +377,18 @@
 	{
 	  gimple stmt = gsi_stmt (bsi);
 
-	  if (gimple_code (stmt) != GIMPLE_LABEL
-	      && !is_gimple_debug (stmt)
-	      && bitmap_bit_p (partition, x++)
-	      && is_gimple_assign (stmt)
+	  if (gimple_code (stmt) == GIMPLE_LABEL
+	      || is_gimple_debug (stmt))
+	    continue;
+
+	  if (!bitmap_bit_p (partition, x++))
+	    continue;
+
+	  /* If the stmt has uses outside of the loop fail.  */
+	  if (stmt_has_scalar_dependences_outside_loop (stmt))
+	    goto end;
+
+	  if (is_gimple_assign (stmt)
 	      && !is_gimple_reg (gimple_assign_lhs (stmt)))
 	    {
 	      /* Don't generate the builtins when there are more than
@@ -826,48 +879,6 @@
 	  }
 }
 
-/* Returns true when DEF is an SSA_NAME defined in LOOP and used after
-   the LOOP.  */
-
-static bool
-ssa_name_has_uses_outside_loop_p (tree def, loop_p loop)
-{
-  imm_use_iterator imm_iter;
-  use_operand_p use_p;
-
-  FOR_EACH_IMM_USE_FAST (use_p, imm_iter, def)
-    if (loop != loop_containing_stmt (USE_STMT (use_p)))
-      return true;
-
-  return false;
-}
-
-/* Returns true when STMT defines a scalar variable used after the
-   loop.  */
-
-static bool
-stmt_has_scalar_dependences_outside_loop (gimple stmt)
-{
-  tree name;
-
-  switch (gimple_code (stmt))
-    {
-    case GIMPLE_ASSIGN:
-      name = gimple_assign_lhs (stmt);
-      break;
-
-    case GIMPLE_PHI:
-      name = gimple_phi_result (stmt);
-      break;
-
-    default:
-      return false;
-    }
-
-  return TREE_CODE (name) == SSA_NAME
-    && ssa_name_has_uses_outside_loop_p (name, loop_containing_stmt (stmt));
-}
-
 /* Returns true when STMT will be code generated in a partition of RDG
    different than PART and that will not be code generated as a
    builtin.  */
Index: gcc/java/ChangeLog
===================================================================
--- gcc/java/ChangeLog	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/java/ChangeLog	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1,3 +1,8 @@
+2012-01-23  Andreas Schwab  <schwab@linux-m68k.org>
+
+	* lang.c (java_init_options_struct): Set
+	frontend_set_flag_trapping_math.
+
 2011-10-26  Release Manager
 
 	* GCC 4.6.2 released.
Index: gcc/java/lang.c
===================================================================
--- gcc/java/lang.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/java/lang.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1,6 +1,6 @@
 /* Java(TM) language-specific utility routines.
    Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
-   2005, 2006, 2007, 2008, 2010 Free Software Foundation, Inc.
+   2005, 2006, 2007, 2008, 2010, 2012 Free Software Foundation, Inc.
 
 This file is part of GCC.
 
@@ -550,6 +550,7 @@
 
   /* In Java floating point operations never trap.  */
   opts->x_flag_trapping_math = 0;
+  opts->frontend_set_flag_trapping_math = true;
 
   /* In Java arithmetic overflow always wraps around.  */
   opts->x_flag_wrapv = 1;
Index: gcc/DATESTAMP
===================================================================
--- gcc/DATESTAMP	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/DATESTAMP	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1 +1 @@
-20111026
+20120201
Index: gcc/configure
===================================================================
--- gcc/configure	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/configure	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -7442,17 +7442,7 @@
   RANLIB="$ac_cv_prog_RANLIB"
 fi
 
-case "${host}" in
-*-*-darwin*)
-  # By default, the Darwin ranlib will not treat common symbols as
-  # definitions when  building the archive table of contents.  Other
-  # ranlibs do that; pass an option to the Darwin ranlib that makes
-  # it behave similarly.
-  ranlib_flags="-c"
-  ;;
-*)
-  ranlib_flags=""
-esac
+ranlib_flags=""
 
 
 # Find a good install program.  We prefer a C program (faster),
@@ -15740,7 +15730,7 @@
       ;;
 
     # Unfortunately, older versions of FreeBSD 2 do not have this feature.
-    freebsd2*)
+    freebsd2.*)
       archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
       hardcode_direct=yes
       hardcode_minus_L=yes
@@ -16653,7 +16643,7 @@
     objformat=`/usr/bin/objformat`
   else
     case $host_os in
-    freebsd[123]*) objformat=aout ;;
+    freebsd[23].*) objformat=aout ;;
     *) objformat=elf ;;
     esac
   fi
@@ -16671,7 +16661,7 @@
   esac
   shlibpath_var=LD_LIBRARY_PATH
   case $host_os in
-  freebsd2*)
+  freebsd2.*)
     shlibpath_overrides_runpath=yes
     ;;
   freebsd3.[01]* | freebsdelf3.[01]*)
@@ -17505,7 +17495,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 17508 "configure"
+#line 17498 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -17611,7 +17601,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 17614 "configure"
+#line 17604 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -18537,7 +18527,7 @@
         esac
         ;;
 
-      freebsd[12]*)
+      freebsd2.*)
         # C++ shared libraries reported to be fairly broken before
 	# switch to ELF
         ld_shlibs_CXX=no
@@ -20312,7 +20302,7 @@
     objformat=`/usr/bin/objformat`
   else
     case $host_os in
-    freebsd[123]*) objformat=aout ;;
+    freebsd[23].*) objformat=aout ;;
     *) objformat=elf ;;
     esac
   fi
@@ -20330,7 +20320,7 @@
   esac
   shlibpath_var=LD_LIBRARY_PATH
   case $host_os in
-  freebsd2*)
+  freebsd2.*)
     shlibpath_overrides_runpath=yes
     ;;
   freebsd3.[01]* | freebsdelf3.[01]*)
Index: gcc/objc/objc-next-runtime-abi-01.c
===================================================================
--- gcc/objc/objc-next-runtime-abi-01.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/objc/objc-next-runtime-abi-01.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -2871,12 +2871,15 @@
   return eh_id;
 }
 
+/* For NeXT ABI 0 and 1, the personality routines are just those of the 
+   underlying language.  */
+
 static tree
 objc_eh_personality (void)
 {
   if (!objc_eh_personality_decl)
 #ifndef OBJCPLUS
-    objc_eh_personality_decl = build_personality_function ("objc");
+    objc_eh_personality_decl = build_personality_function ("gcc");
 #else
     objc_eh_personality_decl = build_personality_function ("gxx");
 #endif
Index: gcc/objc/objc-act.c
===================================================================
--- gcc/objc/objc-act.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/objc/objc-act.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -3136,9 +3136,8 @@
   struct string_descriptor *desc, key;
   void **loc;
 
-  /* Prep the string argument.  */
-  string = fix_string_type (string);
-  TREE_SET_CODE (string, STRING_CST);
+  /* We should be passed a STRING_CST.  */
+  gcc_checking_assert (TREE_CODE (string) == STRING_CST);
   length = TREE_STRING_LENGTH (string) - 1;
 
   /* The target may have different ideas on how to construct an ObjC string 
Index: gcc/objc/ChangeLog
===================================================================
--- gcc/objc/ChangeLog	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/objc/ChangeLog	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1,3 +1,18 @@
+2011-11-12  Iain Sandoe  <iains@gcc.gnu.org>
+
+	Backport from mainline
+	2011-10-29  Iain Sandoe  <iains@gcc.gnu.org>
+	
+	PR target/47997
+	* objc-act.c (objc_build_string_object): Remove redundant second
+	call to fix_string_type ().  Add a checking assert that we are,
+	indeed, passed a STRING_CST.
+
+2011-11-12  Iain Sandoe  <iains@gcc.gnu.org>
+
+	* objc-next-runtime-abi-01.c (objc_eh_personality): Use gcc personality
+	for Objective-C m32.
+
 2011-10-26  Release Manager
 
 	* GCC 4.6.2 released.
Index: gcc/reorg.c
===================================================================
--- gcc/reorg.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/reorg.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -3554,9 +3554,11 @@
 	    }
 	}
 
+      /* See if we have a simple (conditional) jump that is useless.  */
       if (! INSN_ANNULLED_BRANCH_P (delay_insn)
+	  && ! condjump_in_parallel_p (delay_insn)
 	  && prev_active_insn (target_label) == insn
-	  && ! condjump_in_parallel_p (delay_insn)
+	  && ! BARRIER_P (prev_nonnote_insn (target_label))
 #ifdef HAVE_cc0
 	  /* If the last insn in the delay slot sets CC0 for some insn,
 	     various code assumes that it is in a delay slot.  We could
Index: gcc/DEV-PHASE
===================================================================
--- gcc/DEV-PHASE	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/DEV-PHASE	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1 @@
+prerelease
Index: gcc/tree-ssa-sccvn.c
===================================================================
--- gcc/tree-ssa-sccvn.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/tree-ssa-sccvn.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -546,6 +546,7 @@
 	  tem1.type = TREE_TYPE (tem1.op0);
 	  tem1.opcode = TREE_CODE (tem1.op0);
 	  vro1 = &tem1;
+	  deref1 = false;
 	}
       if (deref2 && vro2->opcode == ADDR_EXPR)
 	{
@@ -554,7 +555,10 @@
 	  tem2.type = TREE_TYPE (tem2.op0);
 	  tem2.opcode = TREE_CODE (tem2.op0);
 	  vro2 = &tem2;
+	  deref2 = false;
 	}
+      if (deref1 != deref2)
+	return false;
       if (!vn_reference_op_eq (vro1, vro2))
 	return false;
       ++j;
Index: gcc/ChangeLog
===================================================================
--- gcc/ChangeLog	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/ChangeLog	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1,3 +1,653 @@
+2012-01-31  Matthew Gretton-Dann  <matthew.gretton-dann@arm.com>
+
+	Backport from mainline.
+	2011-01-31  Matthew Gretton-Dann  <matthew.gretton-dann@arm.com>
+
+	config/arm/thumb2.md (thumb2_mov_notscc): Use MVN for true
+	condition.
+
+2012-01-31  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>
+
+	* config/s390/s390.md ("*ashr<mode>3_and"): Add missing z196 flag
+	to srak instruction.
+
+2012-01-30  Bin Cheng  <bin.cheng@arm.com>
+
+	Backport from mainline.
+	2012-01-30  Bin Cheng  <bin.cheng@arm.com>
+
+	PR target/51835
+	* config/arm/arm.c (arm_libcall_uses_aapcs_base): Use correct ABI
+	for __aeabi_d2iz/__aeabi_d2uiz with hard-float.
+
+2012-01-30  Ramana Radhakrishnan  <ramana.radhakrishnan@linaro.org>
+
+	Backport from mainline.
+        2012-01-20  Ramana Radhakrishnan  <ramana.radhakrishnan@linaro.org>
+
+	PR target/50313
+	* config/arm/arm.c (arm_load_pic_register): Use
+	gen_pic_load_addr_unified. Delete calls to gen_pic_load_addr_32bit
+	, gen_pic_add_dot_plus_eight and gen_pic_add_dot_plus_four.
+	(arm_pic_static_addr): Likewise.
+	(arm_rtx_costs_1): Adjust cost for UNSPEC_PIC_UNIFIED.
+	(arm_note_pic_base): Handle UNSPEC_PIC_UNIFIED.
+	* config/arm/arm.md (UNSPEC_PIC_UNIFIED): Define.
+	(pic_load_addr_unified): New.
+
+2012-01-25  Richard Guenther  <rguenther@suse.de>
+
+	* tree-ssa-sccvn.c (vn_reference_eq): Also compare if both
+	bases are dereferenced.
+
+2012-01-24  Richard Guenther  <rguenther@suse.de>
+
+	Forward-port to branch
+	2010-09-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/45678
+	* expr.c (expand_expr_real_1) <case VIEW_CONVERT_EXPR>: If
+	op0 isn't sufficiently aligned and there is movmisalignM
+	insn for mode, use it to load op0 into a temporary register.
+
+2012-01-20  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* cfgrtl.c (rtl_dump_bb): Do not dump insns for {ENTRY|EXIT}_BLOCK.
+
+2012-01-19  Quentin Neill  <quentin.neill@amd.com>
+
+	PR target/48743
+	* config/i386/driver-i386.c (host_detect_local_cpu): Also check
+	family to distinguish PROCESSOR_ATHLON.
+
+2012-01-18  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	PR tree-optimization/49642
+	* ipa-split.c (forbidden_dominators): New variable.
+	(check_forbidden_calls): New function.
+	(dominated_by_forbidden): Likewise.
+	(consider_split): Check for forbidden dominators.
+	(execute_split_functions): Initialize and free forbidden
+	dominators info; call check_forbidden_calls.
+
+2012-01-18  David Edelsohn  <dje.gcc@gmail.com>
+
+	* config/rs6000/rs6000.md (call_value_indirect_aix32): Fix typo
+	in mode of operand[4].
+
+2012-01-15  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR rtl-optimization/51821
+	* recog.c (peep2_find_free_register): Determine clobbered registers
+	from insn pattern.
+
+2012-01-12  Georg-Johann Lay  <avr@gjlay.de>
+
+	Backport from mainline r183129
+	PR target/51756
+	* config/avr/avr.c (avr_encode_section_info): Test for absence of
+	DECL_EXTERNAL when checking for initializers of progmem variables.
+
+22012-01-12  Matthew Gretton-Dann  <matthew.gretton-dann@arm.com>
+
+	Backport from mainline
+	2012-01-11  Matthew Gretton-Dann  <matthew.gretton-dann@arm.com>
+
+	* config/arm/arm.md (mov_notscc): Use MVN for false condition.
+
+2012-01-12  Uros Bizjak  <ubizjak@gmail.com>
+
+	* config/i386/i386.md (*zero_extendsidi2_rex64): Correct movl template.
+	(x86_shift<mode>_adj_1): Remove operand constraint from operand 3.
+
+2012-01-10  Joseph Myers  <joseph@codesourcery.com>
+
+	Revert:
+
+	2008-09-18  Andrew Pinski  <andrew_pinski@playstation.sony.com>
+
+	PR rtl-opt/37451
+	* loop-doloop.c (doloop_modify): New argument zero_extend_p and
+	zero extend count after the correction to it is done.
+	(doloop_optimize): Update call to doloop_modify, don't zero extend
+	count before call.
+
+	2008-11-03  Andrew Pinski  <andrew_pinski@playstation.sony.com>
+
+	PR rtl-opt/37782
+	* loop-doloop.c (doloop_modify): Add from_mode argument that says what
+	mode count is in.
+	(doloop_optimize): Update call to doloop_modify.
+
+2012-01-09  Richard Sandiford  <rdsandiford@googlemail.com>
+
+	* config/mips/mips.md (loadgp_newabi_<mode>): Add missing earlyclobber.
+
+2012-01-09  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* config/sparc/sol2-unwind.h (sparc64_is_sighandler): Check that the
+	purported sigacthandler address isn't null before dereferencing it.
+	(sparc_is_sighandler): Likewise.
+
+2012-01-09  Ramana Radhakrishnan  <ramana.radhakrishnan@linaro.org>
+
+	Backport from mainline
+	2011-11-04  Jiangning Liu  <jiangning.liu@arm.com>
+
+	PR rtl-optimization/38644
+	* config/arm/arm.c (thumb1_expand_epilogue): Add memory barrier
+	for epilogue having stack adjustment.
+
+2012-01-09  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR ada/41929
+	* config/sparc/sol2-unwind.h (sparc64_is_sighandler): Remove SAVPC and
+	add CFA.  Revert back to old code for Solaris 8+ multi-threaded.
+	(sparc_is_sighandler): Likewise.
+	(MD_FALLBACK_FRAME_STATE_FOR): Adjust call to IS_SIGHANDLER.
+
+2012-01-06  Eric Botcazou  <ebotcazou@adacore.com>
+
+	Backport from mainline
+	2012-01-06  Arnaud Charlet  <charlet@adacore.com>
+
+	* c-decl.c (ext_block): Moved up.
+	(collect_all_refs, for_each_global_decl): Take ext_block into account.
+
+2012-01-06  Richard Sandiford  <richard.sandiford@linaro.org>
+
+	PR middle-end/48660
+	* expr.h (copy_blkmode_to_reg): Declare.
+	* expr.c (copy_blkmode_to_reg): New function.
+	(expand_assignment): Don't expand register RESULT_DECLs before
+	the lhs.  Use copy_blkmode_to_reg to copy BLKmode values into a
+	RESULT_DECL register.
+	(expand_expr_real_1): Handle BLKmode decls when looking for promotion.
+
+2012-01-05  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR tree-optimization/51315
+	* tree-sra.c (tree_non_aligned_mem_for_access_p): New predicate.
+	(build_accesses_from_assign): Use it instead of tree_non_aligned_mem_p.
+
+2012-01-04  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR tree-optimization/51624
+	* tree-sra.c (build_ref_for_model): When replicating a chain of
+	COMPONENT_REFs, stop as soon as the offset would become negative.
+
+2012-01-04  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/49651
+	* tree-ssa-structalias.c (type_can_have_subvars): New function.
+	(var_can_have_subvars): Use it.
+	(get_constraint_for_1): Only consider subfields if there can be any.
+
+2012-01-03  Sandra Loosemore  <sandra@codesourcery.com>
+
+	Backport from mainline:
+	2012-01-02  Sandra Loosemore  <sandra@codesourcery.com>
+
+	* doc/invoke.texi (-flto and related options): Copy-edit.
+
+2012-01-03  Richard Guenther  <rguenther@suse.de>
+
+	Backport from mainline
+	2011-11-10  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/51042
+	* tree-ssa-pre.c (phi_translate_1): Avoid recursing on
+	self-referential expressions.  Refactor code to avoid duplication.
+
+2012-01-03  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/51070
+	* tree-loop-distribution.c (generate_builtin): Do not replace
+	the loop with a builtin if the partition contains statements which
+	results are used outside of the loop.
+	(stmt_has_scalar_dependences_outside_loop): Properly handle calls.
+
+2011-12-30  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Backport from the mainline
+	2011-12-30  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	* config/rs6000/rs6000.c (rs6000_inner_target_options): Fix thinko
+	in setting options via target #pragma or attribute.
+
+2011-12-28  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2011-12-28  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	PR target/51623
+	* config/rs6000/rs6000.c (rs6000_assemble_integer): Don't call
+	unlikely_text_section_p.  Instead check for being in a code section.
+
+2011-12-23  Richard Guenther  <rguenther@suse.de>
+
+	PR rtl-optimization/50396
+	* simplify-rtx.c (simplify_binary_operation_1): Properly
+	guard code that only works for integers.
+
+2011-12-22  Doug Kwan  <dougkwan@google.com>
+
+	Backport from mainline
+	2011-03-23  Julian Brown  <julian@codesourcery.com>
+
+	* expr.c (expand_expr_real_1): Only use BLKmode for volatile
+	accesses which are not naturally aligned.
+
+	2011-11-20  Joey Ye  <joey.ye@arm.com>
+
+	* expr.c (expand_expr_real_1): Correctly handle strict volatile
+	bitfield loads smaller than mode size.
+
+2011-12-21  Richard Earnshaw  <rearnsha@arm.com>
+
+	PR target/51643
+	* arm.c (arm_function_ok_for_sibcall): Use DECL_WEAK in previous
+	change.
+
+2011-12-21  Richard Earnshaw  <rearnsha@arm.com>
+
+	PR target/51643
+	* arm.c (arm_function_ok_for_sibcall): Don't try to tailcall a
+	weak function on bare-metal EABI targets.
+
+2011-12-21  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2011-12-21  Richard Guenther  <rguenther@suse.de>
+
+	PR lto/41159
+	* tree-outof-ssa.c (insert_value_copy_on_edge): Use the
+	mode of the pseudo as destination mode.  Only assert that
+	is equal to the promoted mode of the decl if it is a REG.
+
+2011-12-21  Uros Bizjak  <ubizjak@gmail.com>
+
+	* config/alpha/linux-unwind.h: Update copyright years.
+	(MD_FROB_UPDATE_CONTEXT): New define.
+	(alpha_frob_update_context): New function.
+
+2011-12-19  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/51583
+	* tree-sra.c (load_assign_lhs_subreplacements): Call
+	force_gimple_operand_gsi when necessary also in case of no
+	corresponding replacement on the RHS.
+
+2011-12-16  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* config/sparc/sparc.md (UNSPEC_FRAME_BLOCKAGE): New constant.
+	(frame_blockage): New expander.
+	(frame_blockage<P:mode>): New instruction.
+	* config/sparc/sparc.c (sparc_expand_prologue): When the sequence of
+	instructions establishing the frame isn't atomic, emit frame blockage.
+
+2011-12-15  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline.
+	2011-10-28  Chung-Lin Tang  <cltang@codesourcery.com>
+
+	PR rtl-optimization/49720
+	* simplify-rtx.c (simplify_relational_operation_1): Detect
+	infinite recursion condition in "(eq/ne (plus x cst1) cst2)
+	simplifies to (eq/ne x (cst2 - cst1))" case.
+
+2011-12-15  Andreas Tobler  <andreast@fgznet.ch>
+
+	Backport from mainline.
+	2011-12-15  Andreas Tobler  <andreast@fgznet.ch>
+
+	* config/i386/freebsd.h (TARGET_ASM_FILE_END): Define.
+
+2011-12-13  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* lto-streamer-out.c (write_symbol): Use proper 64-bit host type.
+	* lto-cgraph.c (input_cgraph_opt_section): Use 'int' for offsets.
+	* lto-streamer-in.c (lto_read_body): Likewise.
+	(lto_input_toplevel_asms): Likewise.
+	* lto-section-in.c (lto_create_simple_input_block): Likewise.
+	* lto-opts.c (lto_read_file_options): Likewise.
+	* ipa-prop.c (ipa_prop_read_section): Likewise.
+
+	* df.h (DF_NOTE): Fix typo in comment.
+
+2011-12-13  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>
+
+	* regmove.c (fixup_match_2): Only access call_used_regs with hard
+	regs.
+
+2011-12-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/51510
+	* calls.c (internal_arg_pointer_based_exp_scan): Don't use
+	VEC_safe_grow_cleared if idx is smaller than VEC_length.
+
+	Backported from mainline
+	2011-12-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/51485
+	* tree-vect-data-refs.c (vect_analyze_data_refs): Give up on
+	DRs in call stmts.
+
+2011-12-12  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR tree-optimization/50569
+	* tree-sra.c (build_ref_for_model): Replicate a chain of COMPONENT_REFs
+	in the expression of MODEL instead of just the last one.
+
+2011-12-09  Michael Meissner  <meissner@the-meissners.org>
+
+	Backport from mainline
+	2011-12-09  Michael Meissner  <meissner@the-meissners.org>
+
+	PR rtl-optimization/51469
+	* varasm.c (default_binds_local_p_1): If the symbol is a gnu
+	indirect function, mark the symbol as non-local.
+
+2011-12-09  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline
+	2011-12-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/51466
+	* tree-ssa-forwprop.c (forward_propagate_addr_expr_1): Also copy
+	TREE_SIDE_EFFECTS.
+
+	2011-11-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/50078
+	* tree-ssa-forwprop.c (forward_propagate_addr_expr_1): Copy over
+	TREE_THIS_VOLATILE also from the old to new lhs resp. rhs.
+
+2011-12-09  Kazu Hirata  <kazu@codesourcery.com>
+
+	Backport from mainline:
+
+	2011-12-05  Kazu Hirata  <kazu@codesourcery.com>
+
+	PR target/51408
+	* config/arm/arm.md (*minmax_arithsi): Always require the else
+	clause in the MINUS case.
+
+2011-12-08  Teresa Johnson  <tejohnson@google.com>
+
+	Backport from mainline:
+
+	2011-08-05  Uros Bizjak  <ubizjak@gmail.com>
+
+	* config/i386/i386.md (*movdi_internal_rex64): Use "!o" constraint
+	instead of "!m" for operand 0, alternative 4.
+	(*movdf_internal_rex64): Ditto for operand 0, alernative 6.
+
+2011-12-08  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline
+	2011-12-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/51410
+	* c-decl.c (pop_scope): Don't add DECL_EXTERNAL decls
+	for debug info if scope is file_scope.
+
+	PR c/51339
+	* c-decl.c (c_finish_incomplete_decl, finish_decl): Call
+	relayout_decl instead of layout_decl.
+
+	2011-12-05  Jakub Jelinek  <jakub@redhat.com>
+		    Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR middle-end/51323
+	PR middle-end/50074
+	* calls.c (internal_arg_pointer_exp_state): New variable.
+	(internal_arg_pointer_based_exp_1,
+	internal_arg_pointer_exp_scan): New functions.
+	(internal_arg_pointer_based_exp): New function.
+	(mem_overlaps_already_clobbered_arg_p): Use it.
+	(expand_call): Free internal_arg_pointer_exp_state.cache vector
+	and clear internal_arg_pointer_exp_state.scan_start.
+
+	2011-11-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/48721
+	* sched-deps.c (sched_analyze_insn): For SIBLING_CALL_P set
+	reg_pending_barrier to TRUE_BARRIER.
+
+	2011-11-26  Joern Rennecke  <joern.rennecke@embecosm.com>
+
+	PR middle-end/50074
+	* calls.c (mem_overlaps_already_clobbered_arg_p):
+	Return false if no outgoing arguments have been stored so far.
+
+2011-12-08  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR tree-optimization/51315
+	* tree-sra.c (tree_non_mode_aligned_mem_p): Rename to...
+	(tree_non_aligned_mem_p): ...this.  Add ALIGN parameter.  Look into
+	MEM_REFs and use get_object_or_type_alignment for them.
+	(build_accesses_from_assign): Adjust for above change.
+	(access_precludes_ipa_sra_p): Likewise.
+
+2011-12-06  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline:
+
+	2011-12-02  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/50622
+	* tree-sra.c (load_assign_lhs_subreplacements): Force gimple operand
+	if both lacc and racc are grp_partial_lhs.
+
+2011-12-06  Iain Sandoe  <iains@gcc.gnu.org>
+
+	* config/rs6000/rs6000.c (darwin_rs6000_override_options): Initialize
+	rs6000_current_abi.
+
+2011-12-06  Alan Modra  <amodra@gmail.com>
+
+	PR target/50906
+	* config/rs6000/rs6000.c (rs6000_emit_prologue <TARGET_SPE_ABI>):
+	Do not mark r11 setup as frame-related.  Pass correct offset to
+	rs6000_emit_savres_rtx.  Correct out-of-line rs6000_frame_related
+	arguments.  Correct sp_offset.  Remove "offset" fudge from
+	in-line rs6000_frame_related call.  Rename misleading variable.
+	Fix comments and whitespace.  Tidy some expressions.
+	(rs6000_emit_epilogue <TARGET_SPE_ABI>): Always set frame_reg_rtx
+	to r11 in out-of-line case.  Correct sp_offset.  Pass correct
+	offset to rs6000_emit_savres_rtx.  Rename misleading variable.
+	Fix comments and whitespace.  Tidy some expressions.
+	(rs6000_emit_epilogue <non-TARGET_SPE_ABI>): Add sp_offset
+	adjustment when !saving_GPRs_inline.  Correct register mode
+	used in address calcs.
+	(rs6000_emit_epilogue <non-TARGET_SPE_ABI>): Similarly when
+	!restoring_GPRs_inline.
+
+2011-12-04  Jrmie Detrey  <Jeremie.Detrey@loria.fr>
+
+	PR target/51393
+	* config/i386/avxintrin.h (_mm256_insert_epi64): Declare second
+	parameter as long long.
+
+2011-12-02  Georg-Johann Lay  <avr@gjlay.de>
+
+	PR target/51002
+	PR target/51345
+	* config/avr/libgcc.S (__prologue_saves__, __epilogue_restores__):
+	Enclose parts using __SP_H__ in !defined (__AVR_HAVE_8BIT_SP__).
+	Add FIXME comments.
+	* config/avr/avr.md (movhi_sp_r_irq_off, movhi_sp_r_irq_on): Set
+	insn condition to !AVR_HAVE_8BIT_SP.
+	* config/avr/avr.c (output_movhi): "clr%B0" instead of "in
+	%B0,__SP_H__" if AVR_HAVE_8BIT_SP.
+	(avr_file_start): Only print "__SP_H__ = 0x3e" if !AVR_HAVE_8BIT_SP.
+	* config/avr/avr-devices.c (avr_mcu_types): ATtiny4313 and
+	AT86RF401 have a 16-bit SP (their manual is bogus).
+
+2011-11-25  Richard Sandiford  <richard.sandiford@linaro.org>
+
+	Backport from mainline:
+
+	2011-03-29  Richard Sandiford  <richard.sandiford@linaro.org>
+
+	PR debug/48190
+	* dwarf2out.c (dw_loc_list_node): Add resolved_addr and replaced.
+	(cached_dw_loc_list_def): New structure.
+	(cached_dw_loc_list): New typedef.
+	(cached_dw_loc_list_table): New variable.
+	(cached_dw_loc_list_table_hash): New function.
+	(cached_dw_loc_list_table_eq): Likewise.
+	(add_location_or_const_value_attribute): Take a bool cache_p.
+	Cache the list when the parameter is true.
+	(gen_formal_parameter_die): Update caller.
+	(gen_variable_die): Likewise.
+	(dwarf2out_finish): Likewise.
+	(dwarf2out_abstract_function): Nullify cached_dw_loc_list_table
+	while generating debug info for the decl.
+	(dwarf2out_function_decl): Clear cached_dw_loc_list_table.
+	(dwarf2out_init): Initialize cached_dw_loc_list_table.
+	(resolve_addr): Cache the result of resolving a chain of
+	location lists.
+
+2011-11-24  Enkovich Ilya  <ilya.enkovich@intel.com>
+
+	PR target/51287
+	* i386.c (distance_non_agu_define): Fix insn attr check.
+
+2011-11-20  Andreas Tobler  <andreast@fgznet.ch>
+
+	* configure: Regenerate.
+
+2011-11-19  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR rtl-optimization/51187
+	* reorg.c (relax_delay_slots): Do not consider a jump useless if there
+	is a barrier between the jump and its target label.
+
+2011-11-19  Richard Earnshaw  <rearnsha@arm.com>
+
+	PR target/50493
+	* config/arm/arm.c (neon_disambiguate_copy): Correctly handle partial
+	overlap of src and dest operands.
+
+2011-11-18  Iain Sandoe  <iains@gcc.gnu.org>
+
+	PR target/49992
+	* configure.ac: Remove ranlib special-casing for Darwin.
+	* configure: Regenerate.
+
+2011-11-16  Richard Earnshaw  <rearnsha@arm.com>
+	    Bernd Schmidt <bernds@coudesourcery.com>
+	    Sebastian Huber <sebastian.huber@embedded-brains.de>
+
+	PR target/49641
+	* config/arm/arm.c (store_multiple_sequence): Avoid cases where
+	the base reg is stored iff compiling for Thumb1.
+
+2011-11-13  Iain Sandoe  <iains@gcc.gnu.org>
+
+	PR target/48108
+	Backport from mainline r180523
+	* config/darwin.c (top level): Amend comments concerning LTO output.
+	(lto_section_num): New variable.  (darwin_lto_section_e): New GTY.
+	(LTO_SECTS_SECTION, LTO_INDEX_SECTION): New.
+	(LTO_NAMES_SECTION): Rename.
+	(darwin_asm_named_section): Record LTO section counts and switches
+	in a vec of darwin_lto_section_e.
+	(darwin_file_start): Remove unused code.
+	(darwin_file_end): Put an LTO section termination label.  Handle
+	output of the wrapped LTO sections, index and names table.
+
+2011-11-12  Iain Sandoe  <iains@gcc.gnu.org>
+
+	PR target/45233
+	* config/rs6000/rs6000.c (rs6000_legitimize_reload_address):
+	Only expand a symbol ref. into an access when the entity is defined
+	in the TU.
+
+2011-11-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/51077
+	* tree-object-size.c (addr_object_size): Check TREE_CODE of
+	MEM_REF's operand rather than code of the MEM_REF itself.
+
+2011-11-07  Alan Modra  <amodra@gmail.com>
+
+	PR target/30282
+	* config/rs6000/rs6000.c (rs6000_emit_stack_reset): Always emit
+	blockage for ABI_V4.
+
+2011-11-04  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR c++/50608
+	* c-parser.c (c_parser_postfix_expression) <RID_OFFSETOF>: Adjust call
+	to fold_offsetof.
+	* c-typeck.c (build_unary_op) <ADDR_EXPR>: Call fold_offsetof_1.
+
+2011-11-04  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/50979
+	* config/sparc/sparc.h (ASM_CPU_SPEC): Pass -Av8 if -mcpu=v8.
+
+2011-11-03  Uros Bizjak  <ubizjak@gmail.com>
+
+	* config/i386/i386.md (lround<X87MODEF:mode><SWI248x:mode>2,
+	rint<mode>2, floor<mode>2, lfloor<MODEF:mode><SWI48:mode>2,
+	btrunc<mode>2, lwp_lwpval<mode>3): Use operands[N] instead of operandN.
+
+2011-11-02  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/50945
+	* config/sparc/sparc.md (movsf_insn): Reindent constraints.
+	(movsf_insn_no_fpu): Likewise.
+	(movdf_insn_sp32): Likewise.
+	(movdf_insn_sp32_no_fpu): Likewise.
+	(movdf_insn_sp32_v9): Likewise.  Remove redundant GY constraint.
+	(movdf_insn_sp32_v9_no_fpu): Likewise.
+	(movdf_insn_sp64): Likewise.
+	(movdf_insn_sp64_no_fpu): Likewise.
+	(movtf_insn_sp32): Likewise.
+	(movtf_insn_sp32_no_fpu): Likewise.
+	(movtf_insn_sp64): Likewise.
+	(movtf_insn_sp64_hq): Likewise.
+	(movtf_insn_sp64_no_fpu): Likewise.
+
+2011-11-02  Bernd Schmidt  <bernds@codesourcery.com>
+
+	* cfgcleanup.c (try_head_merge_bb): If get_condition returns
+	NULL for a jump that is a cc0 insn, pick the previous insn for
+	move_before.
+
+2011-11-01  Uros Bizjak  <ubizjak@gmail.com>
+
+	* config/i386/i386.md (splitters for int-float conversion): Use
+	SUBREG_REG on SUBREGs in splitter constraints.
+
+2011-11-01  Julian Brown  <julian@codesourcery.com>
+
+	PR rtl-optimization/47918
+	* reload1.c (set_initial_label_offsets): Use initial offsets
+	for labels on the nonlocal_goto_handler_labels chain.
+
+2011-10-29  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	PR target/50691
+	* config/pa/pa.c (emit_move_sequence): Legitimize TLS symbol references.
+	* config/pa/pa.h (LEGITIMATE_CONSTANT_P): Return false for
+	TLS_MODEL_GLOBAL_DYNAMIC and TLS_MODEL_LOCAL_DYNAMIC symbol references.
+
+2011-10-27  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/50875
+	* config/i386/sse.md (*avx_unpcklpd256): Remove extra insn
+	constraints.  Change alternative 1 to "x,m,1".
+
+2011-10-26  Jakub Jelinek  <jakub@redhat.com>
+
+	* BASE-VER: Set to 4.6.3.
+	* DEV-PHASE: Set to prerelease.
+
 2011-10-26  Release Manager
 
 	* GCC 4.6.2 released.
@@ -144,8 +794,8 @@
 
 2011-10-07  Bernd Schmidt  <bernds@codesourcery.com>
 
- 	PR target/49049
- 	* config/arm/arm.md (arm_subsi3_insn): Lose the last alternative.
+	PR target/49049
+	* config/arm/arm.md (arm_subsi3_insn): Lose the last alternative.
 
 2011-10-06  Jakub Jelinek  <jakub@redhat.com>
 
@@ -252,7 +902,7 @@
 	* config/rs6000/rs6000.md (probe_stack): Use explicit operand.
 	* config/rs6000/rs6000.c (output_probe_stack_range): Likewise.
 
-2011-09-14   Diego Novillo  <dnovillo@google.com>
+2011-09-14  Diego Novillo  <dnovillo@google.com>
 
 	* tree-vect-stmts.c (vect_transform_stmt): Remove unused
 	local variable ORIG_SCALAR_STMT.
Index: gcc/testsuite/gcc.target/arm/headmerge-2.c
===================================================================
--- gcc/testsuite/gcc.target/arm/headmerge-2.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/testsuite/gcc.target/arm/headmerge-2.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1,6 +1,6 @@
 /* { dg-do compile }  */
 /* { dg-options "-O2" }  */
-/* { dg-final { scan-assembler-times "120" 1 } } */
+/* { dg-final { scan-assembler-times "120\n" 1 } } */
 
 extern void foo1 (int);
 extern void foo2 (int);
Index: gcc/testsuite/gcc.target/arm/pr49641.c
===================================================================
--- gcc/testsuite/gcc.target/arm/pr49641.c	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/arm/pr49641.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,18 @@
+/* { dg-do compile } */
+/* { dg-options "-mthumb -O2" } */
+/* { dg-require-effective-target arm_thumb1_ok } */
+/* { dg-final { scan-assembler-not "stmia\[\\t \]*r3!\[^\\n]*r3" } } */
+typedef struct {
+  void *t1, *t2, *t3;
+} z;
+extern volatile int y;
+static inline void foo(z *x) {
+  x->t1 = &x->t2;
+  x->t2 = ((void *)0);
+  x->t3 = &x->t1;
+}
+extern z v;
+void bar (void) {
+   y = 0;
+   foo(&v);
+}
Index: gcc/testsuite/gcc.target/arm/stack-red-zone.c
===================================================================
--- gcc/testsuite/gcc.target/arm/stack-red-zone.c	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/arm/stack-red-zone.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,12 @@
+/* No stack red zone.  PR38644.  */
+/* { dg-options "-mthumb -O2" } */
+/* { dg-final { scan-assembler "ldrb\[^\n\]*\\n\[\t \]*add\[\t \]*sp" } } */
+
+extern int doStreamReadBlock (int *, char *, int size, int);
+
+char readStream (int *s)
+{
+       char c = 0;
+       doStreamReadBlock (s, &c, 1, *s);
+       return c;
+}
Index: gcc/testsuite/gcc.target/arm/sibcall-2.c
===================================================================
--- gcc/testsuite/gcc.target/arm/sibcall-2.c	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/arm/sibcall-2.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,12 @@
+/* { dg-require-effective-target arm_eabi } */
+/* { dg-do compile } */
+/* { dg-options "-O2 -mabi=aapcs" } */
+
+
+extern void __attribute__((weak)) wfunc(void);
+void main(void)
+{
+  wfunc();  /* Must not tail-call.  */
+}
+
+/* { dg-final { scan-assembler-not "b\[\\t \]+wfunc" } } */
Index: gcc/testsuite/gcc.target/arm/pr51835.c
===================================================================
--- gcc/testsuite/gcc.target/arm/pr51835.c	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/arm/pr51835.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -mfloat-abi=hard -mfpu=fpv4-sp-d16" }  */
+/* { dg-require-effective-target arm_thumb2_ok } */
+
+int func1 (double d)
+{
+  return (int)d;
+}
+unsigned int func2 (double d)
+{
+  return (unsigned int)d;
+}
+
+/* { dg-final { scan-assembler-times "fmrrd\[\\t \]+r0,\[\\t \]*r1,\[\\t \]*d0" 2 } } */
Index: gcc/testsuite/gcc.target/powerpc/pr51623.c
===================================================================
--- gcc/testsuite/gcc.target/powerpc/pr51623.c	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/powerpc/pr51623.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,123 @@
+/* PR target/51623 */
+/* { dg-do compile { target { { powerpc*-*-linux* && ilp32 } || { powerpc-*-eabi* } } } } */
+/* { dg-options "-mrelocatable -ffreestanding" } */
+
+/* This generated an error, since the compiler was calling
+   unlikely_text_section_p in a context where it wasn't valid.  */
+
+typedef long long loff_t;
+typedef unsigned size_t;
+
+
+struct mtd_info {
+  unsigned writesize;
+  unsigned oobsize;
+  const char *name;
+};
+
+extern int strcmp(const char *,const char *);
+extern char * strchr(const char *,int);
+
+struct cmd_tbl_s {
+  char *name;
+};
+
+
+int printf(const char *fmt, ...) __attribute__ ((format (__printf__, 1, 2)));
+void* malloc(size_t);
+void free(void*);
+
+
+extern int nand_curr_device;
+extern struct mtd_info nand_info[];
+
+static int nand_dump(struct mtd_info *nand, unsigned long off, int only_oob)
+{
+  int i;
+  unsigned char *datbuf, *oobbuf, *p;
+
+  datbuf = malloc(nand->writesize + nand->oobsize);
+  oobbuf = malloc(nand->oobsize);
+  off &= ~(nand->writesize - 1);
+
+  printf("Page %08lx dump:\n", off);
+  i = nand->writesize >> 4;
+  p = datbuf;
+
+  while (i--) {
+    if (!only_oob)
+      printf("\t%02x %02x %02x %02x %02x %02x %02x %02x"
+	     "  %02x %02x %02x %02x %02x %02x %02x %02x\n",
+	     p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7],
+	     p[8], p[9], p[10], p[11], p[12], p[13], p[14],
+	     p[15]);
+    p += 16;
+  }
+
+  i = nand->oobsize >> 3;
+  free(datbuf);
+  free(oobbuf);
+
+  return 0;
+}
+
+int do_nand(struct cmd_tbl_s * cmdtp, int flag, int argc, char *argv[])
+{
+  int dev;
+  unsigned long  off;
+  char *cmd, *s;
+  struct mtd_info *nand;
+
+  if (argc < 2)
+    goto usage;
+
+  cmd = argv[1];
+
+  if (strcmp(cmd, "info") == 0) {
+    putc('\n');
+    return 0;
+  }
+
+  if (strcmp(cmd, "device") == 0) {
+    if (argc < 3) {
+      putc('\n');
+    }
+    dev = (int)simple_strtoul(argv[2], ((void *)0), 10);
+    nand_curr_device = dev;
+    return 0;
+  }
+
+  if (strcmp(cmd, "bad") != 0 && strcmp(cmd, "erase") != 0  )
+    goto usage;
+  
+  if (nand_curr_device < 0 ) {
+    return 1;
+  }
+  nand = &nand_info[nand_curr_device];
+
+  if (strcmp(cmd, "erase") == 0 || strcmp(cmd, "scrub") == 0) {
+    int clean = argc > 2 && !strcmp("clean", argv[2]);
+    int scrub = !strcmp(cmd, "scrub");
+    return 0;
+  }
+
+  if (strncmp(cmd, "dump", 4) == 0) {
+    if (argc < 3)
+      goto usage;
+
+    s = strchr(cmd, '.');
+    off = (int)simple_strtoul(argv[2], ((void *)0), 16);
+    
+    if (s != ((void *)0) && strcmp(s, ".oob") == 0)
+      nand_dump(nand, off, 1);
+    else
+      nand_dump(nand, off, 0);
+    
+    return 0;
+  }
+usage:
+  cmd_usage(cmdtp);
+  return 1;
+}
+
+void *ptr = do_nand;
Index: gcc/testsuite/gcc.target/i386/pr51393.c
===================================================================
--- gcc/testsuite/gcc.target/i386/pr51393.c	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/i386/pr51393.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,22 @@
+/* { dg-do run } */
+/* { dg-require-effective-target avx } */
+/* { dg-require-effective-target lp64 } */
+/* { dg-options "-O -mavx" } */
+
+#include "avx-check.h"
+#include <immintrin.h>
+
+static void
+__attribute__((noinline))
+avx_test (void)
+{
+  long long in = 0x800000000ll;
+  long long out;
+
+  __m256i zero = _mm256_setzero_si256();
+  __m256i tmp  = _mm256_insert_epi64 (zero, in, 0);
+  out = _mm256_extract_epi64(tmp, 0);
+
+  if (in != out)
+    abort ();
+}
Index: gcc/testsuite/gcc.target/i386/pr48721.c
===================================================================
--- gcc/testsuite/gcc.target/i386/pr48721.c	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/i386/pr48721.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,51 @@
+/* PR rtl-optimization/48721 */
+/* { dg-do compile } */
+/* { dg-options "-O -foptimize-sibling-calls -fsched2-use-superblocks -fschedule-insns2 -mtune=core2" } */
+
+extern unsigned char a[];
+extern int b[], d[], e[], f[], g[], *h[], m[], *n[], o[];
+extern char c[];
+
+struct S
+{
+  unsigned char s1;
+  int s2, s3, s4, s5, s6, s7, s8;
+};
+
+__attribute__((noinline, noclone)) int
+foo (int x)
+{
+  return 0;
+}
+
+int
+bar (int x, struct S *y)
+{
+  int z;
+  switch (x)
+    {
+    case 1:
+    case 2:
+      {
+	int t2, t4, t5, t6, t7, t8;
+	z = o[y->s8 * 6];
+	t8 = *n[m[x] * 5];
+	t4 = *h[y->s7];
+	t7 = z;
+	z = g[f[x] + y->s6];
+	t6 = e[y->s5];
+	t5 = d[c[x] + y->s3 * 17];
+	if (z)
+	  t2 = b[z];
+	if (a[z] != y->s1)
+	  return foo (x);
+	y->s8 = t8;
+	y->s4 = t4;
+	y->s7 = t7;
+	y->s6 = t6;
+	y->s5 = t5;
+	y->s2 = t2;
+      }
+    }
+  return 0;
+}
Index: gcc/testsuite/gcc.target/i386/movdi-rex64.c
===================================================================
--- gcc/testsuite/gcc.target/i386/movdi-rex64.c	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/i386/movdi-rex64.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,11 @@
+/* { dg-do compile { target *-*-linux* } } */
+/* { dg-options "-fPIE" } */
+
+char *strcpy (char *dest, const char *src);
+
+static __thread char buffer[25];
+const char * error_message (void)
+{
+    strcpy (buffer, "Unknown code ");
+    return 0;
+}
Index: gcc/testsuite/lib/gcc-dg.exp
===================================================================
--- gcc/testsuite/lib/gcc-dg.exp	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/testsuite/lib/gcc-dg.exp	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -565,6 +565,24 @@
     }
 }
 
+# Scan Fortran modules for absence of a given regexp.
+#
+# Argument 0 is the module name
+# Argument 1 is the regexp to match
+proc scan-module-absence { args } {
+    set modfilename [string tolower [lindex $args 0]].mod
+    set fd [open $modfilename r]
+    set text [read $fd]
+    close $fd
+
+    upvar 2 name testcase
+    if [regexp -- [lindex $args 1] $text] {
+      fail "$testcase scan-module [lindex $args 1]"
+    } else {
+      pass "$testcase scan-module [lindex $args 1]"
+    }
+}
+
 # Verify that the compiler output file exists, invoked via dg-final.
 proc output-exists { args } {
     # Process an optional target or xfail list.
Index: gcc/testsuite/gfortran.dg/whole_file_35.f90
===================================================================
--- gcc/testsuite/gfortran.dg/whole_file_35.f90	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/whole_file_35.f90	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,28 @@
+! { dg-do compile }
+!
+! PR fortran/50408
+!
+! Contributed by Vittorio Zecca
+!
+       module m
+         type int
+           integer  :: val
+         end type int
+         interface ichar
+           module procedure uch
+        end interface
+       contains
+         function uch (c)
+           character (len=1), intent (in) :: c
+           type (int)                     :: uch
+           intrinsic ichar
+           uch%val = 127 - ichar (c)
+         end function uch 
+       end module m
+
+      program p
+        use m
+        print *,ichar('~') ! must print "1"
+      end program p
+
+! { dg-final { cleanup-modules "m" } }
Index: gcc/testsuite/gfortran.dg/dummy_procedure_7.f90
===================================================================
--- gcc/testsuite/gfortran.dg/dummy_procedure_7.f90	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/dummy_procedure_7.f90	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,65 @@
+! { dg-do run }
+!
+! PR fortran/52022
+!
+
+module check
+  integer, save :: icheck = 0
+end module check
+
+module t
+implicit none
+      contains
+subroutine  sol(cost)
+   use check
+   interface 
+        function cost(p) result(y) 
+                double precision,dimension(:) :: p
+                double precision,dimension(:),allocatable :: y
+        end function cost
+   end interface
+
+   if (any (cost([1d0,2d0]) /= [2.d0, 4.d0])) call abort ()
+   icheck = icheck + 1
+end subroutine
+
+end module t
+
+module tt
+   procedure(cost1),pointer :: pcost
+contains
+  subroutine init()
+        pcost=>cost1
+  end subroutine
+
+  function cost1(x) result(y)
+        double precision,dimension(:) :: x
+        double precision,dimension(:),allocatable :: y
+        allocate(y(2))
+        y=2d0*x
+  end function cost1
+
+
+
+  function cost(x) result(y)
+        double precision,dimension(:) :: x
+        double precision,dimension(:),allocatable :: y
+        allocate(y(2))
+        y=pcost(x)
+  end function cost
+end module
+
+program test
+        use tt
+        use t
+        use check
+        implicit none
+
+        call init()
+        if (any (cost([3.d0,7.d0]) /= [6.d0, 14.d0])) call abort ()
+        if (icheck /= 0) call abort ()
+        call sol(cost)
+        if (icheck /= 1) call abort ()
+end program test
+
+! { dg-final { cleanup-modules "t tt check" } }
Index: gcc/testsuite/gfortran.dg/derived_constructor_char_3.f90
===================================================================
--- gcc/testsuite/gfortran.dg/derived_constructor_char_3.f90	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/derived_constructor_char_3.f90	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,30 @@
+! { dg-do compile }
+!
+! PR fortran/51966
+!
+! Contributed by Peter Wind
+!
+
+  type :: Deriv
+    character(len=10) :: name
+  end type
+  character(len=8), dimension(2), parameter :: &
+       DEF_ECOSYSTEMS = (/ "Gridxxxx", "StringYY" /)
+
+  type(Deriv), save :: DepEcoSystem = Deriv(DEF_ECOSYSTEMS(1))
+
+  if (DepEcoSystem%name /= "Gridxxxx" &
+      .or. DepEcoSystem%name(9:9) /= ' ' &
+      .or. DepEcoSystem%name(10:10) /= ' ') call abort()
+  DepEcoSystem%name = 'ABCDEFGHIJ'
+  call Init_EcoSystems()
+  if (DepEcoSystem%name /= "StringYY" &
+      .or. DepEcoSystem%name(9:9) /= ' ' &
+      .or. DepEcoSystem%name(10:10) /= ' ') call abort()
+
+contains
+  subroutine Init_EcoSystems()
+    integer :: i =2
+    DepEcoSystem = Deriv(DEF_ECOSYSTEMS(i))
+  end subroutine Init_EcoSystems
+end
Index: gcc/testsuite/gfortran.dg/move_alloc_8.f90
===================================================================
--- gcc/testsuite/gfortran.dg/move_alloc_8.f90	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/move_alloc_8.f90	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,106 @@
+! { dg-do compile }
+!
+! PR fortran/50684
+!
+! Module "bug" contributed by Martin Steghfer.
+!
+
+MODULE BUG
+  TYPE MY_TYPE
+    INTEGER, ALLOCATABLE :: VALUE
+  END TYPE
+CONTAINS
+  SUBROUTINE POINTER_INTENT_IN_BUG_WORKING(POINTER_INTENT_IN_VARIABLE)
+    TYPE(MY_TYPE), POINTER, INTENT(IN) :: POINTER_INTENT_IN_VARIABLE
+    TYPE(MY_TYPE), POINTER :: POINTER_VARIABLE_LOCAL
+    INTEGER, ALLOCATABLE :: LOCAL_VALUE
+    
+    POINTER_VARIABLE_LOCAL=>POINTER_INTENT_IN_VARIABLE
+    CALL MOVE_ALLOC(POINTER_VARIABLE_LOCAL%VALUE, LOCAL_VALUE)
+    
+    RETURN
+  END SUBROUTINE POINTER_INTENT_IN_BUG_WORKING
+  
+  SUBROUTINE POINTER_INTENT_IN_BUG_FAILING(POINTER_INTENT_IN_VARIABLE)
+    TYPE(MY_TYPE), POINTER, INTENT(IN) :: POINTER_INTENT_IN_VARIABLE
+    INTEGER, ALLOCATABLE :: LOCAL_VALUE
+    
+    CALL MOVE_ALLOC(POINTER_INTENT_IN_VARIABLE%VALUE, LOCAL_VALUE)
+    
+    RETURN
+  END SUBROUTINE POINTER_INTENT_IN_BUG_FAILING
+end module bug
+
+subroutine test1()
+  TYPE MY_TYPE
+    INTEGER, ALLOCATABLE :: VALUE
+  END TYPE
+CONTAINS
+  SUBROUTINE sub (dt)
+    type(MY_TYPE), intent(in) :: dt
+    INTEGER, ALLOCATABLE :: lv
+    call move_alloc(dt%VALUE, lv) ! { dg-error "cannot be INTENT.IN." }
+  END SUBROUTINE
+end subroutine test1
+
+subroutine test2 (x, px)
+  implicit none
+  type t
+    integer, allocatable :: a
+  end type t
+
+  type t2
+    type(t), pointer :: ptr
+    integer, allocatable :: a
+  end type t2
+
+  type(t2), intent(in) :: x
+  type(t2), pointer, intent(in) :: px
+
+  integer, allocatable :: a
+  type(t2), pointer :: ta
+
+  call move_alloc (px, ta)      ! { dg-error "cannot be INTENT.IN." }
+  call move_alloc (x%a, a)      ! { dg-error "cannot be INTENT.IN." }
+  call move_alloc (x%ptr%a, a)  ! OK (3)
+  call move_alloc (px%a, a)     ! OK (4)
+  call move_alloc (px%ptr%a, a) ! OK (5)
+end subroutine test2
+
+subroutine test3 (x, px)
+  implicit none
+  type t
+    integer, allocatable :: a
+  end type t
+
+  type t2
+    class(t), pointer :: ptr
+    integer, allocatable :: a
+  end type t2
+
+  type(t2), intent(in) :: x
+  class(t2), pointer, intent(in) :: px
+
+  integer, allocatable :: a
+  class(t2), pointer :: ta
+
+  call move_alloc (px, ta)      ! { dg-error "cannot be INTENT.IN." }
+  call move_alloc (x%a, a)      ! { dg-error "cannot be INTENT.IN." }
+  call move_alloc (x%ptr%a, a)  ! OK (6)
+  call move_alloc (px%a, a)     ! OK (7)
+  call move_alloc (px%ptr%a, a) ! OK (8)
+end subroutine test3
+
+subroutine test4()
+  TYPE MY_TYPE
+    INTEGER, ALLOCATABLE :: VALUE
+  END TYPE
+CONTAINS
+  SUBROUTINE sub (dt)
+    CLASS(MY_TYPE), intent(in) :: dt
+    INTEGER, ALLOCATABLE :: lv
+    call move_alloc(dt%VALUE, lv) ! { dg-error "cannot be INTENT.IN." }
+  END SUBROUTINE
+end subroutine test4
+
+! { dg-final { cleanup-modules "bug" } }
Index: gcc/testsuite/gfortran.dg/realloc_on_assign_8.f90
===================================================================
--- gcc/testsuite/gfortran.dg/realloc_on_assign_8.f90	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/realloc_on_assign_8.f90	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,17 @@
+! { dg-do compile }
+!
+! PR fortran/51448
+!
+! Contribued by Franois Willot
+!
+  PROGRAM MAIN
+  IMPLICIT NONE
+  TYPE mytype
+    REAL b(2)
+  END TYPE mytype
+  TYPE(mytype) a
+  DOUBLE PRECISION, ALLOCATABLE :: x(:)
+  ALLOCATE(x(2))
+  a%b=0.0E0
+  x=a%b
+  END
Index: gcc/testsuite/gfortran.dg/implicit_pure_2.f90
===================================================================
--- gcc/testsuite/gfortran.dg/implicit_pure_2.f90	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/implicit_pure_2.f90	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,17 @@
+! { dg-do compile }
+! PR 51502 - this was wrongly detected to be implicit pure.
+module m
+  integer :: i
+contains
+  subroutine foo(x)
+    integer, intent(inout) :: x
+    outer: block
+      block
+        i = 5
+      end block
+    end block outer
+  end subroutine foo
+end module m
+
+! { dg-final { scan-module-absence "m" "IMPLICIT_PURE" } }
+! { dg-final { cleanup-modules "m" } }
Index: gcc/testsuite/gfortran.dg/intrinsic_size_2.f90
===================================================================
--- gcc/testsuite/gfortran.dg/intrinsic_size_2.f90	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/intrinsic_size_2.f90	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,17 @@
+! { dg-do compile }
+!
+! PR fortran/51904
+!
+! Contributed by David Sagan.
+!
+
+call qp_draw_polyline_basic([1.0,2.0])
+contains
+subroutine qp_draw_polyline_basic (x)
+  implicit none
+  real :: x(:), f
+  integer :: i
+  f = 0
+  print *, size(f*x)
+end subroutine
+end
Index: gcc/testsuite/gfortran.dg/default_initialization_5.f90
===================================================================
--- gcc/testsuite/gfortran.dg/default_initialization_5.f90	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/default_initialization_5.f90	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,66 @@
+! { dg-do  run }
+! { dg-options "-fdump-tree-original" }
+!
+! PR fortran/51435
+!
+! Contributed by darmar.xxl@gmail.com
+!
+module arr_m
+    type arr_t
+        real(8), dimension(:), allocatable :: rsk
+    end type
+    type arr_t2
+        integer :: a = 77
+    end type
+end module arr_m
+!*********************
+module list_m
+    use arr_m
+    implicit none
+
+    type(arr_t2), target :: tgt
+
+    type my_list
+        type(arr_t), pointer :: head => null()
+    end type my_list
+    type my_list2
+        type(arr_t2), pointer :: head => tgt
+    end type my_list2
+end module list_m
+!***********************
+module worker_mod
+    use list_m
+    implicit none
+
+    type data_all_t
+        type(my_list) :: my_data
+    end type data_all_t
+    type data_all_t2
+        type(my_list2) :: my_data
+    end type data_all_t2
+contains
+    subroutine do_job()
+        type(data_all_t) :: dum
+        type(data_all_t2) :: dum2
+
+        if (associated(dum%my_data%head)) then
+          call abort()
+        else
+            print *, 'OK: do_job my_data%head is NOT associated'
+        end if
+
+        if (dum2%my_data%head%a /= 77) &
+          call abort()
+    end subroutine
+end module
+!***************
+program hello
+    use worker_mod
+    implicit none
+    call do_job()
+end program
+
+! { dg-final { scan-tree-dump-times "my_data.head = 0B" 1 "original" } }
+! { dg-final { scan-tree-dump-times "my_data.head = &tgt" 1 "original" } }
+! { dg-final { cleanup-tree-dump "original" } }
+! { dg-final { cleanup-modules "arr_m list_m worker_mod" } }
Index: gcc/testsuite/gfortran.dg/move_alloc_12.f90
===================================================================
--- gcc/testsuite/gfortran.dg/move_alloc_12.f90	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/move_alloc_12.f90	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,33 @@
+! { dg-do compile }
+!
+! PR fortran/51948
+!
+  type :: t
+  end type t
+contains
+  function func(x, y)
+    class(t) :: y
+    type(t), allocatable :: func
+    type(t), allocatable :: x
+
+    select type (y)
+      type is(t)
+        call move_alloc (x, func)
+    end select
+  end function
+
+  function func2(x, y)
+    class(t) :: y
+    class(t), allocatable :: func2
+    class(t), allocatable :: x
+
+    block
+    block
+    select type (y)
+      type is(t)
+        call move_alloc (x, func2)
+    end select
+    end block
+    end block
+  end function
+end
Index: gcc/testsuite/gfortran.dg/init_flag_9.f90
===================================================================
--- gcc/testsuite/gfortran.dg/init_flag_9.f90	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/init_flag_9.f90	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,15 @@
+! { dg-do run }
+! { dg-options "-finit-character=89" }
+!
+! PR fortran/51800
+!
+
+subroutine foo(n)
+  character(len=n) :: str
+!  print *, str
+  if (str /= repeat ('Y', n)) call abort()
+end subroutine foo
+
+call foo(3)
+call foo(10)
+end
Index: gcc/testsuite/gfortran.dg/pr50875.f90
===================================================================
--- gcc/testsuite/gfortran.dg/pr50875.f90	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/pr50875.f90	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,39 @@
+! { dg-do compile { target { i?86-*-* x86_64-*-* } } }
+! { dg-options "-O3 -mavx" }
+!
+! PR fortran/50875.f90
+
+module test
+
+  implicit none
+
+  integer, parameter :: dp=kind(1.d0)
+
+  integer :: P = 2
+
+  real(kind=dp), allocatable :: real_array_A(:),real_array_B(:,:)
+  complex(kind=dp), allocatable :: cmplx_array_A(:) 
+
+contains
+
+  subroutine routine_A
+
+    integer :: i
+
+    allocate(cmplx_array_A(P),real_array_B(P,P),real_array_A(P))
+
+    real_array_A = 1
+    real_array_B = 1
+
+    do i = 1, p
+       cmplx_array_A = cmplx(real_array_B(:,i),0.0_dp,dp)
+       cmplx_array_A = cmplx_array_A * exp(cmplx(0.0_dp,real_array_A+1))
+    end do
+
+    deallocate(cmplx_array_A,real_array_B,real_array_A)
+
+  end subroutine routine_A
+
+end module test
+
+! { dg-final { cleanup-modules "test" } }
Index: gcc/testsuite/gfortran.dg/class_47.f90
===================================================================
--- gcc/testsuite/gfortran.dg/class_47.f90	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/class_47.f90	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,40 @@
+! { dg-do compile }
+!
+! PR fortran/51913
+!
+! Contributed by Alexander Tismer
+!
+MODULE m_sparseMatrix
+
+  implicit none
+  
+  type :: sparseMatrix_t
+
+  end type sparseMatrix_t
+END MODULE m_sparseMatrix
+
+!===============================================================================
+module m_subroutine
+!  USE m_sparseMatrix !< when uncommenting this line program works fine
+
+  implicit none
+
+  contains
+  subroutine test(matrix)
+    use m_sparseMatrix
+    class(sparseMatrix_t), pointer :: matrix
+  end subroutine
+end module
+
+!===============================================================================
+PROGRAM main
+  use m_subroutine
+  USE m_sparseMatrix
+  implicit none
+
+  CLASS(sparseMatrix_t), pointer :: sparseMatrix
+  
+  call test(sparseMatrix)
+END PROGRAM
+
+! { dg-final { cleanup-modules "m_sparsematrix m_subroutine" } }
Index: gcc/testsuite/gfortran.dg/warn_function_without_result_2.f90
===================================================================
--- gcc/testsuite/gfortran.dg/warn_function_without_result_2.f90	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/warn_function_without_result_2.f90	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,19 @@
+! { dg-do compile }
+! { dg-options "-Wall" }
+!
+! PR fortran/50923
+!
+module m
+contains
+  integer pure function f() ! { dg-warning "Return value of function 'f' at .1. not set" }
+  end function f
+  integer pure function g() result(h) ! { dg-warning "Return value 'h' of function 'g' declared at .1. not set" }
+  end function g
+  integer pure function i()
+    i = 7
+  end function i
+  integer pure function j() result(k)
+    k = 8
+  end function j
+end module m
+! { dg-final { cleanup-modules "mod" } }
Index: gcc/testsuite/gfortran.dg/implicit_pure_1.f90
===================================================================
--- gcc/testsuite/gfortran.dg/implicit_pure_1.f90	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/implicit_pure_1.f90	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,53 @@
+! { dg-do run }
+!
+! PR fortran/51218
+!
+! Contributed by Harald Anlauf
+!
+
+module a
+  implicit none
+  integer :: neval = 0
+contains
+  subroutine inc_eval
+    neval = neval + 1
+  end subroutine inc_eval
+end module a
+
+module b
+  use a
+  implicit none
+contains
+  function f(x) ! Should be implicit pure
+    real :: f
+    real, intent(in) :: x
+    f = x
+  end function f
+
+  function g(x) ! Should NOT be implicit pure
+    real :: g
+    real, intent(in) :: x
+    call inc_eval
+    g = x
+  end function g
+end module b
+
+program gfcbug114a
+  use a
+  use b
+  implicit none
+  real :: x = 1, y = 1, t, u, v, w
+  if (neval /= 0) call abort ()
+  t = f(x)*f(y)
+  if (neval /= 0) call abort ()
+  u = f(x)*f(y) + f(x)*f(y)
+  if (neval /= 0) call abort ()
+  v = g(x)*g(y)
+  if (neval /= 2) call abort ()
+  w = g(x)*g(y) + g(x)*g(y)
+  if (neval /= 6) call abort ()
+  if (t /= 1.0 .or. u /= 2.0 .or. v /= 1.0 .or. w /= 2) call abort ()
+end program gfcbug114a
+
+! { dg-final { scan-module "b" "IMPLICIT_PURE" } }
+! { dg-final { cleanup-modules "b" } }
Index: gcc/testsuite/gfortran.dg/init_flag_8.f90
===================================================================
--- gcc/testsuite/gfortran.dg/init_flag_8.f90	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/init_flag_8.f90	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,18 @@
+! { dg-do compile }
+! { dg-options "-fno-automatic -finit-local-zero" }
+!
+! PR fortran/51800
+!
+! Contributed by Mario Baumann
+!
+      SUBROUTINE FOO( N, A )
+      IMPLICIT NONE
+      INTEGER :: N
+      INTEGER :: A(1:N)
+      INTEGER :: J
+      INTEGER :: DUMMY(1:N)
+      DO J=1,N
+         DUMMY(J) = 0
+         A(J) = DUMMY(J)
+      END DO 
+      END SUBROUTINE FOO
Index: gcc/testsuite/gcc.c-torture/execute/doloop-1.c
===================================================================
--- gcc/testsuite/gcc.c-torture/execute/doloop-1.c	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/execute/doloop-1.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,18 @@
+#include <limits.h>
+
+extern void exit (int);
+extern void abort (void);
+
+volatile unsigned int i;
+
+int
+main (void)
+{
+  unsigned char z = 0;
+
+  do ++i;
+  while (--z > 0);
+  if (i != UCHAR_MAX + 1U)
+    abort ();
+  exit (0);
+}
Index: gcc/testsuite/gcc.c-torture/execute/20120111-1.c
===================================================================
--- gcc/testsuite/gcc.c-torture/execute/20120111-1.c	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/execute/20120111-1.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,18 @@
+#include <stdlib.h>
+#include <stdint.h>
+
+uint32_t f0a (uint64_t arg2) __attribute__((noinline));
+
+uint32_t
+f0a (uint64_t arg)
+{
+  return ~(arg > -3);
+}
+
+int main() {
+  uint32_t r1;
+  r1 = f0a (12094370573988097329ULL);
+  if (r1 != ~0U)
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr51466.c
===================================================================
--- gcc/testsuite/gcc.c-torture/execute/pr51466.c	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/execute/pr51466.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,43 @@
+/* PR tree-optimization/51466 */
+
+extern void abort (void);
+
+__attribute__((noinline, noclone)) int
+foo (int i)
+{
+  volatile int v[4];
+  int *p;
+  v[i] = 6;
+  p = (int *) &v[i];
+  return *p;
+}
+
+__attribute__((noinline, noclone)) int
+bar (int i)
+{
+  volatile int v[4];
+  int *p;
+  v[i] = 6;
+  p = (int *) &v[i];
+  *p = 8;
+  return v[i];
+}
+
+__attribute__((noinline, noclone)) int
+baz (int i)
+{
+  volatile int v[4];
+  int *p;
+  v[i] = 6;
+  p = (int *) &v[0];
+  *p = 8;
+  return v[i];
+}
+
+int
+main ()
+{
+  if (foo (3) != 6 || bar (2) != 8 || baz (0) != 8 || baz (1) != 6)
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/20111212-1.c
===================================================================
--- gcc/testsuite/gcc.c-torture/execute/20111212-1.c	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/execute/20111212-1.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,34 @@
+/* PR tree-optimization/50569 */
+/* Reported by Paul Koning <pkoning@gcc.gnu.org> */
+/* Reduced testcase by Mikael Pettersson <mikpe@it.uu.se> */
+
+struct event {
+    struct {
+	unsigned int sec;
+    } sent __attribute__((packed));
+};
+
+void __attribute__((noinline,noclone)) frob_entry(char *buf)
+{
+    struct event event;
+
+    __builtin_memcpy(&event, buf, sizeof(event));
+    if (event.sent.sec < 64) {
+	event.sent.sec = -1U;
+	__builtin_memcpy(buf, &event, sizeof(event));
+    }
+}
+
+int main(void)
+{
+    union {
+	char buf[1 + sizeof(struct event)];
+	int align;
+    } u;
+
+    __builtin_memset(&u, 0, sizeof u);
+
+    frob_entry(&u.buf[1]);
+
+    return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/20120105-1.c
===================================================================
--- gcc/testsuite/gcc.c-torture/execute/20120105-1.c	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/execute/20120105-1.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,24 @@
+struct __attribute__((packed)) S
+{
+  int a, b, c;
+};
+
+static int __attribute__ ((noinline,noclone))
+extract(const char *p)
+{
+  struct S s;
+  __builtin_memcpy (&s, p, sizeof(struct S));
+  return s.a;
+}
+
+volatile int i;
+
+int main (void)
+{
+  char p[sizeof(struct S) + 1];
+
+  __builtin_memset (p, 0, sizeof(struct S) + 1);
+  i = extract (p + 1);
+
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr51323.c
===================================================================
--- gcc/testsuite/gcc.c-torture/execute/pr51323.c	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/execute/pr51323.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,35 @@
+/* PR middle-end/51323 */
+
+extern void abort (void);
+struct S { int a, b, c; };
+int v;
+
+__attribute__((noinline, noclone)) void
+foo (int x, int y, int z)
+{
+  if (x != v || y != 0 || z != 9)
+    abort ();
+}
+
+static inline int
+baz (const struct S *p)
+{
+  return p->b;
+}
+
+__attribute__((noinline, noclone)) void
+bar (int x, struct S y)
+{
+  foo (baz (&y), 0, x);
+}
+
+int
+main ()
+{
+  struct S s;
+  v = 3; s.a = v - 1; s.b = v; s.c = v + 1;
+  bar (9, s);
+  v = 17; s.a = v - 1; s.b = v; s.c = v + 1;
+  bar (9, s);
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/20111208-1.c
===================================================================
--- gcc/testsuite/gcc.c-torture/execute/20111208-1.c	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/execute/20111208-1.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,94 @@
+/* PR tree-optimization/51315 */
+/* Reported by Jurij Smakov <jurij@wooyd.org> */
+
+typedef unsigned int size_t;
+
+extern void *memcpy (void *__restrict __dest,
+       __const void *__restrict __src, size_t __n)
+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
+
+extern size_t strlen (__const char *__s)
+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
+
+typedef short int int16_t;
+typedef int int32_t;
+
+extern void abort (void);
+
+int a;
+
+static void __attribute__ ((noinline,noclone))
+do_something (int item)
+{
+  a = item;
+}
+
+int
+pack_unpack (char *s, char *p)
+{
+  char *send, *pend;
+  char type;
+  int integer_size;
+
+  send = s + strlen (s);
+  pend = p + strlen (p);
+
+  while (p < pend)
+    {
+      type = *p++;
+
+      switch (type)
+ {
+ case 's':
+   integer_size = 2;
+   goto unpack_integer;
+
+ case 'l':
+   integer_size = 4;
+   goto unpack_integer;
+
+ unpack_integer:
+   switch (integer_size)
+     {
+     case 2:
+       {
+  union
+  {
+    int16_t i;
+    char a[sizeof (int16_t)];
+  }
+  v;
+  memcpy (v.a, s, sizeof (int16_t));
+  s += sizeof (int16_t);
+  do_something (v.i);
+       }
+       break;
+
+     case 4:
+       {
+  union
+  {
+    int32_t i;
+    char a[sizeof (int32_t)];
+  }
+  v;
+  memcpy (v.a, s, sizeof (int32_t));
+  s += sizeof (int32_t);
+  do_something (v.i);
+       }
+       break;
+     }
+   break;
+ }
+    }
+  return (int) *s;
+}
+
+int
+main (void)
+{
+  int n = pack_unpack ("\200\001\377\376\035\300", "sl");
+  if (n != 0)
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/doloop-2.c
===================================================================
--- gcc/testsuite/gcc.c-torture/execute/doloop-2.c	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/execute/doloop-2.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,18 @@
+#include <limits.h>
+
+extern void exit (int);
+extern void abort (void);
+
+volatile unsigned int i;
+
+int
+main (void)
+{
+  unsigned short z = 0;
+
+  do ++i;
+  while (--z > 0);
+  if (i != USHRT_MAX + 1U)
+    abort ();
+  exit (0);
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr51077.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr51077.c	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr51077.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,15 @@
+/* PR middle-end/51077 */
+
+struct S { unsigned char s, t[256]; };
+
+void
+foo (const struct S *x, struct S *y, int z)
+{
+  int i;
+  for (i = 0; i < 8; i++)
+    {
+      const struct S *a = &x[i];
+      __builtin___memcpy_chk (y->t, a->t, z, __builtin_object_size (y->t, 0));
+      y = (struct S *) &y->t[z];
+    }
+}
Index: gcc/testsuite/gcc.c-torture/compile/20110913-1.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/20110913-1.c	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/20110913-1.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,26 @@
+struct ieee754_double {
+  double d;
+};
+extern const float __exp_deltatable[178];
+float __ieee754_expf (float x)
+{
+  static const float himark = 88.72283935546875;
+  static const float lomark = -103.972084045410;
+  if (__builtin_isless(x, himark) && __builtin_isgreater(x, lomark))
+    {
+      int tval;
+      double x22, t, result, dx;
+      float delta;
+      struct ieee754_double ex2_u;
+      dx -= t;
+      tval = (int) (t * 512.0);
+      if (t >= 0)
+	delta = - __exp_deltatable[tval];
+      else
+	delta = __exp_deltatable[-tval];
+      x22 = (0.5000000496709180453 * dx + 1.0000001192102037084) * dx + delta;
+      result = x22 * ex2_u.d + ex2_u.d;
+      return (float) result;
+    }
+  return x;
+}
Index: gcc/testsuite/gnat.dg/frame_overflow.adb
===================================================================
--- gcc/testsuite/gnat.dg/frame_overflow.adb	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/testsuite/gnat.dg/frame_overflow.adb	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1,27 +1,20 @@
 -- { dg-do compile }
 
-with System;
+package body Frame_Overflow is
 
-procedure frame_overflow is
-
-   type Bitpos_Range_T is range 1..2**(System.Word_Size-1)-1;
-   type Bitmap_Array_T is array (Bitpos_Range_T) of Boolean;
-
-   type Bitmap_T is record
-      Bits : Bitmap_Array_T := (others => False);
-   end record;
-
-   function
+   function -- { dg-error "too large" }
      Set_In (Bitmap : Bitmap_T; Bitpos : Bitpos_Range_T)  return Bitmap_T
    is
-      Result: Bitmap_T := Bitmap; -- { dg-error "Storage_Error" }
+      Result: Bitmap_T := Bitmap;
    begin
       Result.Bits (Bitpos) := True;
       return Result;
    end;
 
-   function Negate (Bitmap : Bitmap_T) return Bitmap_T is
-      Result: Bitmap_T; -- { dg-error "Storage_Error" }
+   function -- { dg-error "too large" }
+     Negate (Bitmap : Bitmap_T) return Bitmap_T
+   is
+      Result: Bitmap_T;
    begin
       for E in Bitpos_Range_T loop
         Result.Bits (E) := not Bitmap.Bits (E);
@@ -29,6 +22,4 @@
       return Result;
   end;
 
-begin
-   null;
-end;
+end Frame_Overflow;
Index: gcc/testsuite/gnat.dg/frame_overflow.ads
===================================================================
--- gcc/testsuite/gnat.dg/frame_overflow.ads	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/gnat.dg/frame_overflow.ads	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,17 @@
+with System;
+
+package Frame_Overflow is
+
+   type Bitpos_Range_T is range 1..2**(System.Word_Size-1)-1;
+   type Bitmap_Array_T is array (Bitpos_Range_T) of Boolean;
+
+   type Bitmap_T is record
+      Bits : Bitmap_Array_T := (others => False);
+   end record;
+
+   function
+     Set_In (Bitmap : Bitmap_T; Bitpos : Bitpos_Range_T)  return Bitmap_T;
+
+   function Negate (Bitmap : Bitmap_T) return Bitmap_T;
+
+end Frame_Overflow;
Index: gcc/testsuite/gnat.dg/renaming5.adb
===================================================================
--- gcc/testsuite/gnat.dg/renaming5.adb	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/gnat.dg/renaming5.adb	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,30 @@
+-- PR ada/46192
+-- Testcase by Rolf Ebert <rolf.ebert.gcc@gmx.de>
+
+-- { dg-do compile }
+-- { dg-options "-O2 -fdump-tree-optimized" }
+
+with System; use System;
+
+package body Renaming5 is
+
+   type Bits_In_Byte is array (0 .. 7) of Boolean;
+   pragma Pack (Bits_In_Byte);
+
+   A : Bits_In_Byte;
+   for A'Address use System'To_Address(16#c0#);
+   pragma Volatile (A);
+
+   B : Bits_In_Byte renames A;
+
+   procedure Proc is
+   begin
+      while B (0) = False loop
+         null;
+      end loop;
+   end;
+
+end Renaming5;
+
+-- { dg-final { scan-tree-dump-times "goto" 2 "optimized" } }
+-- { dg-final { cleanup-tree-dump "optimized" } }
Index: gcc/testsuite/gnat.dg/renaming5.ads
===================================================================
--- gcc/testsuite/gnat.dg/renaming5.ads	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/gnat.dg/renaming5.ads	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,5 @@
+package Renaming5 is
+
+   procedure Proc;
+
+end Renaming5;
Index: gcc/testsuite/gnat.dg/specs/addr1.ads
===================================================================
--- gcc/testsuite/gnat.dg/specs/addr1.ads	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/testsuite/gnat.dg/specs/addr1.ads	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -15,7 +15,7 @@
   end record;
   for Rec2'Size use 64;
 
-  A: Arr (1 .. 12);
+  A: Arr (1 .. 4);
 
   Obj1: Rec1;
   for Obj1'Address use A'Address; -- { dg-bogus "alignment" }
Index: gcc/testsuite/gcc.dg/pr45819.c
===================================================================
--- gcc/testsuite/gcc.dg/pr45819.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/testsuite/gcc.dg/pr45819.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -fdump-tree-optimized" } */
+/* { dg-options "-O2 -fdump-tree-optimized -w" } */
 
 struct ehci_regs {
     char x;
Index: gcc/testsuite/gcc.dg/gomp/pr51339.c
===================================================================
--- gcc/testsuite/gcc.dg/gomp/pr51339.c	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/gomp/pr51339.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,15 @@
+/* PR c/51339 */
+/* { dg-do compile } */
+/* { dg-options "-fopenmp" } */
+
+char g[] = "g";
+
+void
+foo (void)
+{
+#pragma omp parallel sections firstprivate (g) lastprivate (g)
+  {
+  #pragma omp section
+    g[0] = 'h';
+  }
+}
Index: gcc/testsuite/gcc.dg/cpp/assert4.c
===================================================================
--- gcc/testsuite/gcc.dg/cpp/assert4.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/testsuite/gcc.dg/cpp/assert4.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1,4 +1,4 @@
-/* Copyright (C) 2003, 2006, 2008 Free Software Foundation, Inc.
+/* Copyright (C) 2003, 2006, 2008, 2009, 2011 Free Software Foundation, Inc.
    Test builtin preprocessor assertions.
    By Kaveh Ghazi <ghazi@caip.rutgers.edu>.  */
 
@@ -7,7 +7,7 @@
 
 /* Check for #system assertions.  */
 
-#if defined __gnu_linux__
+#if defined __linux__
 # if !#system(linux) || !#system(unix) || !#system(posix)
 #  error
 # endif
Index: gcc/testsuite/gcc.dg/pr50078.c
===================================================================
--- gcc/testsuite/gcc.dg/pr50078.c	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/pr50078.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,14 @@
+/* PR tree-optimization/50078 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+unsigned nonvolvar[2];
+
+void
+test (int arg)
+{
+  unsigned v = *(volatile unsigned *) (&nonvolvar[arg]);
+  *(volatile unsigned *) (&nonvolvar[arg]) = v;
+}
+
+/* { dg-final { scan-assembler-times "movl\[^\n\r\]*nonvolvar" 2 { target { { i?86-*-* x86_64-*-* } && nonpic } } } } */
Index: gcc/testsuite/gcc.dg/debug/dwarf2/pr51410.c
===================================================================
--- gcc/testsuite/gcc.dg/debug/dwarf2/pr51410.c	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/debug/dwarf2/pr51410.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,13 @@
+/* PR debug/51410 */
+/* { dg-do compile } */
+/* { dg-options "-O0 -gdwarf-2 -dA -fno-merge-debug-strings" } */
+
+int x;
+
+int
+foo (void)
+{
+  return x;
+}
+
+/* { dg-final { scan-assembler-times "\\(DIE\[^\\r\\n\]*DW_TAG_variable\\)" 1 } } */
Index: gcc/testsuite/gcc.dg/pr51821.c
===================================================================
--- gcc/testsuite/gcc.dg/pr51821.c	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/pr51821.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,25 @@
+/* { dg-do run } */
+/* { dg-options "-std=c99 -O2" } */
+/* { dg-options "-std=c99 -O2 -msse" { target { i?86-*-* x86_64-*-* } } } */
+/* { dg-require-effective-target sse_runtime { target { i?86-*-* x86_64-*-* } } } */
+
+extern void abort (void);
+
+unsigned int  __attribute__((noinline))
+test (int shift_size)
+{
+  unsigned long long res = ~0;
+
+  return res << shift_size;
+}
+
+int
+main ()
+{
+  int dst = 32;
+
+  if (test (dst) != 0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/volatile-bitfields-1.c
===================================================================
--- gcc/testsuite/gcc.dg/volatile-bitfields-1.c	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/volatile-bitfields-1.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,23 @@
+/* { dg-options "-fstrict-volatile-bitfields" } */
+/* { dg-do run } */
+
+extern int puts(const char *);
+extern void abort(void) __attribute__((noreturn));
+
+typedef struct {
+  volatile unsigned short a:8, b:8;
+} BitStruct;
+
+BitStruct bits = {1, 2};
+
+void check(int i, int j)
+{
+  if (i != 1 || j != 2) puts("FAIL"), abort();
+}
+
+int main ()
+{
+  check(bits.a, bits.b);
+
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/pr51408.c
===================================================================
--- gcc/testsuite/gcc.dg/pr51408.c	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/pr51408.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,22 @@
+/* This testcase used to fail because of a bug in 
+   arm.md:*minmax_arithsi.  */
+
+/* { dg-do run } */
+/* { dg-options "-O1" } */
+
+extern void abort (void);
+
+int __attribute__((noinline))
+foo (int a, int b)
+{
+  int max = (b > 0) ? b : 0;
+  return max - a;
+}
+
+int
+main (void)
+{
+  if (foo (3, -1) != -3)
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/torture/pr50396.c
===================================================================
--- gcc/testsuite/gcc.dg/torture/pr50396.c	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/torture/pr50396.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,22 @@
+/* { dg-do run } */
+/* { dg-add-options ieee } */
+
+extern void abort (void);
+typedef float vf128 __attribute__((vector_size(16)));
+typedef float vf64 __attribute__((vector_size(8)));
+int main()
+{
+#if !__FINITE_MATH_ONLY__
+#if __FLT_HAS_QUIET_NAN__
+  vf128 v = (vf128){ 0.f, 0.f, 0.f, 0.f };
+  vf64 u = (vf64){ 0.f, 0.f };
+  v = v / (vf128){ 0.f, 0.f, 0.f, 0.f };
+  if (v[0] == v[0])
+    abort ();
+  u = u / (vf64){ 0.f, 0.f };
+  if (u[0] == u[0])
+    abort ();
+#endif
+#endif
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/torture/pr51042.c
===================================================================
--- gcc/testsuite/gcc.dg/torture/pr51042.c	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/torture/pr51042.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,22 @@
+/* { dg-do compile } */
+
+int a, b;
+
+void
+foo (int x)
+{
+  int e[2];
+  int d;
+  while (x)
+    {
+      for (d = 0; d <= 1; d = 1)
+	if (e[a])
+	  break;
+      for (b = 0; b <= 0; b = 1)
+	{
+	  e[a] = a;
+	  if (a)
+	    break;
+	}
+    }
+}
Index: gcc/testsuite/gcc.dg/torture/pr51070-2.c
===================================================================
--- gcc/testsuite/gcc.dg/torture/pr51070-2.c	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/torture/pr51070-2.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,35 @@
+/* { dg-do compile } */
+/* { dg-options "-fno-inline" } */
+
+int
+func_4 (int si1, int si2)
+{
+  return si1;
+}
+
+int
+func_14 (int left, int right)
+{
+  return 1;
+}
+
+int
+func_37 (int left, int right)
+{
+  return left;
+}
+
+int g_92[1024];
+int g_95[1024];
+int g_224;
+int g_352[1024];
+int
+func_9 ()
+{
+  for (; g_224; g_224 += 1)
+    {
+      g_95[0] = func_4 (func_37 (g_92[g_224], 0), 0);
+      g_92[g_224] = 0, g_352[g_224] = func_14 (0, 0);
+    }
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/torture/pr51070.c
===================================================================
--- gcc/testsuite/gcc.dg/torture/pr51070.c	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/torture/pr51070.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,34 @@
+/* { dg-do compile } */
+
+int
+func_4 (int si1, int si2)
+{
+  return si1;
+}
+
+int
+func_14 (int left, int right)
+{
+  return 1;
+}
+
+int
+func_37 (int left, int right)
+{
+  return left;
+}
+
+int g_92[1024];
+int g_95[1024];
+int g_224;
+int g_352[1024];
+int
+func_9 ()
+{
+  for (; g_224; g_224 += 1)
+    {
+      g_95[0] = func_4 (func_37 (g_92[g_224], 0), 0);
+      g_92[g_224] = 0, g_352[g_224] = func_14 (0, 0);
+    }
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/tree-ssa/pr49642.c
===================================================================
--- gcc/testsuite/gcc.dg/tree-ssa/pr49642.c	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/tree-ssa/pr49642.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,49 @@
+/* Verify that ipa-split is disabled following __builtin_constant_p.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-optimized" } */
+
+typedef unsigned int u32;
+typedef unsigned long long u64;
+
+static inline __attribute__((always_inline)) __attribute__((const))
+int __ilog2_u32(u32 n)
+{
+ int bit;
+ asm ("cntlzw %0,%1" : "=r" (bit) : "r" (n));
+ return 31 - bit;
+}
+
+
+static inline __attribute__((always_inline)) __attribute__((const))
+int __ilog2_u64(u64 n)
+{
+ int bit;
+ asm ("cntlzd %0,%1" : "=r" (bit) : "r" (n));
+ return 63 - bit;
+}
+
+
+
+static u64 ehca_map_vaddr(void *caddr);
+
+struct ehca_shca {
+        u32 hca_cap_mr_pgsize;
+};
+
+static u64 ehca_get_max_hwpage_size(struct ehca_shca *shca)
+{
+ return 1UL << ( __builtin_constant_p(shca->hca_cap_mr_pgsize) ? ( (shca->hca_cap_mr_pgsize) < 1 ? ____ilog2_NaN() : (shca->hca_cap_mr_pgsize) & (1ULL << 63) ? 63 : (shca->hca_cap_mr_pgsize) & (1ULL << 62) ? 62 : (shca->hca_cap_mr_pgsize) & (1ULL << 61) ? 61 : (shca->hca_cap_mr_pgsize) & (1ULL << 60) ? 60 : (shca->hca_cap_mr_pgsize) & (1ULL << 59) ? 59 : (shca->hca_cap_mr_pgsize) & (1ULL << 58) ? 58 : (shca->hca_cap_mr_pgsize) & (1ULL << 57) ? 57 : (shca->hca_cap_mr_pgsize) & (1ULL << 56) ? 56 : (shca->hca_cap_mr_pgsize) & (1ULL << 55) ? 55 : (shca->hca_cap_mr_pgsize) & (1ULL << 54) ? 54 : (shca->hca_cap_mr_pgsize) & (1ULL << 53) ? 53 : (shca->hca_cap_mr_pgsize) & (1ULL << 52) ? 52 : (shca->hca_cap_mr_pgsize) & (1ULL << 51) ? 51 : (shca->hca_cap_mr_pgsize) & (1ULL << 50) ? 50 : (shca->hca_cap_mr_pgsize) & (1ULL << 49) ? 49 : (shca->hca_cap_mr_pgsize) & (1ULL << 48) ? 48 : (shca->hca_cap_mr_pgsize) & (1ULL << 47) ? 47 : (shca->hca_cap_mr_pgsize) & (1ULL << 46) ? 46 : (shca->hca_cap_mr_pgsize) & (1ULL << 45) ? 45 : (shca->hca_cap_mr_pgsize) & (1ULL << 44) ? 44 : (shca->hca_cap_mr_pgsize) & (1ULL << 43) ? 43 : (shca->hca_cap_mr_pgsize) & (1ULL << 42) ? 42 : (shca->hca_cap_mr_pgsize) & (1ULL << 41) ? 41 : (shca->hca_cap_mr_pgsize) & (1ULL << 40) ? 40 : (shca->hca_cap_mr_pgsize) & (1ULL << 39) ? 39 : (shca->hca_cap_mr_pgsize) & (1ULL << 38) ? 38 : (shca->hca_cap_mr_pgsize) & (1ULL << 37) ? 37 : (shca->hca_cap_mr_pgsize) & (1ULL << 36) ? 36 : (shca->hca_cap_mr_pgsize) & (1ULL << 35) ? 35 : (shca->hca_cap_mr_pgsize) & (1ULL << 34) ? 34 : (shca->hca_cap_mr_pgsize) & (1ULL << 33) ? 33 : (shca->hca_cap_mr_pgsize) & (1ULL << 32) ? 32 : (shca->hca_cap_mr_pgsize) & (1ULL << 31) ? 31 : (shca->hca_cap_mr_pgsize) & (1ULL << 30) ? 30 : (shca->hca_cap_mr_pgsize) & (1ULL << 29) ? 29 : (shca->hca_cap_mr_pgsize) & (1ULL << 28) ? 28 : (shca->hca_cap_mr_pgsize) & (1ULL << 27) ? 27 : (shca->hca_cap_mr_pgsize) & (1ULL << 26) ? 26 : (shca->hca_cap_mr_pgsize) & (1ULL << 25) ? 25 : (shca->hca_cap_mr_pgsize) & (1ULL << 24) ? 24 : (shca->hca_cap_mr_pgsize) & (1ULL << 23) ? 23 : (shca->hca_cap_mr_pgsize) & (1ULL << 22) ? 22 : (shca->hca_cap_mr_pgsize) & (1ULL << 21) ? 21 : (shca->hca_cap_mr_pgsize) & (1ULL << 20) ? 20 : (shca->hca_cap_mr_pgsize) & (1ULL << 19) ? 19 : (shca->hca_cap_mr_pgsize) & (1ULL << 18) ? 18 : (shca->hca_cap_mr_pgsize) & (1ULL << 17) ? 17 : (shca->hca_cap_mr_pgsize) & (1ULL << 16) ? 16 : (shca->hca_cap_mr_pgsize) & (1ULL << 15) ? 15 : (shca->hca_cap_mr_pgsize) & (1ULL << 14) ? 14 : (shca->hca_cap_mr_pgsize) & (1ULL << 13) ? 13 : (shca->hca_cap_mr_pgsize) & (1ULL << 12) ? 12 : (shca->hca_cap_mr_pgsize) & (1ULL << 11) ? 11 : (shca->hca_cap_mr_pgsize) & (1ULL << 10) ? 10 : (shca->hca_cap_mr_pgsize) & (1ULL << 9) ? 9 : (shca->hca_cap_mr_pgsize) & (1ULL << 8) ? 8 : (shca->hca_cap_mr_pgsize) & (1ULL << 7) ? 7 : (shca->hca_cap_mr_pgsize) & (1ULL << 6) ? 6 : (shca->hca_cap_mr_pgsize) & (1ULL << 5) ? 5 : (shca->hca_cap_mr_pgsize) & (1ULL << 4) ? 4 : (shca->hca_cap_mr_pgsize) & (1ULL << 3) ? 3 : (shca->hca_cap_mr_pgsize) & (1ULL << 2) ? 2 : (shca->hca_cap_mr_pgsize) & (1ULL << 1) ? 1 : (shca->hca_cap_mr_pgsize) & (1ULL << 0) ? 0 : ____ilog2_NaN() ) : (sizeof(shca->hca_cap_mr_pgsize) <= 4) ? __ilog2_u32(shca->hca_cap_mr_pgsize) : __ilog2_u64(shca->hca_cap_mr_pgsize) );
+}
+
+int x(struct ehca_shca *shca) {
+        return ehca_get_max_hwpage_size(shca);
+}
+
+int y(struct ehca_shca *shca)
+{
+        return ehca_get_max_hwpage_size(shca);
+}
+
+/* { dg-final { scan-tree-dump-times "____ilog2_NaN" 0 "optimized" } } */
+/* { dg-final { cleanup-tree-dump "optimized" } } */
Index: gcc/testsuite/gcc.dg/tree-ssa/pta-ptrarith-1.c
===================================================================
--- gcc/testsuite/gcc.dg/tree-ssa/pta-ptrarith-1.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/testsuite/gcc.dg/tree-ssa/pta-ptrarith-1.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -fno-tree-ccp -fdump-tree-ealias" } */
+/* { dg-options "-O2 -fno-tree-forwprop -fno-tree-ccp -fdump-tree-ealias" } */
 
 extern void abort (void);
 struct X {
Index: gcc/testsuite/gcc.dg/tree-ssa/pta-ptrarith-2.c
===================================================================
--- gcc/testsuite/gcc.dg/tree-ssa/pta-ptrarith-2.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/testsuite/gcc.dg/tree-ssa/pta-ptrarith-2.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -fno-tree-ccp -fdump-tree-ealias" } */
+/* { dg-options "-O2 -fno-tree-forwprop -fno-tree-ccp -fdump-tree-ealias" } */
 
 extern void abort (void);
 struct X {
Index: gcc/testsuite/gcc.dg/tree-ssa/pr51583.c
===================================================================
--- gcc/testsuite/gcc.dg/tree-ssa/pr51583.c	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/tree-ssa/pr51583.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,34 @@
+/* { dg-do compile } */
+/* { dg-options "-O1" } */
+
+typedef __complex__ double Value;
+
+union U
+{
+  Value v;
+  char c[sizeof(Value)];
+};
+
+struct S
+{
+  union U u;
+  int i,j;
+};
+
+Value gv;
+int gi, gj;
+
+Value foo (void)
+{
+  struct S s,t;
+
+  t.i = gi;
+  t.j = gj;
+  t.u.v = gv;
+  t.u.c[0] = 0;
+
+  s = t;
+  __imag__ s.u.v += s.i;
+
+  return s.u.v;
+}
Index: gcc/testsuite/gcc.dg/delay-slot-2.c
===================================================================
--- gcc/testsuite/gcc.dg/delay-slot-2.c	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/delay-slot-2.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,116 @@
+/* PR rtl-optimization/51187 */
+/* Reported by Jurij Smakov <jurij@wooyd.org> */
+
+/* { dg-do compile } */
+/* { dg-options "-g -O2" } */
+
+extern int printf (__const char *__restrict __format, ...);
+extern void print_c_condition (const char *);
+
+enum decision_type
+{
+  DT_num_insns,
+  DT_mode, DT_code, DT_veclen,
+  DT_elt_zero_int, DT_elt_one_int, DT_elt_zero_wide, DT_elt_zero_wide_safe,
+  DT_const_int,
+  DT_veclen_ge, DT_dup, DT_pred, DT_c_test,
+  DT_accept_op, DT_accept_insn
+};
+
+struct decision_test
+{
+  struct decision_test *next;
+  enum decision_type type;
+
+  union
+  {
+    int num_insns;
+
+    struct
+    {
+      const char *name;
+    } pred;
+
+    const char *c_test;
+    int veclen;
+    int dup;
+    long intval;
+    int opno;
+
+    struct {
+      int code_number;
+      int lineno;
+      int num_clobbers_to_add;
+    } insn;
+  } u;
+};
+
+enum routine_type {
+  RECOG, SPLIT, PEEPHOLE2
+};
+
+void
+write_cond (struct decision_test *p, int depth,
+     enum routine_type subroutine_type)
+{
+  switch (p->type)
+    {
+    case DT_num_insns:
+      printf ("peep2_current_count >= %d", p->u.num_insns);
+      break;
+
+    case DT_code:
+      printf ("GET_CODE (x%d) == ", depth);
+      break;
+
+    case DT_veclen:
+      printf ("XVECLEN (x%d, 0) == %d", depth, p->u.veclen);
+      break;
+
+    case DT_elt_zero_int:
+      printf ("XINT (x%d, 0) == %d", depth, (int) p->u.intval);
+      break;
+
+    case DT_elt_one_int:
+      printf ("XINT (x%d, 1) == %d", depth, (int) p->u.intval);
+      break;
+
+    case DT_elt_zero_wide:
+    case DT_elt_zero_wide_safe:
+      printf ("XWINT (x%d, 0) == ", depth);
+      print_host_wide_int (p->u.intval);
+      break;
+
+    case DT_const_int:
+      printf ("x%d == const_int_rtx[MAX_SAVED_CONST_INT + (%d)]",
+       depth, (int) p->u.intval);
+      break;
+
+    case DT_veclen_ge:
+      printf ("XVECLEN (x%d, 0) >= %d", depth, p->u.veclen);
+      break;
+
+    case DT_dup:
+      printf ("rtx_equal_p (x%d, operands[%d])", depth, p->u.dup);
+      break;
+
+    case DT_pred:
+      printf ("%s (x%d)", p->u.pred.name, depth);
+      break;
+
+    case DT_c_test:
+      print_c_condition (p->u.c_test);
+      break;
+
+    case DT_accept_insn:
+      ((void)(__builtin_expect(!(subroutine_type == RECOG), 0) ? __builtin_unreachable(), 0 : 0));
+      ((void)(__builtin_expect(!(p->u.insn.num_clobbers_to_add), 0) ? __builtin_unreachable(), 0 : 0));
+      printf ("pnum_clobbers != NULL");
+      break;
+
+    default:
+      __builtin_unreachable();
+    }
+}
+
+/* { dg-final { scan-assembler "printf" } } */
Index: gcc/testsuite/ada/acats/overflow.lst
===================================================================
--- gcc/testsuite/ada/acats/overflow.lst	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/testsuite/ada/acats/overflow.lst	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -14,3 +14,4 @@
 c460008
 c460011
 c4a012b
+cb20004
Index: gcc/testsuite/ChangeLog
===================================================================
--- gcc/testsuite/ChangeLog	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/testsuite/ChangeLog	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1,3 +1,411 @@
+2012-01-30  Bin Cheng  <bin.cheng@arm.com>
+
+	Backport from mainline.
+	2012-01-30  Bin Cheng  <bin.cheng@arm.com>
+
+	PR target/51835
+	* gcc.target/arm/pr51835.c: New testcase.
+
+2012-01-28  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/52022
+	* gfortran.dg/dummy_procedure_7.f90: New.
+
+2012-01-25  Jason Merrill  <jason@redhat.com>
+
+	PR target/51934
+	* g++.dg/torture/pr51344.C: Limit to x86.
+
+2012-01-25  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/51966
+	* gfortran.dg/derived_constructor_char_3.f90: New.
+
+2012-01-24  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/51948
+	* gfortran.dg/move_alloc_12.f90: New.
+
+2012-01-21  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/51913
+	* gfortran.dg/class_47.f90: New.
+
+2012-01-21  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/renaming5.ad[sb]: New test.
+
+2012-01-20  Kai Tietz  <ktietz@redhat.com>
+
+	* g++.dg/torture/pr51344.C: Fix typo.
+
+2012-01-19  Kai Tietz  <ktietz@redhat.com>
+
+	* g++.dg/torture/pr51344.C: New test.
+
+2012-01-19  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/51904
+	* gfortran.dg/intrinsic_size_2.f90: New.
+
+2012-01-18  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	PR tree-optimization/49642
+	* gcc.dg/tree-ssa/pr49642.c: New test.
+
+2012-01-16  Jason Merrill  <jason@redhat.com>
+
+	PR c++/51854
+	* g++.dg/abi/mangle60.C: New.
+
+	PR c++/51868
+	* g++.dg/cpp0x/rv-bitfield.C: New.
+	* g++.dg/cpp0x/rv-bitfield2.C: New.
+
+2012-01-15  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR rtl-optimization/51821
+	* gcc.dg/pr51821.c: New test.
+
+2012-01-14  Tobias Burnus  <burnus@net-b.de>
+
+	Backported from mainline
+	2012-01-14  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/51800
+	* gfortran.dg/init_flag_8.f90: New.
+	* gfortran.dg/init_flag_9.f90: New.
+
+2012-01-12  Matthew Gretton-Dann  <matthew.gretton-dann@arm.com>
+
+	Backport from mainline:
+	2012-01-11  Matthew Gretton-Dann  <matthew.gretton-dann@arm.com>
+
+	* testsuite/gcc.c-torture/execute/20120110-1.c: New testcase.
+
+2012-01-10  Joseph Myers  <joseph@codesourcery.com>
+
+	* gcc.c-torture/execute/doloop-1.c,
+	gcc.c-torture/execute/doloop-2.c: New tests.
+
+2012-01-09  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/51759
+	* g++.dg/ipa/pr51759.C: New test.
+
+2012-01-09  Ramana Radhakrishnan  <ramana.radhakrishnan@linaro.org>
+
+	Backport from mainline:
+	2011-11-04  Jiangning Liu  <jiangning.liu@arm.com>
+
+	PR rtl-optimization/38644
+	* gcc.target/arm/stack-red-zone.c: New.
+
+2012-01-09  Andrew Stubbs  <ams@codesourcery.com>
+
+	Backport from mainline:
+
+	2012-01-06  Andrew Stubbs  <ams@codesourcery.com>
+
+	* gcc.target/arm/headmerge-2.c: Adjust scan pattern.
+
+2012-01-06  Richard Sandiford  <richard.sandiford@linaro.org>
+
+	PR middle-end/48660
+	* g++.dg/pr48660.C: New test.
+
+2012-01-06  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* ada/acats/overflow.lst: Add cb20004.
+
+2012-01-05  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.c-torture/execute/20120104-1.c: New test.
+
+2012-01-04  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/49651
+	* gcc.dg/tree-ssa/pta-ptrarith-1.c: Adjust.
+	* gcc.dg/tree-ssa/pta-ptrarith-2.c: Likewise.
+
+2012-01-03  Richard Guenther  <rguenther@suse.de>
+
+	Backport from mainline
+	2011-11-10  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/51042
+	* gcc.dg/torture/pr51042.c: New testcase.
+
+2012-01-03  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/51070
+	* gcc.dg/torture/pr51070.c: New testcase.
+	* gcc.dg/torture/pr51070-2.c: Likewise.
+
+2011-12-20  Dodji Seketeli  <dodji@redhat.com>
+
+	PR debug/49951
+	* g++.dg/gcov/gcov-2.C: Adjust.
+
+2012-01-01  Thomas Knig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/51502
+	* lib/gcc-dg.exp (scan-module-absence):  New function.
+	* gfortran.dg/implicit_pure_2.f90:  New test.
+
+2011-12-28  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2011-12-28  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	PR target/51623
+	* gcc.target/powerpc/pr51623.c: New file.
+
+2011-12-28  Uros Bizjak  <ubizjak@gmail.com>
+
+	* gcc.dg/torture/pr50396.c: Use dg-add-options ieee.
+
+2011-12-23  Richard Guenther  <rguenther@suse.de>
+
+	PR rtl-optimization/50396
+	* gcc.dg/torture/pr50396.c: New testcase.
+
+2011-12-22  Doug Kwan  <dougkwan@google.com>
+
+	Backport from mainline
+	2011-11-20  Joey Ye  <joey.ye@arm.com>
+
+	* gcc.dg/volatile-bitfields-1.c: New.
+
+2011-12-21  Richard Earnshaw  <rearnsha@arm.com>
+
+	PR target/51643
+	* gcc.target/arm/sibcall-2.c: New test.
+
+2011-12-19  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/51583
+	* gcc.dg/tree-ssa/pr51583.c: New test.
+
+2011-12-16  Jason Merrill  <jason@redhat.com>
+
+	PR c++/51416
+	* g++.dg/cpp0x/auto31.C: New.
+
+2011-12-16  Jason Merrill  <jason@redhat.com>
+
+	PR c++/51331
+	* g++.dg/init/value10.C: New.
+
+2011-12-15  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline.
+	2011-10-28  Chung-Lin Tang  <cltang@codesourcery.com>
+
+	PR rtl-optimization/49720
+	* g++.dg/torture/pr49720.C: New test.
+
+2011-12-14  Jason Merrill  <jason@redhat.com>
+
+	PR c++/51248
+	* g++.dg/other/enum2.C: New.
+
+2011-12-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/51406
+	PR c++/51161
+	* g++.dg/cpp0x/rv-cast3.C: New.
+	* g++.dg/cpp0x/rv-cast4.C: New.
+
+2011-12-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR testsuite/51511
+	* gcc.dg/pr45819.c: Add -w to dg-options.
+
+	Backported from mainline
+	2011-12-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/51485
+	* g++.dg/vect/pr51485.cc: New test.
+
+2011-12-12  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.c-torture/execute/20111212-1.c: New test.
+
+2011-12-11  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/50923
+	* gfortran.dg/warn_function_without_result_2.f90: New.
+
+2011-12-11  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/51338
+	Backport from trunk
+	* gfortran.dg/assumed_charlen_substring_1.f90:  New test.
+
+2011-12-09  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline
+	2011-12-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/51466
+	* gcc.c-torture/execute/pr51466.c: New test.
+
+	2011-11-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/50078
+	* gcc.dg/pr50078.c: New test.
+
+2011-12-09  Kazu Hirata  <kazu@codesourcery.com>
+
+	Backport from mainline:
+
+	2011-12-05  Kazu Hirata  <kazu@codesourcery.com>
+
+	PR target/51408
+	* gcc.dg/pr51408.c: New.
+
+2011-12-08  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/51448
+	* gfortran.dg/realloc_on_assign_8.f90: New.
+
+2011-12-08  Teresa Johnson  <tejohnson@google.com>
+
+	* gcc.target/i386/movdi-rex64.c: Remove unnecessary
+	unused label.
+
+2011-12-08  Teresa Johnson  <tejohnson@google.com>
+
+	* gcc.target/i386/movdi-rex64.c: Remove unnecessary
+	-Wwrite-strings option.
+
+2011-12-08  Teresa Johnson  <tejohnson@google.com>
+
+	* gcc.target/i386/movdi-rex64.c: New.
+
+2011-12-08  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline
+	2011-12-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/51410
+	* gcc.dg/debug/dwarf2/pr51410.c: New test.
+
+	PR c/51339
+	* gcc.dg/gomp/pr51339.c: New test.
+
+	2011-12-05  Jakub Jelinek  <jakub@redhat.com>
+		    Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR middle-end/51323
+	PR middle-end/50074
+	* gcc.c-torture/execute/pr51323.c: New test.
+
+	2011-11-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/48721
+	* gcc.target/i386/pr48721.c: New test.
+
+2011-12-08  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.c-torture/execute/20111208-1.c: New test.
+
+	Backport from mainline
+	2011-09-25  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/frame_overflow.ads: New.
+	* gnat.dg/frame_overflow.adb: Adjust.
+	* gnat.dg/specs/addr1.ads: Likewise.
+
+2011-12-06  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/51435
+	* gfortran.dg/default_initialization_5.f90: New.
+
+2011-12-06  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/50622
+	* g++.dg/tree-ssa/pr50622.C: New test.
+
+2011-12-04  Uros Bizjak  <ubizjak@gmail.com>
+	    Jrmie Detrey  <Jeremie.Detrey@loria.fr>
+
+	PR target/51393
+	* gcc.target/i386/pr51393.c: New test.
+
+2011-12-03  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/50684
+	* gfortran.dg/move_alloc_8.f90: New.
+
+2011-11-25  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/50408
+	* gfortran.dg/whole_file_35.f90: New.
+
+2011-11-24  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/51218
+	* resolve.c (pure_subroutine): If called subroutine is
+	impure, unset implicit_pure.
+	(resolve_function): Move impure check to simplify code.
+
+2011-11-22  Paolo Carlini  <paolo.carlini@oracle.com>
+
+	PR c++/51265
+	* g++.dg/cpp0x/decltype36.C: New.
+
+2011-11-19  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.dg/delay-slot-2.c: New test.
+
+2011-11-18  Joseph Myers  <joseph@codesourcery.com>
+
+	* gcc.dg/cpp/assert4.c: Test __linux__, not __gnu_linux__.
+
+2011-11-18  Paolo Carlini  <paolo.carlini@oracle.com>
+
+	PR c++/51150
+	* g++.dg/cpp0x/pr51150.C: New.
+
+2011-11-16  Richard Earnshaw  <rearnsha@arm.com>
+	    Bernd Schmidt <bernds@coudesourcery.com>
+	    Sebastian Huber <sebastian.huber@embedded-brains.de>
+
+	PR target/49641
+	* gcc.target/arm/pr49641.c: New test.
+
+2011-11-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/51077
+	* gcc.c-torture/compile/pr51077.c: New test.
+
+2011-11-07  Jason Merrill  <jason@redhat.com>
+
+	PR c++/50870
+	* g++.dg/cpp0x/decltype35.C: New.
+
+2011-11-04  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* g++.dg/other/offsetof7.C: New test.
+
+2011-11-02  Bernd Schmidt  <bernds@codesourcery.com>
+
+	* gcc.c-torture/compile/20110907.c: New file.
+
+2011-10-29  Paolo Carlini  <paolo.carlini@oracle.com>
+
+	PR c++/50901
+	* g++.dg/cpp0x/pr50901.C: New.
+
+2011-10-27  Uros Bizjak  <ubizjak@gmail.com>
+	    Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR target/50875
+	* gfortran.dg/pr50875.f90: New test.
+
 2011-10-26  Release Manager
 
 	* GCC 4.6.2 released.
@@ -9,9 +417,9 @@
 
 2011-10-20  Uros Bizjak  <ubizjak@gmail.com>
 
-       * gcc.dg/ipa/ipa-sra-2.c: Add dg-require-effective-target
-       non_strict_align.
-       * gcc.dg/ipa/ipa-sra-6.c: Ditto.
+	* gcc.dg/ipa/ipa-sra-2.c: Add dg-require-effective-target
+	non_strict_align.
+	* gcc.dg/ipa/ipa-sra-6.c: Ditto.
 
 2011-10-19  Jason Merrill  <jason@redhat.com>
 
Index: gcc/testsuite/g++.dg/vect/pr51485.cc
===================================================================
--- gcc/testsuite/g++.dg/vect/pr51485.cc	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/vect/pr51485.cc	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+
+struct A { A (); unsigned int a; };
+double bar (A a) throw () __attribute__((pure));
+
+void
+foo (unsigned int x, double *y, A *z)
+{
+  unsigned int i;
+  for (i = 0; i < x; i++)
+    y[i] = bar (z[i]);
+}
+
+/* { dg-final { cleanup-tree-dump "vect" } } */
Index: gcc/testsuite/g++.dg/pr48660.C
===================================================================
--- gcc/testsuite/g++.dg/pr48660.C	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/pr48660.C	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,22 @@
+template<int N> struct val { char a[N]; };
+
+class Base
+{
+public:
+  virtual val<1> get1() const = 0;
+  virtual val<2> get2() const = 0;
+  virtual val<3> get3() const = 0;
+  virtual val<4> get4() const = 0;
+};
+
+class Derived : public virtual Base
+{
+public:
+  virtual val<1> get1() const { return foo->get1(); }
+  virtual val<2> get2() const { return foo->get2(); }
+  virtual val<3> get3() const { return foo->get3(); }
+  virtual val<4> get4() const { return foo->get4(); }
+  Base *foo;
+};
+
+Base* make() { return new Derived; }
Index: gcc/testsuite/g++.dg/abi/mangle60.C
===================================================================
--- gcc/testsuite/g++.dg/abi/mangle60.C	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/abi/mangle60.C	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,21 @@
+// PR c++/51854
+// { dg-options "" }
+// { dg-excess-errors "" { xfail *-*-* } }
+
+template <unsigned N> struct A;
+
+template <typename U, typename V>
+char foo(U, V);
+
+// { dg-final { scan-assembler "_Z3barIiEvP1AIXszcl3foocvT__ELCi0_42EEEE" } }
+template <typename U>
+void bar(A<sizeof(foo(U(), 42i))> *);
+
+// { dg-final { scan-assembler "_Z3bazIiEvP1AIXszcl3foocvT__ELCf00000000_00000000EEEE" } }
+template <typename U>
+void baz(A<sizeof(foo(U(), 0.0fj))> *);
+
+int main() {
+   bar<int>(0);
+   baz<int>(0);
+}
Index: gcc/testsuite/g++.dg/init/value10.C
===================================================================
--- gcc/testsuite/g++.dg/init/value10.C	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/init/value10.C	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,27 @@
+// PR c++/51331
+// { dg-do run }
+
+struct A {
+  A(): x(10) {}
+  virtual ~A() {}
+
+  int x;
+};
+
+struct B: public virtual A {
+};
+
+struct C: public virtual A {
+};
+
+struct D: public B, virtual public C {
+  D(): B(), C() {}  // note an explicit call to C() which is auto-generated
+};
+
+int main() {
+  D* d = new D();
+
+  // Crashes here with the following message:
+  // *** glibc detected *** ./test: free(): invalid next size (fast)
+  delete d;
+}
Index: gcc/testsuite/g++.dg/other/enum2.C
===================================================================
--- gcc/testsuite/g++.dg/other/enum2.C	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/other/enum2.C	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,3 @@
+// PR c++/51248
+
+enum E { e = sizeof(const E*) };
Index: gcc/testsuite/g++.dg/other/offsetof7.C
===================================================================
--- gcc/testsuite/g++.dg/other/offsetof7.C	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/other/offsetof7.C	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,17 @@
+// PR c++/50608
+// Testcase by <dberger@oubliette.org>
+// { dg-do compile }
+
+struct A {
+    int offset;
+};
+
+struct B: public A {
+};
+
+struct C {
+    A a;
+    B b;
+};
+
+int fails = __builtin_offsetof (C, b.offset);
Index: gcc/testsuite/g++.dg/tree-ssa/pr50622.C
===================================================================
--- gcc/testsuite/g++.dg/tree-ssa/pr50622.C	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/tree-ssa/pr50622.C	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,30 @@
+// { dg-do compile }
+// { dg-options "-O2" }
+
+typedef __complex__ double Value;
+struct LorentzVector
+{
+  LorentzVector & operator+=(const LorentzVector & a) {
+    theX += a.theX;
+    theY += a.theY;
+    theZ += a.theZ;
+    theT += a.theT;
+    return *this;
+  }
+
+  Value theX;
+  Value theY;
+  Value theZ;
+  Value theT;
+};
+
+inline LorentzVector
+operator+(LorentzVector a, const LorentzVector & b) {
+  return a += b;
+}
+
+Value ex, et;
+LorentzVector sum() {
+  LorentzVector v1; v1.theX =ex; v1.theY =ex+et; v1.theZ =ex-et;   v1.theT =et;
+  return v1+v1;
+}
Index: gcc/testsuite/g++.dg/cpp0x/auto31.C
===================================================================
--- gcc/testsuite/g++.dg/cpp0x/auto31.C	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/cpp0x/auto31.C	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,12 @@
+// PR c++/51416
+// { dg-options "-std=c++0x" }
+
+template<typename T, typename... U> void foo(T, U... u)
+{
+  auto foo(u...);		// { dg-error "auto" }
+}
+
+void bar()
+{
+  foo(0);
+}
Index: gcc/testsuite/g++.dg/cpp0x/pr50901.C
===================================================================
--- gcc/testsuite/g++.dg/cpp0x/pr50901.C	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/cpp0x/pr50901.C	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,9 @@
+// { dg-options "-std=c++0x" }
+
+template<class T> int foo(int a)
+{
+  const unsigned b = a < 0 ? -a : a;
+  return 0;
+}
+
+int i = foo<float>(1);
Index: gcc/testsuite/g++.dg/cpp0x/variadic103.C
===================================================================
--- gcc/testsuite/g++.dg/cpp0x/variadic103.C	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/testsuite/g++.dg/cpp0x/variadic103.C	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -5,7 +5,7 @@
 
 template<class T, class... Args>
 void test() {
-  T t(create<Args>()...);	// { dg-error "unknown bound" }
+  T t(create<Args>()...);	// { dg-error "incomplete" }
   (void) t;
 }
 
Index: gcc/testsuite/g++.dg/cpp0x/decltype35.C
===================================================================
--- gcc/testsuite/g++.dg/cpp0x/decltype35.C	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/cpp0x/decltype35.C	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,15 @@
+// PR c++/50870
+// { dg-options -std=c++0x }
+
+template <class V>
+  struct impl
+  {
+    template <class T> static T create();
+  };
+
+template <class T, class U, class V, class
+      = decltype(impl<V>::template create<T>()
+             -> impl<V>::template create<U>())>
+struct tester { };
+
+tester<impl<float>*, int, float> ti;
Index: gcc/testsuite/g++.dg/cpp0x/decltype36.C
===================================================================
--- gcc/testsuite/g++.dg/cpp0x/decltype36.C	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/cpp0x/decltype36.C	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,21 @@
+// PR c++/51265
+// { dg-options -std=c++0x }
+
+struct Funny
+{
+  int print(int);
+};
+
+template<typename X>
+void c();
+
+template<typename X, X ff>
+void xx()
+{
+  c<decltype(ff)>();
+}
+
+int main()
+{
+  xx<int(Funny::*)(int), &Funny::print>();
+}
Index: gcc/testsuite/g++.dg/cpp0x/pr51150.C
===================================================================
--- gcc/testsuite/g++.dg/cpp0x/pr51150.C	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/cpp0x/pr51150.C	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,20 @@
+// PR c++/51150
+// { dg-options "-std=c++0x" }
+
+struct Clock {
+  double Now();
+};
+template <class T> void Foo(Clock* clock) {
+  const int now = clock->Now();
+}
+
+template void Foo<float>(Clock*);
+
+template <class T> void Boo(int val) {
+  const int now1 = (double)(val);
+  const int now2 = const_cast<double>(val); // { dg-error "invalid" }
+  const int now3 = static_cast<double>(val);
+  const int now4 = reinterpret_cast<double>(val); // { dg-error "invalid" }
+}
+
+template void Boo<float>(int);
Index: gcc/testsuite/g++.dg/cpp0x/rv-bitfield2.C
===================================================================
--- gcc/testsuite/g++.dg/cpp0x/rv-bitfield2.C	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/cpp0x/rv-bitfield2.C	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,17 @@
+// PR c++/51868
+// { dg-options -std=c++0x }
+
+struct A {
+  A() {}
+  A(const A&) {}
+  A(A&&) {}
+};
+
+struct B {
+  A a;
+  int f : 1;
+};
+
+B func() {
+  return B();
+}
Index: gcc/testsuite/g++.dg/cpp0x/rv-bitfield.C
===================================================================
--- gcc/testsuite/g++.dg/cpp0x/rv-bitfield.C	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/cpp0x/rv-bitfield.C	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,12 @@
+// { dg-options -std=c++0x }
+
+struct A
+{
+  int i : 1;
+};
+
+int main()
+{
+  A a;
+  static_cast<int&&>(a.i);
+}
Index: gcc/testsuite/g++.dg/cpp0x/rv-cast3.C
===================================================================
--- gcc/testsuite/g++.dg/cpp0x/rv-cast3.C	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/cpp0x/rv-cast3.C	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,18 @@
+// PR c++/51406
+// { dg-do run }
+// { dg-options "-std=c++0x" }
+
+extern "C" int printf(const char *,...);
+extern "C" void abort();
+
+struct A { int a; A() : a(1) {} };
+struct B { int b; B() : b(2) {} };
+struct X : A, B {};
+
+int main() {
+    X x;
+    int a=static_cast<A&&>(x).a;
+    int b=static_cast<B&&>(x).b;
+    // printf ("%d %d\n", a, b);
+    if (a!=1 || b!=2) abort();
+}
Index: gcc/testsuite/g++.dg/cpp0x/rv-cast4.C
===================================================================
--- gcc/testsuite/g++.dg/cpp0x/rv-cast4.C	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/cpp0x/rv-cast4.C	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,13 @@
+// PR c++/51161
+// { dg-options "-std=c++0x" }
+
+struct A{};
+struct B : A{};
+struct C : A{};
+struct D : B, C{};
+
+int main()
+{
+  D d;
+  static_cast<A &&>(d);		// { dg-error "ambiguous" }
+}
Index: gcc/testsuite/g++.dg/gcov/gcov-2.C
===================================================================
--- gcc/testsuite/g++.dg/gcov/gcov-2.C	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/testsuite/g++.dg/gcov/gcov-2.C	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -20,7 +20,7 @@
 
 void foo()
 {
-  C c;					/* count(2) */
+  C c;					/* count(1) */
   c.seti (1);				/* count(1) */
 }
 
Index: gcc/testsuite/g++.dg/torture/pr51344.C
===================================================================
--- gcc/testsuite/g++.dg/torture/pr51344.C	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/torture/pr51344.C	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,11 @@
+/* { dg-do compile { target { i?86-*-* && ilp32 } } } */
+class A;
+
+template <class T>
+class B
+{
+  friend __attribute__((cdecl)) A& operator >>(A& a, B& b)
+  {
+    return a;
+  }
+};
Index: gcc/testsuite/g++.dg/torture/pr49720.C
===================================================================
--- gcc/testsuite/g++.dg/torture/pr49720.C	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/torture/pr49720.C	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,8 @@
+/* { dg-do compile } */
+
+extern char t_start[], t_end[], t_size[];
+bool foo (void)
+{
+  long size = reinterpret_cast<long>(t_size);
+  return (size == t_end - t_start);
+}
Index: gcc/testsuite/g++.dg/ipa/pr51759.C
===================================================================
--- gcc/testsuite/g++.dg/ipa/pr51759.C	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/ipa/pr51759.C	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,26 @@
+/* { dg-do run } */
+/* { dg-options "-O2"  } */
+
+extern "C" void abort (void);
+struct S
+{
+  void __attribute__((noinline)) set(unsigned val)
+    {
+      data = val;
+      if (data != val)
+        abort ();
+    }
+  int pad0;
+  unsigned pad1 : 8;
+  unsigned data : 24;
+  int pad2;
+};
+int main()
+{
+  S s;
+  s.pad2 = -1;
+  s.set(0);
+  if (s.pad2 != -1)
+    abort ();
+}
+
Index: gcc/cp/typeck.c
===================================================================
--- gcc/cp/typeck.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/cp/typeck.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -4835,9 +4835,7 @@
       && TREE_CONSTANT (TREE_OPERAND (val, 0)))
     {
       tree type = build_pointer_type (argtype);
-      tree op0 = fold_convert (type, TREE_OPERAND (val, 0));
-      tree op1 = fold_convert (sizetype, fold_offsetof (arg, val));
-      return fold_build2 (POINTER_PLUS_EXPR, type, op0, op1);
+      return fold_convert (type, fold_offsetof_1 (arg));
     }
 
   /* Handle complex lvalues (when permitted)
@@ -5698,11 +5696,12 @@
 {
   tree intype;
   tree result;
+  cp_lvalue_kind clk;
 
   /* Assume the cast is valid.  */
   *valid_p = true;
 
-  intype = TREE_TYPE (expr);
+  intype = unlowered_expr_type (expr);
 
   /* Save casted types in the function's used types hash table.  */
   used_types_insert (type);
@@ -5768,12 +5767,29 @@
      cv2 T2 if cv2 T2 is reference-compatible with cv1 T1 (8.5.3)."  */
   if (TREE_CODE (type) == REFERENCE_TYPE
       && TYPE_REF_IS_RVALUE (type)
-      && real_lvalue_p (expr)
+      && (clk = real_lvalue_p (expr))
       && reference_related_p (TREE_TYPE (type), intype)
       && (c_cast_p || at_least_as_qualified_p (TREE_TYPE (type), intype)))
     {
-      expr = build_typed_address (expr, type);
-      return convert_from_reference (expr);
+      if (clk == clk_ordinary)
+	{
+	  /* Handle the (non-bit-field) lvalue case here by casting to
+	     lvalue reference and then changing it to an rvalue reference.
+	     Casting an xvalue to rvalue reference will be handled by the
+	     main code path.  */
+	  tree lref = cp_build_reference_type (TREE_TYPE (type), false);
+	  result = (perform_direct_initialization_if_possible
+		    (lref, expr, c_cast_p, complain));
+	  result = cp_fold_convert (type, result);
+	  /* Make sure we don't fold back down to a named rvalue reference,
+	     because that would be an lvalue.  */
+	  if (DECL_P (result))
+	    result = build1 (NON_LVALUE_EXPR, type, result);
+	  return convert_from_reference (result);
+	}
+      else
+	/* For a bit-field or packed field, bind to a temporary.  */
+	expr = rvalue (expr);
     }
 
   /* Resolve overloaded address here rather than once in
Index: gcc/cp/init.c
===================================================================
--- gcc/cp/init.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/cp/init.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -141,7 +141,9 @@
    zero-initialization does not simply mean filling the storage with
    zero bytes.  FIELD_SIZE, if non-NULL, is the bit size of the field,
    subfields with bit positions at or above that bit size shouldn't
-   be added.  */
+   be added.  Note that this only works when the result is assigned
+   to a base COMPONENT_REF; if we only have a pointer to the base subobject,
+   expand_assignment will end up clearing the full size of TYPE.  */
 
 static tree
 build_zero_init_1 (tree type, tree nelts, bool static_storage_p,
@@ -368,6 +370,12 @@
 tree
 build_value_init_noctor (tree type, tsubst_flags_t complain)
 {
+  if (!COMPLETE_TYPE_P (type))
+    {
+      if (complain & tf_error)
+	error ("value-initialization of incomplete type %qT", type);
+      return error_mark_node;
+    }
   if (CLASS_TYPE_P (type))
     {
       gcc_assert (!TYPE_NEEDS_CONSTRUCTING (type));
Index: gcc/cp/class.c
===================================================================
--- gcc/cp/class.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/cp/class.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -464,7 +464,14 @@
     /* Is this the base field created by build_base_field?  */
     if (TREE_CODE (field) == FIELD_DECL
 	&& DECL_FIELD_IS_BASE (field)
-	&& TREE_TYPE (field) == type)
+	&& TREE_TYPE (field) == type
+	/* If we're looking for a field in the most-derived class,
+	   also check the field offset; we can have two base fields
+	   of the same type if one is an indirect virtual base and one
+	   is a direct non-virtual base.  */
+	&& (BINFO_INHERITANCE_CHAIN (d_binfo)
+	    || tree_int_cst_equal (byte_position (field),
+				   BINFO_OFFSET (binfo))))
       {
 	/* We don't use build_class_member_access_expr here, as that
 	   has unnecessary checks, and more importantly results in
@@ -541,6 +548,10 @@
     {
       tree pointer_type;
 
+      /* If this is a non-empty base, use a COMPONENT_REF.  */
+      if (!is_empty_class (BINFO_TYPE (base)))
+	return build_simple_base_path (expr, base);
+
       pointer_type = build_pointer_type (expr_type);
 
       /* We use fold_build2 and fold_convert below to simplify the trees
Index: gcc/cp/decl.c
===================================================================
--- gcc/cp/decl.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/cp/decl.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -11540,15 +11540,19 @@
 static void
 copy_type_enum (tree dst, tree src)
 {
-  TYPE_MIN_VALUE (dst) = TYPE_MIN_VALUE (src);
-  TYPE_MAX_VALUE (dst) = TYPE_MAX_VALUE (src);
-  TYPE_SIZE (dst) = TYPE_SIZE (src);
-  TYPE_SIZE_UNIT (dst) = TYPE_SIZE_UNIT (src);
-  SET_TYPE_MODE (dst, TYPE_MODE (src));
-  TYPE_PRECISION (dst) = TYPE_PRECISION (src);
-  TYPE_ALIGN (dst) = TYPE_ALIGN (src);
-  TYPE_USER_ALIGN (dst) = TYPE_USER_ALIGN (src);
-  TYPE_UNSIGNED (dst) = TYPE_UNSIGNED (src);
+  tree t;
+  for (t = dst; t; t = TYPE_NEXT_VARIANT (t))
+    {
+      TYPE_MIN_VALUE (t) = TYPE_MIN_VALUE (src);
+      TYPE_MAX_VALUE (t) = TYPE_MAX_VALUE (src);
+      TYPE_SIZE (t) = TYPE_SIZE (src);
+      TYPE_SIZE_UNIT (t) = TYPE_SIZE_UNIT (src);
+      SET_TYPE_MODE (dst, TYPE_MODE (src));
+      TYPE_PRECISION (t) = TYPE_PRECISION (src);
+      TYPE_ALIGN (t) = TYPE_ALIGN (src);
+      TYPE_USER_ALIGN (t) = TYPE_USER_ALIGN (src);
+      TYPE_UNSIGNED (t) = TYPE_UNSIGNED (src);
+    }
 }
 
 /* Begin compiling the definition of an enumeration type.
@@ -11903,9 +11907,12 @@
       return;
     }
 
-  /* Here there should not be any variants of this type.  */
+  /* If this is a forward declaration, there should not be any variants,
+     though we can get a variant in the middle of an enum-specifier with
+     wacky code like 'enum E { e = sizeof(const E*) };'  */
   gcc_assert (enumtype == TYPE_MAIN_VARIANT (enumtype)
-	      && !TYPE_NEXT_VARIANT (enumtype));
+	      && (TYPE_VALUES (enumtype)
+		  || !TYPE_NEXT_VARIANT (enumtype)));
 }
 
 /* Build and install a CONST_DECL for an enumeration constant of the
@@ -13356,8 +13363,17 @@
 	cleanup = call;
     }
 
+  /* build_delete sets the location of the destructor call to the
+     current location, even though the destructor is going to be
+     called later, at the end of the current scope.  This can lead to
+     a "jumpy" behaviour for users of debuggers when they step around
+     the end of the block.  So let's unset the location of the
+     destructor call instead.  */
+  if (cleanup != NULL && EXPR_P (cleanup))
+    SET_EXPR_LOCATION (cleanup, UNKNOWN_LOCATION);
   return cleanup;
 }
+
 
 /* When a stmt has been parsed, this function is called.  */
 
Index: gcc/cp/ChangeLog
===================================================================
--- gcc/cp/ChangeLog	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/cp/ChangeLog	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1,3 +1,79 @@
+2012-01-19  Kai Tietz  <ktietz@redhat.com>
+
+	PR c++/51344
+	* decl2.c (save_template_attributes): Use merge_attributes
+	instead of chaining up via TREE_CHAIN.
+
+2012-01-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/51854
+	* mangle.c (write_template_arg_literal): Sorry instead of aborting.
+
+2012-01-16  Jason Merrill  <jason@redhat.com>
+
+	PR c++/51868
+	* typeck.c (build_static_cast_1): Handle bit-fields properly.
+
+2011-12-20  Dodji Seketeli  <dodji@redhat.com>
+
+	PR debug/49951
+	* decl.c (cxx_maybe_build_cleanup): Don't set location of the call
+	to the destructor.
+
+2011-12-16  Jason Merrill  <jason@redhat.com>
+
+	PR c++/51416
+	* init.c (build_value_init_noctor): Check for incomplete type.
+
+2011-12-16  Jason Merrill  <jason@redhat.com>
+
+	PR c++/51331
+	* class.c (convert_to_base_statically): Just call
+	build_simple_base_path.
+	(build_simple_base_path): Check field offset.
+
+2011-12-14  Jason Merrill  <jason@redhat.com>
+
+	PR c++/51248
+	* decl.c (copy_type_enum): Also update variants.
+	(finish_enum): Allow variants of complete enums.
+
+2011-12-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/51406
+	PR c++/51161
+	* typeck.c (build_static_cast_1): Fix cast of lvalue to
+	base rvalue reference.
+
+2011-11-22  Paolo Carlini  <paolo.carlini@oracle.com>
+
+	PR c++/51265
+	* semantics.c (finish_decltype_type): Handle PTRMEM_CST.
+
+2011-11-18  Paolo Carlini  <paolo.carlini@oracle.com>
+
+	PR c++/51150
+	* pt.c (tsubst_copy_and_build): Handle FIX_TRUNC_EXPR.
+
+2011-11-07  Jason Merrill  <jason@redhat.com>
+
+	PR c++/50870
+	* pt.c (tsubst_copy): Handle NAMESPACE_DECL.
+	(tsubst_copy_and_build) [COMPONENT_REF]: Handle a still-dependent
+	object.
+
+2011-11-04  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR c++/50608
+	* semantics.c (finish_offsetof): Adjust call to fold_offsetof.
+	* typeck.c (cp_build_addr_expr_1): Call fold_offsetof_1.
+
+2011-10-29  Paolo Carlini  <paolo.carlini@oracle.com>
+
+	PR c++/50901
+	* call.c (build_new_op_1): Handle ABS_EXPR together with the
+	other unary EXPR.
+
 2011-10-26  Release Manager
 
 	* GCC 4.6.2 released.
Index: gcc/cp/pt.c
===================================================================
--- gcc/cp/pt.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/cp/pt.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -11439,6 +11439,9 @@
       mark_used (t);
       return t;
 
+    case NAMESPACE_DECL:
+      return t;
+
     case OVERLOAD:
       /* An OVERLOAD will always be a non-dependent overload set; an
 	 overload set from function scope will just be represented with an
@@ -12704,6 +12707,10 @@
       return build_x_unary_op (TREE_CODE (t), RECUR (TREE_OPERAND (t, 0)),
                                complain);
 
+    case FIX_TRUNC_EXPR:
+      return cp_build_unary_op (FIX_TRUNC_EXPR, RECUR (TREE_OPERAND (t, 0)),
+				0, complain);
+
     case ADDR_EXPR:
       op1 = TREE_OPERAND (t, 0);
       if (TREE_CODE (op1) == LABEL_DECL)
@@ -13179,7 +13186,9 @@
 	if (member == error_mark_node)
 	  return error_mark_node;
 
-	if (object_type && !CLASS_TYPE_P (object_type))
+	if (type_dependent_expression_p (object))
+	  /* We can't do much here.  */;
+	else if (!CLASS_TYPE_P (object_type))
 	  {
 	    if (SCALAR_TYPE_P (object_type))
 	      {
Index: gcc/cp/semantics.c
===================================================================
--- gcc/cp/semantics.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/cp/semantics.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -3348,7 +3348,7 @@
     }
   if (TREE_CODE (expr) == INDIRECT_REF && REFERENCE_REF_P (expr))
     expr = TREE_OPERAND (expr, 0);
-  return fold_offsetof (expr, NULL_TREE);
+  return fold_offsetof (expr);
 }
 
 /* Replace the AGGR_INIT_EXPR at *TP with an equivalent CALL_EXPR.  This
@@ -4927,8 +4927,9 @@
           gcc_unreachable ();
 
         case INTEGER_CST:
+	case PTRMEM_CST:
           /* We can get here when the id-expression refers to an
-             enumerator.  */
+             enumerator or non-type template parameter.  */
           type = TREE_TYPE (expr);
           break;
 
Index: gcc/cp/decl2.c
===================================================================
--- gcc/cp/decl2.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/cp/decl2.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1185,9 +1185,9 @@
 
   old_attrs = *q;
 
-  /* Place the late attributes at the beginning of the attribute
+  /* Merge the late attributes at the beginning with the attribute
      list.  */
-  TREE_CHAIN (tree_last (late_attrs)) = *q;
+  late_attrs = merge_attributes (late_attrs, *q);
   *q = late_attrs;
 
   if (!DECL_P (*decl_p) && *decl_p == TYPE_MAIN_VARIANT (*decl_p))
Index: gcc/cp/call.c
===================================================================
--- gcc/cp/call.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/cp/call.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -4996,6 +4996,7 @@
     case POSTDECREMENT_EXPR:
     case REALPART_EXPR:
     case IMAGPART_EXPR:
+    case ABS_EXPR:
       return cp_build_unary_op (code, arg1, candidates != 0, complain);
 
     case ARRAY_REF:
Index: gcc/cp/mangle.c
===================================================================
--- gcc/cp/mangle.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/cp/mangle.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -2770,7 +2770,8 @@
       break;
 
     default:
-      gcc_unreachable ();
+      sorry ("mangling %C", TREE_CODE (value));
+      break;
     }
 
   write_char ('E');
Index: gcc/lto-cgraph.c
===================================================================
--- gcc/lto-cgraph.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/lto-cgraph.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1792,9 +1792,9 @@
 {
   const struct lto_function_header *header =
     (const struct lto_function_header *) data;
-  const int32_t cfg_offset = sizeof (struct lto_function_header);
-  const int32_t main_offset = cfg_offset + header->cfg_size;
-  const int32_t string_offset = main_offset + header->main_size;
+  const int cfg_offset = sizeof (struct lto_function_header);
+  const int main_offset = cfg_offset + header->cfg_size;
+  const int string_offset = main_offset + header->main_size;
   struct data_in *data_in;
   struct lto_input_block ib_main;
   unsigned int i;
Index: gcc/lto-streamer-out.c
===================================================================
--- gcc/lto-streamer-out.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/lto-streamer-out.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -2408,7 +2408,7 @@
   enum gcc_plugin_symbol_kind kind;
   enum gcc_plugin_symbol_visibility visibility;
   int slot_num;
-  uint64_t size;
+  unsigned HOST_WIDEST_INT size;
   const char *comdat;
   unsigned char c;
 
@@ -2466,7 +2466,7 @@
      when symbol has attribute (visibility("hidden")) specified.
      targetm.binds_local_p check DECL_VISIBILITY_SPECIFIED and gets this
      right. */
-     
+
   if (DECL_EXTERNAL (t)
       && !targetm.binds_local_p (t))
     visibility = GCCPV_DEFAULT;
@@ -2488,14 +2488,9 @@
       }
 
   if (kind == GCCPK_COMMON
-      && DECL_SIZE (t)
-      && TREE_CODE (DECL_SIZE (t)) == INTEGER_CST)
-    {
-      size = (HOST_BITS_PER_WIDE_INT >= 64)
-	? (uint64_t) int_size_in_bytes (TREE_TYPE (t))
-	: (((uint64_t) TREE_INT_CST_HIGH (DECL_SIZE_UNIT (t))) << 32)
-		| TREE_INT_CST_LOW (DECL_SIZE_UNIT (t));
-    }
+      && DECL_SIZE_UNIT (t)
+      && TREE_CODE (DECL_SIZE_UNIT (t)) == INTEGER_CST)
+    size = TREE_INT_CST_LOW (DECL_SIZE_UNIT (t));
   else
     size = 0;
 
Index: gcc/dwarf2out.c
===================================================================
--- gcc/dwarf2out.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/dwarf2out.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -4431,6 +4431,11 @@
   const char *section; /* Section this loclist is relative to */
   dw_loc_descr_ref expr;
   hashval_t hash;
+  /* True if all addresses in this and subsequent lists are known to be
+     resolved.  */
+  bool resolved_addr;
+  /* True if this list has been replaced by dw_loc_next.  */
+  bool replaced;
   bool emitted;
 } dw_loc_list_node;
 
@@ -6091,6 +6096,19 @@
 /* Table of decl location linked lists.  */
 static GTY ((param_is (var_loc_list))) htab_t decl_loc_table;
 
+/* A cached location list.  */
+struct GTY (()) cached_dw_loc_list_def {
+  /* The DECL_UID of the decl that this entry describes.  */
+  unsigned int decl_id;
+
+  /* The cached location list.  */
+  dw_loc_list_ref loc_list;
+};
+typedef struct cached_dw_loc_list_def cached_dw_loc_list;
+
+/* Table of cached location lists.  */
+static GTY ((param_is (cached_dw_loc_list))) htab_t cached_dw_loc_list_table;
+
 /* A pointer to the base of a list of references to DIE's that
    are uniquely identified by their tag, presence/absence of
    children DIE's, and list of attribute/value pairs.  */
@@ -6439,7 +6457,7 @@
 static void insert_double (double_int, unsigned char *);
 static void insert_float (const_rtx, unsigned char *);
 static rtx rtl_for_decl_location (tree);
-static bool add_location_or_const_value_attribute (dw_die_ref, tree,
+static bool add_location_or_const_value_attribute (dw_die_ref, tree, bool,
 						   enum dwarf_attribute);
 static bool tree_add_const_value_attribute (dw_die_ref, tree);
 static bool tree_add_const_value_attribute_for_decl (dw_die_ref, tree);
@@ -8173,6 +8191,24 @@
     htab_find_with_hash (decl_loc_table, decl, DECL_UID (decl));
 }
 
+/* Returns a hash value for X (which really is a cached_dw_loc_list_list).  */
+
+static hashval_t
+cached_dw_loc_list_table_hash (const void *x)
+{
+  return (hashval_t) ((const cached_dw_loc_list *) x)->decl_id;
+}
+
+/* Return nonzero if decl_id of cached_dw_loc_list X is the same as
+   UID of decl *Y.  */
+
+static int
+cached_dw_loc_list_table_eq (const void *x, const void *y)
+{
+  return (((const cached_dw_loc_list *) x)->decl_id
+	  == DECL_UID ((const_tree) y));
+}
+
 /* Equate a DIE to a particular declaration.  */
 
 static void
@@ -16995,15 +17031,22 @@
    these things can crop up in other ways also.)  Note that one type of
    constant value which can be passed into an inlined function is a constant
    pointer.  This can happen for example if an actual argument in an inlined
-   function call evaluates to a compile-time constant address.  */
+   function call evaluates to a compile-time constant address.
 
+   CACHE_P is true if it is worth caching the location list for DECL,
+   so that future calls can reuse it rather than regenerate it from scratch.
+   This is true for BLOCK_NONLOCALIZED_VARS in inlined subroutines,
+   since we will need to refer to them each time the function is inlined.  */
+
 static bool
-add_location_or_const_value_attribute (dw_die_ref die, tree decl,
+add_location_or_const_value_attribute (dw_die_ref die, tree decl, bool cache_p,
 				       enum dwarf_attribute attr)
 {
   rtx rtl;
   dw_loc_list_ref list;
   var_loc_list *loc_list;
+  cached_dw_loc_list *cache;
+  void **slot;
 
   if (TREE_CODE (decl) == ERROR_MARK)
     return false;
@@ -17040,7 +17083,33 @@
 	  && add_const_value_attribute (die, rtl))
 	 return true;
     }
-  list = loc_list_from_tree (decl, decl_by_reference_p (decl) ? 0 : 2);
+  /* If this decl is from BLOCK_NONLOCALIZED_VARS, we might need its
+     list several times.  See if we've already cached the contents.  */
+  list = NULL;
+  if (loc_list == NULL || cached_dw_loc_list_table == NULL)
+    cache_p = false;
+  if (cache_p)
+    {
+      cache = (cached_dw_loc_list *)
+	htab_find_with_hash (cached_dw_loc_list_table, decl, DECL_UID (decl));
+      if (cache)
+	list = cache->loc_list;
+    }
+  if (list == NULL)
+    {
+      list = loc_list_from_tree (decl, decl_by_reference_p (decl) ? 0 : 2);
+      /* It is usually worth caching this result if the decl is from
+	 BLOCK_NONLOCALIZED_VARS and if the list has at least two elements.  */
+      if (cache_p && list && list->dw_loc_next)
+	{
+	  slot = htab_find_slot_with_hash (cached_dw_loc_list_table, decl,
+					   DECL_UID (decl), INSERT);
+	  cache = ggc_alloc_cleared_cached_dw_loc_list ();
+	  cache->decl_id = DECL_UID (decl);
+	  cache->loc_list = list;
+	  *slot = cache;
+	}
+    }
   if (list)
     {
       add_AT_location_description (die, attr, list);
@@ -18738,7 +18807,7 @@
         equate_decl_number_to_die (node, parm_die);
       if (! DECL_ABSTRACT (node_or_origin))
 	add_location_or_const_value_attribute (parm_die, node_or_origin,
-					       DW_AT_location);
+					       node == NULL, DW_AT_location);
 
       break;
 
@@ -18923,6 +18992,7 @@
   tree context;
   int was_abstract;
   htab_t old_decl_loc_table;
+  htab_t old_cached_dw_loc_list_table;
 
   /* Make sure we have the actual abstract inline, not a clone.  */
   decl = DECL_ORIGIN (decl);
@@ -18937,6 +19007,8 @@
      get locations in abstract instantces.  */
   old_decl_loc_table = decl_loc_table;
   decl_loc_table = NULL;
+  old_cached_dw_loc_list_table = cached_dw_loc_list_table;
+  cached_dw_loc_list_table = NULL;
 
   /* Be sure we've emitted the in-class declaration DIE (if any) first, so
      we don't get confused by DECL_ABSTRACT.  */
@@ -18961,6 +19033,7 @@
 
   current_function_decl = save_fn;
   decl_loc_table = old_decl_loc_table;
+  cached_dw_loc_list_table = old_cached_dw_loc_list_table;
   pop_cfun ();
 }
 
@@ -19745,9 +19818,8 @@
           && !TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl_or_origin)))
 	defer_location (decl_or_origin, var_die);
       else
-        add_location_or_const_value_attribute (var_die,
-					       decl_or_origin,
-					       DW_AT_location);
+        add_location_or_const_value_attribute (var_die, decl_or_origin,
+					       decl == NULL, DW_AT_location);
       add_pubname (decl_or_origin, var_die);
     }
   else
@@ -21534,6 +21606,7 @@
   dwarf2out_decl (decl);
 
   htab_empty (decl_loc_table);
+  htab_empty (cached_dw_loc_list_table);
 }
 
 /* Output a marker (i.e. a label) for the beginning of the generated code for
@@ -22267,6 +22340,11 @@
   decl_loc_table = htab_create_ggc (10, decl_loc_table_hash,
 				    decl_loc_table_eq, NULL);
 
+  /* Allocate the cached_dw_loc_list_table.  */
+  cached_dw_loc_list_table
+    = htab_create_ggc (10, cached_dw_loc_list_table_hash,
+		       cached_dw_loc_list_table_eq, NULL);
+
   /* Allocate the initial hunk of the decl_scope_table.  */
   decl_scope_table = VEC_alloc (tree, gc, 256);
 
@@ -22907,30 +22985,53 @@
 {
   dw_die_ref c;
   dw_attr_ref a;
-  dw_loc_list_ref *curr;
+  dw_loc_list_ref *curr, *start, loc;
   unsigned ix;
 
   FOR_EACH_VEC_ELT (dw_attr_node, die->die_attr, ix, a)
     switch (AT_class (a))
       {
       case dw_val_class_loc_list:
-	curr = AT_loc_list_ptr (a);
-	while (*curr)
+	start = curr = AT_loc_list_ptr (a);
+	loc = *curr;
+	gcc_assert (loc);
+	/* The same list can be referenced more than once.  See if we have
+	   already recorded the result from a previous pass.  */
+	if (loc->replaced)
+	  *curr = loc->dw_loc_next;
+	else if (!loc->resolved_addr)
 	  {
-	    if (!resolve_addr_in_expr ((*curr)->expr))
+	    /* As things stand, we do not expect or allow one die to
+	       reference a suffix of another die's location list chain.
+	       References must be identical or completely separate.
+	       There is therefore no need to cache the result of this
+	       pass on any list other than the first; doing so
+	       would lead to unnecessary writes.  */
+	    while (*curr)
 	      {
-		dw_loc_list_ref next = (*curr)->dw_loc_next;
-		if (next && (*curr)->ll_symbol)
+		gcc_assert (!(*curr)->replaced && !(*curr)->resolved_addr);
+		if (!resolve_addr_in_expr ((*curr)->expr))
 		  {
-		    gcc_assert (!next->ll_symbol);
-		    next->ll_symbol = (*curr)->ll_symbol;
+		    dw_loc_list_ref next = (*curr)->dw_loc_next;
+		    if (next && (*curr)->ll_symbol)
+		      {
+			gcc_assert (!next->ll_symbol);
+			next->ll_symbol = (*curr)->ll_symbol;
+		      }
+		    *curr = next;
 		  }
-		*curr = next;
+		else
+		  curr = &(*curr)->dw_loc_next;
 	      }
+	    if (loc == *start)
+	      loc->resolved_addr = 1;
 	    else
-	      curr = &(*curr)->dw_loc_next;
+	      {
+		loc->replaced = 1;
+		loc->dw_loc_next = *start;
+	      }
 	  }
-	if (!AT_loc_list (a))
+	if (!*start)
 	  {
 	    remove_AT (die, a->dw_attr);
 	    ix--;
@@ -23359,6 +23460,7 @@
       add_location_or_const_value_attribute (
         VEC_index (deferred_locations, deferred_locations_list, i)->die,
         VEC_index (deferred_locations, deferred_locations_list, i)->variable,
+	false,
 	DW_AT_location);
     }
 
Index: gcc/expr.c
===================================================================
--- gcc/expr.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/expr.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -2180,6 +2180,111 @@
   return tgtblk;
 }
 
+/* Copy BLKmode value SRC into a register of mode MODE.  Return the
+   register if it contains any data, otherwise return null.
+
+   This is used on targets that return BLKmode values in registers.  */
+
+rtx
+copy_blkmode_to_reg (enum machine_mode mode, tree src)
+{
+  int i, n_regs;
+  unsigned HOST_WIDE_INT bitpos, xbitpos, padding_correction = 0, bytes;
+  unsigned int bitsize;
+  rtx *dst_words, dst, x, src_word = NULL_RTX, dst_word = NULL_RTX;
+  enum machine_mode dst_mode;
+
+  gcc_assert (TYPE_MODE (TREE_TYPE (src)) == BLKmode);
+
+  x = expand_normal (src);
+
+  bytes = int_size_in_bytes (TREE_TYPE (src));
+  if (bytes == 0)
+    return NULL_RTX;
+
+  /* If the structure doesn't take up a whole number of words, see
+     whether the register value should be padded on the left or on
+     the right.  Set PADDING_CORRECTION to the number of padding
+     bits needed on the left side.
+
+     In most ABIs, the structure will be returned at the least end of
+     the register, which translates to right padding on little-endian
+     targets and left padding on big-endian targets.  The opposite
+     holds if the structure is returned at the most significant
+     end of the register.  */
+  if (bytes % UNITS_PER_WORD != 0
+      && (targetm.calls.return_in_msb (TREE_TYPE (src))
+	  ? !BYTES_BIG_ENDIAN
+	  : BYTES_BIG_ENDIAN))
+    padding_correction = (BITS_PER_WORD - ((bytes % UNITS_PER_WORD)
+					   * BITS_PER_UNIT));
+
+  n_regs = (bytes + UNITS_PER_WORD - 1) / UNITS_PER_WORD;
+  dst_words = XALLOCAVEC (rtx, n_regs);
+  bitsize = MIN (TYPE_ALIGN (TREE_TYPE (src)), BITS_PER_WORD);
+
+  /* Copy the structure BITSIZE bits at a time.  */
+  for (bitpos = 0, xbitpos = padding_correction;
+       bitpos < bytes * BITS_PER_UNIT;
+       bitpos += bitsize, xbitpos += bitsize)
+    {
+      /* We need a new destination pseudo each time xbitpos is
+	 on a word boundary and when xbitpos == padding_correction
+	 (the first time through).  */
+      if (xbitpos % BITS_PER_WORD == 0
+	  || xbitpos == padding_correction)
+	{
+	  /* Generate an appropriate register.  */
+	  dst_word = gen_reg_rtx (word_mode);
+	  dst_words[xbitpos / BITS_PER_WORD] = dst_word;
+
+	  /* Clear the destination before we move anything into it.  */
+	  emit_move_insn (dst_word, CONST0_RTX (word_mode));
+	}
+
+      /* We need a new source operand each time bitpos is on a word
+	 boundary.  */
+      if (bitpos % BITS_PER_WORD == 0)
+	src_word = operand_subword_force (x, bitpos / BITS_PER_WORD, BLKmode);
+
+      /* Use bitpos for the source extraction (left justified) and
+	 xbitpos for the destination store (right justified).  */
+      store_bit_field (dst_word, bitsize, xbitpos % BITS_PER_WORD, word_mode,
+		       extract_bit_field (src_word, bitsize,
+					  bitpos % BITS_PER_WORD, 1, false,
+					  NULL_RTX, word_mode, word_mode));
+    }
+
+  if (mode == BLKmode)
+    {
+      /* Find the smallest integer mode large enough to hold the
+	 entire structure.  */
+      for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT);
+	   mode != VOIDmode;
+	   mode = GET_MODE_WIDER_MODE (mode))
+	/* Have we found a large enough mode?  */
+	if (GET_MODE_SIZE (mode) >= bytes)
+	  break;
+
+      /* A suitable mode should have been found.  */
+      gcc_assert (mode != VOIDmode);
+    }
+
+  if (GET_MODE_SIZE (mode) < GET_MODE_SIZE (word_mode))
+    dst_mode = word_mode;
+  else
+    dst_mode = mode;
+  dst = gen_reg_rtx (dst_mode);
+
+  for (i = 0; i < n_regs; i++)
+    emit_move_insn (operand_subword (dst, i, 0, dst_mode), dst_words[i]);
+
+  if (mode != dst_mode)
+    dst = gen_lowpart (mode, dst);
+
+  return dst;
+}
+
 /* Add a USE expression for REG to the (possibly empty) list pointed
    to by CALL_FUSAGE.  REG must denote a hard register.  */
 
@@ -4382,7 +4487,9 @@
   if (TREE_CODE (from) == CALL_EXPR && ! aggregate_value_p (from, from)
       && COMPLETE_TYPE_P (TREE_TYPE (from))
       && TREE_CODE (TYPE_SIZE (TREE_TYPE (from))) == INTEGER_CST
-      && ! (((TREE_CODE (to) == VAR_DECL || TREE_CODE (to) == PARM_DECL)
+      && ! (((TREE_CODE (to) == VAR_DECL
+	      || TREE_CODE (to) == PARM_DECL
+	      || TREE_CODE (to) == RESULT_DECL)
 	     && REG_P (DECL_RTL (to)))
 	    || TREE_CODE (to) == SSA_NAME))
     {
@@ -4428,12 +4535,15 @@
       rtx temp;
 
       push_temp_slots ();
-      temp = expand_expr (from, NULL_RTX, GET_MODE (to_rtx), EXPAND_NORMAL);
+      if (REG_P (to_rtx) && TYPE_MODE (TREE_TYPE (from)) == BLKmode)
+	temp = copy_blkmode_to_reg (GET_MODE (to_rtx), from);
+      else
+	temp = expand_expr (from, NULL_RTX, GET_MODE (to_rtx), EXPAND_NORMAL);
 
       if (GET_CODE (to_rtx) == PARALLEL)
 	emit_group_load (to_rtx, temp, TREE_TYPE (from),
 			 int_size_in_bytes (TREE_TYPE (from)));
-      else
+      else if (temp)
 	emit_move_insn (to_rtx, temp);
 
       preserve_temp_slots (to_rtx);
@@ -8533,10 +8643,15 @@
 	  return temp;
 	}
 
-      /* If the mode of DECL_RTL does not match that of the decl, it
-	 must be a promoted value.  We return a SUBREG of the wanted mode,
-	 but mark it so that we know that it was already extended.  */
-      if (REG_P (decl_rtl) && GET_MODE (decl_rtl) != DECL_MODE (exp))
+      /* If the mode of DECL_RTL does not match that of the decl,
+	 there are two cases: we are dealing with a BLKmode value
+	 that is returned in a register, or we are dealing with
+	 a promoted value.  In the latter case, return a SUBREG
+	 of the wanted mode, but mark it so that we know that it
+	 was already extended.  */
+      if (REG_P (decl_rtl)
+	  && DECL_MODE (exp) != BLKmode
+	  && GET_MODE (decl_rtl) != DECL_MODE (exp))
 	{
 	  enum machine_mode pmode;
 
@@ -9189,8 +9304,16 @@
 		&& modifier != EXPAND_CONST_ADDRESS
 		&& modifier != EXPAND_INITIALIZER)
 	    /* If the field is volatile, we always want an aligned
-	       access.  */
-	    || (volatilep && flag_strict_volatile_bitfields > 0)
+	       access.  Do this in following two situations:
+	       1. the access is not already naturally
+	       aligned, otherwise "normal" (non-bitfield) volatile fields
+	       become non-addressable.
+	       2. the bitsize is narrower than the access size. Need
+	       to extract bitfields from the access.  */
+	    || (volatilep && flag_strict_volatile_bitfields > 0
+		&& (bitpos % GET_MODE_ALIGNMENT (mode) != 0 
+		    || (mode1 != BLKmode
+		        && bitsize < GET_MODE_SIZE (mode1) * BITS_PER_UNIT)))
 	    /* If the field isn't aligned enough to fetch as a memref,
 	       fetch it as a bit field.  */
 	    || (mode1 != BLKmode
@@ -9486,10 +9609,32 @@
 	 results.  */
       if (MEM_P (op0))
 	{
+	  enum insn_code icode;
+
 	  op0 = copy_rtx (op0);
 
 	  if (TYPE_ALIGN_OK (type))
 	    set_mem_align (op0, MAX (MEM_ALIGN (op0), TYPE_ALIGN (type)));
+	  else if (mode != BLKmode
+		   && MEM_ALIGN (op0) < GET_MODE_ALIGNMENT (mode)
+		   /* If the target does have special handling for unaligned
+		      loads of mode then use them.  */
+		   && ((icode = optab_handler (movmisalign_optab, mode))
+		       != CODE_FOR_nothing))
+	    {
+	      rtx reg, insn;
+
+	      op0 = adjust_address (op0, mode, 0);
+	      /* We've already validated the memory, and we're creating a
+		 new pseudo destination.  The predicates really can't
+		 fail.  */
+	      reg = gen_reg_rtx (mode);
+
+	      /* Nor can the insn generator.  */
+	      insn = GEN_FCN (icode) (reg, op0);
+	      emit_insn (insn);
+	      return reg;
+	    }
 	  else if (STRICT_ALIGNMENT
 		   && mode != BLKmode
 		   && MEM_ALIGN (op0) < GET_MODE_ALIGNMENT (mode))
Index: gcc/expr.h
===================================================================
--- gcc/expr.h	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/expr.h	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -324,6 +324,8 @@
 /* Copy BLKmode object from a set of registers.  */
 extern rtx copy_blkmode_from_reg (rtx, rtx, tree);
 
+extern rtx copy_blkmode_to_reg (enum machine_mode, tree);
+
 /* Mark REG as holding a parameter for the next CALL_INSN.  */
 extern void use_reg (rtx *, rtx);
 
Index: gcc/recog.c
===================================================================
--- gcc/recog.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/recog.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -3023,6 +3023,7 @@
   static int search_ofs;
   enum reg_class cl;
   HARD_REG_SET live;
+  df_ref *def_rec;
   int i;
 
   gcc_assert (from < MAX_INSNS_PER_PEEP2 + 1);
@@ -3036,12 +3037,14 @@
 
   while (from != to)
     {
-      HARD_REG_SET this_live;
+      gcc_assert (peep2_insn_data[from].insn != NULL_RTX);
 
+      /* Don't use registers set or clobbered by the insn.  */
+      for (def_rec = DF_INSN_DEFS (peep2_insn_data[from].insn);
+	   *def_rec; def_rec++)
+	SET_HARD_REG_BIT (live, DF_REF_REGNO (*def_rec));
+
       from = peep2_buf_position (from + 1);
-      gcc_assert (peep2_insn_data[from].insn != NULL_RTX);
-      REG_SET_TO_HARD_REG_SET (this_live, peep2_insn_data[from].live_before);
-      IOR_HARD_REG_SET (live, this_live);
     }
 
   cl = (class_str[0] == 'r' ? GENERAL_REGS
Index: gcc/ada/mlib-tgt-specific-darwin.adb
===================================================================
--- gcc/ada/mlib-tgt-specific-darwin.adb	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/ada/mlib-tgt-specific-darwin.adb	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -36,8 +36,6 @@
 
    --  Non default subprograms
 
-   function Archive_Indexer_Options return String_List_Access;
-
    procedure Build_Dynamic_Library
      (Ofiles       : Argument_List;
       Options      : Argument_List;
@@ -67,15 +65,6 @@
                       (1 => Flat_Namespace'Access,
                        2 => Shared_Libgcc'Access);
 
-   -----------------------------
-   -- Archive_Indexer_Options --
-   -----------------------------
-
-   function Archive_Indexer_Options return String_List_Access is
-   begin
-      return new String_List'(1 => new String'("-c"));
-   end Archive_Indexer_Options;
-
    ---------------------------
    -- Build_Dynamic_Library --
    ---------------------------
@@ -180,7 +169,6 @@
    end Is_Archive_Ext;
 
 begin
-   Archive_Indexer_Options_Ptr := Archive_Indexer_Options'Access;
    Build_Dynamic_Library_Ptr := Build_Dynamic_Library'Access;
    DLL_Ext_Ptr := DLL_Ext'Access;
    Dynamic_Option_Ptr := Dynamic_Option'Access;
Index: gcc/ada/init.c
===================================================================
--- gcc/ada/init.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/ada/init.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -2216,12 +2216,33 @@
   return 0;
 }
 
+#define HAVE_GNAT_ADJUST_CONTEXT_FOR_RAISE
+
+void
+__gnat_adjust_context_for_raise (int signo ATTRIBUTE_UNUSED,
+				 void *ucontext ATTRIBUTE_UNUSED)
+{
+#if defined (__x86_64__)
+  /* Work around radar #10302855/pr50678, where the unwinders (libunwind or
+     libgcc_s depending on the system revision) and the DWARF unwind data for
+     the sigtramp have different ideas about register numbering (causing rbx
+     and rdx to be transposed)..  */
+  ucontext_t *uc = (ucontext_t *)ucontext ;
+  unsigned long t = uc->uc_mcontext->__ss.__rbx;
+
+  uc->uc_mcontext->__ss.__rbx = uc->uc_mcontext->__ss.__rdx;
+  uc->uc_mcontext->__ss.__rdx = t;
+#endif
+}
+
 static void
-__gnat_error_handler (int sig, siginfo_t *si, void *ucontext ATTRIBUTE_UNUSED)
+__gnat_error_handler (int sig, siginfo_t *si, void *ucontext)
 {
   struct Exception_Data *exception;
   const char *msg;
 
+  __gnat_adjust_context_for_raise (sig, ucontext);
+
   switch (sig)
     {
     case SIGSEGV:
Index: gcc/ada/ChangeLog
===================================================================
--- gcc/ada/ChangeLog	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/ada/ChangeLog	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1,3 +1,56 @@
+2012-01-21  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR ada/46192
+	* gcc-interface/decl.c (gnat_to_gnu_entity) <object>: In the case of a
+	renaming, preserve the volatileness through the indirection, if any.
+
+2012-01-09  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/trans.c (addressable_p) <COMPONENT_REF>: Fix thinko.
+
+2012-01-02  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnatvsn.ads (Current_Year): Bump to 2011.
+
+2011-12-08  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR tree-optimization/51315
+	Backport from mainline
+	2011-09-25  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/decl.c (gnat_to_gnu_entity) <object>: Do not promote
+	the alignment if this doesn't prevent BLKmode access to the object.
+
+2011-11-13  Iain Sandoe  <iains@gcc.gnu.org>
+
+	Backport from mainline r181474
+	PR target/50678
+	* init.c (__gnat_error_handler) [Darwin]: Move work-around to the
+	bug filed as radar #10302855 from __gnat_error_handler ...
+	... to (__gnat_adjust_context_for_raise) [Darwin]: New.
+	(HAVE_GNAT_ADJUST_CONTEXT_FOR_RAISE) [Darwin]: Define.
+	(__gnat_error_handler) [Darwin]: Use __gnat_adjust_context_for_raise.
+	
+2011-11-18  Tristan Gingold  <gingold@adacore.com>
+	    Iain Sandoe  <iains@gcc.gnu.org>
+
+	PR target/49992
+	* mlib-tgt-specific-darwin.adb (Archive_Indexer_Options): Remove.
+	* gcc-interface/Makefile.in (darwin): Remove ranlib special-casing
+	for Darwin.
+
+2011-11-13  Iain Sandoe  <iains@gcc.gnu.org>
+
+	Backport from mainline r181319
+	* gcc-interface/Makefile.in (stamp-gnatlib-$(RTSDIR)): Don't link
+	s-oscons.ads.
+	(OSCONS_CPP, OSCONS_EXTRACT): New.
+	(./bldtools/oscons/xoscons): New Target.
+	($(RTSDIR)/s-oscons.ads): New Target.
+	(gnatlib): Depend on  $(RTSDIR)/s-oscons.ads.
+	* Make-generated.in: Remove machinery to generate xoscons and
+	ada/s-oscons.ads.
+	
 2011-10-26  Release Manager
 
 	* GCC 4.6.2 released.
Index: gcc/ada/gnatvsn.ads
===================================================================
--- gcc/ada/gnatvsn.ads	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/ada/gnatvsn.ads	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -6,7 +6,7 @@
 --                                                                          --
 --                                 S p e c                                  --
 --                                                                          --
---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --
+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --
 --                                                                          --
 -- GNAT is free software;  you can  redistribute it  and/or modify it under --
 -- terms of the  GNU General Public License as published  by the Free Soft- --
@@ -92,7 +92,7 @@
    Verbose_Library_Version : constant String := "GNAT Lib v" & Library_Version;
    --  Version string stored in e.g. ALI files
 
-   Current_Year : constant String := "2010";
+   Current_Year : constant String := "2011";
    --  Used in printing copyright messages
 
 end Gnatvsn;
Index: gcc/ada/gcc-interface/Makefile.in
===================================================================
--- gcc/ada/gcc-interface/Makefile.in	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/ada/gcc-interface/Makefile.in	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -2189,7 +2189,6 @@
 
   EH_MECHANISM=-gcc
   GNATLIB_SHARED = gnatlib-shared-darwin
-  RANLIB = ranlib -c
   GMEM_LIB = gmemlib
   LIBRARY_VERSION := $(LIB_VERSION)
   soext = .dylib
@@ -2447,21 +2446,52 @@
 	$(foreach PAIR,$(LIBGNAT_TARGET_PAIRS), \
 	          $(LN_S) $(fsrcpfx)ada/$(word 2,$(subst <, ,$(PAIR))) \
 	                $(RTSDIR)/$(word 1,$(subst <, ,$(PAIR)));)
-# Copy generated target dependent sources
-	$(RM) $(RTSDIR)/s-oscons.ads
-	(cd $(RTSDIR); $(LN_S) ../s-oscons.ads s-oscons.ads)
+# Copy tsystem.h
+	$(CP) $(srcdir)/tsystem.h $(RTSDIR)
 	$(RM) ../stamp-gnatlib-$(RTSDIR)
 	touch ../stamp-gnatlib1-$(RTSDIR)
 
 # GNULLI End #############################################################
 
+ifeq ($(strip $(filter-out alpha64 ia64 dec hp vms% openvms% alphavms%,$(subst -, ,$(host)))),)
+OSCONS_CPP=../../$(DECC) -E /comment=as_is -DNATIVE \
+             -DTARGET='""$(target)""' $(fsrcpfx)ada/s-oscons-tmplt.c
+
+OSCONS_EXTRACT=../../$(DECC) -DNATIVE \
+                 -DTARGET='""$(target)""' $(fsrcpfx)ada/s-oscons-tmplt.c ; \
+  ld -o s-oscons-tmplt.exe s-oscons-tmplt.obj; \
+  ./s-oscons-tmplt.exe > s-oscons-tmplt.s
+
+else
+# GCC_FOR_TARGET has paths relative to the gcc directory, so we need to adjust
+# for running it from $(RTSDIR)
+OSCONS_CC=`echo "$(GCC_FOR_TARGET)" \
+  | sed -e 's^\./xgcc^../../xgcc^' -e 's^-B./^-B../../^'`
+OSCONS_CPP=$(OSCONS_CC) $(GNATLIBCFLAGS) -E -C \
+  -DTARGET=\"$(target)\" $(fsrcpfx)ada/s-oscons-tmplt.c > s-oscons-tmplt.i
+OSCONS_EXTRACT=$(OSCONS_CC) -S s-oscons-tmplt.i
+endif
+
+./bldtools/oscons/xoscons: xoscons.adb xutil.ads xutil.adb
+	-$(MKDIR) ./bldtools/oscons
+	$(RM) $(addprefix ./bldtools/oscons/,$(notdir $^))
+	$(CP) $^ ./bldtools/oscons
+	(cd ./bldtools/oscons ; gnatmake -q xoscons)
+
+$(RTSDIR)/s-oscons.ads: ../stamp-gnatlib1-$(RTSDIR) s-oscons-tmplt.c gsocket.h ./bldtools/oscons/xoscons
+	$(RM) $(RTSDIR)/s-oscons-tmplt.i $(RTSDIR)/s-oscons-tmplt.s
+	(cd $(RTSDIR) ; \
+	    $(OSCONS_CPP) ; \
+	    $(OSCONS_EXTRACT) ; \
+	    ../bldtools/oscons/xoscons)
+
 # Don't use semicolon separated shell commands that involve list expansions.
 # The semicolon triggers a call to DCL on VMS and DCL can't handle command
 # line lengths in excess of 256 characters.
 # Example: cd $(RTSDIR); ar rc libfoo.a $(LONG_LIST_OF_OBJS)
 # is guaranteed to overflow the buffer.
 
-gnatlib: ../stamp-gnatlib1-$(RTSDIR) ../stamp-gnatlib2-$(RTSDIR)
+gnatlib: ../stamp-gnatlib1-$(RTSDIR) ../stamp-gnatlib2-$(RTSDIR) $(RTSDIR)/s-oscons.ads
 	$(MAKE) -C $(RTSDIR) \
 		CC="`echo \"$(GCC_FOR_TARGET)\" \
 		| sed -e 's,\./xgcc,../../xgcc,' -e 's,-B\./,-B../../,'`" \
Index: gcc/ada/gcc-interface/decl.c
===================================================================
--- gcc/ada/gcc-interface/decl.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/ada/gcc-interface/decl.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -808,16 +808,30 @@
 		    && No (Address_Clause (gnat_entity))))
 	    && TREE_CODE (TYPE_SIZE (gnu_type)) == INTEGER_CST)
 	  {
-	    /* No point in jumping through all the hoops needed in order
+	    unsigned int size_cap, align_cap;
+
+	    /* No point in promoting the alignment if this doesn't prevent
+	       BLKmode access to the object, in particular block copy, as
+	       this will for example disable the NRV optimization for it.
+	       No point in jumping through all the hoops needed in order
 	       to support BIGGEST_ALIGNMENT if we don't really have to.
 	       So we cap to the smallest alignment that corresponds to
 	       a known efficient memory access pattern of the target.  */
-	    unsigned int align_cap = Is_Atomic (gnat_entity)
-				     ? BIGGEST_ALIGNMENT
-				     : get_mode_alignment (ptr_mode);
+	    if (Is_Atomic (gnat_entity))
+	      {
+		size_cap = UINT_MAX;
+		align_cap = BIGGEST_ALIGNMENT;
+	      }
+	    else
+	      {
+		size_cap = MAX_FIXED_MODE_SIZE;
+		align_cap = get_mode_alignment (ptr_mode);
+	      }
 
 	    if (!host_integerp (TYPE_SIZE (gnu_type), 1)
-		|| compare_tree_int (TYPE_SIZE (gnu_type), align_cap) >= 0)
+		|| compare_tree_int (TYPE_SIZE (gnu_type), size_cap) > 0)
+	      align = 0;
+	    else if (compare_tree_int (TYPE_SIZE (gnu_type), align_cap) > 0)
 	      align = align_cap;
 	    else
 	      align = ceil_alignment (tree_low_cst (TYPE_SIZE (gnu_type), 1));
@@ -1009,6 +1023,14 @@
 		   entity is always accessed indirectly through it.  */
 		else
 		  {
+		    /* We need to preserve the volatileness of the renamed
+		       object through the indirection.  */
+		    if (TREE_THIS_VOLATILE (gnu_expr)
+			&& !TYPE_VOLATILE (gnu_type))
+		      gnu_type
+			= build_qualified_type (gnu_type,
+						(TYPE_QUALS (gnu_type)
+						 | TYPE_QUAL_VOLATILE));
 		    gnu_type = build_reference_type (gnu_type);
 		    inner_const_flag = TREE_READONLY (gnu_expr);
 		    const_flag = true;
Index: gcc/ada/gcc-interface/trans.c
===================================================================
--- gcc/ada/gcc-interface/trans.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/ada/gcc-interface/trans.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -6,7 +6,7 @@
  *                                                                          *
  *                          C Implementation File                           *
  *                                                                          *
- *          Copyright (C) 1992-2011, Free Software Foundation, Inc.         *
+ *          Copyright (C) 1992-2012, Free Software Foundation, Inc.         *
  *                                                                          *
  * GNAT is free software;  you can  redistribute it  and/or modify it under *
  * terms of the  GNU General Public License as published  by the Free Soft- *
@@ -7409,7 +7409,7 @@
 		    || DECL_ALIGN (TREE_OPERAND (gnu_expr, 1))
 		       >= TYPE_ALIGN (TREE_TYPE (gnu_expr))))
 	       /* The field of a padding record is always addressable.  */
-	       || TYPE_PADDING_P (TREE_TYPE (TREE_OPERAND (gnu_expr, 0))))
+	       || TYPE_IS_PADDING_P (TREE_TYPE (TREE_OPERAND (gnu_expr, 0))))
 	      && addressable_p (TREE_OPERAND (gnu_expr, 0), NULL_TREE));
 
     case ARRAY_REF:  case ARRAY_RANGE_REF:
Index: gcc/ada/Make-generated.in
===================================================================
--- gcc/ada/Make-generated.in	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/ada/Make-generated.in	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -64,37 +64,6 @@
 	$(CP) $^ $(ADA_GEN_SUBDIR)/bldtools/nmake_s
 	(cd $(ADA_GEN_SUBDIR)/bldtools/nmake_s; gnatmake -q xnmake ; ./xnmake -s ../../nmake.ads )
 
-ifeq ($(strip $(filter-out alpha64 ia64 dec hp vms% openvms% alphavms%,$(subst -, ,$(host)))),)
-OSCONS_CPP=../../../$(DECC) -E /comment=as_is -DNATIVE \
-             -DTARGET='""$(target)""' s-oscons-tmplt.c
-
-OSCONS_EXTRACT=../../../$(DECC) -DNATIVE \
-                 -DTARGET='""$(target)""' s-oscons-tmplt.c ; \
-  ld -o s-oscons-tmplt.exe s-oscons-tmplt.obj; \
-  ./s-oscons-tmplt.exe > s-oscons-tmplt.s
-
-else
-# GCC_FOR_TARGET has paths relative to the gcc directory, so we need to ajust
-# for running it from $(ADA_GEN_SUBDIR)/bldtools/oscons
-OSCONS_CC=`echo "$(GCC_FOR_TARGET)" \
-  | sed -e 's^\./xgcc^../../../xgcc^' -e 's^-B./^-B../../../^'`
-OSCONS_CPP=$(OSCONS_CC) $(GNATLIBCFLAGS) -E -C \
-  -DTARGET=\"$(target)\" s-oscons-tmplt.c > s-oscons-tmplt.i
-OSCONS_EXTRACT=$(OSCONS_CC) -S s-oscons-tmplt.i
-endif
-
-$(ADA_GEN_SUBDIR)/s-oscons.ads : $(ADA_GEN_SUBDIR)/s-oscons-tmplt.c $(ADA_GEN_SUBDIR)/gsocket.h $(ADA_GEN_SUBDIR)/xoscons.adb $(ADA_GEN_SUBDIR)/xutil.ads $(ADA_GEN_SUBDIR)/xutil.adb
-	-$(MKDIR) $(ADA_GEN_SUBDIR)/bldtools/oscons
-	$(RM) $(addprefix $(ADA_GEN_SUBDIR)/bldtools/oscons/,$(notdir $^))
-	$(CP) $^ $(ADA_GEN_SUBDIR)/bldtools/oscons
-	(cd $(ADA_GEN_SUBDIR)/bldtools/oscons ; gnatmake -q xoscons ; \
-		$(RM) s-oscons-tmplt.i s-oscons-tmplt.s ; \
-		$(OSCONS_CPP) ; \
-		$(OSCONS_EXTRACT) ; \
-		./xoscons ; \
-		$(RM) ../../s-oscons.ads ; \
-		$(CP) s-oscons.ads s-oscons.h ../../)
-
 $(ADA_GEN_SUBDIR)/sdefault.adb: $(ADA_GEN_SUBDIR)/stamp-sdefault ; @true
 $(ADA_GEN_SUBDIR)/stamp-sdefault : $(srcdir)/version.c Makefile
 	$(ECHO) "pragma Style_Checks (Off);" >tmp-sdefault.adb
Index: gcc/lto-streamer-in.c
===================================================================
--- gcc/lto-streamer-in.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/lto-streamer-in.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1366,9 +1366,9 @@
 {
   const struct lto_function_header *header;
   struct data_in *data_in;
-  int32_t cfg_offset;
-  int32_t main_offset;
-  int32_t string_offset;
+  int cfg_offset;
+  int main_offset;
+  int string_offset;
   struct lto_input_block ib_cfg;
   struct lto_input_block ib_main;
 
Index: gcc/c-decl.c
===================================================================
--- gcc/c-decl.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/c-decl.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -721,7 +721,7 @@
 
 	  complete_array_type (&TREE_TYPE (decl), NULL_TREE, true);
 
-	  layout_decl (decl, 0);
+	  relayout_decl (decl);
 	}
     }
 }
@@ -1200,7 +1200,7 @@
 	      DECL_CHAIN (p) = BLOCK_VARS (block);
 	      BLOCK_VARS (block) = p;
 	    }
-	  else if (VAR_OR_FUNCTION_DECL_P (p))
+	  else if (VAR_OR_FUNCTION_DECL_P (p) && scope != file_scope)
 	    {
 	      /* For block local externs add a special
 		 DECL_EXTERNAL decl for debug info generation.  */
@@ -4261,7 +4261,7 @@
       if (DECL_INITIAL (decl))
 	TREE_TYPE (DECL_INITIAL (decl)) = type;
 
-      layout_decl (decl, 0);
+      relayout_decl (decl);
     }
 
   if (TREE_CODE (decl) == VAR_DECL)
@@ -9782,6 +9782,9 @@
     collect_source_ref (LOCATION_FILE (decl_sloc (decl, false)));
 }
 
+/* Preserve the external declarations scope across a garbage collect.  */
+static GTY(()) tree ext_block;
+
 /* Collect all references relevant to SOURCE_FILE.  */
 
 static void
@@ -9792,6 +9795,8 @@
 
   FOR_EACH_VEC_ELT (tree, all_translation_units, i, t)
     collect_ada_nodes (BLOCK_VARS (DECL_INITIAL (t)), source_file);
+
+  collect_ada_nodes (BLOCK_VARS (ext_block), source_file);
 }
 
 /* Iterate over all global declarations and call CALLBACK.  */
@@ -9810,11 +9815,11 @@
       for (decl = BLOCK_VARS (decls); decl; decl = TREE_CHAIN (decl))
 	callback (decl);
     }
+
+  for (decl = BLOCK_VARS (ext_block); decl; decl = TREE_CHAIN (decl))
+    callback (decl);
 }
 
-/* Preserve the external declarations scope across a garbage collect.  */
-static GTY(()) tree ext_block;
-
 void
 c_write_global_declarations (void)
 {
Index: gcc/fortran/interface.c
===================================================================
--- gcc/fortran/interface.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/fortran/interface.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1535,7 +1535,7 @@
       return 0;
     }
     
-  /* F2003, 12.5.2.5.  */
+  /* F2008, 12.5.2.5.  */
   if (formal->ts.type == BT_CLASS
       && (CLASS_DATA (formal)->attr.class_pointer
           || CLASS_DATA (formal)->attr.allocatable))
@@ -1547,8 +1547,8 @@
 			formal->name, &actual->where);
 	  return 0;
 	}
-      if (CLASS_DATA (actual)->ts.u.derived
-	  != CLASS_DATA (formal)->ts.u.derived)
+      if (!gfc_compare_derived_types (CLASS_DATA (actual)->ts.u.derived,
+				      CLASS_DATA (formal)->ts.u.derived))
 	{
 	  if (where)
 	    gfc_error ("Actual argument to '%s' at %L must have the same "
Index: gcc/fortran/trans-expr.c
===================================================================
--- gcc/fortran/trans-expr.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/fortran/trans-expr.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -3064,7 +3064,8 @@
 			  || (fsym->attr.proc_pointer
 			      && e->expr_type == EXPR_VARIABLE
 			      && gfc_is_proc_ptr_comp (e, NULL))
-			  || fsym->attr.allocatable))
+			  || (fsym->attr.allocatable
+			      && fsym->attr.flavor != FL_PROCEDURE)))
 		    {
 		      /* Scalar pointer dummy args require an extra level of
 			 indirection. The null pointer already contains
Index: gcc/fortran/trans-array.c
===================================================================
--- gcc/fortran/trans-array.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/fortran/trans-array.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -6772,8 +6772,17 @@
 			      gfc_array_index_type, cond,
 			      lbound, gfc_index_one_node);
     }
-  else if (expr->expr_type == EXPR_VARIABLE)
+
+  if (expr->expr_type == EXPR_FUNCTION)
     {
+      /* A conversion function, so use the argument.  */
+      gcc_assert (expr->value.function.isym
+		  && expr->value.function.isym->conversion);
+      expr = expr->value.function.actual->expr;
+    }
+
+  if (expr->expr_type == EXPR_VARIABLE)
+    {
       tmp = TREE_TYPE (expr->symtree->n.sym->backend_decl);
       for (ref = expr->ref; ref; ref = ref->next)
 	{
@@ -6785,15 +6794,6 @@
 	}
       return GFC_TYPE_ARRAY_LBOUND(tmp, dim);
     }
-  else if (expr->expr_type == EXPR_FUNCTION)
-    {
-      /* A conversion function, so use the argument.  */
-      expr = expr->value.function.actual->expr;
-      if (expr->expr_type != EXPR_VARIABLE)
-	return gfc_index_one_node;
-      desc = TREE_TYPE (expr->symtree->n.sym->backend_decl);
-      return get_std_lbound (expr, desc, dim, assumed_size);
-    }
 
   return gfc_index_one_node;
 }
Index: gcc/fortran/ChangeLog
===================================================================
--- gcc/fortran/ChangeLog	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/fortran/ChangeLog	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1,3 +1,121 @@
+2012-01-28  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/52022
+	* trans-expr.c (gfc_conv_procedure_call): Fix passing
+	of functions, which return allocatables.
+
+2012-01-25  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/51966
+	* resolve.c (resolve_structure_cons): Only create an
+	array constructors for nonscalars.
+
+2012-01-24  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/51948
+	* check.c (variable_check): Fix checking for
+	result variables and deeply nested BLOCKs.
+
+2012-01-21  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/51913
+	* interface.c (compare_parameter): Fix CLASS comparison.
+
+2012-01-19  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/51904
+	*expr.c (gfc_build_intrinsic_call): Also set the symtree.
+
+2012-01-14  Tobias Burnus  <burnus@net-b.de>
+
+	Backported from mainline
+	2012-01-14  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/51800
+	* resolve.c (build_default_init_expr): Also initialize
+	nonconstant-length strings with -finit-character=<n>.
+
+2012-01-01  Thomas Knig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/51502
+	* expr.c (gfc_check_vardef_context):  When determining
+	implicit pure status, also check for variable definition
+	context.  Walk up namespaces until a procedure is
+	found to reset the implict pure attribute.
+	* resolve.c (gfc_implicit_pure):  Walk up namespaces
+	until a procedure is found.
+
+2011-12-22  Toon Moene  <toon@moene.org>
+
+	PR fortran/51310
+	* resolve.c (build_default_init_expr): Allow non-allocatable,
+	non-compile-time-constant-shape arrays to have a default
+	initializer.
+	* invoke.texi: Delete the restriction on automatic arrays not
+	being initialized by -finit-<type>=<constant>.
+
+2011-12-15  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/51550
+	PR fortran/47545
+	PR fortran/49050
+	PR fortran/51075
+	* resolve.c (resolve_fl_derived0): Print not-implemented error
+	for deferred-length character components.
+
+2011-12-11  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/50923
+	* trans-decl.c (generate_local_decl): Set TREE_NO_WARNING only
+	if the front end has printed a warning.
+	(gfc_generate_function_code): Fix unset-result warning.
+
+2011-12-11  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/51338
+	Backport from trunk
+	* dependency.c (are_identical_variables):  Handle case where
+	end fields of substring references are NULL.
+
+2011-12-08  Toon Moene  <toon@moene.org>
+
+	PR fortran/51310
+	* invoke.texi: Itemize the cases for which
+	-finit-<type>=<constant> doesn't work.
+
+2011-12-08  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/51448
+	* fortran/trans-array.c (get_std_lbound): Fix handling of
+	conversion functions.
+
+2011-12-06  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/51435
+	* expr.c (gfc_has_default_initializer): Fix handling of
+	DT with initialized pointer components.
+
+2011-12-03  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/50684
+	* check.c (variable_check): Fix intent(in) check.
+
+2011-11-25  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/50408
+	* trans-decl.c (gfc_get_module_backend_decl): Also copy
+	ts.u.derived from the gsym if the ts.type is BT_CLASS.
+	(gfc_get_extern_function_decl): Copy also the backend_decl
+	for the symbol's ts.u.{derived,cl} from the gsym.
+	* trans-types.c (gfc_copy_dt_decls_ifequal): Directly
+	return if "from" and "to" are the same.
+
+2011-11-24  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/51218
+	* gfortran.dg/implicit_pure_1.f90: New.
+
 2011-10-26  Release Manager
 
 	* GCC 4.6.2 released.
Index: gcc/fortran/expr.c
===================================================================
--- gcc/fortran/expr.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/fortran/expr.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -3679,6 +3679,8 @@
         if (!c->attr.pointer
 	     && gfc_has_default_initializer (c->ts.u.derived))
 	  return true;
+	if (c->attr.pointer && c->initializer)
+	  return true;
       }
     else
       {
@@ -3689,6 +3691,7 @@
   return false;
 }
 
+
 /* Get an expression for a default initializer.  */
 
 gfc_expr *
@@ -4360,6 +4363,11 @@
   result->value.function.name = name;
   result->value.function.isym = isym;
 
+  result->symtree = gfc_find_symtree (gfc_current_ns->sym_root, name);
+  gcc_assert (result->symtree
+	      && (result->symtree->n.sym->attr.flavor == FL_PROCEDURE
+		  || result->symtree->n.sym->attr.flavor == FL_UNKNOWN));
+
   va_start (ap, numarg);
   atail = NULL;
   for (i = 0; i < numarg; ++i)
@@ -4520,9 +4528,24 @@
       return FAILURE;
     }
 
-  if (!pointer && gfc_implicit_pure (NULL) && gfc_impure_variable (sym))
-    gfc_current_ns->proc_name->attr.implicit_pure = 0;
+  if (!pointer && context && gfc_implicit_pure (NULL)
+      && gfc_impure_variable (sym))
+    {
+      gfc_namespace *ns;
+      gfc_symbol *sym;
 
+      for (ns = gfc_current_ns; ns; ns = ns->parent)
+	{
+	  sym = ns->proc_name;
+	  if (sym == NULL)
+	    break;
+	  if (sym->attr.flavor == FL_PROCEDURE)
+	    {
+	      sym->attr.implicit_pure = 0;
+	      break;
+	    }
+	}
+    }
   /* Check variable definition context for associate-names.  */
   if (!pointer && sym->assoc)
     {
Index: gcc/fortran/invoke.texi
===================================================================
--- gcc/fortran/invoke.texi	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/fortran/invoke.texi	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1438,10 +1438,16 @@
 the real and imaginary parts of local @code{COMPLEX} variables),
 @option{-finit-logical=@var{<true|false>}}, and
 @option{-finit-character=@var{n}} (where @var{n} is an ASCII character
-value) options.  These options do not initialize components of derived
-type variables, nor do they initialize variables that appear in an
-@code{EQUIVALENCE} statement.  (This limitation may be removed in
-future releases).
+value) options.  These options do not initialize
+@itemize @bullet
+@item
+allocatable arrays
+@item
+components of derived type variables
+@item
+variables that appear in an @code{EQUIVALENCE} statement.
+@end itemize
+(These limitations may be removed in future releases).
 
 Note that the @option{-finit-real=nan} option initializes @code{REAL}
 and @code{COMPLEX} variables with a quiet NaN. For a signalling NaN
Index: gcc/fortran/trans-types.c
===================================================================
--- gcc/fortran/trans-types.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/fortran/trans-types.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -2092,6 +2092,9 @@
   gfc_component *to_cm;
   gfc_component *from_cm;
 
+  if (from == to)
+    return 1;
+
   if (from->backend_decl == NULL
 	|| !gfc_compare_derived_types (from, to))
     return 0;
Index: gcc/fortran/resolve.c
===================================================================
--- gcc/fortran/resolve.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/fortran/resolve.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1053,6 +1053,7 @@
 	  && comp->ts.u.cl->length->expr_type == EXPR_CONSTANT
 	  && cons->expr->ts.u.cl && cons->expr->ts.u.cl->length
 	  && cons->expr->ts.u.cl->length->expr_type == EXPR_CONSTANT
+	  && cons->expr->rank != 0
 	  && mpz_cmp (cons->expr->ts.u.cl->length->value.integer,
 		      comp->ts.u.cl->length->value.integer) != 0)
 	{
@@ -3132,11 +3133,11 @@
 		     "procedure within a PURE procedure", name, &expr->where);
 	  t = FAILURE;
 	}
+
+      if (gfc_implicit_pure (NULL))
+	gfc_current_ns->proc_name->attr.implicit_pure = 0;
     }
 
-  if (!pure_function (expr, &name) && name && gfc_implicit_pure (NULL))
-    gfc_current_ns->proc_name->attr.implicit_pure = 0;
-
   /* Functions without the RECURSIVE attribution are not allowed to
    * call themselves.  */
   if (expr->value.function.esym && !expr->value.function.esym->attr.recursive)
@@ -3195,6 +3196,9 @@
   else if (gfc_pure (NULL))
     gfc_error ("Subroutine call to '%s' at %L is not PURE", sym->name,
 	       &c->loc);
+
+  if (gfc_implicit_pure (NULL))
+    gfc_current_ns->proc_name->attr.implicit_pure = 0;
 }
 
 
@@ -9687,7 +9691,7 @@
   int i;
 
   /* These symbols should never have a default initialization.  */
-  if ((sym->attr.dimension && !gfc_is_compile_time_shape (sym->as))
+  if (sym->attr.allocatable
       || sym->attr.external
       || sym->attr.dummy
       || sym->attr.pointer
@@ -9811,6 +9815,26 @@
 	  gfc_free_expr (init_expr);
 	  init_expr = NULL;
 	}
+      if (!init_expr && gfc_option.flag_init_character == GFC_INIT_CHARACTER_ON
+	  && sym->ts.u.cl->length)
+	{
+	  gfc_actual_arglist *arg;
+	  init_expr = gfc_get_expr ();
+	  init_expr->where = sym->declared_at;
+	  init_expr->ts = sym->ts;
+	  init_expr->expr_type = EXPR_FUNCTION;
+	  init_expr->value.function.isym =
+		gfc_intrinsic_function_by_id (GFC_ISYM_REPEAT);
+	  init_expr->value.function.name = "repeat";
+	  arg = gfc_get_actual_arglist ();
+	  arg->expr = gfc_get_character_expr (sym->ts.kind, &sym->declared_at,
+					      NULL, 1);
+	  arg->expr->value.character.string[0]
+		= gfc_option.flag_init_character_value;
+	  arg->next = gfc_get_actual_arglist ();
+	  arg->next->expr = gfc_copy_expr (sym->ts.u.cl->length);
+	  init_expr->value.function.actual = arg;
+	}
       break;
 	  
     default:
@@ -9837,10 +9861,12 @@
   if (init == NULL)
     return;
 
-  /* For saved variables, we don't want to add an initializer at 
-     function entry, so we just add a static initializer.  */
+  /* For saved variables, we don't want to add an initializer at function
+     entry, so we just add a static initializer. Note that automatic variables
+     are stack allocated even with -fno-automatic.  */
   if (sym->attr.save || sym->ns->save_all 
-      || gfc_option.flag_max_stack_var_size == 0)
+      || (gfc_option.flag_max_stack_var_size == 0
+	  && (!sym->attr.dimension || !is_non_constant_shape_array (sym))))
     {
       /* Don't clobber an existing initializer!  */
       gcc_assert (sym->value == NULL);
@@ -11394,6 +11420,14 @@
 
   for (c = sym->components; c != NULL; c = c->next)
     {
+      /* See PRs 51550, 47545, 48654, 49050, 51075 - and 45170.  */
+      if (c->ts.type == BT_CHARACTER && c->ts.deferred)
+	{
+	  gfc_error ("Deferred-length character component '%s' at %L is not "
+		     "yet supported", c->name, &c->loc);
+	  return FAILURE;
+	}
+
       /* F2008, C442.  */
       if (c->attr.codimension /* FIXME: c->as check due to PR 43412.  */
 	  && (!c->attr.allocatable || (c->as && c->as->type != AS_DEFERRED)))
@@ -12925,24 +12959,25 @@
 int
 gfc_implicit_pure (gfc_symbol *sym)
 {
-  symbol_attribute attr;
+  gfc_namespace *ns;
 
   if (sym == NULL)
     {
-      /* Check if the current namespace is implicit_pure.  */
-      sym = gfc_current_ns->proc_name;
-      if (sym == NULL)
-	return 0;
-      attr = sym->attr;
-      if (attr.flavor == FL_PROCEDURE
-	    && attr.implicit_pure && !attr.pure)
-	return 1;
-      return 0;
+      /* Check if the current procedure is implicit_pure.  Walk up
+	 the procedure list until we find a procedure.  */
+      for (ns = gfc_current_ns; ns; ns = ns->parent)
+	{
+	  sym = ns->proc_name;
+	  if (sym == NULL)
+	    return 0;
+	  
+	  if (sym->attr.flavor == FL_PROCEDURE)
+	    break;
+	}
     }
-
-  attr = sym->attr;
-
-  return attr.flavor == FL_PROCEDURE && attr.implicit_pure && !attr.pure;
+  
+  return sym->attr.flavor == FL_PROCEDURE && sym->attr.implicit_pure
+    && !sym->attr.pure;
 }
 
 
Index: gcc/fortran/trans-decl.c
===================================================================
--- gcc/fortran/trans-decl.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/fortran/trans-decl.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -677,7 +677,7 @@
 	}
       else if (s->backend_decl)
 	{
-	  if (sym->ts.type == BT_DERIVED)
+	  if (sym->ts.type == BT_DERIVED || sym->ts.type == BT_CLASS)
 	    gfc_copy_dt_decls_ifequal (s->ts.u.derived, sym->ts.u.derived,
 				       true);
 	  else if (sym->ts.type == BT_CHARACTER)
@@ -1602,6 +1602,11 @@
       gfc_find_symbol (sym->name, gsym->ns, 0, &s);
       if (s && s->backend_decl)
 	{
+	  if (sym->ts.type == BT_DERIVED || sym->ts.type == BT_CLASS)
+	    gfc_copy_dt_decls_ifequal (s->ts.u.derived, sym->ts.u.derived,
+				       true);
+	  else if (sym->ts.type == BT_CHARACTER)
+	    sym->ts.u.cl->backend_decl = s->ts.u.cl->backend_decl;
 	  sym->backend_decl = s->backend_decl;
 	  return sym->backend_decl;
 	}
@@ -4179,10 +4184,16 @@
 			     "declared INTENT(OUT) but was not set and "
 			     "does not have a default initializer",
 			     sym->name, &sym->declared_at);
+	      if (sym->backend_decl != NULL_TREE)
+		TREE_NO_WARNING(sym->backend_decl) = 1;
 	    }
 	  else if (gfc_option.warn_unused_dummy_argument)
-	    gfc_warning ("Unused dummy argument '%s' at %L", sym->name,
+	    {
+	      gfc_warning ("Unused dummy argument '%s' at %L", sym->name,
 			 &sym->declared_at);
+	      if (sym->backend_decl != NULL_TREE)
+		TREE_NO_WARNING(sym->backend_decl) = 1;
+	    }
 	}
 
       /* Warn for unused variables, but not if they're inside a common
@@ -4227,11 +4238,6 @@
 	mark the symbol now, as well as in traverse_ns, to prevent
 	getting stuck in a circular dependency.  */
       sym->mark = 1;
-
-      /* We do not want the middle-end to warn about unused parameters
-         as this was already done above.  */
-      if (sym->attr.dummy && sym->backend_decl != NULL_TREE)
-	  TREE_NO_WARNING(sym->backend_decl) = 1;
     }
   else if (sym->attr.flavor == FL_PARAMETER)
     {
@@ -4846,11 +4852,11 @@
       if (result == NULL_TREE)
 	{
 	  /* TODO: move to the appropriate place in resolve.c.  */
-	  if (warn_return_type && !sym->attr.referenced && sym == sym->result)
+	  if (warn_return_type && sym == sym->result)
 	    gfc_warning ("Return value of function '%s' at %L not set",
 			 sym->name, &sym->declared_at);
-
-	  TREE_NO_WARNING(sym->backend_decl) = 1;
+	  if (warn_return_type)
+	    TREE_NO_WARNING(sym->backend_decl) = 1;
 	}
       else
 	gfc_add_expr_to_block (&body, gfc_generate_return ());
Index: gcc/fortran/check.c
===================================================================
--- gcc/fortran/check.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/fortran/check.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -485,23 +485,47 @@
       && (gfc_current_intrinsic_arg[n]->intent == INTENT_OUT
 	  || gfc_current_intrinsic_arg[n]->intent == INTENT_INOUT))
     {
-      gfc_error ("'%s' argument of '%s' intrinsic at %L cannot be INTENT(IN)",
-		 gfc_current_intrinsic_arg[n]->name, gfc_current_intrinsic,
-		 &e->where);
-      return FAILURE;
+      gfc_ref *ref;
+      bool pointer = e->symtree->n.sym->ts.type == BT_CLASS
+		     && CLASS_DATA (e->symtree->n.sym)
+		     ? CLASS_DATA (e->symtree->n.sym)->attr.class_pointer
+		     : e->symtree->n.sym->attr.pointer;
+
+      for (ref = e->ref; ref; ref = ref->next)
+	{
+	  if (pointer && ref->type == REF_COMPONENT)
+	    break;
+	  if (ref->type == REF_COMPONENT
+	      && ((ref->u.c.component->ts.type == BT_CLASS
+		   && CLASS_DATA (ref->u.c.component)->attr.class_pointer)
+		  || (ref->u.c.component->ts.type != BT_CLASS
+		      && ref->u.c.component->attr.pointer)))
+	    break;
+	} 
+
+      if (!ref)
+	{
+	  gfc_error ("'%s' argument of '%s' intrinsic at %L cannot be "
+		     "INTENT(IN)", gfc_current_intrinsic_arg[n]->name,
+		     gfc_current_intrinsic, &e->where);
+	  return FAILURE;
+	}
     }
 
   if (e->expr_type == EXPR_VARIABLE
       && e->symtree->n.sym->attr.flavor != FL_PARAMETER
-      && (allow_proc
-	  || !e->symtree->n.sym->attr.function
-	  || (e->symtree->n.sym == e->symtree->n.sym->result
-	      && (e->symtree->n.sym == gfc_current_ns->proc_name
-		  || (gfc_current_ns->parent
-		      && e->symtree->n.sym
-			 == gfc_current_ns->parent->proc_name)))))
+      && (allow_proc || !e->symtree->n.sym->attr.function))
     return SUCCESS;
 
+  if (e->expr_type == EXPR_VARIABLE && e->symtree->n.sym->attr.function
+      && e->symtree->n.sym == e->symtree->n.sym->result)
+    {
+      gfc_namespace *ns;
+      for (ns = gfc_current_ns; ns; ns = ns->parent)
+	if (ns->proc_name == e->symtree->n.sym)
+	  return SUCCESS;
+    }
+
   gfc_error ("'%s' argument of '%s' intrinsic at %L must be a variable",
 	     gfc_current_intrinsic_arg[n]->name, gfc_current_intrinsic, &e->where);
 
Index: gcc/fortran/dependency.c
===================================================================
--- gcc/fortran/dependency.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/fortran/dependency.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -163,9 +163,19 @@
 	  break;
 
 	case REF_SUBSTRING:
-	  if (gfc_dep_compare_expr (r1->u.ss.start, r2->u.ss.start) != 0
-	      || gfc_dep_compare_expr (r1->u.ss.end, r2->u.ss.end) != 0)
+	  if (gfc_dep_compare_expr (r1->u.ss.start, r2->u.ss.start) != 0)
 	    return false;
+
+	  /* If both are NULL, the end length compares equal, because we
+	     are looking at the same variable. This can only happen for
+	     assumed- or deferred-length character arguments.  */ 
+
+	  if (r1->u.ss.end == NULL && r2->u.ss.end == NULL)
+	    break;
+
+	  if (gfc_dep_compare_expr (r1->u.ss.end, r2->u.ss.end) != 0)
+	    return false;
+	  
 	  break;
 
 	default:
Index: gcc/regmove.c
===================================================================
--- gcc/regmove.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/regmove.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -860,7 +860,7 @@
 	  if (REG_N_CALLS_CROSSED (REGNO (src)) == 0)
 	    break;
 
-	  if (call_used_regs [REGNO (dst)]
+	  if ((HARD_REGISTER_P (dst) && call_used_regs [REGNO (dst)])
 	      || find_reg_fusage (p, CLOBBER, dst))
 	    break;
 	}
Index: gcc/configure.ac
===================================================================
--- gcc/configure.ac	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/configure.ac	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -807,17 +807,7 @@
 gcc_AC_PROG_LN_S
 ACX_PROG_LN($LN_S)
 AC_PROG_RANLIB
-case "${host}" in
-*-*-darwin*)
-  # By default, the Darwin ranlib will not treat common symbols as
-  # definitions when  building the archive table of contents.  Other 
-  # ranlibs do that; pass an option to the Darwin ranlib that makes
-  # it behave similarly.
-  ranlib_flags="-c" 
-  ;;
-*)
-  ranlib_flags=""
-esac
+ranlib_flags=""
 AC_SUBST(ranlib_flags)
      
 gcc_AC_PROG_INSTALL
Index: gcc/BASE-VER
===================================================================
--- gcc/BASE-VER	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/BASE-VER	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1 +1 @@
-4.6.2
+4.6.3
Index: gcc/df.h
===================================================================
--- gcc/df.h	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/df.h	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -53,7 +53,7 @@
 #define DF_RD      3      /* Reaching Defs. */
 #define DF_CHAIN   4      /* Def-Use and/or Use-Def Chains. */
 #define DF_WORD_LR 5      /* Subreg tracking lr.  */
-#define DF_NOTE    6      /* REG_DEF and REG_UNUSED notes. */
+#define DF_NOTE    6      /* REG_DEAD and REG_UNUSED notes.  */
 #define DF_MD      7      /* Multiple Definitions. */
 
 #define DF_LAST_PROBLEM_PLUS1 (DF_MD + 1)
Index: gcc/ipa-split.c
===================================================================
--- gcc/ipa-split.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/ipa-split.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -130,6 +130,10 @@
 
 struct split_point best_split_point;
 
+/* Set of basic blocks that are not allowed to dominate a split point.  */
+
+static bitmap forbidden_dominators;
+
 static tree find_retval (basic_block return_bb);
 
 /* Callback for walk_stmt_load_store_addr_ops.  If T is non-SSA automatic
@@ -270,6 +274,83 @@
   return ok;
 }
 
+/* If STMT is a call, check the callee against a list of forbidden
+   predicate functions.  If a match is found, look for uses of the
+   call result in condition statements that compare against zero.
+   For each such use, find the block targeted by the condition
+   statement for the nonzero result, and set the bit for this block
+   in the forbidden dominators bitmap.  The purpose of this is to avoid
+   selecting a split point where we are likely to lose the chance
+   to optimize away an unused function call.  */
+
+static void
+check_forbidden_calls (gimple stmt)
+{
+  imm_use_iterator use_iter;
+  use_operand_p use_p;
+  tree lhs;
+
+  /* At the moment, __builtin_constant_p is the only forbidden
+     predicate function call (see PR49642).  */
+  if (!gimple_call_builtin_p (stmt, BUILT_IN_CONSTANT_P))
+    return;
+
+  lhs = gimple_call_lhs (stmt);
+
+  if (!lhs || TREE_CODE (lhs) != SSA_NAME)
+    return;
+
+  FOR_EACH_IMM_USE_FAST (use_p, use_iter, lhs)
+    {
+      tree op1;
+      basic_block use_bb, forbidden_bb;
+      enum tree_code code;
+      edge true_edge, false_edge;
+      gimple use_stmt = USE_STMT (use_p);
+
+      if (gimple_code (use_stmt) != GIMPLE_COND)
+	continue;
+
+      /* Assuming canonical form for GIMPLE_COND here, with constant
+	 in second position.  */
+      op1 = gimple_cond_rhs (use_stmt);
+      code = gimple_cond_code (use_stmt);
+      use_bb = gimple_bb (use_stmt);
+
+      extract_true_false_edges_from_block (use_bb, &true_edge, &false_edge);
+
+      /* We're only interested in comparisons that distinguish
+	 unambiguously from zero.  */
+      if (!integer_zerop (op1) || code == LE_EXPR || code == GE_EXPR)
+	continue;
+
+      if (code == EQ_EXPR)
+	forbidden_bb = false_edge->dest;
+      else
+	forbidden_bb = true_edge->dest;
+
+      bitmap_set_bit (forbidden_dominators, forbidden_bb->index);
+    }
+}
+
+/* If BB is dominated by any block in the forbidden dominators set,
+   return TRUE; else FALSE.  */
+
+static bool
+dominated_by_forbidden (basic_block bb)
+{
+  unsigned dom_bb;
+  bitmap_iterator bi;
+
+  EXECUTE_IF_SET_IN_BITMAP (forbidden_dominators, 1, dom_bb, bi)
+    {
+      if (dominated_by_p (CDI_DOMINATORS, bb, BASIC_BLOCK (dom_bb)))
+	return true;
+    }
+
+  return false;
+}
+
 /* We found an split_point CURRENT.  NON_SSA_VARS is bitmap of all non ssa
    variables used and RETURN_BB is return basic block.
    See if we can split function here.  */
@@ -411,6 +492,18 @@
 		 "  Refused: split part has non-ssa uses\n");
       return;
     }
+
+  /* If the split point is dominated by a forbidden block, reject
+     the split.  */
+  if (!bitmap_empty_p (forbidden_dominators)
+      && dominated_by_forbidden (current->entry_bb))
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file,
+		 "  Refused: split point dominated by forbidden block\n");
+      return;
+    }
+
   /* See if retval used by return bb is computed by header or split part.
      When it is computed by split part, we need to produce return statement
      in the split part and add code to header to pass it around.
@@ -1329,6 +1422,10 @@
       return 0;
     }
 
+  /* Initialize bitmap to track forbidden calls.  */
+  forbidden_dominators = BITMAP_ALLOC (NULL);
+  calculate_dominance_info (CDI_DOMINATORS);
+
   /* Compute local info about basic blocks and determine function size/time.  */
   VEC_safe_grow_cleared (bb_info, heap, bb_info_vec, last_basic_block + 1);
   memset (&best_split_point, 0, sizeof (best_split_point));
@@ -1350,6 +1447,7 @@
 	  this_time = estimate_num_insns (stmt, &eni_time_weights) * freq;
 	  size += this_size;
 	  time += this_time;
+	  check_forbidden_calls (stmt);
 
 	  if (dump_file && (dump_flags & TDF_DETAILS))
 	    {
@@ -1371,6 +1469,7 @@
       BITMAP_FREE (best_split_point.split_bbs);
       todo = TODO_update_ssa | TODO_cleanup_cfg;
     }
+  BITMAP_FREE (forbidden_dominators);
   VEC_free (bb_info, heap, bb_info_vec);
   bb_info_vec = NULL;
   return todo;
Index: gcc/lto-section-in.c
===================================================================
--- gcc/lto-section-in.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/lto-section-in.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -296,7 +296,7 @@
     = (const struct lto_simple_header *) data;
 
   struct lto_input_block* ib_main;
-  int32_t main_offset = sizeof (struct lto_simple_header);
+  int main_offset = sizeof (struct lto_simple_header);
 
   if (!data)
     return NULL;
Index: gcc/tree-vect-data-refs.c
===================================================================
--- gcc/tree-vect-data-refs.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/tree-vect-data-refs.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -2631,6 +2631,16 @@
           return false;
         }
 
+      if (is_gimple_call (stmt))
+	{
+	  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))
+	    {
+	      fprintf (vect_dump, "not vectorized: dr in a call ");
+	      print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);
+	    }
+	  return false;
+	}
+
       /* Update DR field in stmt_vec_info struct.  */
 
       /* If the dataref is in an inner-loop of the loop that is considered for
Index: gcc/c-typeck.c
===================================================================
--- gcc/c-typeck.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/c-typeck.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -3802,11 +3802,7 @@
       if (val && TREE_CODE (val) == INDIRECT_REF
           && TREE_CONSTANT (TREE_OPERAND (val, 0)))
 	{
-	  tree op0 = fold_convert_loc (location, sizetype,
-				       fold_offsetof (arg, val)), op1;
-
-	  op1 = fold_convert_loc (location, argtype, TREE_OPERAND (val, 0));
-	  ret = fold_build2_loc (location, POINTER_PLUS_EXPR, argtype, op1, op0);
+	  ret = fold_convert_loc (location, argtype, fold_offsetof_1 (arg));
 	  goto return_build_unary_op;
 	}
 
Index: gcc/calls.c
===================================================================
--- gcc/calls.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/calls.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1548,6 +1548,131 @@
   return funexp;
 }
 
+/* Internal state for internal_arg_pointer_based_exp and its helpers.  */
+static struct
+{
+  /* Last insn that has been scanned by internal_arg_pointer_based_exp_scan,
+     or NULL_RTX if none has been scanned yet.  */
+  rtx scan_start;
+  /* Vector indexed by REGNO - FIRST_PSEUDO_REGISTER, recording if a pseudo is
+     based on crtl->args.internal_arg_pointer.  The element is NULL_RTX if the
+     pseudo isn't based on it, a CONST_INT offset if the pseudo is based on it
+     with fixed offset, or PC if this is with variable or unknown offset.  */
+  VEC(rtx, heap) *cache;
+} internal_arg_pointer_exp_state;
+
+static rtx internal_arg_pointer_based_exp (rtx, bool);
+
+/* Helper function for internal_arg_pointer_based_exp.  Scan insns in
+   the tail call sequence, starting with first insn that hasn't been
+   scanned yet, and note for each pseudo on the LHS whether it is based
+   on crtl->args.internal_arg_pointer or not, and what offset from that
+   that pointer it has.  */
+
+static void
+internal_arg_pointer_based_exp_scan (void)
+{
+  rtx insn, scan_start = internal_arg_pointer_exp_state.scan_start;
+
+  if (scan_start == NULL_RTX)
+    insn = get_insns ();
+  else
+    insn = NEXT_INSN (scan_start);
+
+  while (insn)
+    {
+      rtx set = single_set (insn);
+      if (set && REG_P (SET_DEST (set)) && !HARD_REGISTER_P (SET_DEST (set)))
+	{
+	  rtx val = NULL_RTX;
+	  unsigned int idx = REGNO (SET_DEST (set)) - FIRST_PSEUDO_REGISTER;
+	  /* Punt on pseudos set multiple times.  */
+	  if (idx < VEC_length (rtx, internal_arg_pointer_exp_state.cache)
+	      && (VEC_index (rtx, internal_arg_pointer_exp_state.cache, idx)
+		  != NULL_RTX))
+	    val = pc_rtx;
+	  else
+	    val = internal_arg_pointer_based_exp (SET_SRC (set), false);
+	  if (val != NULL_RTX)
+	    {
+	      if (idx
+		  >= VEC_length (rtx, internal_arg_pointer_exp_state.cache))
+		VEC_safe_grow_cleared (rtx, heap,
+				       internal_arg_pointer_exp_state.cache,
+				       idx + 1);
+	      VEC_replace (rtx, internal_arg_pointer_exp_state.cache,
+			   idx, val);
+	    }
+	}
+      if (NEXT_INSN (insn) == NULL_RTX)
+	scan_start = insn;
+      insn = NEXT_INSN (insn);
+    }
+
+  internal_arg_pointer_exp_state.scan_start = scan_start;
+}
+
+/* Helper function for internal_arg_pointer_based_exp, called through
+   for_each_rtx.  Return 1 if *LOC is a register based on
+   crtl->args.internal_arg_pointer.  Return -1 if *LOC is not based on it
+   and the subexpressions need not be examined.  Otherwise return 0.  */
+
+static int
+internal_arg_pointer_based_exp_1 (rtx *loc, void *data ATTRIBUTE_UNUSED)
+{
+  if (REG_P (*loc) && internal_arg_pointer_based_exp (*loc, false) != NULL_RTX)
+    return 1;
+  if (MEM_P (*loc))
+    return -1;
+  return 0;
+}
+
+/* Compute whether RTL is based on crtl->args.internal_arg_pointer.  Return
+   NULL_RTX if RTL isn't based on it, a CONST_INT offset if RTL is based on
+   it with fixed offset, or PC if this is with variable or unknown offset.
+   TOPLEVEL is true if the function is invoked at the topmost level.  */
+
+static rtx
+internal_arg_pointer_based_exp (rtx rtl, bool toplevel)
+{
+  if (CONSTANT_P (rtl))
+    return NULL_RTX;
+
+  if (rtl == crtl->args.internal_arg_pointer)
+    return const0_rtx;
+
+  if (REG_P (rtl) && HARD_REGISTER_P (rtl))
+    return NULL_RTX;
+
+  if (GET_CODE (rtl) == PLUS && CONST_INT_P (XEXP (rtl, 1)))
+    {
+      rtx val = internal_arg_pointer_based_exp (XEXP (rtl, 0), toplevel);
+      if (val == NULL_RTX || val == pc_rtx)
+	return val;
+      return plus_constant (val, INTVAL (XEXP (rtl, 1)));
+    }
+
+  /* When called at the topmost level, scan pseudo assignments in between the
+     last scanned instruction in the tail call sequence and the latest insn
+     in that sequence.  */
+  if (toplevel)
+    internal_arg_pointer_based_exp_scan ();
+
+  if (REG_P (rtl))
+    {
+      unsigned int idx = REGNO (rtl) - FIRST_PSEUDO_REGISTER;
+      if (idx < VEC_length (rtx, internal_arg_pointer_exp_state.cache))
+	return VEC_index (rtx, internal_arg_pointer_exp_state.cache, idx);
+
+      return NULL_RTX;
+    }
+
+  if (for_each_rtx (&rtl, internal_arg_pointer_based_exp_1, NULL))
+    return pc_rtx;
+
+  return NULL_RTX;
+}
+
 /* Return true if and only if SIZE storage units (usually bytes)
    starting from address ADDR overlap with already clobbered argument
    area.  This function is used to determine if we should give up a
@@ -1557,20 +1682,17 @@
 mem_overlaps_already_clobbered_arg_p (rtx addr, unsigned HOST_WIDE_INT size)
 {
   HOST_WIDE_INT i;
+  rtx val;
 
-  if (addr == crtl->args.internal_arg_pointer)
-    i = 0;
-  else if (GET_CODE (addr) == PLUS
-	   && XEXP (addr, 0) == crtl->args.internal_arg_pointer
-	   && CONST_INT_P (XEXP (addr, 1)))
-    i = INTVAL (XEXP (addr, 1));
-  /* Return true for arg pointer based indexed addressing.  */
-  else if (GET_CODE (addr) == PLUS
-	   && (XEXP (addr, 0) == crtl->args.internal_arg_pointer
-	       || XEXP (addr, 1) == crtl->args.internal_arg_pointer))
+  if (sbitmap_empty_p (stored_args_map))
+    return false;
+  val = internal_arg_pointer_based_exp (addr, true);
+  if (val == NULL_RTX)
+    return false;
+  else if (val == pc_rtx)
     return true;
   else
-    return false;
+    i = INTVAL (val);
 
 #ifdef ARGS_GROW_DOWNWARD
   i = -i - size;
@@ -3175,6 +3297,8 @@
 	    }
 
 	  sbitmap_free (stored_args_map);
+	  internal_arg_pointer_exp_state.scan_start = NULL_RTX;
+	  VEC_free (rtx, heap, internal_arg_pointer_exp_state.cache);
 	}
       else
 	{
Index: gcc/loop-doloop.c
===================================================================
--- gcc/loop-doloop.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/loop-doloop.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -334,14 +334,11 @@
    describes the loop, DESC describes the number of iterations of the
    loop, and DOLOOP_INSN is the low-overhead looping insn to emit at the
    end of the loop.  CONDITION is the condition separated from the
-   DOLOOP_SEQ.  COUNT is the number of iterations of the LOOP.
-   ZERO_EXTEND_P says to zero extend COUNT after the increment of it to
-   word_mode from FROM_MODE.  */
+   DOLOOP_SEQ.  COUNT is the number of iterations of the LOOP.  */
 
 static void
 doloop_modify (struct loop *loop, struct niter_desc *desc,
-	       rtx doloop_seq, rtx condition, rtx count,
-	       bool zero_extend_p, enum machine_mode from_mode)
+	       rtx doloop_seq, rtx condition, rtx count)
 {
   rtx counter_reg;
   rtx tmp, noloop = NULL_RTX;
@@ -415,12 +412,8 @@
     }
 
   if (increment_count)
-    count = simplify_gen_binary (PLUS, from_mode, count, const1_rtx);
+    count = simplify_gen_binary (PLUS, mode, count, const1_rtx);
 
-  if (zero_extend_p)
-    count = simplify_gen_unary (ZERO_EXTEND, word_mode,
-				count, from_mode);
-
   /* Insert initialization of the count register into the loop header.  */
   start_sequence ();
   tmp = force_operand (count, counter_reg);
@@ -555,7 +548,6 @@
   struct niter_desc *desc;
   unsigned word_mode_size;
   unsigned HOST_WIDE_INT word_mode_max;
-  bool zero_extend_p = false;
 
   if (dump_file)
     fprintf (dump_file, "Doloop: Processing loop %d.\n", loop->num);
@@ -630,7 +622,8 @@
     {
       if (word_mode_size > GET_MODE_BITSIZE (mode))
 	{
-	  zero_extend_p = true;
+	  count = simplify_gen_unary (ZERO_EXTEND, word_mode,
+				      count, mode);
 	  iterations = simplify_gen_unary (ZERO_EXTEND, word_mode,
 					   iterations, mode);
 	  iterations_max = simplify_gen_unary (ZERO_EXTEND, word_mode,
@@ -674,8 +667,7 @@
       return false;
     }
 
-  doloop_modify (loop, desc, doloop_seq, condition, count,
-		 zero_extend_p, mode);
+  doloop_modify (loop, desc, doloop_seq, condition, count);
   return true;
 }
 
Index: gcc/tree-ssa-pre.c
===================================================================
--- gcc/tree-ssa-pre.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/tree-ssa-pre.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1545,7 +1545,7 @@
 	tree newvuse = vuse;
 	VEC (vn_reference_op_s, heap) *newoperands = NULL;
 	bool changed = false, same_valid = true;
-	unsigned int i, j;
+	unsigned int i, j, n;
 	vn_reference_op_t operand;
 	vn_reference_t newref;
 
@@ -1554,100 +1554,83 @@
 	  {
 	    pre_expr opresult;
 	    pre_expr leader;
-	    tree oldop0 = operand->op0;
-	    tree oldop1 = operand->op1;
-	    tree oldop2 = operand->op2;
-	    tree op0 = oldop0;
-	    tree op1 = oldop1;
-	    tree op2 = oldop2;
+	    tree op[3];
 	    tree type = operand->type;
 	    vn_reference_op_s newop = *operand;
-
-	    if (op0 && TREE_CODE (op0) == SSA_NAME)
+	    op[0] = operand->op0;
+	    op[1] = operand->op1;
+	    op[2] = operand->op2;
+	    for (n = 0; n < 3; ++n)
 	      {
-		unsigned int op_val_id = VN_INFO (op0)->value_id;
-		leader = find_leader_in_sets (op_val_id, set1, set2);
-		opresult = phi_translate (leader, set1, set2, pred, phiblock);
-		if (opresult && opresult != leader)
+		unsigned int op_val_id;
+		if (!op[n])
+		  continue;
+		if (TREE_CODE (op[n]) != SSA_NAME)
 		  {
-		    tree name = get_representative_for (opresult);
-		    if (!name)
+		    /* We can't possibly insert these.  */
+		    if (n != 0
+			&& !is_gimple_min_invariant (op[n]))
 		      break;
-		    op0 = name;
+		    continue;
 		  }
-		else if (!opresult)
+		op_val_id = VN_INFO (op[n])->value_id;
+		leader = find_leader_in_sets (op_val_id, set1, set2);
+		if (!leader)
 		  break;
-	      }
-	    changed |= op0 != oldop0;
-
-	    if (op1 && TREE_CODE (op1) == SSA_NAME)
-	      {
-		unsigned int op_val_id = VN_INFO (op1)->value_id;
-		leader = find_leader_in_sets (op_val_id, set1, set2);
-		opresult = phi_translate (leader, set1, set2, pred, phiblock);
-		if (opresult && opresult != leader)
+		/* Make sure we do not recursively translate ourselves
+		   like for translating a[n_1] with the leader for
+		   n_1 being a[n_1].  */
+		if (get_expression_id (leader) != get_expression_id (expr))
 		  {
-		    tree name = get_representative_for (opresult);
-		    if (!name)
+		    opresult = phi_translate (leader, set1, set2,
+					      pred, phiblock);
+		    if (!opresult)
 		      break;
-		    op1 = name;
+		    if (opresult != leader)
+		      {
+			tree name = get_representative_for (opresult);
+			if (!name)
+			  break;
+			changed |= name != op[n];
+			op[n] = name;
+		      }
 		  }
-		else if (!opresult)
-		  break;
 	      }
-	    /* We can't possibly insert these.  */
-	    else if (op1 && !is_gimple_min_invariant (op1))
-	      break;
-	    changed |= op1 != oldop1;
-	    if (op2 && TREE_CODE (op2) == SSA_NAME)
+	    if (n != 3)
 	      {
-		unsigned int op_val_id = VN_INFO (op2)->value_id;
-		leader = find_leader_in_sets (op_val_id, set1, set2);
-		opresult = phi_translate (leader, set1, set2, pred, phiblock);
-		if (opresult && opresult != leader)
-		  {
-		    tree name = get_representative_for (opresult);
-		    if (!name)
-		      break;
-		    op2 = name;
-		  }
-		else if (!opresult)
-		  break;
+		if (newoperands)
+		  VEC_free (vn_reference_op_s, heap, newoperands);
+		return NULL;
 	      }
-	    /* We can't possibly insert these.  */
-	    else if (op2 && !is_gimple_min_invariant (op2))
-	      break;
-	    changed |= op2 != oldop2;
-
 	    if (!newoperands)
 	      newoperands = VEC_copy (vn_reference_op_s, heap, operands);
 	    /* We may have changed from an SSA_NAME to a constant */
-	    if (newop.opcode == SSA_NAME && TREE_CODE (op0) != SSA_NAME)
-	      newop.opcode = TREE_CODE (op0);
+	    if (newop.opcode == SSA_NAME && TREE_CODE (op[0]) != SSA_NAME)
+	      newop.opcode = TREE_CODE (op[0]);
 	    newop.type = type;
-	    newop.op0 = op0;
-	    newop.op1 = op1;
-	    newop.op2 = op2;
+	    newop.op0 = op[0];
+	    newop.op1 = op[1];
+	    newop.op2 = op[2];
 	    /* If it transforms a non-constant ARRAY_REF into a constant
 	       one, adjust the constant offset.  */
 	    if (newop.opcode == ARRAY_REF
 		&& newop.off == -1
-		&& TREE_CODE (op0) == INTEGER_CST
-		&& TREE_CODE (op1) == INTEGER_CST
-		&& TREE_CODE (op2) == INTEGER_CST)
+		&& TREE_CODE (op[0]) == INTEGER_CST
+		&& TREE_CODE (op[1]) == INTEGER_CST
+		&& TREE_CODE (op[2]) == INTEGER_CST)
 	      {
-		double_int off = tree_to_double_int (op0);
+		double_int off = tree_to_double_int (op[0]);
 		off = double_int_add (off,
 				      double_int_neg
-				        (tree_to_double_int (op1)));
-		off = double_int_mul (off, tree_to_double_int (op2));
+				        (tree_to_double_int (op[1])));
+		off = double_int_mul (off, tree_to_double_int (op[2]));
 		if (double_int_fits_in_shwi_p (off))
 		  newop.off = off.low;
 	      }
 	    VEC_replace (vn_reference_op_s, newoperands, j, &newop);
 	    /* If it transforms from an SSA_NAME to an address, fold with
 	       a preceding indirect reference.  */
-	    if (j > 0 && op0 && TREE_CODE (op0) == ADDR_EXPR
+	    if (j > 0 && op[0] && TREE_CODE (op[0]) == ADDR_EXPR
 		&& VEC_index (vn_reference_op_s,
 			      newoperands, j - 1)->opcode == MEM_REF)
 	      vn_reference_fold_indirect (&newoperands, &j);
Index: gcc/cfgcleanup.c
===================================================================
--- gcc/cfgcleanup.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/cfgcleanup.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1969,7 +1969,14 @@
 
   cond = get_condition (jump, &move_before, true, false);
   if (cond == NULL_RTX)
-    move_before = jump;
+    {
+#ifdef HAVE_cc0
+      if (reg_mentioned_p (cc0_rtx, jump))
+	move_before = prev_nonnote_nondebug_insn (jump);
+      else
+#endif
+	move_before = jump;
+    }
 
   for (ix = 0; ix < nedges; ix++)
     if (EDGE_SUCC (bb, ix)->dest == EXIT_BLOCK_PTR)
@@ -2131,7 +2138,14 @@
       jump = BB_END (final_dest_bb);
       cond = get_condition (jump, &move_before, true, false);
       if (cond == NULL_RTX)
-	move_before = jump;
+	{
+#ifdef HAVE_cc0
+	  if (reg_mentioned_p (cc0_rtx, jump))
+	    move_before = prev_nonnote_nondebug_insn (jump);
+	  else
+#endif
+	    move_before = jump;
+	}
     }
 
   do
Index: gcc/simplify-rtx.c
===================================================================
--- gcc/simplify-rtx.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/simplify-rtx.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -2777,7 +2777,7 @@
 		}
 	    }
 	}
-      else
+      else if (SCALAR_INT_MODE_P (mode))
 	{
 	  /* 0/x is 0 (or x&0 if x has side-effects).  */
 	  if (trueop0 == CONST0_RTX (mode)
@@ -4177,10 +4177,20 @@
     {
       rtx x = XEXP (op0, 0);
       rtx c = XEXP (op0, 1);
+      enum rtx_code invcode = op0code == PLUS ? MINUS : PLUS;
+      rtx tem = simplify_gen_binary (invcode, cmp_mode, op1, c);
 
-      c = simplify_gen_binary (op0code == PLUS ? MINUS : PLUS,
-			       cmp_mode, op1, c);
-      return simplify_gen_relational (code, mode, cmp_mode, x, c);
+      /* Detect an infinite recursive condition, where we oscillate at this
+	 simplification case between:
+	    A + B == C  <--->  C - B == A,
+	 where A, B, and C are all constants with non-simplifiable expressions,
+	 usually SYMBOL_REFs.  */
+      if (GET_CODE (tem) == invcode
+	  && CONSTANT_P (x)
+	  && rtx_equal_p (c, XEXP (tem, 1)))
+	return NULL_RTX;
+
+      return simplify_gen_relational (code, mode, cmp_mode, x, tem);
     }
 
   /* (ne:SI (zero_extract:SI FOO (const_int 1) BAR) (const_int 0))) is
Index: gcc/tree-sra.c
===================================================================
--- gcc/tree-sra.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/tree-sra.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1020,31 +1020,52 @@
   return false;
 }
 
-/* Return true iff type of EXP is not sufficiently aligned.  */
+/* Return true if EXP is a memory reference less aligned than ALIGN.  This is
+   invoked only on strict-alignment targets.  */
 
 static bool
-tree_non_mode_aligned_mem_p (tree exp)
+tree_non_aligned_mem_p (tree exp, unsigned int align)
 {
-  enum machine_mode mode = TYPE_MODE (TREE_TYPE (exp));
-  unsigned int align;
+  unsigned int exp_align;
 
   if (TREE_CODE (exp) == VIEW_CONVERT_EXPR)
     exp = TREE_OPERAND (exp, 0);
 
-  if (TREE_CODE (exp) == SSA_NAME
-      || TREE_CODE (exp) == MEM_REF
-      || mode == BLKmode
-      || is_gimple_min_invariant (exp)
-      || !STRICT_ALIGNMENT)
+  if (TREE_CODE (exp) == SSA_NAME || is_gimple_min_invariant (exp))
     return false;
 
-  align = get_object_alignment (exp, BIGGEST_ALIGNMENT);
-  if (GET_MODE_ALIGNMENT (mode) > align)
+  /* get_object_alignment will fall back to BITS_PER_UNIT if it cannot
+     compute an explicit alignment.  Pretend that dereferenced pointers
+     are always aligned on strict-alignment targets.  */
+  exp_align = get_object_alignment (exp, BIGGEST_ALIGNMENT);
+  if (TREE_CODE (exp) == MEM_REF || TREE_CODE (exp) == TARGET_MEM_REF)
+    exp_align = MAX (TYPE_ALIGN (TREE_TYPE (exp)), exp_align);
+
+  if (exp_align < align)
     return true;
 
   return false;
 }
 
+/* Return true if EXP is a memory reference less aligned than what the access
+   ACC would require.  This is invoked only on strict-alignment targets.  */
+
+static bool
+tree_non_aligned_mem_for_access_p (tree exp, struct access *acc)
+{
+  unsigned int acc_align;
+
+  /* The alignment of the access is that of its expression.  However, it may
+     have been artificially increased, e.g. by a local alignment promotion,
+     so we cap it to the alignment of the type of the base, on the grounds
+     that valid sub-accesses cannot be more aligned than that.  */
+  acc_align = get_object_alignment (acc->expr, BIGGEST_ALIGNMENT);
+  if (acc->base && acc_align > TYPE_ALIGN (TREE_TYPE (acc->base)))
+    acc_align = TYPE_ALIGN (TREE_TYPE (acc->base));
+
+  return tree_non_aligned_mem_p (exp, acc_align);
+}
+
 /* Scan expressions occuring in STMT, create access structures for all accesses
    to candidates for scalarization and remove those candidates which occur in
    statements or expressions that prevent them from being split apart.  Return
@@ -1071,7 +1092,8 @@
   if (lacc)
     {
       lacc->grp_assignment_write = 1;
-      lacc->grp_unscalarizable_region |= tree_non_mode_aligned_mem_p (rhs);
+      if (STRICT_ALIGNMENT && tree_non_aligned_mem_for_access_p (rhs, lacc))
+        lacc->grp_unscalarizable_region = 1;
     }
 
   if (racc)
@@ -1080,7 +1102,8 @@
       if (should_scalarize_away_bitmap && !gimple_has_volatile_ops (stmt)
 	  && !is_gimple_reg_type (racc->type))
 	bitmap_set_bit (should_scalarize_away_bitmap, DECL_UID (racc->base));
-      racc->grp_unscalarizable_region |= tree_non_mode_aligned_mem_p (lhs);
+      if (STRICT_ALIGNMENT && tree_non_aligned_mem_for_access_p (lhs, racc))
+        racc->grp_unscalarizable_region = 1;
     }
 
   if (lacc && racc
@@ -1435,29 +1458,67 @@
   return fold_build2_loc (loc, MEM_REF, exp_type, base, off);
 }
 
+DEF_VEC_ALLOC_P_STACK (tree);
+#define VEC_tree_stack_alloc(alloc) VEC_stack_alloc (tree, alloc)
+
 /* Construct a memory reference to a part of an aggregate BASE at the given
-   OFFSET and of the same type as MODEL.  In case this is a reference to a
-   component, the function will replicate the last COMPONENT_REF of model's
-   expr to access it.  GSI and INSERT_AFTER have the same meaning as in
-   build_ref_for_offset.  */
+   OFFSET and of the type of MODEL.  In case this is a chain of references
+   to component, the function will replicate the chain of COMPONENT_REFs of
+   the expression of MODEL to access it.  GSI and INSERT_AFTER have the same
+   meaning as in build_ref_for_offset.  */
 
 static tree
 build_ref_for_model (location_t loc, tree base, HOST_WIDE_INT offset,
 		     struct access *model, gimple_stmt_iterator *gsi,
 		     bool insert_after)
 {
+  tree type = model->type, t;
+  VEC(tree,stack) *cr_stack = NULL;
+
   if (TREE_CODE (model->expr) == COMPONENT_REF)
     {
-      tree t, exp_type, fld = TREE_OPERAND (model->expr, 1);
-      offset -= int_bit_position (fld);
-      exp_type = TREE_TYPE (TREE_OPERAND (model->expr, 0));
-      t = build_ref_for_offset (loc, base, offset, exp_type, gsi, insert_after);
-      return fold_build3_loc (loc, COMPONENT_REF, TREE_TYPE (fld), t, fld,
-			      NULL_TREE);
+      tree expr = model->expr;
+
+      /* Create a stack of the COMPONENT_REFs so later we can walk them in
+	 order from inner to outer.  */
+      cr_stack = VEC_alloc (tree, stack, 6);
+
+      do {
+	tree field = TREE_OPERAND (expr, 1);
+	HOST_WIDE_INT bit_pos = int_bit_position (field);
+
+	/* We can be called with a model different from the one associated
+	   with BASE so we need to avoid going up the chain too far.  */
+	if (offset - bit_pos < 0)
+	  break;
+
+	offset -= bit_pos;
+	VEC_safe_push (tree, stack, cr_stack, expr);
+
+	expr = TREE_OPERAND (expr, 0);
+	type = TREE_TYPE (expr);
+      } while (TREE_CODE (expr) == COMPONENT_REF);
     }
-  else
-    return build_ref_for_offset (loc, base, offset, model->type,
-				 gsi, insert_after);
+
+  t = build_ref_for_offset (loc, base, offset, type, gsi, insert_after);
+
+  if (TREE_CODE (model->expr) == COMPONENT_REF)
+    {
+      unsigned i;
+      tree expr;
+
+      /* Now replicate the chain of COMPONENT_REFs from inner to outer.  */
+      FOR_EACH_VEC_ELT_REVERSE (tree, cr_stack, i, expr)
+	{
+	  tree field = TREE_OPERAND (expr, 1);
+	  t = fold_build3_loc (loc, COMPONENT_REF, TREE_TYPE (field), t, field,
+			       NULL_TREE);
+	}
+
+      VEC_free (tree, stack, cr_stack);
+    }
+
+  return t;
 }
 
 /* Construct a memory reference consisting of component_refs and array_refs to
@@ -2594,6 +2655,10 @@
 	      rhs = get_access_replacement (racc);
 	      if (!useless_type_conversion_p (lacc->type, racc->type))
 		rhs = fold_build1_loc (loc, VIEW_CONVERT_EXPR, lacc->type, rhs);
+
+	      if (racc->grp_partial_lhs && lacc->grp_partial_lhs)
+		rhs = force_gimple_operand_gsi (old_gsi, rhs, true, NULL_TREE,
+						true, GSI_SAME_STMT);
 	    }
 	  else
 	    {
@@ -2609,6 +2674,9 @@
 	      else
 		rhs = build_ref_for_model (loc, top_racc->base, offset, lacc,
 					    new_gsi, true);
+	      if (lacc->grp_partial_lhs)
+		rhs = force_gimple_operand_gsi (new_gsi, rhs, true, NULL_TREE,
+						false, GSI_NEW_STMT);
 	    }
 
 	  stmt = gimple_build_assign (get_access_replacement (lacc), rhs);
@@ -3604,7 +3672,8 @@
 	  || gimple_code (access->stmt) == GIMPLE_ASM))
     return true;
 
-  if (tree_non_mode_aligned_mem_p (access->expr))
+  if (STRICT_ALIGNMENT
+      && tree_non_aligned_mem_p (access->expr, TYPE_ALIGN (access->type)))
     return true;
 
   return false;
Index: gcc/lto/lto.c
===================================================================
--- gcc/lto/lto.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/lto/lto.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -198,7 +198,7 @@
   uint32_t ix;
   tree decl;
   uint32_t i, j;
-  
+
   ix = *data++;
   decl = lto_streamer_cache_get (data_in->reader_cache, (int) ix);
   if (TREE_CODE (decl) != FUNCTION_DECL)
@@ -241,9 +241,9 @@
 		VEC(ld_plugin_symbol_resolution_t,heap) *resolutions)
 {
   const struct lto_decl_header *header = (const struct lto_decl_header *) data;
-  const int32_t decl_offset = sizeof (struct lto_decl_header);
-  const int32_t main_offset = decl_offset + header->decl_state_size;
-  const int32_t string_offset = main_offset + header->main_size;
+  const int decl_offset = sizeof (struct lto_decl_header);
+  const int main_offset = decl_offset + header->decl_state_size;
+  const int string_offset = main_offset + header->main_size;
   struct lto_input_block ib_main;
   struct data_in *data_in;
   unsigned int i;
@@ -291,17 +291,20 @@
 
   if (data_ptr != data_end)
     internal_error ("bytecode stream: garbage at the end of symbols section");
-  
+
   /* Set the current decl state to be the global state. */
   decl_data->current_decl_state = decl_data->global_decl_state;
 
   lto_data_in_delete (data_in);
 }
 
-/* strtoll is not portable. */
-int64_t
-lto_parse_hex (const char *p) {
-  uint64_t ret = 0;
+/* Custom version of strtoll, which is not portable.  */
+
+static HOST_WIDEST_INT
+lto_parse_hex (const char *p)
+{
+  HOST_WIDEST_INT ret = 0;
+
   for (; *p != '\0'; ++p)
     {
       char c = *p;
@@ -317,6 +320,7 @@
         internal_error ("could not parse hex number");
       ret |= part;
     }
+
   return ret;
 }
 
@@ -352,7 +356,7 @@
     {
       int t;
       char offset_p[17];
-      int64_t offset;
+      HOST_WIDEST_INT offset;
       t = fscanf (resolution, "@0x%16s", offset_p);
       if (t != 1)
         internal_error ("could not parse file offset");
Index: gcc/lto/lto.h
===================================================================
--- gcc/lto/lto.h	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/lto/lto.h	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -60,6 +60,4 @@
   size_t len;
 };
 
-int64_t lto_parse_hex (const char *p);
-
 #endif /* LTO_H */
Index: gcc/lto/ChangeLog
===================================================================
--- gcc/lto/ChangeLog	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/lto/ChangeLog	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1,3 +1,10 @@
+2011-12-13  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* lto.h (lto_parse_hex): Delete.
+	* lto.c (lto_read_decls): Use 'int' for offsets.
+	(lto_parse_hex): Make static and return proper 64-bit host type.
+	(lto_resolution_read): Use proper 64-bit host type.
+
 2011-10-26  Release Manager
 
 	* GCC 4.6.2 released.
Index: gcc/ipa-prop.c
===================================================================
--- gcc/ipa-prop.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/ipa-prop.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -2868,9 +2868,9 @@
 {
   const struct lto_function_header *header =
     (const struct lto_function_header *) data;
-  const int32_t cfg_offset = sizeof (struct lto_function_header);
-  const int32_t main_offset = cfg_offset + header->cfg_size;
-  const int32_t string_offset = main_offset + header->main_size;
+  const int cfg_offset = sizeof (struct lto_function_header);
+  const int main_offset = cfg_offset + header->cfg_size;
+  const int string_offset = main_offset + header->main_size;
   struct data_in *data_in;
   struct lto_input_block ib_main;
   unsigned int i;
Index: gcc/po/ChangeLog
===================================================================
--- gcc/po/ChangeLog	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/po/ChangeLog	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1,3 +1,7 @@
+2011-10-30  Joseph Myers  <joseph@codesourcery.com>
+
+	* ja.po: Update.
+
 2011-10-26  Release Manager
 
 	* GCC 4.6.2 released.
Index: gcc/po/ja.po
===================================================================
--- gcc/po/ja.po	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/po/ja.po	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -20,7 +20,7 @@
 "Project-Id-Version: gcc 4.6.1\n"
 "Report-Msgid-Bugs-To: http://gcc.gnu.org/bugs.html\n"
 "POT-Creation-Date: 2011-06-21 10:27+0000\n"
-"PO-Revision-Date: 2011-10-25 22:36+0900\n"
+"PO-Revision-Date: 2011-10-30 18:48+0900\n"
 "Last-Translator: Yasuaki Taniguchi <yasuakit@gmail.com>\n"
 "Language-Team: Japanese <translation-team-ja@lists.sourceforge.net>\n"
 "Language: ja\n"
@@ -834,12 +834,12 @@
 #: gcov.c:420
 #, c-format
 msgid "  -a, --all-blocks                Show information for every basic block\n"
-msgstr ""
+msgstr "  -a, --all-blocks                \n"
 
 #: gcov.c:421
 #, c-format
 msgid "  -b, --branch-probabilities      Include branch probabilities in output\n"
-msgstr ""
+msgstr "  -b, --branch-probabilities      \n"
 
 #: gcov.c:422
 #, c-format
@@ -847,6 +847,8 @@
 "  -c, --branch-counts             Given counts of branches taken\n"
 "                                    rather than percentages\n"
 msgstr ""
+"  -c, --branch-counts             \n"
+"                                    \n"
 
 #: gcov.c:424
 #, c-format
@@ -859,21 +861,23 @@
 "  -l, --long-file-names           Use long output file names for included\n"
 "                                    source files\n"
 msgstr ""
+"  -l, --long-file-names           \n"
+"                                    \n"
 
 #: gcov.c:427
 #, c-format
 msgid "  -f, --function-summaries        Output summaries for each function\n"
-msgstr ""
+msgstr "  -f, --function-summaries        \n"
 
 #: gcov.c:428
 #, c-format
 msgid "  -o, --object-directory DIR|FILE Search for object files in DIR or called FILE\n"
-msgstr ""
+msgstr "  -o, --object-directory DIR|FILE  DIR  FILE \n"
 
 #: gcov.c:429
 #, c-format
 msgid "  -p, --preserve-paths            Preserve all pathname components\n"
-msgstr ""
+msgstr "  -p, --preserve-paths            \n"
 
 #: gcov.c:430
 #, c-format
@@ -977,7 +981,7 @@
 #: gcov.c:1045
 #, c-format
 msgid "%s:cannot open data file, assuming not executed\n"
-msgstr ""
+msgstr "%s:\n"
 
 #: gcov.c:1052
 #, c-format
@@ -1027,7 +1031,7 @@
 #: gcov.c:1379
 #, c-format
 msgid "%s:graph is unsolvable for '%s'\n"
-msgstr ""
+msgstr "%s: '%s' \n"
 
 #: gcov.c:1459
 #, c-format
@@ -1037,7 +1041,7 @@
 #: gcov.c:1462
 #, c-format
 msgid "Lines executed:%s of %d\n"
-msgstr ""
+msgstr ":%s of %d\n"
 
 #: gcov.c:1466
 #, c-format
@@ -1047,7 +1051,7 @@
 #: gcov.c:1472
 #, c-format
 msgid "Branches executed:%s of %d\n"
-msgstr ""
+msgstr ":%s of %d\n"
 
 #: gcov.c:1476
 #, c-format
@@ -1057,12 +1061,12 @@
 #: gcov.c:1482
 #, c-format
 msgid "No branches\n"
-msgstr ""
+msgstr "\n"
 
 #: gcov.c:1484
 #, c-format
 msgid "Calls executed:%s of %d\n"
-msgstr ""
+msgstr ":%s of %d\n"
 
 #: gcov.c:1488
 #, c-format
@@ -1075,24 +1079,24 @@
 msgstr "%s: '%s' \n"
 
 #: gcov.c:1843
-#, fuzzy, c-format
+#, c-format
 msgid "call   %2d returned %s\n"
-msgstr " %d  = %d\n"
+msgstr ""
 
 #: gcov.c:1848
-#, fuzzy, c-format
+#, c-format
 msgid "call   %2d never executed\n"
-msgstr " %d \n"
+msgstr ""
 
 #: gcov.c:1853
-#, fuzzy, c-format
+#, c-format
 msgid "branch %2d taken %s%s\n"
-msgstr " %d  = %d%%\n"
+msgstr ""
 
 #: gcov.c:1857
-#, fuzzy, c-format
+#, c-format
 msgid "branch %2d never executed\n"
-msgstr " %d \n"
+msgstr ""
 
 #: gcov.c:1862
 #, c-format
@@ -1100,9 +1104,9 @@
 msgstr ""
 
 #: gcov.c:1865
-#, fuzzy, c-format
+#, c-format
 msgid "unconditional %2d never executed\n"
-msgstr " %d \n"
+msgstr ""
 
 #: gcov.c:1901
 #, c-format
@@ -1412,11 +1416,11 @@
 
 #: opts.c:1183
 msgid "The following options take separate arguments"
-msgstr ""
+msgstr ""
 
 #: opts.c:1185
 msgid "The following options take joined arguments"
-msgstr ""
+msgstr ""
 
 #: opts.c:1196
 msgid "The following options are language-related"
@@ -1472,7 +1476,7 @@
 #: targhooks.c:1469
 #, c-format
 msgid "created and used with differing settings of '%s'"
-msgstr ""
+msgstr " '%s' "
 
 #: targhooks.c:1471
 msgid "out of memory"
@@ -1480,11 +1484,11 @@
 
 #: targhooks.c:1486
 msgid "created and used with different settings of -fpic"
-msgstr ""
+msgstr " -fpic "
 
 #: targhooks.c:1488
 msgid "created and used with different settings of -fpie"
-msgstr ""
+msgstr " -fpie "
 
 #: tlink.c:386
 #, c-format
@@ -1717,11 +1721,11 @@
 
 #: params.def:100
 msgid "The maximum depth of recursive inlining for inline functions"
-msgstr ""
+msgstr ""
 
 #: params.def:105
 msgid "The maximum depth of recursive inlining for non-inline functions"
-msgstr ""
+msgstr ""
 
 #: params.def:110
 msgid "Inline recursively only when the probability of call being executed exceeds the parameter"
@@ -1761,16 +1765,15 @@
 
 #: params.def:180
 msgid "The size of function body to be considered large"
-msgstr ""
+msgstr ""
 
 #: params.def:184
 msgid "Maximal growth due to inlining of large function (in percent)"
 msgstr ""
 
 #: params.def:188
-#, fuzzy
 msgid "The size of translation unit to be considered large"
-msgstr ""
+msgstr ""
 
 #: params.def:192
 msgid "How much can given compilation unit grow because of the inlining (in percent)"
@@ -1786,20 +1789,19 @@
 
 #: params.def:204
 msgid "The size of stack frame to be considered large"
-msgstr ""
+msgstr ""
 
 #: params.def:208
 msgid "Maximal stack frame growth due to inlining (in percent)"
-msgstr ""
+msgstr " ()"
 
 #: params.def:215
 msgid "The maximum amount of memory to be allocated by GCSE"
-msgstr ""
+msgstr "GCSE "
 
 #: params.def:222
-#, fuzzy
 msgid "The maximum ratio of insertions to deletions of expressions in GCSE"
-msgstr "RPTS "
+msgstr ""
 
 #: params.def:233
 msgid "The threshold ratio for performing partial redundancy elimination after reload"
@@ -1963,9 +1965,8 @@
 msgstr ""
 
 #: params.def:470
-#, fuzzy
 msgid "Bound on number of iv uses in loop optimized in iv optimizations"
-msgstr ""
+msgstr ""
 
 #: params.def:478
 msgid "If number of candidates in the set is smaller, we always try to remove unused ivs during its optimization"
@@ -2044,9 +2045,8 @@
 msgstr ""
 
 #: params.def:594
-#, fuzzy
 msgid "The maximum number of iterations through CFG to extend regions"
-msgstr "RPTS "
+msgstr ""
 
 #: params.def:599
 msgid "The maximum conflict delay for an insn to be considered for speculative motion"
@@ -2077,9 +2077,8 @@
 msgstr ""
 
 #: params.def:637
-#, fuzzy
 msgid "The upper bound for sharing integer constants"
-msgstr "`%s' "
+msgstr ""
 
 #: params.def:656
 msgid "Minimum number of virtual mappings to consider switching to full virtual renames"
@@ -2111,11 +2110,11 @@
 
 #: params.def:714
 msgid "The number of insns executed before prefetch is completed"
-msgstr ""
+msgstr ""
 
 #: params.def:721
 msgid "The number of prefetches that can run at the same time"
-msgstr ""
+msgstr ""
 
 #: params.def:728
 msgid "The size of L1 cache"
@@ -2162,9 +2161,8 @@
 msgstr ""
 
 #: params.def:806
-#, fuzzy
 msgid "maximum number of parameters in a SCoP"
-msgstr "RPTS "
+msgstr "SCoP "
 
 #: params.def:813
 msgid "maximum number of basic blocks per function to be analyzed by Graphite"
@@ -2597,9 +2595,9 @@
 msgstr " %%E "
 
 #: config/alpha/alpha.c:5431 config/alpha/alpha.c:5479
-#, fuzzy, c-format
+#, c-format
 msgid "unknown relocation unspec"
-msgstr ""
+msgstr ""
 
 #: config/alpha/alpha.c:5440 config/crx/crx.c:1119
 #: config/rs6000/rs6000.c:16490 config/spu/spu.c:1726
@@ -3000,32 +2998,32 @@
 #: config/i386/i386.c:14106 config/i386/i386.c:14146
 #, c-format
 msgid "operand is not a condition code, invalid operand code 'D'"
-msgstr ""
+msgstr " 'D' "
 
 #: config/i386/i386.c:14172
 #, c-format
 msgid "operand is neither a constant nor a condition code, invalid operand code 'C'"
-msgstr ""
+msgstr " 'C' "
 
 #: config/i386/i386.c:14182
 #, c-format
 msgid "operand is neither a constant nor a condition code, invalid operand code 'F'"
-msgstr ""
+msgstr " 'F' "
 
 #: config/i386/i386.c:14200
 #, c-format
 msgid "operand is neither a constant nor a condition code, invalid operand code 'c'"
-msgstr ""
+msgstr " 'c' "
 
 #: config/i386/i386.c:14210
 #, c-format
 msgid "operand is neither a constant nor a condition code, invalid operand code 'f'"
-msgstr ""
+msgstr " 'f' "
 
 #: config/i386/i386.c:14313
 #, c-format
 msgid "operand is not a condition code, invalid operand code 'Y'"
-msgstr ""
+msgstr " 'Y' "
 
 #: config/i386/i386.c:14339
 #, c-format
@@ -3098,7 +3096,7 @@
 #: config/lm32/lm32.c:529
 #, c-format
 msgid "only 0.0 can be loaded as an immediate"
-msgstr ""
+msgstr " 0.0 "
 
 #: config/lm32/lm32.c:599
 msgid "bad operand"
@@ -3138,15 +3136,15 @@
 
 #: config/m32r/m32r.c:2290
 msgid "pre-increment address is not a register"
-msgstr ""
+msgstr ""
 
 #: config/m32r/m32r.c:2297
 msgid "pre-decrement address is not a register"
-msgstr ""
+msgstr ""
 
 #: config/m32r/m32r.c:2304
 msgid "post-increment address is not a register"
-msgstr ""
+msgstr ""
 
 #: config/m32r/m32r.c:2380 config/m32r/m32r.c:2394
 #: config/rs6000/rs6000.c:25500
@@ -3252,7 +3250,7 @@
 
 #: config/mmix/mmix.c:1589 config/mmix/mmix.c:1719
 msgid "MMIX Internal: Expected a CONST_INT, not this"
-msgstr ""
+msgstr "MMIX : CONST_INT "
 
 #: config/mmix/mmix.c:1668
 msgid "MMIX Internal: Bad value for 'm', not a CONST_INT"
@@ -3260,11 +3258,11 @@
 
 #: config/mmix/mmix.c:1687
 msgid "MMIX Internal: Expected a register, not this"
-msgstr ""
+msgstr "MMIX : "
 
 #: config/mmix/mmix.c:1697
 msgid "MMIX Internal: Expected a constant, not this"
-msgstr ""
+msgstr "MMIX : "
 
 #. We need the original here.
 #: config/mmix/mmix.c:1781
@@ -3301,7 +3299,7 @@
 
 #: config/picochip/picochip.c:2983 config/picochip/picochip.c:3015
 msgid "Bad address, not (reg+disp):"
-msgstr ""
+msgstr " (reg+disp) :"
 
 #: config/picochip/picochip.c:3029
 msgid "Bad address, not register:"
@@ -3526,15 +3524,15 @@
 
 #: config/sh/sh.c:9271
 msgid "created and used with different architectures / ABIs"
-msgstr ""
+msgstr " /ABI "
 
 #: config/sh/sh.c:9273
 msgid "created and used with different ABIs"
-msgstr ""
+msgstr " ABI "
 
 #: config/sh/sh.c:9275
 msgid "created and used with different endianness"
-msgstr ""
+msgstr ""
 
 #: config/sparc/sparc.c:7445 config/sparc/sparc.c:7451
 #, c-format
@@ -3617,7 +3615,7 @@
 #: config/vax/vax.c:427
 #, c-format
 msgid "symbol with offset used in PIC mode"
-msgstr ""
+msgstr "PIC "
 
 #: config/vax/vax.c:513
 #, c-format
@@ -3837,19 +3835,19 @@
 msgstr "%s:%d:%d:   "
 
 #: cp/error.c:2913
-#, fuzzy, c-format
+#, c-format
 msgid "%s:%d:%d:   instantiated from here"
 msgstr "%s:%d:%d:   "
 
 #: cp/error.c:2918
 #, c-format
 msgid "%s:%d:   recursively instantiated from here"
-msgstr ""
+msgstr "%s:%d:   "
 
 #: cp/error.c:2919
-#, fuzzy, c-format
+#, c-format
 msgid "%s:%d:   instantiated from here"
-msgstr "%s:%d:   \n"
+msgstr "%s:%d:   "
 
 #: cp/error.c:2962
 #, c-format
@@ -4029,22 +4027,21 @@
 #: fortran/expr.c:607
 #, c-format
 msgid "Constant expression required at %C"
-msgstr ""
+msgstr "%C "
 
 #: fortran/expr.c:610
 #, c-format
 msgid "Integer expression required at %C"
-msgstr ""
+msgstr "%C "
 
 #: fortran/expr.c:615
-#, fuzzy, c-format
+#, c-format
 msgid "Integer value too large in expression at %C"
-msgstr ""
+msgstr "%C "
 
 #: fortran/expr.c:3147
-#, fuzzy
 msgid "array assignment"
-msgstr ""
+msgstr ""
 
 #: fortran/gfortranspec.c:303
 #, c-format
@@ -4080,7 +4077,7 @@
 
 #: fortran/io.c:551
 msgid "Unexpected element '%c' in format string at %L"
-msgstr ""
+msgstr " '%c'  ( %L) "
 
 #: fortran/io.c:553
 msgid "Unexpected end of format string"
@@ -4088,15 +4085,15 @@
 
 #: fortran/io.c:554
 msgid "Zero width in format descriptor"
-msgstr ""
+msgstr " 0 "
 
 #: fortran/io.c:574
 msgid "Missing leading left parenthesis"
-msgstr ""
+msgstr ""
 
 #: fortran/io.c:603
 msgid "Left parenthesis required after '*'"
-msgstr ""
+msgstr "'*' "
 
 #: fortran/io.c:634
 msgid "Expected P edit descriptor"
@@ -4116,9 +4113,8 @@
 msgstr ""
 
 #: fortran/io.c:844
-#, fuzzy
 msgid "E specifier not allowed with g0 descriptor"
-msgstr " `%s'  struct  class "
+msgstr ""
 
 #: fortran/io.c:914
 msgid "Positive exponent width required"
@@ -4362,9 +4358,8 @@
 msgstr ""
 
 #: fortran/resolve.c:6233
-#, fuzzy
 msgid "End expression in DO loop"
-msgstr ""
+msgstr ""
 
 #: fortran/resolve.c:6237
 msgid "Step expression in DO loop"
@@ -4564,7 +4559,7 @@
 #: java/jcf-dump.c:1148
 #, c-format
 msgid "  --extdirs PATH          Set extensions directory path\n"
-msgstr ""
+msgstr "  --extdirs PATH          \n"
 
 #: java/jcf-dump.c:1149
 #, c-format
@@ -4734,18 +4729,18 @@
 #: config/pa/pa-hpux11.h:111 config/pa/pa64-hpux.h:30 config/pa/pa64-hpux.h:33
 #: config/pa/pa64-hpux.h:42 config/pa/pa64-hpux.h:45
 msgid "warning: consider linking with '-static' as system libraries with"
-msgstr ""
+msgstr ":  '-static' "
 
 #: config/pa/pa-hpux10.h:90 config/pa/pa-hpux10.h:93 config/pa/pa-hpux10.h:101
 #: config/pa/pa-hpux10.h:104 config/pa/pa-hpux11.h:109
 #: config/pa/pa-hpux11.h:112 config/pa/pa64-hpux.h:31 config/pa/pa64-hpux.h:34
 #: config/pa/pa64-hpux.h:43 config/pa/pa64-hpux.h:46
 msgid "  profiling support are only provided in archive format"
-msgstr ""
+msgstr "  "
 
 #: config/rs6000/darwin.h:99
 msgid " conflicting code gen style switches are used"
-msgstr ""
+msgstr " "
 
 #: config/arm/arm.h:178
 msgid "-msoft-float and -mhard_float may not be used together"
@@ -4805,7 +4800,7 @@
 
 #: config/i386/linux-unwind.h:186
 msgid "ax ; {int $0x80 | syscall"
-msgstr ""
+msgstr "ax ; {int $0x80 | syscall"
 
 #: config/s390/tpf.h:120
 msgid "static is not supported on TPF-OS"
@@ -4869,7 +4864,7 @@
 
 #: java/lang.opt:206
 msgid "--extdirs=<path>\tSet the extension directory path"
-msgstr ""
+msgstr "--extdirs=<path>\t"
 
 #: java/lang.opt:216
 msgid "Input file is a file with a list of filenames to compile"
@@ -5388,7 +5383,7 @@
 
 #: config/frv/frv.opt:31
 msgid "Enable label alignment optimizations"
-msgstr ""
+msgstr ""
 
 #: config/frv/frv.opt:35
 msgid "Dynamically allocate cc registers"
@@ -5452,7 +5447,7 @@
 
 #: config/frv/frv.opt:116
 msgid "Enable use of GPREL for read-only data in FDPIC"
-msgstr ""
+msgstr "FDPIC  GPREL "
 
 #: config/frv/frv.opt:120 config/rs6000/rs6000.opt:216
 #: config/pdp11/pdp11.opt:67
@@ -5460,9 +5455,8 @@
 msgstr ""
 
 #: config/frv/frv.opt:124 config/bfin/bfin.opt:77
-#, fuzzy
 msgid "Enable inlining of PLT in function calls"
-msgstr ""
+msgstr " PLT "
 
 #: config/frv/frv.opt:128
 msgid "Enable PIC support for building libraries"
@@ -5478,7 +5472,7 @@
 
 #: config/frv/frv.opt:140
 msgid "Use media instructions"
-msgstr ""
+msgstr "media "
 
 #: config/frv/frv.opt:144
 msgid "Use multiply add/subtract instructions"
@@ -5494,7 +5488,7 @@
 
 #: config/frv/frv.opt:157
 msgid "Do not mark ABI switches in e_flags"
-msgstr ""
+msgstr "e_flags  ABI "
 
 #: config/frv/frv.opt:161
 msgid "Remove redundant membars"
@@ -5506,7 +5500,7 @@
 
 #: config/frv/frv.opt:169
 msgid "Enable setting GPRs to the result of comparisons"
-msgstr ""
+msgstr ""
 
 #: config/frv/frv.opt:173
 msgid "Change the amount of scheduler lookahead"
@@ -5565,9 +5559,8 @@
 msgstr ""
 
 #: config/mn10300/mn10300.opt:56
-#, fuzzy
 msgid "Allow gcc to generate LIW instructions"
-msgstr "gcc  repeat/erepeat "
+msgstr "gcc  LIW "
 
 #: config/s390/tpf.opt:23
 msgid "Enable TPF-OS tracing code"
@@ -5640,11 +5633,11 @@
 
 #: config/s390/s390.opt:91
 msgid "Warn if a function uses alloca or creates an array with dynamic size"
-msgstr ""
+msgstr " alloca "
 
 #: config/s390/s390.opt:95
 msgid "Warn if a single function's framesize exceeds the given framesize"
-msgstr ""
+msgstr ""
 
 #: config/s390/s390.opt:99
 msgid "z/Architecture"
@@ -5692,7 +5685,7 @@
 
 #: config/ia64/ia64.opt:56
 msgid "gp is constant (but save/restore gp on indirect calls)"
-msgstr "gp  gp  save/restore "
+msgstr "gp  gp  save/restore "
 
 #: config/ia64/ia64.opt:60
 msgid "Generate self-relocatable code"
@@ -5741,39 +5734,39 @@
 #: config/ia64/ia64.opt:107 config/spu/spu.opt:72 config/sh/sh.opt:258
 #: config/pa/pa.opt:51
 msgid "Specify range of registers to make fixed"
-msgstr ""
+msgstr ""
 
 #: config/ia64/ia64.opt:119
 msgid "Use data speculation before reload"
-msgstr ""
+msgstr "reload "
 
 #: config/ia64/ia64.opt:123
 msgid "Use data speculation after reload"
-msgstr ""
+msgstr "reload "
 
 #: config/ia64/ia64.opt:127
 msgid "Use control speculation"
-msgstr ""
+msgstr ""
 
 #: config/ia64/ia64.opt:131
 msgid "Use in block data speculation before reload"
-msgstr ""
+msgstr "reload "
 
 #: config/ia64/ia64.opt:135
 msgid "Use in block data speculation after reload"
-msgstr ""
+msgstr "reload "
 
 #: config/ia64/ia64.opt:139
 msgid "Use in block control speculation"
-msgstr ""
+msgstr ""
 
 #: config/ia64/ia64.opt:143
 msgid "Use simple data speculation check"
-msgstr ""
+msgstr ""
 
 #: config/ia64/ia64.opt:147
 msgid "Use simple data speculation check for control speculation"
-msgstr ""
+msgstr ""
 
 #: config/ia64/ia64.opt:151
 msgid "If set, data speculative instructions will be chosen for schedule only if there are no other choices at the moment "
@@ -5789,7 +5782,7 @@
 
 #: config/ia64/ia64.opt:163
 msgid "Place a stop bit after every cycle when scheduling"
-msgstr ""
+msgstr ""
 
 #: config/ia64/ia64.opt:167
 msgid "Assume that floating-point stores and loads are not likely to cause conflict when placed into one instruction group"
@@ -5805,7 +5798,7 @@
 
 #: config/ia64/ia64.opt:179
 msgid "Don't generate checks for control speculation in selective scheduling"
-msgstr ""
+msgstr ""
 
 #: config/ia64/vms_symvec_libgcc_s.opt:3
 msgid "! It would be better to auto-generate this file."
@@ -6109,7 +6102,7 @@
 
 #: config/m68k/m68k.opt:160 config/bfin/bfin.opt:61
 msgid "Enable separate data segment"
-msgstr ""
+msgstr ""
 
 #: config/m68k/m68k.opt:164 config/bfin/bfin.opt:57
 msgid "ID of shared library to build"
@@ -6149,7 +6142,7 @@
 
 #: config/i386/mingw.opt:23
 msgid "Warn about none ISO msvcrt scanf/printf width extensions"
-msgstr ""
+msgstr " ISO  msvcrt scanf/printf "
 
 #: config/i386/mingw.opt:27
 msgid "For nested functions on stack executable permission is set."
@@ -6201,7 +6194,7 @@
 
 #: config/i386/i386.opt:114
 msgid "Data greater than given threshold will go into .ldata section in x86-64 medium model"
-msgstr ""
+msgstr "x86-64  .ldata "
 
 #: config/i386/i386.opt:118
 msgid "Use given x86-64 code model"
@@ -6217,16 +6210,15 @@
 
 #: config/i386/i386.opt:129
 msgid "Always use Dynamic Realigned Argument Pointer (DRAP) to realign stack"
-msgstr ""
+msgstr " (Dynamic Realigned Argument Pointer, DRAP) "
 
 #: config/i386/i386.opt:133
 msgid "Return values of functions in FPU registers"
 msgstr "FPU "
 
 #: config/i386/i386.opt:137
-#, fuzzy
 msgid "Generate floating point mathematics using given instruction set"
-msgstr ""
+msgstr ""
 
 #: config/i386/i386.opt:149
 msgid "Inline all known string operations"
@@ -6314,8 +6306,9 @@
 msgstr "8 "
 
 #: config/i386/i386.opt:253
+#, fuzzy
 msgid "Generate reciprocals instead of divss and sqrtss."
-msgstr ""
+msgstr "divss  sqrtss  (reciprocal) "
 
 #: config/i386/i386.opt:257
 msgid "Generate cld instruction in the function prologue."
@@ -6331,7 +6324,7 @@
 
 #: config/i386/i386.opt:271
 msgid "Use 128-bit AVX instructions instead of 256-bit AVX instructions in the auto-vectorizer."
-msgstr ""
+msgstr " 256  AVX  128  AVX "
 
 #: config/i386/i386.opt:277
 msgid "Generate 32bit i386 code"
@@ -6382,9 +6375,8 @@
 msgstr "SSE4.1  SSE4.2 "
 
 #: config/i386/i386.opt:328
-#, fuzzy
 msgid "%<-msse5%> was removed"
-msgstr "'-msse5' "
+msgstr "%<-msse5%> "
 
 #: config/i386/i386.opt:333
 msgid "Support MMX, SSE, SSE2, SSE3, SSSE3, SSE4.1, SSE4.2 and AVX built-in functions and code generation"
@@ -6544,7 +6536,7 @@
 
 #: config/rs6000/rs6000.opt:152
 msgid "Use PowerPC General Purpose group optional instructions"
-msgstr "PowerPC "
+msgstr "PowerPC "
 
 #: config/rs6000/rs6000.opt:156
 msgid "Use PowerPC Graphics group optional instructions"
@@ -7002,7 +6994,7 @@
 
 #: config/mcore/mcore.opt:56 config/fr30/fr30.opt:27
 msgid "Assume that run-time support has been provided, so omit -lsim from the linker command line"
-msgstr ""
+msgstr " -lsim "
 
 #: config/mcore/mcore.opt:60
 msgid "Use arbitrary sized immediates in bit operations"
@@ -7014,7 +7006,7 @@
 
 #: config/mcore/mcore.opt:71
 msgid "Set the maximum amount for a single stack increment operation"
-msgstr ""
+msgstr ""
 
 #: config/mcore/mcore.opt:75
 msgid "Always treat bitfields as int-sized"
@@ -7234,7 +7226,7 @@
 
 #: config/sh/sh.opt:246
 msgid "Division strategy, one of: call, call2, fp, inv, inv:minlat, inv20u, inv20l, inv:call, inv:call2, inv:fp, call-div1, call-fp, call-table"
-msgstr ""
+msgstr ": call, call2, fp, inv, inv:minlat, inv20u, inv20l, inv:call, inv:call2, inv:fp, call-div1, call-fp, call-table"
 
 #: config/sh/sh.opt:250
 msgid "Specify name for 32 bit signed division function"
@@ -7282,7 +7274,7 @@
 
 #: config/sh/sh.opt:298
 msgid "Mark MAC register as call-clobbered"
-msgstr ""
+msgstr "MAC "
 
 #: config/sh/sh.opt:304
 msgid "Make structs a multiple of 4 bytes (warning: ABI altered)"
@@ -7960,7 +7952,7 @@
 
 #: config/m68hc11/m68hc11.opt:49
 msgid "Auto pre/post decrement increment allowed"
-msgstr " pre/post  "
+msgstr " / / "
 
 #: config/m68hc11/m68hc11.opt:53
 msgid "Min/max instructions allowed"
@@ -7972,7 +7964,7 @@
 
 #: config/m68hc11/m68hc11.opt:61
 msgid "Auto pre/post decrement increment not allowed"
-msgstr " pre/post  "
+msgstr " / /"
 
 #: config/m68hc11/m68hc11.opt:65
 msgid "Use jsr and rts for function calls and returns"
@@ -8346,7 +8338,7 @@
 
 #: config/bfin/bfin.opt:69
 msgid "Link with the fast floating-point library"
-msgstr ""
+msgstr ""
 
 #: config/bfin/bfin.opt:81
 msgid "Do stack checking using bounds in L1 scratch memory"
@@ -8382,7 +8374,7 @@
 
 #: config/picochip/picochip.opt:31
 msgid "Specify whether the byte access instructions should be used. Enabled by default."
-msgstr ""
+msgstr ""
 
 #: config/picochip/picochip.opt:35
 msgid "Enable debug output to be generated."
@@ -8390,11 +8382,11 @@
 
 #: config/picochip/picochip.opt:39
 msgid "Allow a symbol value to be used as an immediate value in an instruction."
-msgstr ""
+msgstr ""
 
 #: config/picochip/picochip.opt:43
 msgid "Generate warnings when inefficient code is known to be generated."
-msgstr ""
+msgstr ""
 
 #: config/vxworks.opt:36
 msgid "Assume the VxWorks RTP environment"
@@ -8418,7 +8410,7 @@
 
 #: config/darwin.opt:205
 msgid "Warn if constant CFString objects contain non-portable characters"
-msgstr ""
+msgstr " CFString "
 
 #: config/darwin.opt:210
 msgid "Generate AT&T-style stubs for Mach-O"
@@ -8430,7 +8422,7 @@
 
 #: config/darwin.opt:218
 msgid "Generate code suitable for fast turn around debugging"
-msgstr ""
+msgstr ""
 
 #: config/darwin.opt:227
 msgid "The earliest MacOS X version on which this program will run"
@@ -8442,15 +8434,15 @@
 
 #: config/darwin.opt:235
 msgid "Generate code for darwin loadable kernel extensions"
-msgstr ""
+msgstr "darwin "
 
 #: config/darwin.opt:239
 msgid "Generate code for the kernel or loadable kernel extensions"
-msgstr ""
+msgstr ""
 
 #: config/darwin.opt:243
 msgid "-iframework <dir>\tAdd <dir> to the end of the system framework include path"
-msgstr ""
+msgstr "-iframework <dir>\t<dir> "
 
 #: config/lynx.opt:23
 msgid "Support legacy multi-threading"
@@ -8737,7 +8729,6 @@
 msgstr ""
 
 #: config/microblaze/microblaze.opt:92
-#, fuzzy
 msgid "Use hardware floating point conversion instructions"
 msgstr ""
 
@@ -8862,7 +8853,7 @@
 
 #: c-family/c.opt:249
 msgid "-MT <target>\tAdd an unquoted target"
-msgstr ""
+msgstr "-MT <target>\t () "
 
 #: c-family/c.opt:253
 msgid "Do not generate #line directives"
@@ -8898,11 +8889,11 @@
 
 #: c-family/c.opt:288
 msgid "Warn about C constructs that are not in the common subset of C and C++"
-msgstr ""
+msgstr "C  C++  C "
 
 #: c-family/c.opt:292
 msgid "Warn about C++ constructs whose meaning differs between ISO C++ 1998 and ISO C++ 200x"
-msgstr ""
+msgstr "ISO C++ 1998  ISO C++ 200x  C++ "
 
 #: c-family/c.opt:296
 msgid "Warn about casts which discard qualifiers"
@@ -8962,7 +8953,7 @@
 
 #: c-family/c.opt:352
 msgid "Warn about stray tokens after #elif and #endif"
-msgstr ""
+msgstr "#elif  #endif "
 
 #: c-family/c.opt:356
 msgid "Warn about comparison of different enum types"
@@ -8977,9 +8968,8 @@
 msgstr ""
 
 #: c-family/c.opt:372
-#, fuzzy
 msgid "Warn about printf/scanf/strftime/strfmon format string anomalies"
-msgstr "printf/scanf/strftime/strfmon "
+msgstr "printf/scanf/strftime/strfmon "
 
 #: c-family/c.opt:376
 msgid "Warn if passing too many arguments to a function for its format string"
@@ -8998,9 +8988,8 @@
 msgstr ""
 
 #: c-family/c.opt:392
-#, fuzzy
 msgid "Warn about strftime formats yielding 2-digit years"
-msgstr "strftime "
+msgstr "strftime  2 "
 
 #: c-family/c.opt:396
 msgid "Warn about zero-length formats"
@@ -9409,7 +9398,7 @@
 
 #: c-family/c.opt:823
 msgid "Don't emit dllexported inline functions unless needed"
-msgstr ""
+msgstr " dllexported "
 
 #: c-family/c.opt:830
 msgid "Allow implicit conversions between vectors with differing numbers of subparts and/or differing element types."
@@ -9501,7 +9490,7 @@
 
 #: c-family/c.opt:942
 msgid "Generate run time type descriptor information"
-msgstr ""
+msgstr ""
 
 #: c-family/c.opt:946
 msgid "Use the same size for double as for float"
@@ -9889,19 +9878,16 @@
 msgstr " __attribute__((pure)) "
 
 #: common.opt:608
-#, fuzzy
 msgid "Warn about enumerated switches, with no default, missing a case"
-msgstr " switch  case "
+msgstr " switch  default  case "
 
 #: common.opt:612
-#, fuzzy
 msgid "Warn about enumerated switches missing a \"default:\" statement"
-msgstr " switch  case "
+msgstr " switch  \"default:\" "
 
 #: common.opt:616
-#, fuzzy
 msgid "Warn about all enumerated switches missing a specific case"
-msgstr " switch  case "
+msgstr " switch  case "
 
 #: common.opt:620
 msgid "Do not suppress warnings from system headers"
@@ -10000,9 +9986,8 @@
 msgstr "/"
 
 #: common.opt:821
-#, fuzzy
 msgid "Generate code to check bounds before indexing arrays"
-msgstr ""
+msgstr ""
 
 #: common.opt:825
 #, fuzzy
@@ -10043,7 +10028,7 @@
 
 #: common.opt:864
 msgid "Looks for opportunities to reduce stack adjustments and stack references."
-msgstr ""
+msgstr ""
 
 #: common.opt:868
 msgid "Do not put uninitialized globals in the common section"
@@ -10058,18 +10043,16 @@
 msgstr ""
 
 #: common.opt:884
-#, fuzzy
 msgid "Perform comparison elimination after register allocation has finished"
-msgstr ""
+msgstr ""
 
 #: common.opt:888
 msgid "Do not perform optimizations increasing noticeably stack usage"
-msgstr ""
+msgstr ""
 
 #: common.opt:892
-#, fuzzy
 msgid "Perform a register copy-propagation optimization pass"
-msgstr ""
+msgstr ""
 
 #: common.opt:896
 msgid "Perform cross-jumping optimization"
@@ -10101,7 +10084,7 @@
 
 #: common.opt:928
 msgid "Map one directory name to another in debug information"
-msgstr ""
+msgstr ""
 
 #: common.opt:934
 msgid "Defer popping functions args from stack until later"
@@ -10116,9 +10099,8 @@
 msgstr " null "
 
 #: common.opt:946
-#, fuzzy
 msgid "Try to convert virtual calls to direct ones."
-msgstr " PIC "
+msgstr ""
 
 #: common.opt:950
 #, fuzzy
@@ -10137,7 +10119,7 @@
 
 #: common.opt:978
 msgid "-fdump-final-insns=filename\tDump to filename the insns at the end of translation"
-msgstr ""
+msgstr "-fdump-final-insns=filename\t filename "
 
 #: common.opt:982
 msgid "-fdump-go-spec=filename\tWrite all declarations to file as Go code"
@@ -10173,7 +10155,7 @@
 
 #: common.opt:1014 common.opt:1018
 msgid "Perform unused type elimination in debug info"
-msgstr ""
+msgstr ""
 
 #: common.opt:1022
 msgid "Do not suppress C++ class debug information."
@@ -10181,25 +10163,24 @@
 
 #: common.opt:1026
 msgid "Generate debug information to support Identical Code Folding (ICF)"
-msgstr ""
+msgstr "Identical Code Folding (ICF) "
 
 #: common.opt:1030
 msgid "Enable exception handling"
 msgstr ""
 
 #: common.opt:1034
-#, fuzzy
 msgid "Perform a number of minor, expensive optimizations"
-msgstr ""
+msgstr ""
 
 #: common.opt:1038
 msgid "-fexcess-precision=[fast|standard]\tSpecify handling of excess floating-point precision"
-msgstr ""
+msgstr "-fexcess-precision=[fast|standard]\t"
 
 #: common.opt:1041
 #, c-format
 msgid "unknown excess precision style %qs"
-msgstr ""
+msgstr " %qs "
 
 #: common.opt:1054
 msgid "Assume no NaNs or infinities are generated"
@@ -10222,52 +10203,45 @@
 msgstr ""
 
 #: common.opt:1077
-#, fuzzy, c-format
+#, c-format
 msgid "unknown floating point contraction style %qs"
-msgstr " TOC "
+msgstr " %qs "
 
 #: common.opt:1094
 msgid "Allow function addresses to be held in registers"
 msgstr ""
 
 #: common.opt:1098
-#, fuzzy
 msgid "Place each function into its own section"
-msgstr ""
+msgstr ""
 
 #: common.opt:1102
-#, fuzzy
 msgid "Perform global common subexpression elimination"
-msgstr ""
+msgstr ""
 
 #: common.opt:1106
-#, fuzzy
 msgid "Perform enhanced load motion during global common subexpression elimination"
-msgstr ""
+msgstr ""
 
 #: common.opt:1110
-#, fuzzy
 msgid "Perform store motion after global common subexpression elimination"
-msgstr ""
+msgstr ""
 
 #: common.opt:1114
 msgid "Perform redundant load after store elimination in global common subexpression"
 msgstr ""
 
 #: common.opt:1119
-#, fuzzy
 msgid "Perform global common subexpression elimination after register allocation"
-msgstr ""
+msgstr ""
 
 #: common.opt:1125
-#, fuzzy
 msgid "Enable in and out of Graphite representation"
-msgstr ""
+msgstr ""
 
 #: common.opt:1129
-#, fuzzy
 msgid "Enable Graphite Identity transformation"
-msgstr ""
+msgstr ""
 
 #: common.opt:1133
 msgid "Mark all loops as parallel"
@@ -10306,9 +10280,8 @@
 msgstr ""
 
 #: common.opt:1173
-#, fuzzy
 msgid "Perform conversion of conditional jumps to conditional execution"
-msgstr ""
+msgstr ""
 
 #: common.opt:1177
 msgid "Convert conditional jumps in innermost loops to branchless equivalents"
@@ -10376,13 +10349,12 @@
 msgstr ""
 
 #: common.opt:1253
-#, fuzzy
 msgid "Discover pure and const functions"
-msgstr ""
+msgstr ""
 
 #: common.opt:1257
 msgid "Discover readonly and non addressable static variables"
-msgstr ""
+msgstr ""
 
 #: common.opt:1261
 msgid "Perform matrix layout flattening and transposing based"
@@ -10415,9 +10387,8 @@
 msgstr ""
 
 #: common.opt:1305
-#, fuzzy
 msgid "Share slots for saving different hard registers."
-msgstr ""
+msgstr ""
 
 #: common.opt:1309
 msgid "Share stack slots for spilled pseudo-registers."
@@ -10621,19 +10592,19 @@
 
 #: common.opt:1521
 msgid "Enable basic program profiling code"
-msgstr ""
+msgstr ""
 
 #: common.opt:1525
 msgid "Insert arc-based program profiling code"
-msgstr ""
+msgstr ""
 
 #: common.opt:1529
 msgid "Set the top-level directory for storing the profile data."
-msgstr ""
+msgstr ""
 
 #: common.opt:1534
 msgid "Enable correction of flow inconsistent profile data input"
-msgstr ""
+msgstr ""
 
 #: common.opt:1538
 msgid "Enable common options for generating profile info for profile feedback directed optimizations"
@@ -10653,7 +10624,7 @@
 
 #: common.opt:1554
 msgid "Insert code to profile values of expressions"
-msgstr ""
+msgstr ""
 
 #: common.opt:1561
 msgid "-frandom-seed=<string>\tMake compile reproducible using <string>"
@@ -11836,7 +11807,7 @@
 #: c-decl.c:1150
 #, gcc-internal-format
 msgid "nested function %q+D declared but never defined"
-msgstr ""
+msgstr " %q+D "
 
 #: c-decl.c:1162
 #, gcc-internal-format
@@ -11893,7 +11864,7 @@
 #: c-decl.c:1613
 #, gcc-internal-format
 msgid "prototype for %q+D follows non-prototype definition"
-msgstr ""
+msgstr " %q+D "
 
 #: c-decl.c:1628
 #, gcc-internal-format
@@ -11969,9 +11940,9 @@
 msgstr "%q+D "
 
 #: c-decl.c:1818
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "redefinition of typedef %q+D with variably modified type"
-msgstr "%q+D "
+msgstr ""
 
 #: c-decl.c:1825
 #, gcc-internal-format
@@ -12016,17 +11987,17 @@
 #: c-decl.c:2001
 #, gcc-internal-format
 msgid "extern declaration of %q+D follows declaration with no linkage"
-msgstr ""
+msgstr " %q+D  extern "
 
 #: c-decl.c:2037
 #, gcc-internal-format
 msgid "declaration of %q+D with no linkage follows extern declaration"
-msgstr ""
+msgstr "extern  %q+D "
 
 #: c-decl.c:2043
 #, gcc-internal-format
 msgid "redeclaration of %q+D with no linkage"
-msgstr ""
+msgstr " %q+D "
 
 #: c-decl.c:2069
 #, gcc-internal-format
@@ -12354,7 +12325,7 @@
 #: c-decl.c:4614
 #, gcc-internal-format
 msgid "defining a type in a compound literal is invalid in C++"
-msgstr ""
+msgstr " C++ "
 
 #: c-decl.c:4666 c-decl.c:4681
 #, gcc-internal-format
@@ -13393,23 +13364,23 @@
 #: c-parser.c:1829
 #, gcc-internal-format
 msgid "expression in static assertion is not an integer"
-msgstr ""
+msgstr ""
 
 #: c-parser.c:1836
 #, gcc-internal-format
 msgid "expression in static assertion is not an integer constant expression"
-msgstr ""
+msgstr ""
 
 #: c-parser.c:1841
 #, gcc-internal-format
 msgid "expression in static assertion is not constant"
-msgstr ""
+msgstr ""
 
 #. Report the error.
 #: c-parser.c:1846 cp/semantics.c:4719
 #, gcc-internal-format
 msgid "static assertion failed: %E"
-msgstr ""
+msgstr ": %E"
 
 #: c-parser.c:2207 c-parser.c:3063 c-parser.c:3709 c-parser.c:3983
 #: c-parser.c:5084 c-parser.c:5175 c-parser.c:5800 c-parser.c:6083
@@ -14125,12 +14096,12 @@
 #: c-typeck.c:3578
 #, gcc-internal-format
 msgid "increment of enumeration value is invalid in C++"
-msgstr " C++ "
+msgstr " C++ "
 
 #: c-typeck.c:3581
 #, gcc-internal-format
 msgid "decrement of enumeration value is invalid in C++"
-msgstr " C++ "
+msgstr " C++ "
 
 #: c-typeck.c:3594
 #, gcc-internal-format
@@ -14140,22 +14111,22 @@
 #: c-typeck.c:3613 c-typeck.c:3645
 #, gcc-internal-format
 msgid "wrong type argument to increment"
-msgstr ""
+msgstr ""
 
 #: c-typeck.c:3615 c-typeck.c:3648
 #, gcc-internal-format
 msgid "wrong type argument to decrement"
-msgstr ""
+msgstr ""
 
 #: c-typeck.c:3635
 #, gcc-internal-format
 msgid "increment of pointer to unknown structure"
-msgstr ""
+msgstr ""
 
 #: c-typeck.c:3638
 #, gcc-internal-format
 msgid "decrement of pointer to unknown structure"
-msgstr ""
+msgstr ""
 
 #: c-typeck.c:3722
 #, gcc-internal-format
@@ -14170,12 +14141,12 @@
 #: c-typeck.c:3895 c-family/c-common.c:8658
 #, gcc-internal-format
 msgid "increment of read-only location %qE"
-msgstr " %qE "
+msgstr " %qE "
 
 #: c-typeck.c:3898 c-family/c-common.c:8659
 #, gcc-internal-format
 msgid "decrement of read-only location %qE"
-msgstr " %qE "
+msgstr " %qE "
 
 #: c-typeck.c:3939
 #, gcc-internal-format
@@ -19787,12 +19758,12 @@
 #: c-family/c-common.c:8611
 #, gcc-internal-format
 msgid "increment of member %qD in read-only object"
-msgstr " %qD "
+msgstr " %qD "
 
 #: c-family/c-common.c:8613
 #, gcc-internal-format
 msgid "decrement of member %qD in read-only object"
-msgstr " %qD "
+msgstr " %qD "
 
 #: c-family/c-common.c:8615
 #, gcc-internal-format
@@ -19807,12 +19778,12 @@
 #: c-family/c-common.c:8620
 #, gcc-internal-format
 msgid "increment of read-only member %qD"
-msgstr " %qD "
+msgstr " %qD "
 
 #: c-family/c-common.c:8621
 #, gcc-internal-format
 msgid "decrement of read-only member %qD"
-msgstr " %qD "
+msgstr " %qD "
 
 #: c-family/c-common.c:8622
 #, gcc-internal-format
@@ -19827,12 +19798,12 @@
 #: c-family/c-common.c:8627
 #, gcc-internal-format
 msgid "increment of read-only variable %qD"
-msgstr " %qD "
+msgstr " %qD "
 
 #: c-family/c-common.c:8628
 #, gcc-internal-format
 msgid "decrement of read-only variable %qD"
-msgstr " %qD "
+msgstr " %qD "
 
 #: c-family/c-common.c:8629
 #, gcc-internal-format
@@ -19847,12 +19818,12 @@
 #: c-family/c-common.c:8633
 #, gcc-internal-format
 msgid "increment of read-only parameter %qD"
-msgstr " %qD "
+msgstr " %qD "
 
 #: c-family/c-common.c:8634
 #, gcc-internal-format
 msgid "decrement of read-only parameter %qD"
-msgstr " %qD "
+msgstr " %qD "
 
 #: c-family/c-common.c:8635
 #, gcc-internal-format
@@ -19867,12 +19838,12 @@
 #: c-family/c-common.c:8642
 #, gcc-internal-format
 msgid "increment of read-only named return value %qD"
-msgstr " %qD "
+msgstr " %qD "
 
 #: c-family/c-common.c:8644
 #, gcc-internal-format
 msgid "decrement of read-only named return value %qD"
-msgstr " %qD "
+msgstr " %qD "
 
 #: c-family/c-common.c:8646
 #, gcc-internal-format
@@ -19887,12 +19858,12 @@
 #: c-family/c-common.c:8652
 #, gcc-internal-format
 msgid "increment of function %qD"
-msgstr " %qD "
+msgstr " %qD "
 
 #: c-family/c-common.c:8653
 #, gcc-internal-format
 msgid "decrement of function %qD"
-msgstr " %qD "
+msgstr " %qD "
 
 #: c-family/c-common.c:8654
 #, gcc-internal-format
@@ -19912,12 +19883,12 @@
 #: c-family/c-common.c:8677
 #, gcc-internal-format
 msgid "lvalue required as increment operand"
-msgstr ""
+msgstr ""
 
 #: c-family/c-common.c:8680
 #, gcc-internal-format
 msgid "lvalue required as decrement operand"
-msgstr ""
+msgstr ""
 
 #: c-family/c-common.c:8683
 #, gcc-internal-format
@@ -20556,12 +20527,12 @@
 #: c-family/c-omp.c:375 cp/semantics.c:4431
 #, gcc-internal-format
 msgid "missing increment expression"
-msgstr ""
+msgstr ""
 
 #: c-family/c-omp.c:444 cp/semantics.c:4287
 #, gcc-internal-format
 msgid "invalid increment expression"
-msgstr ""
+msgstr ""
 
 #: c-family/c-opts.c:303
 #, gcc-internal-format
@@ -20571,7 +20542,7 @@
 #: c-family/c-opts.c:306
 #, gcc-internal-format
 msgid "obsolete option -I- used, please use -iquote instead"
-msgstr " -I-  -iquote "
+msgstr " -I-  -iquote "
 
 #: c-family/c-opts.c:486
 #, gcc-internal-format
Index: gcc/tree-ssa-forwprop.c
===================================================================
--- gcc/tree-ssa-forwprop.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/tree-ssa-forwprop.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -872,7 +872,7 @@
 		     TREE_TYPE (gimple_assign_rhs1 (use_stmt))))
 	{
 	  tree *def_rhs_basep = &TREE_OPERAND (def_rhs, 0);
-	  tree new_offset, new_base, saved;
+	  tree new_offset, new_base, saved, new_lhs;
 	  while (handled_component_p (*def_rhs_basep))
 	    def_rhs_basep = &TREE_OPERAND (*def_rhs_basep, 0);
 	  saved = *def_rhs_basep;
@@ -891,9 +891,12 @@
 	  *def_rhs_basep = build2 (MEM_REF, TREE_TYPE (*def_rhs_basep),
 				   new_base, new_offset);
 	  TREE_THIS_VOLATILE (*def_rhs_basep) = TREE_THIS_VOLATILE (lhs);
+	  TREE_SIDE_EFFECTS (*def_rhs_basep) = TREE_SIDE_EFFECTS (lhs);
 	  TREE_THIS_NOTRAP (*def_rhs_basep) = TREE_THIS_NOTRAP (lhs);
-	  gimple_assign_set_lhs (use_stmt,
-				 unshare_expr (TREE_OPERAND (def_rhs, 0)));
+	  new_lhs = unshare_expr (TREE_OPERAND (def_rhs, 0));
+	  gimple_assign_set_lhs (use_stmt, new_lhs);
+	  TREE_THIS_VOLATILE (new_lhs) = TREE_THIS_VOLATILE (lhs);
+	  TREE_SIDE_EFFECTS (new_lhs) = TREE_SIDE_EFFECTS (lhs);
 	  *def_rhs_basep = saved;
 	  tidy_after_forward_propagate_addr (use_stmt);
 	  /* Continue propagating into the RHS if this was not the
@@ -953,7 +956,7 @@
 		     TREE_TYPE (TREE_OPERAND (def_rhs, 0))))
 	{
 	  tree *def_rhs_basep = &TREE_OPERAND (def_rhs, 0);
-	  tree new_offset, new_base, saved;
+	  tree new_offset, new_base, saved, new_rhs;
 	  while (handled_component_p (*def_rhs_basep))
 	    def_rhs_basep = &TREE_OPERAND (*def_rhs_basep, 0);
 	  saved = *def_rhs_basep;
@@ -972,9 +975,12 @@
 	  *def_rhs_basep = build2 (MEM_REF, TREE_TYPE (*def_rhs_basep),
 				   new_base, new_offset);
 	  TREE_THIS_VOLATILE (*def_rhs_basep) = TREE_THIS_VOLATILE (rhs);
+	  TREE_SIDE_EFFECTS (*def_rhs_basep) = TREE_SIDE_EFFECTS (rhs);
 	  TREE_THIS_NOTRAP (*def_rhs_basep) = TREE_THIS_NOTRAP (rhs);
-	  gimple_assign_set_rhs1 (use_stmt,
-				  unshare_expr (TREE_OPERAND (def_rhs, 0)));
+	  new_rhs = unshare_expr (TREE_OPERAND (def_rhs, 0));
+	  gimple_assign_set_rhs1 (use_stmt, new_rhs);
+	  TREE_THIS_VOLATILE (new_rhs) = TREE_THIS_VOLATILE (rhs);
+	  TREE_SIDE_EFFECTS (new_rhs) = TREE_SIDE_EFFECTS (rhs);
 	  *def_rhs_basep = saved;
 	  fold_stmt_inplace (use_stmt);
 	  tidy_after_forward_propagate_addr (use_stmt);
Index: gcc/varasm.c
===================================================================
--- gcc/varasm.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/varasm.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -6751,11 +6751,14 @@
   /* A non-decl is an entry in the constant pool.  */
   if (!DECL_P (exp))
     local_p = true;
-  /* Weakrefs may not bind locally, even though the weakref itself is
-     always static and therefore local.
-     FIXME: We can resolve this more curefuly by looking at the weakref
-     alias.  */
-  else if (lookup_attribute ("weakref", DECL_ATTRIBUTES (exp)))
+  /* Weakrefs may not bind locally, even though the weakref itself is always
+     static and therefore local.  Similarly, the resolver for ifunc functions
+     might resolve to a non-local function.
+     FIXME: We can resolve the weakref case more curefuly by looking at the
+     weakref alias.  */
+  else if (lookup_attribute ("weakref", DECL_ATTRIBUTES (exp))
+	   || (TREE_CODE (exp) == FUNCTION_DECL
+	       && lookup_attribute ("ifunc", DECL_ATTRIBUTES (exp))))
     local_p = false;
   /* Static variables are always local.  */
   else if (! TREE_PUBLIC (exp))
Index: gcc/sched-deps.c
===================================================================
--- gcc/sched-deps.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/sched-deps.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -2687,7 +2687,11 @@
 	  else
 	    sched_analyze_2 (deps, XEXP (link, 0), insn);
 	}
-      if (find_reg_note (insn, REG_SETJMP, NULL))
+      /* Don't schedule anything after a tail call, tail call needs
+	 to use at least all call-saved registers.  */
+      if (SIBLING_CALL_P (insn))
+	reg_pending_barrier = TRUE_BARRIER;
+      else if (find_reg_note (insn, REG_SETJMP, NULL))
 	reg_pending_barrier = MOVE_BARRIER;
     }
 
Index: gcc/tree-object-size.c
===================================================================
--- gcc/tree-object-size.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/tree-object-size.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -175,7 +175,7 @@
       unsigned HOST_WIDE_INT sz;
 
       if (!osi || (object_size_type & 1) != 0
-	  || TREE_CODE (pt_var) != SSA_NAME)
+	  || TREE_CODE (TREE_OPERAND (pt_var, 0)) != SSA_NAME)
 	{
 	  sz = compute_builtin_object_size (TREE_OPERAND (pt_var, 0),
 					    object_size_type & ~1);
Index: gcc/tree-outof-ssa.c
===================================================================
--- gcc/tree-outof-ssa.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/tree-outof-ssa.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -237,9 +237,10 @@
 
   var = SSA_NAME_VAR (partition_to_var (SA.map, dest));
   src_mode = TYPE_MODE (TREE_TYPE (src));
-  dest_mode = promote_decl_mode (var, &unsignedp);
+  dest_mode = GET_MODE (SA.partition_to_pseudo[dest]);
   gcc_assert (src_mode == TYPE_MODE (TREE_TYPE (var)));
-  gcc_assert (dest_mode == GET_MODE (SA.partition_to_pseudo[dest]));
+  gcc_assert (!REG_P (SA.partition_to_pseudo[dest])
+	      || dest_mode == promote_decl_mode (var, &unsignedp));
 
   if (src_mode != dest_mode)
     {
Index: gcc/tree-ssa-structalias.c
===================================================================
--- gcc/tree-ssa-structalias.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/tree-ssa-structalias.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -308,6 +308,7 @@
 static varinfo_t first_or_preceding_vi_for_offset (varinfo_t,
 						   unsigned HOST_WIDE_INT);
 static varinfo_t lookup_vi_for_tree (tree);
+static inline bool type_can_have_subvars (const_tree);
 
 /* Pool of variable info structures.  */
 static alloc_pool variable_info_pool;
@@ -3353,7 +3354,8 @@
 		return;
 
 	      cs = *VEC_last (ce_s, *results);
-	      if (cs.type == DEREF)
+	      if (cs.type == DEREF
+		  && type_can_have_subvars (TREE_TYPE (t)))
 		{
 		  /* For dereferences this means we have to defer it
 		     to solving time.  */
@@ -4981,6 +4983,15 @@
   VEC_qsort (fieldoff_s, fieldstack, fieldoff_compare);
 }
 
+/* Return true if T is a type that can have subvars.  */
+
+static inline bool
+type_can_have_subvars (const_tree t)
+{
+  /* Aggregates without overlapping fields can have subvars.  */
+  return TREE_CODE (t) == RECORD_TYPE;
+}
+
 /* Return true if V is a tree that we can have subvars for.
    Normally, this is any aggregate type.  Also complex
    types which are not gimple registers can have subvars.  */
@@ -4996,11 +5007,7 @@
   if (!DECL_P (v))
     return false;
 
-  /* Aggregates without overlapping fields can have subvars.  */
-  if (TREE_CODE (TREE_TYPE (v)) == RECORD_TYPE)
-    return true;
-
-  return false;
+  return type_can_have_subvars (TREE_TYPE (v));
 }
 
 /* Return true if T is a type that does contain pointers.  */
Index: gcc/lto-opts.c
===================================================================
--- gcc/lto-opts.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/lto-opts.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -358,7 +358,7 @@
   size_t len, l, skip;
   const char *data, *p;
   const struct lto_simple_header *header;
-  int32_t opts_offset;
+  int opts_offset;
   struct lto_input_block ib;
 
   data = lto_get_section_data (file_data, LTO_section_opts, NULL, &len);
@@ -379,10 +379,10 @@
 
       lto_check_version (header->lto_header.major_version,
 			 header->lto_header.minor_version);
-      
+
       LTO_INIT_INPUT_BLOCK (ib, p + opts_offset, 0, header->main_size);
       input_options (&ib);
-      
+
       skip = header->main_size + opts_offset;
       l -= skip;
       p += skip;
Index: gcc/c-parser.c
===================================================================
--- gcc/c-parser.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/c-parser.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -6294,7 +6294,7 @@
 	      c_parser_error (parser, "expected identifier");
 	    c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,
 				       "expected %<)%>");
-	    expr.value = fold_offsetof (offsetof_ref, NULL_TREE);
+	    expr.value = fold_offsetof (offsetof_ref);
 	  }
 	  break;
 	case RID_CHOOSE_EXPR:
Index: gcc/config/alpha/linux-unwind.h
===================================================================
--- gcc/config/alpha/linux-unwind.h	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/config/alpha/linux-unwind.h	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1,5 +1,5 @@
 /* DWARF2 EH unwinding support for Alpha Linux.
-   Copyright (C) 2004, 2005, 2009 Free Software Foundation, Inc.
+   Copyright (C) 2004, 2005, 2009, 2011 Free Software Foundation, Inc.
 
 This file is part of GCC.
 
@@ -36,16 +36,17 @@
 {
   unsigned int *pc = context->ra;
   struct sigcontext *sc;
-  long new_cfa, i;
+  long new_cfa;
+  int i;
 
   if (pc[0] != 0x47fe0410		/* mov $30,$16 */
-      || pc[2] != 0x00000083		/* callsys */)
+      || pc[2] != 0x00000083)		/* callsys */
     return _URC_END_OF_STACK;
   if (context->cfa == 0)
     return _URC_END_OF_STACK;
   if (pc[1] == 0x201f0067)		/* lda $0,NR_sigreturn */
     sc = context->cfa;
-  else if (pc[1] == 0x201f015f)	/* lda $0,NR_rt_sigreturn */
+  else if (pc[1] == 0x201f015f)		/* lda $0,NR_rt_sigreturn */
     {
       struct rt_sigframe {
 	struct siginfo info;
@@ -55,6 +56,7 @@
     }
   else
     return _URC_END_OF_STACK;
+
   new_cfa = sc->sc_regs[30];
   fs->regs.cfa_how = CFA_REG_OFFSET;
   fs->regs.cfa_reg = 30;
@@ -63,13 +65,13 @@
     {
       fs->regs.reg[i].how = REG_SAVED_OFFSET;
       fs->regs.reg[i].loc.offset
-	= (long)&sc->sc_regs[i] - new_cfa;
+	= (long) &sc->sc_regs[i] - new_cfa;
     }
   for (i = 0; i < 31; ++i)
     {
       fs->regs.reg[i+32].how = REG_SAVED_OFFSET;
       fs->regs.reg[i+32].loc.offset
-	= (long)&sc->sc_fpregs[i] - new_cfa;
+	= (long) &sc->sc_fpregs[i] - new_cfa;
     }
   fs->regs.reg[64].how = REG_SAVED_OFFSET;
   fs->regs.reg[64].loc.offset = (long)&sc->sc_pc - new_cfa;
@@ -78,3 +80,20 @@
 
   return _URC_NO_REASON;
 }
+
+#define MD_FROB_UPDATE_CONTEXT alpha_frob_update_context
+
+/* Fix up for signal handlers that don't have S flag set.  */
+
+static void
+alpha_frob_update_context (struct _Unwind_Context *context,
+			   _Unwind_FrameState *fs ATTRIBUTE_UNUSED)
+{
+  unsigned int *pc = context->ra;
+
+  if (pc[0] == 0x47fe0410		/* mov $30,$16 */
+      && pc[2] == 0x00000083		/* callsys */
+      && (pc[1] == 0x201f0067		/* lda $0,NR_sigreturn */
+	  || pc[1] == 0x201f015f))	/* lda $0,NR_rt_sigreturn */
+    _Unwind_SetSignalFrame (context, 1);
+}
Index: gcc/config/s390/s390.md
===================================================================
--- gcc/config/s390/s390.md	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/config/s390/s390.md	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -7644,6 +7644,7 @@
    sra<gk>\t%0,%1,%Y2"
   [(set_attr "op_type"  "RS<E>,RSY")
    (set_attr "atype"    "reg,reg")
+   (set_attr "cpu_facility" "*,z196")
    (set_attr "z10prop" "z10_super_E1,*")])
 
 
Index: gcc/config/sparc/sparc.md
===================================================================
--- gcc/config/sparc/sparc.md	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/config/sparc/sparc.md	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -28,6 +28,7 @@
   [(UNSPEC_MOVE_PIC		0)
    (UNSPEC_UPDATE_RETURN	1)
    (UNSPEC_LOAD_PCREL_SYM	2)
+   (UNSPEC_FRAME_BLOCKAGE      3)
    (UNSPEC_MOVE_PIC_LABEL	5)
    (UNSPEC_SETH44		6)
    (UNSPEC_SETM44		7)
@@ -1813,8 +1814,8 @@
 })
 
 (define_insn "*movsf_insn"
-  [(set (match_operand:V32 0 "nonimmediate_operand" "=d,f,*r,*r,*r,f,*r,m,m")
-	(match_operand:V32 1 "input_operand"        "GY,f,*rRY,Q,S,m,m,f,*rGY"))]
+  [(set (match_operand:V32 0 "nonimmediate_operand" "=d,f,  *r,*r,*r,f,*r,m,   m")
+	(match_operand:V32 1 "input_operand"        "GY,f,*rRY, Q, S,m, m,f,*rGY"))]
   "TARGET_FPU
    && (register_operand (operands[0], <V32:MODE>mode)
        || register_or_zero_operand (operands[1], <V32:MODE>mode))"
@@ -1861,8 +1862,8 @@
 ;; when -mno-fpu.
 
 (define_insn "*movsf_insn_no_fpu"
-  [(set (match_operand:SF 0 "nonimmediate_operand" "=r,r,r,r,m")
-	(match_operand:SF 1 "input_operand"    "rR,Q,S,m,rG"))]
+  [(set (match_operand:SF 0 "nonimmediate_operand" "=r,r,r,r, m")
+	(match_operand:SF 1 "input_operand"        "rR,Q,S,m,rG"))]
   "! TARGET_FPU
    && (register_operand (operands[0], SFmode)
        || register_or_zero_operand (operands[1], SFmode))"
@@ -1948,8 +1949,8 @@
 
 ;; Be careful, fmovd does not exist when !v9.
 (define_insn "*movdf_insn_sp32"
-  [(set (match_operand:DF 0 "nonimmediate_operand" "=e,W,U,T,o,e,*r,o,e,o")
-	(match_operand:DF 1 "input_operand"    "W#F,e,T,U,G,e,*rFo,*r,o#F,e"))]
+  [(set (match_operand:DF 0 "nonimmediate_operand" "= e,W,U,T,o,e,  *r, o,  e,o")
+	(match_operand:DF 1 "input_operand"        "W#F,e,T,U,G,e,*rFo,*r,o#F,e"))]
   "TARGET_FPU
    && ! TARGET_V9
    && (register_operand (operands[0], DFmode)
@@ -1969,8 +1970,8 @@
   (set_attr "length" "*,*,*,*,2,2,2,2,2,2")])
 
 (define_insn "*movdf_insn_sp32_no_fpu"
-  [(set (match_operand:DF 0 "nonimmediate_operand" "=U,T,o,r,o")
-	(match_operand:DF 1 "input_operand"    "T,U,G,ro,r"))]
+  [(set (match_operand:DF 0 "nonimmediate_operand" "=U,T,o, r,o")
+	(match_operand:DF 1 "input_operand"        " T,U,G,ro,r"))]
   "! TARGET_FPU
    && ! TARGET_V9
    && (register_operand (operands[0], DFmode)
@@ -1986,8 +1987,8 @@
 
 ;; We have available v9 double floats but not 64-bit integer registers.
 (define_insn "*movdf_insn_sp32_v9"
-  [(set (match_operand:V64 0 "nonimmediate_operand" "=b,e,e,T,W,U,T,f,*r,o")
-        (match_operand:V64 1 "input_operand" "GY,e,W#F,GY,e,T,U,o#F,*roGYDF,*rGYf"))]
+  [(set (match_operand:V64 0 "nonimmediate_operand" "=b,e,  e, T,W,U,T,  f,   *r,    o")
+	(match_operand:V64 1 "input_operand"        "GY,e,W#F,GY,e,T,U,o#F,*roFD,*rGYf"))]
   "TARGET_FPU
    && TARGET_V9
    && ! TARGET_ARCH64
@@ -2009,8 +2010,8 @@
    (set_attr "fptype" "double,double,*,*,*,*,*,*,*,*")])
 
 (define_insn "*movdf_insn_sp32_v9_no_fpu"
-  [(set (match_operand:DF 0 "nonimmediate_operand" "=U,T,T,r,o")
-	(match_operand:DF 1 "input_operand"    "T,U,G,ro,rG"))]
+  [(set (match_operand:DF 0 "nonimmediate_operand" "=U,T,T, r, o")
+	(match_operand:DF 1 "input_operand"        " T,U,G,ro,rG"))]
   "! TARGET_FPU
    && TARGET_V9
    && ! TARGET_ARCH64
@@ -2027,8 +2028,8 @@
 
 ;; We have available both v9 double floats and 64-bit integer registers.
 (define_insn "*movdf_insn_sp64"
-  [(set (match_operand:V64 0 "nonimmediate_operand" "=b,e,e,W,*r,*r,m,*r")
-        (match_operand:V64 1 "input_operand"    "GY,e,W#F,e,*rGY,m,*rGY,DF"))]
+  [(set (match_operand:V64 0 "nonimmediate_operand" "=b,e,  e,W,  *r,*r,   m,*r")
+	(match_operand:V64 1 "input_operand"        "GY,e,W#F,e,*rGY, m,*rGY,FD"))]
   "TARGET_FPU
    && TARGET_ARCH64
    && (register_operand (operands[0], <V64:MODE>mode)
@@ -2047,8 +2048,8 @@
    (set_attr "fptype" "double,double,*,*,*,*,*,*")])
 
 (define_insn "*movdf_insn_sp64_no_fpu"
-  [(set (match_operand:DF 0 "nonimmediate_operand" "=r,r,m")
-        (match_operand:DF 1 "input_operand"    "r,m,rG"))]
+  [(set (match_operand:DF 0 "nonimmediate_operand" "=r,r, m")
+	(match_operand:DF 1 "input_operand"         "r,m,rG"))]
   "! TARGET_FPU
    && TARGET_ARCH64
    && (register_operand (operands[0], DFmode)
@@ -2288,8 +2289,8 @@
 })
 
 (define_insn "*movtf_insn_sp32"
-  [(set (match_operand:TF 0 "nonimmediate_operand" "=b,e,o,U,r")
-	(match_operand:TF 1 "input_operand"    "G,oe,GeUr,o,roG"))]
+  [(set (match_operand:TF 0 "nonimmediate_operand" "=b, e,   o,U,  r")
+	(match_operand:TF 1 "input_operand"        " G,oe,GeUr,o,roG"))]
   "TARGET_FPU
    && ! TARGET_ARCH64
    && (register_operand (operands[0], TFmode)
@@ -2302,8 +2303,8 @@
 ;; when -mno-fpu.
 
 (define_insn "*movtf_insn_sp32_no_fpu"
-  [(set (match_operand:TF 0 "nonimmediate_operand" "=o,U,o,r,o")
-	(match_operand:TF 1 "input_operand"    "G,o,U,roG,r"))]
+  [(set (match_operand:TF 0 "nonimmediate_operand" "=o,U,o,  r,o")
+	(match_operand:TF 1 "input_operand"        " G,o,U,roG,r"))]
   "! TARGET_FPU
    && ! TARGET_ARCH64
    && (register_operand (operands[0], TFmode)
@@ -2312,8 +2313,8 @@
   [(set_attr "length" "4")])
 
 (define_insn "*movtf_insn_sp64"
-  [(set (match_operand:TF 0 "nonimmediate_operand" "=b,e,o,r")
-        (match_operand:TF 1 "input_operand"    "G,oe,Ger,roG"))]
+  [(set (match_operand:TF 0 "nonimmediate_operand" "=b, e,  o,  r")
+	(match_operand:TF 1 "input_operand"         "G,oe,Ger,roG"))]
   "TARGET_FPU
    && TARGET_ARCH64
    && ! TARGET_HARD_QUAD
@@ -2323,8 +2324,8 @@
   [(set_attr "length" "2")])
 
 (define_insn "*movtf_insn_sp64_hq"
-  [(set (match_operand:TF 0 "nonimmediate_operand" "=b,e,e,m,o,r")
-        (match_operand:TF 1 "input_operand"    "G,e,m,e,rG,roG"))]
+  [(set (match_operand:TF 0 "nonimmediate_operand" "=b,e,e,m, o,  r")
+	(match_operand:TF 1 "input_operand"         "G,e,m,e,rG,roG"))]
   "TARGET_FPU
    && TARGET_ARCH64
    && TARGET_HARD_QUAD
@@ -2341,8 +2342,8 @@
    (set_attr "length" "2,*,*,*,2,2")])
 
 (define_insn "*movtf_insn_sp64_no_fpu"
-  [(set (match_operand:TF 0 "nonimmediate_operand" "=r,o")
-        (match_operand:TF 1 "input_operand"    "orG,rG"))]
+  [(set (match_operand:TF 0 "nonimmediate_operand" "=  r, o")
+	(match_operand:TF 1 "input_operand"         "orG,rG"))]
   "! TARGET_FPU
    && TARGET_ARCH64
    && (register_operand (operands[0], TFmode)
@@ -6338,6 +6339,25 @@
   ""
   [(set_attr "length" "0")])
 
+;; Do not schedule instructions accessing memory before this point.
+
+(define_expand "frame_blockage"
+  [(set (match_dup 0)
+	(unspec:BLK [(match_dup 1)] UNSPEC_FRAME_BLOCKAGE))]
+  ""
+{
+  operands[0] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));
+  MEM_VOLATILE_P (operands[0]) = 1;
+  operands[1] = stack_pointer_rtx;
+})
+
+(define_insn "*frame_blockage<P:mode>"
+  [(set (match_operand:BLK 0 "" "")
+	(unspec:BLK [(match_operand:P 1 "" "")] UNSPEC_FRAME_BLOCKAGE))]
+  ""
+  ""
+  [(set_attr "length" "0")])
+
 (define_expand "probe_stack"
   [(set (match_operand 0 "memory_operand" "") (const_int 0))]
   ""
Index: gcc/config/sparc/sparc.c
===================================================================
--- gcc/config/sparc/sparc.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/config/sparc/sparc.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -4569,8 +4569,9 @@
       else if (actual_fsize <= 8192)
 	{
 	  insn = emit_insn (gen_stack_pointer_inc (GEN_INT (-4096)));
+	  RTX_FRAME_RELATED_P (insn) = 1;
+
 	  /* %sp is still the CFA register.  */
-	  RTX_FRAME_RELATED_P (insn) = 1;
 	  insn
 	    = emit_insn (gen_stack_pointer_inc (GEN_INT (4096-actual_fsize)));
 	}
@@ -4592,8 +4593,18 @@
       else if (actual_fsize <= 8192)
 	{
 	  insn = emit_insn (gen_save_register_window (GEN_INT (-4096)));
+
 	  /* %sp is not the CFA register anymore.  */
 	  emit_insn (gen_stack_pointer_inc (GEN_INT (4096-actual_fsize)));
+
+	  /* Make sure no %fp-based store is issued until after the frame is
+	     established.  The offset between the frame pointer and the stack
+	     pointer is calculated relative to the value of the stack pointer
+	     at the end of the function prologue, and moving instructions that
+	     access the stack via the frame pointer between the instructions
+	     that decrement the stack pointer could result in accessing the
+	     register window save area, which is volatile.  */
+	  emit_insn (gen_frame_blockage ());
 	}
       else
 	{
Index: gcc/config/sparc/sparc.h
===================================================================
--- gcc/config/sparc/sparc.h	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/config/sparc/sparc.h	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -408,6 +408,7 @@
 %{mcpu=sparclite:-Asparclite} \
 %{mcpu=sparclite86x:-Asparclite} \
 %{mcpu=f930:-Asparclite} %{mcpu=f934:-Asparclite} \
+%{mcpu=v8:-Av8} \
 %{mv8plus:-Av8plus} \
 %{mcpu=v9:-Av9} \
 %{mcpu=ultrasparc:%{!mv8plus:-Av9a}} \
Index: gcc/config/sparc/sol2-unwind.h
===================================================================
--- gcc/config/sparc/sol2-unwind.h	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/config/sparc/sol2-unwind.h	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1,5 +1,5 @@
 /* DWARF2 EH unwinding support for SPARC Solaris.
-   Copyright (C) 2009, 2010, 2011 Free Software Foundation, Inc.
+   Copyright (C) 2009, 2010, 2011, 2012 Free Software Foundation, Inc.
 
 This file is part of GCC.
 
@@ -34,7 +34,7 @@
 #define IS_SIGHANDLER sparc64_is_sighandler
 
 static int
-sparc64_is_sighandler (unsigned int *pc, unsigned int *savpc, int *nframes)
+sparc64_is_sighandler (unsigned int *pc, void *cfa, int *nframes)
 {
   if (/* Solaris 8 - single-threaded
 	----------------------------
@@ -110,38 +110,58 @@
       && pc[ 0] == 0x81c7e008
       && pc[ 1] == 0x81e80000)
     {
-      if (/* Solaris 8 /usr/lib/sparcv9/libthread.so.1
-	    ------------------------------------------
-	    Before patch 108827-08:
-	    <sigacthandler+1760>:     st  %g4, [ %i1 + 0x1c ]
+      /* We have observed different calling frames among different
+	 versions of the operating system, so that we need to
+	 discriminate using the upper frame.  We look for the return
+	 address of the caller frame (there is an offset of 15 double
+	 words between the frame address and the place where this return
+	 address is stored) in order to do some more pattern matching.  */
+      unsigned int cuh_pattern
+	= *(unsigned int *)(*(unsigned long *)(cfa + 15*8) - 4);
 
-	    Since patch 108827-08:
-	    <sigacthandler+1816>:     st  %l0, [ %i4 + 0x10 ]  */
-	        savpc[-1] == 0xc826601c
-	     || savpc[-1] == 0xe0272010)
+      if (cuh_pattern == 0xd25fa7ef)
 	{
-	  /* We need to move up three frames:
+	  /* This matches the call_user_handler pattern for Solaris 10.
+	     There are 2 cases so we look for the return address of the
+	     caller's caller frame in order to do more pattern matching.  */
+	  unsigned long sah_address = *(unsigned long *)(cfa + 176 + 15*8);
 
+          if (sah_address && *(unsigned int *)(sah_address - 4) == 0x92100019)
+	    /* This is the same setup as for Solaris 9, see below.  */
+	    *nframes = 3;
+	  else
+	    /* The sigacthandler frame isn't present in the chain.
+	       We need to move up two frames:
+
 		<signal handler>	<-- context->cfa
 		__sighndlr
-		sigacthandler
+		call_user_handler frame
 		<kernel>
-	  */
-	  *nframes = 2;
+	    */
+	    *nframes = 2;
 	}
-      else /* Solaris 8 /usr/lib/lwp/sparcv9/libthread.so.1, Solaris 9+
-	     ----------------------------------------------------------  */
-	{
-	  /* We need to move up three frames:
+      else if (cuh_pattern == 0x9410001a || cuh_pattern == 0x94100013)
+	/* This matches the call_user_handler pattern for Solaris 9 and
+	   for Solaris 8 running inside Solaris Containers respectively
+	   We need to move up three frames:
 
 		<signal handler>	<-- context->cfa
 		__sighndlr
 		call_user_handler
 		sigacthandler
 		<kernel>
-	  */
-	  *nframes = 3;
-	}
+	*/
+	*nframes = 3;
+      else
+	/* This is the default Solaris 8 case.
+	   We need to move up two frames:
+
+		<signal handler>	<-- context->cfa
+		__sighndlr
+		sigacthandler
+		<kernel>
+	*/
+	*nframes = 2;
       return 1;
     }
 
@@ -172,7 +192,7 @@
 #define IS_SIGHANDLER sparc_is_sighandler
 
 static int
-sparc_is_sighandler (unsigned int *pc, unsigned int * savpc, int *nframes)
+sparc_is_sighandler (unsigned int *pc, void *cfa, int *nframes)
 {
   if (/* Solaris 8, 9 - single-threaded
         -------------------------------
@@ -200,7 +220,7 @@
       && pc[-1] == 0x9410001a
       && pc[ 0] == 0x80a62008)
     {
-      /* Need to move up one frame:
+      /* We need to move up one frame:
 
 		<signal handler>	<-- context->cfa
 		sigacthandler
@@ -231,7 +251,7 @@
       && pc[ 1] == 0x81e80000
       && pc[ 2] == 0x80a26000)
     {
-      /* Need to move up one frame:
+      /* We need to move up one frame:
 
 		<signal handler>	<-- context->cfa
 		__libthread_segvhdlr
@@ -258,33 +278,58 @@
      && pc[ 0] == 0x81c7e008
      && pc[ 1] == 0x81e80000)
     {
-      if (/* Solaris 8 /usr/lib/libthread.so.1
-	    ----------------------------------
-	    <sigacthandler+1796>:     mov  %i0, %o0  */
-	  savpc[-1] == 0x90100018)
+      /* We have observed different calling frames among different
+	 versions of the operating system, so that we need to
+	 discriminate using the upper frame.  We look for the return
+	 address of the caller frame (there is an offset of 15 words
+	 between the frame address and the place where this return
+	 address is stored) in order to do some more pattern matching.  */
+      unsigned int cuh_pattern
+	= *(unsigned int *)(*(unsigned int *)(cfa + 15*4) - 4);
+
+      if (cuh_pattern == 0xd407a04c)
 	{
-	  /* We need to move up two frames:
+	  /* This matches the call_user_handler pattern for Solaris 10.
+	     There are 2 cases so we look for the return address of the
+	     caller's caller frame in order to do more pattern matching.  */
+	  unsigned int sah_address = *(unsigned int *)(cfa + 96 + 15*4);
 
+          if (sah_address && *(unsigned int *)(sah_address - 4) == 0x92100019)
+	    /* This is the same setup as for Solaris 9, see below.  */
+	    *nframes = 3;
+	  else
+	    /* The sigacthandler frame isn't present in the chain.
+	       We need to move up two frames:
+
 		<signal handler>	<-- context->cfa
 		__sighndlr
-		sigacthandler
+		call_user_handler frame
 		<kernel>
-	  */
-	  *nframes = 2;
+	    */
+	    *nframes = 2;
 	}
-      else /* Solaris 8 /usr/lib/lwp/libthread.so.1, Solaris 9+
-	     --------------------------------------------------  */
-	{
-	  /* We need to move up three frames:
+      else if (cuh_pattern == 0x9410001a || cuh_pattern == 0x9410001b)
+	/* This matches the call_user_handler pattern for Solaris 9 and
+	   for Solaris 8 running inside Solaris Containers respectively.
+	   We need to move up three frames:
 
 		<signal handler>	<-- context->cfa
 		__sighndlr
 		call_user_handler
 		sigacthandler
 		<kernel>
-	  */
-	  *nframes = 3;
-	}
+	*/
+	*nframes = 3;
+      else
+	/* This is the default Solaris 8 case.
+	   We need to move up two frames:
+
+		<signal handler>	<-- context->cfa
+		__sighndlr
+		sigacthandler
+		<kernel>
+	*/
+	*nframes = 2;
       return 1;
     }
 
@@ -322,7 +367,7 @@
       return _URC_NO_REASON;
     }
 
-  if (IS_SIGHANDLER (pc, (unsigned int *)fp->fr_savpc, &nframes))
+  if (IS_SIGHANDLER (pc, this_cfa, &nframes))
     {
       struct handler_args {
 	struct frame frwin;
Index: gcc/config/i386/i386.md
===================================================================
--- gcc/config/i386/i386.md	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/config/i386/i386.md	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1960,7 +1960,7 @@
 
 (define_insn "*movdi_internal_rex64"
   [(set (match_operand:DI 0 "nonimmediate_operand"
-	  "=r,r  ,r,m ,!m,*y,*y,?r ,m ,?*Ym,?*y,*x,*x,?r ,m,?*Yi,*x,?*x,?*Ym")
+	  "=r,r  ,r,m ,!o,*y,*y,?r ,m ,?*Ym,?*y,*x,*x,?r ,m,?*Yi,*x,?*x,?*Ym")
 	(match_operand:DI 1 "general_operand"
 	  "Z ,rem,i,re,n ,C ,*y,*Ym,*y,r   ,m  ,C ,*x,*Yi,*x,r  ,m ,*Ym,*x"))]
   "TARGET_64BIT && !(MEM_P (operands[0]) && MEM_P (operands[1]))"
@@ -2905,7 +2905,7 @@
 
 (define_insn "*movdf_internal_rex64"
   [(set (match_operand:DF 0 "nonimmediate_operand"
-		"=f,m,f,r ,m,!r,!m,Y2*x,Y2*x,Y2*x,m   ,Yi,r ")
+		"=f,m,f,r ,m,!r,!o,Y2*x,Y2*x,Y2*x,m   ,Yi,r ")
 	(match_operand:DF 1 "general_operand"
 		"fm,f,G,rm,r,F ,F ,C   ,Y2*x,m   ,Y2*x,r ,Yi"))]
   "TARGET_64BIT && !(MEM_P (operands[0]) && MEM_P (operands[1]))
@@ -3647,7 +3647,7 @@
 	 (match_operand:SI 1 "nonimmediate_operand" "rm,0,r   ,m  ,r   ,m")))]
   "TARGET_64BIT"
   "@
-   mov\t{%k1, %k0|%k0, %k1}
+   mov{l}\t{%1, %k0|%k0, %1}
    #
    movd\t{%1, %0|%0, %1}
    movd\t{%1, %0|%0, %1}
@@ -5103,7 +5103,7 @@
    && reload_completed
    && (SSE_REG_P (operands[0])
        || (GET_CODE (operands[0]) == SUBREG
-	   && SSE_REG_P (operands[0])))"
+	   && SSE_REG_P (SUBREG_REG (operands[0]))))"
   [(set (match_dup 0) (float:MODEF (match_dup 1)))])
 
 (define_split
@@ -5116,7 +5116,7 @@
    && reload_completed
    && (SSE_REG_P (operands[0])
        || (GET_CODE (operands[0]) == SUBREG
-	   && SSE_REG_P (operands[0])))"
+	   && SSE_REG_P (SUBREG_REG (operands[0]))))"
   [(set (match_dup 2) (match_dup 1))
    (set (match_dup 0) (float:MODEF (match_dup 2)))])
 
@@ -5207,7 +5207,7 @@
    && reload_completed
    && (SSE_REG_P (operands[0])
        || (GET_CODE (operands[0]) == SUBREG
-	   && SSE_REG_P (operands[0])))"
+	   && SSE_REG_P (SUBREG_REG (operands[0]))))"
   [(const_int 0)]
 {
   rtx op1 = operands[1];
@@ -5248,7 +5248,7 @@
    && reload_completed
    && (SSE_REG_P (operands[0])
        || (GET_CODE (operands[0]) == SUBREG
-	   && SSE_REG_P (operands[0])))"
+	   && SSE_REG_P (SUBREG_REG (operands[0]))))"
   [(const_int 0)]
 {
   operands[3] = simplify_gen_subreg (<ssevecmode>mode, operands[0],
@@ -5270,7 +5270,7 @@
    && reload_completed
    && (SSE_REG_P (operands[0])
        || (GET_CODE (operands[0]) == SUBREG
-	   && SSE_REG_P (operands[0])))"
+	   && SSE_REG_P (SUBREG_REG (operands[0]))))"
   [(const_int 0)]
 {
   rtx op1 = operands[1];
@@ -5314,7 +5314,7 @@
    && reload_completed
    && (SSE_REG_P (operands[0])
        || (GET_CODE (operands[0]) == SUBREG
-	   && SSE_REG_P (operands[0])))"
+	   && SSE_REG_P (SUBREG_REG (operands[0]))))"
   [(const_int 0)]
 {
   operands[3] = simplify_gen_subreg (<ssevecmode>mode, operands[0],
@@ -5375,7 +5375,7 @@
    && reload_completed
    && (SSE_REG_P (operands[0])
        || (GET_CODE (operands[0]) == SUBREG
-	   && SSE_REG_P (operands[0])))"
+	   && SSE_REG_P (SUBREG_REG (operands[0]))))"
   [(set (match_dup 0) (float:MODEF (match_dup 1)))])
 
 (define_insn "*float<SSEMODEI24:mode><MODEF:mode>2_sse_nointerunit"
@@ -5410,7 +5410,7 @@
    && reload_completed
    && (SSE_REG_P (operands[0])
        || (GET_CODE (operands[0]) == SUBREG
-	   && SSE_REG_P (operands[0])))"
+	   && SSE_REG_P (SUBREG_REG (operands[0]))))"
   [(set (match_dup 2) (match_dup 1))
    (set (match_dup 0) (float:MODEF (match_dup 2)))])
 
@@ -5423,7 +5423,7 @@
    && reload_completed
    && (SSE_REG_P (operands[0])
        || (GET_CODE (operands[0]) == SUBREG
-	   && SSE_REG_P (operands[0])))"
+	   && SSE_REG_P (SUBREG_REG (operands[0]))))"
   [(set (match_dup 0) (float:MODEF (match_dup 1)))])
 
 (define_insn "*float<SSEMODEI24:mode><X87MODEF:mode>2_i387_with_temp"
@@ -9222,7 +9222,7 @@
 			    (match_dup 0)))
    (set (match_dup 1)
 	(if_then_else:SWI48 (ne (reg:CCZ FLAGS_REG) (const_int 0))
-			    (match_operand:SWI48 3 "register_operand" "r")
+			    (match_operand:SWI48 3 "register_operand" "")
 			    (match_dup 1)))]
   "TARGET_CMOVE"
   "operands[4] = GEN_INT (GET_MODE_BITSIZE (<MODE>mode));")
@@ -14625,7 +14625,7 @@
 	emit_insn (gen_sse4_1_round<mode>2
 		   (operands[0], operands[1], GEN_INT (0x04)));
       else
-	ix86_expand_rint (operand0, operand1);
+	ix86_expand_rint (operands[0], operands[1]);
     }
   else
     {
@@ -14649,9 +14649,9 @@
   if (optimize_insn_for_size_p ())
     FAIL;
   if (TARGET_64BIT || (<MODE>mode != DFmode))
-    ix86_expand_round (operand0, operand1);
+    ix86_expand_round (operands[0], operands[1]);
   else
-    ix86_expand_rounddf_32 (operand0, operand1);
+    ix86_expand_rounddf_32 (operands[0], operands[1]);
   DONE;
 })
 
@@ -14796,7 +14796,7 @@
 {
   if (optimize_insn_for_size_p ())
     FAIL;
-  ix86_expand_lround (operand0, operand1);
+  ix86_expand_lround (operands[0], operands[1]);
   DONE;
 })
 
@@ -14871,9 +14871,9 @@
 	emit_insn (gen_sse4_1_round<mode>2
 		   (operands[0], operands[1], GEN_INT (0x01)));
       else if (TARGET_64BIT || (<MODE>mode != DFmode))
-	ix86_expand_floorceil (operand0, operand1, true);
+	ix86_expand_floorceil (operands[0], operands[1], true);
       else
-	ix86_expand_floorceildf_32 (operand0, operand1, true);
+	ix86_expand_floorceildf_32 (operands[0], operands[1], true);
     }
   else
     {
@@ -15053,7 +15053,7 @@
 {
   if (TARGET_64BIT && optimize_insn_for_size_p ())
     FAIL;
-  ix86_expand_lfloorceil (operand0, operand1, true);
+  ix86_expand_lfloorceil (operands[0], operands[1], true);
   DONE;
 })
 
@@ -15128,9 +15128,9 @@
       else if (optimize_insn_for_size_p ())
 	FAIL;
       else if (TARGET_64BIT || (<MODE>mode != DFmode))
-	ix86_expand_floorceil (operand0, operand1, false);
+	ix86_expand_floorceil (operands[0], operands[1], false);
       else
-	ix86_expand_floorceildf_32 (operand0, operand1, false);
+	ix86_expand_floorceildf_32 (operands[0], operands[1], false);
     }
   else
     {
@@ -15308,7 +15308,7 @@
   "SSE_FLOAT_MODE_P (<MODEF:MODE>mode) && TARGET_SSE_MATH
    && !flag_trapping_math"
 {
-  ix86_expand_lfloorceil (operand0, operand1, false);
+  ix86_expand_lfloorceil (operands[0], operands[1], false);
   DONE;
 })
 
@@ -15383,9 +15383,9 @@
       else if (optimize_insn_for_size_p ())
 	FAIL;
       else if (TARGET_64BIT || (<MODE>mode != DFmode))
-	ix86_expand_trunc (operand0, operand1);
+	ix86_expand_trunc (operands[0], operands[1]);
       else
-	ix86_expand_truncdf_32 (operand0, operand1);
+	ix86_expand_truncdf_32 (operands[0], operands[1]);
     }
   else
     {
@@ -18285,8 +18285,8 @@
 		     (match_operand:SI 3 "const_int_operand" "i")]
 		    UNSPECV_LWPVAL_INTRINSIC)]
   "TARGET_LWP"
-  "/* Avoid unused variable warning.  */
-   (void) operand0;")
+  ;; Avoid unused variable warning.
+  "(void) operands[0];")
 
 (define_insn "*lwp_lwpval<mode>3_1"
   [(unspec_volatile [(match_operand:SWI48 0 "register_operand" "r")
Index: gcc/config/i386/sse.md
===================================================================
--- gcc/config/i386/sse.md	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/config/i386/sse.md	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -4521,15 +4521,14 @@
   [(set (match_operand:V4DF 0 "register_operand"         "=x,x")
 	(vec_select:V4DF
 	  (vec_concat:V8DF
-	    (match_operand:V4DF 1 "nonimmediate_operand" "xm,x")
-	    (match_operand:V4DF 2 "nonimmediate_operand" " 1,xm"))
+	    (match_operand:V4DF 1 "nonimmediate_operand" " x,m")
+	    (match_operand:V4DF 2 "nonimmediate_operand" "xm,1"))
 	  (parallel [(const_int 0) (const_int 4)
 		     (const_int 2) (const_int 6)])))]
-  "TARGET_AVX
-   && (!MEM_P (operands[1]) || rtx_equal_p (operands[1], operands[2]))"
+  "TARGET_AVX"
   "@
-   vmovddup\t{%1, %0|%0, %1}
-   vunpcklpd\t{%2, %1, %0|%0, %1, %2}"
+   vunpcklpd\t{%2, %1, %0|%0, %1, %2}
+   vmovddup\t{%1, %0|%0, %1}"
   [(set_attr "type" "sselog")
    (set_attr "prefix" "vex")
    (set_attr "mode" "V4DF")])
Index: gcc/config/i386/freebsd.h
===================================================================
--- gcc/config/i386/freebsd.h	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/config/i386/freebsd.h	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -147,3 +147,6 @@
 #if FBSD_MAJOR >= 6
 #define SUBTARGET32_DEFAULT_CPU "i486"
 #endif
+
+#define TARGET_ASM_FILE_END file_end_indicate_exec_stack
+
Index: gcc/config/i386/driver-i386.c
===================================================================
--- gcc/config/i386/driver-i386.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/config/i386/driver-i386.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -507,7 +507,7 @@
 	processor = PROCESSOR_AMDFAM10;
       else if (has_sse2 || has_longmode)
 	processor = PROCESSOR_K8;
-      else if (has_3dnowp)
+      else if (has_3dnowp && family == 6)
 	processor = PROCESSOR_ATHLON;
       else if (has_mmx)
 	processor = PROCESSOR_K6;
Index: gcc/config/i386/avxintrin.h
===================================================================
--- gcc/config/i386/avxintrin.h	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/config/i386/avxintrin.h	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -759,7 +759,7 @@
 
 #ifdef __x86_64__
 extern __inline __m256i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
-_mm256_insert_epi64 (__m256i __X, int __D, int const __N)
+_mm256_insert_epi64 (__m256i __X, long long __D, int const __N)
 {
   __m128i __Y = _mm256_extractf128_si256 (__X, __N >> 1);
   __Y = _mm_insert_epi64 (__Y, __D, __N % 2);
Index: gcc/config/i386/i386.c
===================================================================
--- gcc/config/i386/i386.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/config/i386/i386.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -16329,7 +16329,6 @@
   basic_block bb = BLOCK_FOR_INSN (insn);
   int distance = 0;
   df_ref *def_rec;
-  enum attr_type insn_type;
 
   if (insn != BB_HEAD (bb))
     {
@@ -16345,8 +16344,8 @@
                     && (regno1 == DF_REF_REGNO (*def_rec)
 			|| regno2 == DF_REF_REGNO (*def_rec)))
 		  {
-		    insn_type = get_attr_type (prev);
-		    if (insn_type != TYPE_LEA)
+		    if (recog_memoized (prev) < 0
+			|| get_attr_type (prev) != TYPE_LEA)
 		      goto done;
 		  }
 	    }
@@ -16385,8 +16384,8 @@
 			&& (regno1 == DF_REF_REGNO (*def_rec)
 			    || regno2 == DF_REF_REGNO (*def_rec)))
 		      {
-			insn_type = get_attr_type (prev);
-			if (insn_type != TYPE_LEA)
+			if (recog_memoized (prev) < 0
+			    || get_attr_type (prev) != TYPE_LEA)
 			  goto done;
 		      }
 		}
Index: gcc/config/avr/libgcc.S
===================================================================
--- gcc/config/avr/libgcc.S	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/config/avr/libgcc.S	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -582,7 +582,16 @@
 	push r17
 	push r28
 	push r29
+#if defined (__AVR_HAVE_8BIT_SP__)
+;; FIXME: __AVR_HAVE_8BIT_SP__ is set on device level, not on core level
+;;        so this lines are dead code.  To make it work, devices without
+;;        SP_H must get their own multilib(s), see PR51345.
 	in	r28,__SP_L__
+	sub	r28,r26
+	clr	r29
+	out	__SP_L__,r28
+#else
+	in	r28,__SP_L__
 	in	r29,__SP_H__
 	sub	r28,r26
 	sbc	r29,r27
@@ -591,6 +600,7 @@
 	out	__SP_H__,r29
 	out	__SREG__,__tmp_reg__
 	out	__SP_L__,r28
+#endif
 #if defined (__AVR_HAVE_EIJMP_EICALL__)
 	eijmp
 #else
@@ -625,6 +635,15 @@
 	ldd	r16,Y+4
 	ldd	r17,Y+3
 	ldd	r26,Y+2
+#if defined (__AVR_HAVE_8BIT_SP__)
+;; FIXME: __AVR_HAVE_8BIT_SP__ is set on device level, not on core level
+;;        so this lines are dead code.  To make it work, devices without
+;;        SP_H must get their own multilib(s).
+	ldd	r29,Y+1
+	add	r28,r30
+	out	__SP_L__,r28
+	mov	r28, r26
+#else
 	ldd	r27,Y+1
 	add	r28,r30
 	adc	r29,__zero_reg__
@@ -635,6 +654,7 @@
 	out	__SP_L__,r28
 	mov_l	r28, r26
 	mov_h	r29, r27
+#endif
 	ret
 .endfunc
 #endif /* defined (L_epilogue) */
Index: gcc/config/avr/avr.md
===================================================================
--- gcc/config/avr/avr.md	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/config/avr/avr.md	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -299,7 +299,7 @@
   [(set (match_operand:HI 0 "stack_register_operand" "=q")
         (unspec_volatile:HI [(match_operand:HI 1 "register_operand"  "r")] 
 			    UNSPECV_WRITE_SP_IRQ_OFF))]
-  ""
+  "!AVR_HAVE_8BIT_SP"
   "out __SP_H__, %B1
 	out __SP_L__, %A1"
   [(set_attr "length" "2")
@@ -309,7 +309,7 @@
   [(set (match_operand:HI 0 "stack_register_operand" "=q")
         (unspec_volatile:HI [(match_operand:HI 1 "register_operand"  "r")] 
 			    UNSPECV_WRITE_SP_IRQ_ON))]
-  ""
+  "!AVR_HAVE_8BIT_SP"
   "cli
         out __SP_H__, %B1
 	sei
Index: gcc/config/avr/avr-devices.c
===================================================================
--- gcc/config/avr/avr-devices.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/config/avr/avr-devices.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -70,7 +70,7 @@
   { "attiny2313a",          ARCH_AVR25, "__AVR_ATtiny2313A__",      1, 0x0060, "tn2313a" },
   { "attiny24",             ARCH_AVR25, "__AVR_ATtiny24__",         1, 0x0060, "tn24" },
   { "attiny24a",            ARCH_AVR25, "__AVR_ATtiny24A__",        1, 0x0060, "tn24a" },
-  { "attiny4313",           ARCH_AVR25, "__AVR_ATtiny4313__",       1, 0x0060, "tn4313" },
+  { "attiny4313",           ARCH_AVR25, "__AVR_ATtiny4313__",       0, 0x0060, "tn4313" },
   { "attiny44",             ARCH_AVR25, "__AVR_ATtiny44__",         0, 0x0060, "tn44" },
   { "attiny44a",            ARCH_AVR25, "__AVR_ATtiny44A__",        0, 0x0060, "tn44a" },
   { "attiny84",             ARCH_AVR25, "__AVR_ATtiny84__",         0, 0x0060, "tn84" },
@@ -88,7 +88,7 @@
   { "attiny87",             ARCH_AVR25, "__AVR_ATtiny87__",         0, 0x0100, "tn87" },
   { "attiny48",             ARCH_AVR25, "__AVR_ATtiny48__",         0, 0x0100, "tn48" },
   { "attiny88",             ARCH_AVR25, "__AVR_ATtiny88__",         0, 0x0100, "tn88" },
-  { "at86rf401",            ARCH_AVR25, "__AVR_AT86RF401__",        1, 0x0060, "86401" },
+  { "at86rf401",            ARCH_AVR25, "__AVR_AT86RF401__",        0, 0x0060, "86401" },
     /* Classic, > 8K, <= 64K.  */
   { "avr3",                 ARCH_AVR3, NULL,                        0, 0x0060, "43355" },
   { "at43usb355",           ARCH_AVR3, "__AVR_AT43USB355__",        0, 0x0060, "43355" },
Index: gcc/config/avr/avr.c
===================================================================
--- gcc/config/avr/avr.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/config/avr/avr.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1879,9 +1879,12 @@
 	    }
 	  else if (test_hard_reg_class (STACK_REG, src))
 	    {
-	      *l = 2;	
-	      return (AS2 (in,%A0,__SP_L__) CR_TAB
-		      AS2 (in,%B0,__SP_H__));
+              *l = 2;
+              return AVR_HAVE_8BIT_SP
+                ? (AS2 (in,%A0,__SP_L__) CR_TAB
+                   AS1 (clr,%B0))
+                : (AS2 (in,%A0,__SP_L__) CR_TAB
+                   AS2 (in,%B0,__SP_H__));
 	    }
 
 	  if (AVR_HAVE_MOVW)
@@ -5151,6 +5154,7 @@
   if (new_decl_p
       && decl && DECL_P (decl)
       && NULL_TREE == DECL_INITIAL (decl)
+      && !DECL_EXTERNAL (decl)
       && avr_progmem_p (decl, DECL_ATTRIBUTES (decl)))
     {
       warning (OPT_Wuninitialized,
@@ -5173,10 +5177,10 @@
 
   default_file_start ();
 
-/*  fprintf (asm_out_file, "\t.arch %s\n", avr_mcu_name);*/
-  fputs ("__SREG__ = 0x3f\n"
-	 "__SP_H__ = 0x3e\n"
-	 "__SP_L__ = 0x3d\n", asm_out_file);
+  fputs ("__SREG__ = 0x3f\n", asm_out_file);
+  if (!AVR_HAVE_8BIT_SP)
+    fputs ("__SP_H__ = 0x3e\n", asm_out_file);
+  fputs ("__SP_L__ = 0x3d\n", asm_out_file);
   
   fputs ("__tmp_reg__ = 0\n" 
          "__zero_reg__ = 1\n", asm_out_file);
Index: gcc/config/rs6000/rs6000.c
===================================================================
--- gcc/config/rs6000/rs6000.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/config/rs6000/rs6000.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -2612,6 +2612,7 @@
      off.  */
   rs6000_altivec_abi = 1;
   TARGET_ALTIVEC_VRSAVE = 1;
+  rs6000_current_abi = ABI_DARWIN;
 
   if (DEFAULT_ABI == ABI_DARWIN
       && TARGET_64BIT)
@@ -6824,6 +6825,7 @@
 #if TARGET_MACHO
       && DEFAULT_ABI == ABI_DARWIN
       && (flag_pic || MACHO_DYNAMIC_NO_PIC_P)
+      && machopic_symbol_defined_p (x)
 #else
       && DEFAULT_ABI == ABI_V4
       && !flag_pic
@@ -16613,7 +16615,7 @@
       if (TARGET_RELOCATABLE
 	  && in_section != toc_section
 	  && in_section != text_section
-	  && !unlikely_text_section_p (in_section)
+	  && (in_section && (in_section->common.flags & SECTION_CODE)) == 0
 	  && !recurse
 	  && GET_CODE (x) != CONST_INT
 	  && GET_CODE (x) != CONST_DOUBLE
@@ -20227,7 +20229,7 @@
 {
   /* This blockage is needed so that sched doesn't decide to move
      the sp change before the register restores.  */
-  if (frame_reg_rtx != sp_reg_rtx
+  if (DEFAULT_ABI == ABI_V4
       || (TARGET_SPE_ABI
 	  && info->spe_64bit_regs_used != 0
 	  && info->first_gp_reg_save != 32))
@@ -20644,56 +20646,52 @@
     {
       int i;
       rtx spe_save_area_ptr;
- 
+      int save_ptr_to_sp;
+      int ool_adjust = 0;
+
       /* Determine whether we can address all of the registers that need
-	 to be saved with an offset from the stack pointer that fits in
+	 to be saved with an offset from frame_reg_rtx that fits in
 	 the small const field for SPE memory instructions.  */
-      int spe_regs_addressable_via_sp
-	= (SPE_CONST_OFFSET_OK(info->spe_gp_save_offset + sp_offset
-			       + (32 - info->first_gp_reg_save - 1) * reg_size)
+      int spe_regs_addressable
+	= (SPE_CONST_OFFSET_OK (info->spe_gp_save_offset + sp_offset
+				+ reg_size * (32 - info->first_gp_reg_save - 1))
 	   && saving_GPRs_inline);
       int spe_offset;
- 
-      if (spe_regs_addressable_via_sp)
+
+      if (spe_regs_addressable)
 	{
 	  spe_save_area_ptr = frame_reg_rtx;
+	  save_ptr_to_sp = info->total_size - sp_offset;
 	  spe_offset = info->spe_gp_save_offset + sp_offset;
 	}
       else
 	{
 	  /* Make r11 point to the start of the SPE save area.  We need
 	     to be careful here if r11 is holding the static chain.  If
-	     it is, then temporarily save it in r0.  We would use r0 as
-	     our base register here, but using r0 as a base register in
-	     loads and stores means something different from what we
-	     would like.  */
-	  int ool_adjust = (saving_GPRs_inline
-			    ? 0
-			    : (info->first_gp_reg_save
-			       - (FIRST_SAVRES_REGISTER+1))*8);
-	  HOST_WIDE_INT offset = (info->spe_gp_save_offset
-				  + sp_offset - ool_adjust);
+	     it is, then temporarily save it in r0.  */
+	  int offset;
 
+	  if (!saving_GPRs_inline)
+	    ool_adjust = 8 * (info->first_gp_reg_save
+			      - (FIRST_SAVRES_REGISTER + 1));
+	  offset = info->spe_gp_save_offset + sp_offset - ool_adjust;
+	  spe_save_area_ptr = gen_rtx_REG (Pmode, 11);
+	  save_ptr_to_sp = info->total_size - sp_offset + offset;
+	  spe_offset = 0;
+
 	  if (using_static_chain_p)
 	    {
 	      rtx r0 = gen_rtx_REG (Pmode, 0);
 	      gcc_assert (info->first_gp_reg_save > 11);
- 
-	      emit_move_insn (r0, gen_rtx_REG (Pmode, 11));
+
+	      emit_move_insn (r0, spe_save_area_ptr);
 	    }
- 
-	  spe_save_area_ptr = gen_rtx_REG (Pmode, 11);
-	  insn = emit_insn (gen_addsi3 (spe_save_area_ptr,
-					frame_reg_rtx,
-					GEN_INT (offset)));
-	  /* We need to make sure the move to r11 gets noted for
-	     properly outputting unwind information.  */
-	  if (!saving_GPRs_inline)
-	    rs6000_frame_related (insn, frame_reg_rtx, offset,
-				  NULL_RTX, NULL_RTX);
-	  spe_offset = 0;
+	  emit_insn (gen_addsi3 (spe_save_area_ptr,
+				 frame_reg_rtx, GEN_INT (offset)));
+	  if (REGNO (frame_reg_rtx) == 11)
+	    sp_offset = -info->spe_gp_save_offset + ool_adjust;
 	}
- 
+
       if (saving_GPRs_inline)
 	{
 	  for (i = 0; i < 32 - info->first_gp_reg_save; i++)
@@ -20705,36 +20703,34 @@
 		/* We're doing all this to ensure that the offset fits into
 		   the immediate offset of 'evstdd'.  */
 		gcc_assert (SPE_CONST_OFFSET_OK (reg_size * i + spe_offset));
- 
+
 		offset = GEN_INT (reg_size * i + spe_offset);
 		addr = gen_rtx_PLUS (Pmode, spe_save_area_ptr, offset);
 		mem = gen_rtx_MEM (V2SImode, addr);
-  
+
 		insn = emit_move_insn (mem, reg);
-	   
-		rs6000_frame_related (insn, spe_save_area_ptr,
-				      info->spe_gp_save_offset
-				      + sp_offset + reg_size * i,
-				      offset, const0_rtx);
+
+		rs6000_frame_related (insn,
+				      spe_save_area_ptr, save_ptr_to_sp,
+				      NULL_RTX, NULL_RTX);
 	      }
 	}
       else
 	{
 	  rtx par;
 
-	  par = rs6000_make_savres_rtx (info, gen_rtx_REG (Pmode, 11),
-					0, reg_mode,
+	  par = rs6000_make_savres_rtx (info, spe_save_area_ptr,
+					ool_adjust, reg_mode,
 					/*savep=*/true, /*gpr=*/true,
 					/*lr=*/false);
 	  insn = emit_insn (par);
-	  rs6000_frame_related (insn, frame_ptr_rtx, info->total_size,
+	  rs6000_frame_related (insn, spe_save_area_ptr, save_ptr_to_sp,
 				NULL_RTX, NULL_RTX);
 	}
-					
- 
+
       /* Move the static chain pointer back.  */
-      if (using_static_chain_p && !spe_regs_addressable_via_sp)
-	emit_move_insn (gen_rtx_REG (Pmode, 11), gen_rtx_REG (Pmode, 0));
+      if (using_static_chain_p && !spe_regs_addressable)
+	emit_move_insn (spe_save_area_ptr, gen_rtx_REG (Pmode, 0));
     }
   else if (!WORLD_SAVE_P (info) && !saving_GPRs_inline)
     {
@@ -20743,10 +20739,12 @@
       /* Need to adjust r11 (r12) if we saved any FPRs.  */
       if (info->first_fp_reg_save != 64)
         {
-	  rtx dest_reg = gen_rtx_REG (reg_mode, DEFAULT_ABI == ABI_AIX
-				      ? 12 : 11);
-	  rtx offset = GEN_INT (sp_offset
-                                + (-8 * (64-info->first_fp_reg_save)));
+	  rtx dest_reg = gen_rtx_REG (Pmode, DEFAULT_ABI == ABI_AIX ? 12 : 11);
+	  int save_off = 8 * (64 - info->first_fp_reg_save);
+	  rtx offset = GEN_INT (sp_offset - save_off);
+
+	  if (REGNO (dest_reg) == REGNO (frame_reg_rtx))
+	    sp_offset = save_off;
 	  emit_insn (gen_add3_insn (dest_reg, frame_reg_rtx, offset));
         }
 
@@ -21622,40 +21620,39 @@
       && info->first_gp_reg_save != 32)
     {
       /* Determine whether we can address all of the registers that need
-         to be saved with an offset from the stack pointer that fits in
-         the small const field for SPE memory instructions.  */
-      int spe_regs_addressable_via_sp
-	= (SPE_CONST_OFFSET_OK(info->spe_gp_save_offset + sp_offset
-			       + (32 - info->first_gp_reg_save - 1) * reg_size)
+	 to be saved with an offset from frame_reg_rtx that fits in
+	 the small const field for SPE memory instructions.  */
+      int spe_regs_addressable
+	= (SPE_CONST_OFFSET_OK (info->spe_gp_save_offset + sp_offset
+				+ reg_size * (32 - info->first_gp_reg_save - 1))
 	   && restoring_GPRs_inline);
       int spe_offset;
+      int ool_adjust = 0;
 
-      if (spe_regs_addressable_via_sp)
+      if (spe_regs_addressable)
 	spe_offset = info->spe_gp_save_offset + sp_offset;
       else
-        {
+	{
 	  rtx old_frame_reg_rtx = frame_reg_rtx;
-          /* Make r11 point to the start of the SPE save area.  We worried about
-             not clobbering it when we were saving registers in the prologue.
-             There's no need to worry here because the static chain is passed
-             anew to every function.  */
-	  int ool_adjust = (restoring_GPRs_inline
-			    ? 0
-			    : (info->first_gp_reg_save
-			       - (FIRST_SAVRES_REGISTER+1))*8);
+	  /* Make r11 point to the start of the SPE save area.  We worried about
+	     not clobbering it when we were saving registers in the prologue.
+	     There's no need to worry here because the static chain is passed
+	     anew to every function.  */
 
-	  if (frame_reg_rtx == sp_reg_rtx)
-	    frame_reg_rtx = gen_rtx_REG (Pmode, 11);
-          emit_insn (gen_addsi3 (frame_reg_rtx, old_frame_reg_rtx,
+	  if (!restoring_GPRs_inline)
+	    ool_adjust = 8 * (info->first_gp_reg_save
+			      - (FIRST_SAVRES_REGISTER + 1));
+	  frame_reg_rtx = gen_rtx_REG (Pmode, 11);
+	  emit_insn (gen_addsi3 (frame_reg_rtx, old_frame_reg_rtx,
 				 GEN_INT (info->spe_gp_save_offset
 					  + sp_offset
 					  - ool_adjust)));
 	  /* Keep the invariant that frame_reg_rtx + sp_offset points
 	     at the top of the stack frame.  */
-	  sp_offset = -info->spe_gp_save_offset;
+	  sp_offset = -info->spe_gp_save_offset + ool_adjust;
 
-          spe_offset = 0;
-        }
+	  spe_offset = 0;
+	}
 
       if (restoring_GPRs_inline)
 	{
@@ -21695,8 +21692,8 @@
 	{
 	  rtx par;
 
-	  par = rs6000_make_savres_rtx (info, gen_rtx_REG (Pmode, 11),
-					0, reg_mode,
+	  par = rs6000_make_savres_rtx (info, frame_reg_rtx,
+					ool_adjust, reg_mode,
 					/*savep=*/false, /*gpr=*/true,
 					/*lr=*/true);
 	  emit_jump_insn (par);
@@ -21717,12 +21714,12 @@
 				 sp_offset, can_use_exit);
       else
 	{
-	  emit_insn (gen_add3_insn (gen_rtx_REG (Pmode, DEFAULT_ABI == ABI_AIX
-							? 12 : 11),
-				    frame_reg_rtx,
+	  rtx src_reg = gen_rtx_REG (Pmode, DEFAULT_ABI == ABI_AIX ? 12 : 11);
+
+	  emit_insn (gen_add3_insn (src_reg, frame_reg_rtx,
 				    GEN_INT (sp_offset - info->fp_size)));
-	  if (REGNO (frame_reg_rtx) == 11)
-	    sp_offset += info->fp_size;
+	  if (REGNO (frame_reg_rtx) == REGNO (src_reg))
+	    sp_offset = info->fp_size;
 	}
 
       par = rs6000_make_savres_rtx (info, frame_reg_rtx,
@@ -27763,7 +27760,7 @@
 		    if (strcmp (r, rs6000_opt_vars[i].name) == 0)
 		      {
 			size_t j = rs6000_opt_vars[i].global_offset;
-			((int *) &global_options)[j] = !invert;
+			*((int *) ((char *)&global_options + j)) = !invert;
 			error_p = false;
 			break;
 		      }
Index: gcc/config/rs6000/rs6000.md
===================================================================
--- gcc/config/rs6000/rs6000.md	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/config/rs6000/rs6000.md	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -12241,8 +12241,8 @@
   "
 {
   operands[3] = gen_reg_rtx (SImode);
-  operands[4] = gen_rtx_MEM (DImode,
-			     gen_rtx_PLUS (DImode, stack_pointer_rtx,
+  operands[4] = gen_rtx_MEM (SImode,
+			     gen_rtx_PLUS (SImode, stack_pointer_rtx,
 					   GEN_INT (20)));
 
   operands[5] = gen_rtx_MEM (SImode,
Index: gcc/config/darwin.c
===================================================================
--- gcc/config/darwin.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/config/darwin.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1753,19 +1753,51 @@
   return (!strncmp ((const char *)p, "_OBJC_", 6));
 }
 
-/* LTO support for Mach-O.  */
+/* LTO support for Mach-O.
 
-/* Section names for LTO sections.  */
-static unsigned int lto_section_names_offset = 0;
+   This version uses three mach-o sections to encapsulate the (unlimited
+   number of) lto sections.
 
-/* This is the obstack which we use to allocate the many strings.  */
-static struct obstack lto_section_names_obstack;
+   __GNU_LTO, __lto_sections  contains the concatented GNU LTO section data.
+   __GNU_LTO, __section_names contains the GNU LTO section names.
+   __GNU_LTO, __section_index contains an array of values that index these.
 
-/* Segment name for LTO sections.  */
+   Indexed thus:
+     <section offset from the start of __GNU_LTO, __lto_sections>,
+     <section length>
+     <name offset from the start of __GNU_LTO, __section_names,
+     <name length>.
+
+   At present, for both m32 and m64 mach-o files each of these fields is
+   represented  by a uint32_t.  This is because, AFAICT, a mach-o object
+   cannot exceed 4Gb because the section_64 offset field (see below) is 32bits.
+
+    uint32_t offset;
+   "offset  An integer specifying the offset to this section in the file."  */
+
+/* Count lto section numbers.  */
+static unsigned int lto_section_num = 0;
+
+/* A vector of information about LTO sections, at present, we only have
+   the name.  TODO: see if we can get the data length somehow.  */
+typedef struct GTY (()) darwin_lto_section_e {
+  const char *sectname;
+} darwin_lto_section_e ;
+DEF_VEC_O(darwin_lto_section_e);
+DEF_VEC_ALLOC_O(darwin_lto_section_e, gc);
+
+static GTY (()) VEC (darwin_lto_section_e, gc) * lto_section_names;
+
+/* Segment for LTO data.  */
 #define LTO_SEGMENT_NAME "__GNU_LTO"
 
-/* Section name for LTO section names section.  */
-#define LTO_NAMES_SECTION "__section_names"
+/* Section wrapper scheme (used here to wrap the unlimited number of LTO
+   sections into three Mach-O ones).
+   NOTE: These names MUST be kept in sync with those in
+	 libiberty/simple-object-mach-o.  */
+#define LTO_SECTS_SECTION "__wrapper_sects"
+#define LTO_NAMES_SECTION "__wrapper_names"
+#define LTO_INDEX_SECTION "__wrapper_index"
 
 /* File to temporarily store LTO data.  This is appended to asm_out_file
    in darwin_end_file.  */
@@ -1808,37 +1840,38 @@
 			  unsigned int flags,
 			  tree decl ATTRIBUTE_UNUSED)
 {
-  /* LTO sections go in a special segment __GNU_LTO.  We want to replace the
-     section name with something we can use to represent arbitrary-length
-     names (section names in Mach-O are at most 16 characters long).  */
+  /* LTO sections go in a special section that encapsulates the (unlimited)
+     number of GNU LTO sections within a single mach-o one.  */
   if (strncmp (name, LTO_SECTION_NAME_PREFIX,
 	       strlen (LTO_SECTION_NAME_PREFIX)) == 0)
     {
+      darwin_lto_section_e e;
       /* We expect certain flags to be set...  */
       gcc_assert ((flags & (SECTION_DEBUG | SECTION_NAMED))
 		  == (SECTION_DEBUG | SECTION_NAMED));
 
-      /* Add the section name to the things to output when we end the
-	 current assembler output file.
-	 This is all not very efficient, but that doesn't matter -- this
-	 shouldn't be a hot path in the compiler...  */
-      obstack_1grow (&lto_section_names_obstack, '\t');
-      obstack_grow (&lto_section_names_obstack, ".ascii ", 7);
-      obstack_1grow (&lto_section_names_obstack, '"');
-      obstack_grow (&lto_section_names_obstack, name, strlen (name));
-      obstack_grow (&lto_section_names_obstack, "\\0\"\n", 4);
-
-      /* Output the dummy section name.  */
-      fprintf (asm_out_file, "\t# %s\n", name);
-      fprintf (asm_out_file, "\t.section %s,__%08X,regular,debug\n",
-	       LTO_SEGMENT_NAME, lto_section_names_offset);
-
-      /* Update the offset for the next section name.  Make sure we stay
-	 within reasonable length.  */  
-      lto_section_names_offset += strlen (name) + 1;
-      gcc_assert (lto_section_names_offset > 0
-		  && lto_section_names_offset < ((unsigned) 1 << 31));
-    }
+      /* Switch to our combined section.  */
+      fprintf (asm_out_file, "\t.section %s,%s,regular,debug\n",
+	       LTO_SEGMENT_NAME, LTO_SECTS_SECTION);
+      /* Output a label for the start of this sub-section.  */
+      fprintf (asm_out_file, "L_GNU_LTO%d:\t;# %s\n",
+	       lto_section_num, name);
+      /* We have to jump through hoops to get the values of the intra-section
+         offsets... */
+      fprintf (asm_out_file, "\t.set L$gnu$lto$offs%d,L_GNU_LTO%d-L_GNU_LTO0\n",
+	       lto_section_num, lto_section_num);
+      fprintf (asm_out_file,
+	       "\t.set L$gnu$lto$size%d,L_GNU_LTO%d-L_GNU_LTO%d\n",
+	       lto_section_num, lto_section_num+1, lto_section_num);
+      lto_section_num++;
+      e.sectname = xstrdup (name);
+      /* Keep the names, we'll need to make a table later.
+         TODO: check that we do not revisit sections, that would break
+         the assumption of how this is done.  */
+      if (lto_section_names == NULL)
+        lto_section_names = VEC_alloc (darwin_lto_section_e, gc, 16);
+      VEC_safe_push (darwin_lto_section_e, gc, lto_section_names, &e);
+   }
   else if (strncmp (name, "__DWARF,", 8) == 0)
     darwin_asm_dwarf_section (name, flags, decl);
   else
@@ -2711,16 +2744,12 @@
   darwin_asm_output_dwarf_delta (file, size, lab, sname);
 }
 
-/* Called from the within the TARGET_ASM_FILE_START for each target. 
-  Initialize the stuff we need for LTO long section names support.  */
+/* Called from the within the TARGET_ASM_FILE_START for each target.  */
 
 void
 darwin_file_start (void)
 {
-  /* We fill this obstack with the complete section text for the lto section
-     names to write in darwin_file_end.  */
-  obstack_init (&lto_section_names_obstack);
-  lto_section_names_offset = 0;
+  /* Nothing to do.  */
 }
 
 /* Called for the TARGET_ASM_FILE_END hook.
@@ -2731,8 +2760,6 @@
 void
 darwin_file_end (void)
 {
-  const char *lto_section_names;
-
   machopic_finish (asm_out_file);
   if (strcmp (lang_hooks.name, "GNU C++") == 0)
     {
@@ -2762,6 +2789,13 @@
 	  lto_asm_txt = buf = (char *) xmalloc (n + 1);
 	  while (fgets (lto_asm_txt, n, lto_asm_out_file))
 	    fputs (lto_asm_txt, asm_out_file);
+	  /* Put a termination label.  */
+	  fprintf (asm_out_file, "\t.section %s,%s,regular,debug\n",
+		   LTO_SEGMENT_NAME, LTO_SECTS_SECTION);
+	  fprintf (asm_out_file, "L_GNU_LTO%d:\t;# end of lto\n",
+		   lto_section_num);
+	  /* Make sure our termination label stays in this section.  */
+	  fputs ("\t.space\t1\n", asm_out_file);
 	}
 
       /* Remove the temporary file.  */
@@ -2770,21 +2804,50 @@
       free (lto_asm_out_name);
     }
 
-  /* Finish the LTO section names obstack.  Don't output anything if
-     there are no recorded section names.  */
-  obstack_1grow (&lto_section_names_obstack, '\0');
-  lto_section_names = XOBFINISH (&lto_section_names_obstack, const char *);
-  if (strlen (lto_section_names) > 0)
+  /* Output the names and indices.  */
+  if (lto_section_names && VEC_length (darwin_lto_section_e, lto_section_names))
     {
-      fprintf (asm_out_file,
-	       "\t.section %s,%s,regular,debug\n",
+      int count;
+      darwin_lto_section_e *ref;
+      /* For now, we'll make the offsets 4 bytes and unaligned - we'll fix
+         the latter up ourselves.  */
+      const char *op = integer_asm_op (4,0);
+
+      /* Emit the names.  */
+      fprintf (asm_out_file, "\t.section %s,%s,regular,debug\n",
 	       LTO_SEGMENT_NAME, LTO_NAMES_SECTION);
-      fprintf (asm_out_file,
-	       "\t# Section names in %s are offsets into this table\n",
-	       LTO_SEGMENT_NAME);
-      fprintf (asm_out_file, "%s\n", lto_section_names);
+      FOR_EACH_VEC_ELT (darwin_lto_section_e, lto_section_names, count, ref)
+	{
+	  fprintf (asm_out_file, "L_GNU_LTO_NAME%d:\n", count);
+         /* We have to jump through hoops to get the values of the intra-section
+            offsets... */
+	  fprintf (asm_out_file,
+		   "\t.set L$gnu$lto$noff%d,L_GNU_LTO_NAME%d-L_GNU_LTO_NAME0\n",
+		   count, count);
+	  fprintf (asm_out_file,
+		   "\t.set L$gnu$lto$nsiz%d,L_GNU_LTO_NAME%d-L_GNU_LTO_NAME%d\n",
+		   count, count+1, count);
+	  fprintf (asm_out_file, "\t.asciz\t\"%s\"\n", ref->sectname);
+	}
+      fprintf (asm_out_file, "L_GNU_LTO_NAME%d:\t;# end\n", lto_section_num);
+      /* make sure our termination label stays in this section.  */
+      fputs ("\t.space\t1\n", asm_out_file);
+
+      /* Emit the Index.  */
+      fprintf (asm_out_file, "\t.section %s,%s,regular,debug\n",
+	       LTO_SEGMENT_NAME, LTO_INDEX_SECTION);
+      fputs ("\t.align\t2\n", asm_out_file);
+      fputs ("# Section offset, Section length, Name offset, Name length\n",
+	     asm_out_file);
+      FOR_EACH_VEC_ELT (darwin_lto_section_e, lto_section_names, count, ref)
+	{
+	  fprintf (asm_out_file, "%s L$gnu$lto$offs%d\t;# %s\n",
+		   op, count, ref->sectname);
+	  fprintf (asm_out_file, "%s L$gnu$lto$size%d\n", op, count);
+	  fprintf (asm_out_file, "%s L$gnu$lto$noff%d\n", op, count);
+	  fprintf (asm_out_file, "%s L$gnu$lto$nsiz%d\n", op, count);
+	}
     }
-  obstack_free (&lto_section_names_obstack, NULL);
 
   /* If we have section anchors, then we must prevent the linker from
      re-arranging data.  */
Index: gcc/config/arm/thumb2.md
===================================================================
--- gcc/config/arm/thumb2.md	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/config/arm/thumb2.md	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -257,7 +257,7 @@
 	(not:SI (match_operator:SI 1 "arm_comparison_operator"
 		 [(match_operand 2 "cc_register" "") (const_int 0)])))]
   "TARGET_THUMB2"
-  "ite\\t%D1\;mov%D1\\t%0, #0\;mvn%d1\\t%0, #1"
+  "ite\\t%D1\;mvn%D1\\t%0, #0\;mvn%d1\\t%0, #1"
   [(set_attr "conds" "use")
    (set_attr "length" "10")]
 )
Index: gcc/config/arm/arm.c
===================================================================
--- gcc/config/arm/arm.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/config/arm/arm.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -3570,6 +3570,10 @@
       add_libcall (libcall_htab,
 		   convert_optab_libfunc (trunc_optab, HFmode, SFmode));
       add_libcall (libcall_htab,
+		   convert_optab_libfunc (sfix_optab, SImode, DFmode));
+      add_libcall (libcall_htab,
+		   convert_optab_libfunc (ufix_optab, SImode, DFmode));
+      add_libcall (libcall_htab,
 		   convert_optab_libfunc (sfix_optab, DImode, DFmode));
       add_libcall (libcall_htab,
 		   convert_optab_libfunc (ufix_optab, DImode, DFmode));
@@ -5077,6 +5081,14 @@
   if (IS_STACKALIGN (func_type))
     return false;
 
+  /* The AAPCS says that, on bare-metal, calls to unresolved weak
+     references should become a NOP.  Don't convert such calls into
+     sibling calls.  */
+  if (TARGET_AAPCS_BASED
+      && arm_abi == ARM_ABI_AAPCS
+      && DECL_WEAK (decl))
+    return false;
+
   /* Everything else is ok.  */
   return true;
 }
@@ -5379,11 +5391,7 @@
 
       if (TARGET_32BIT)
 	{
-	  emit_insn (gen_pic_load_addr_32bit (pic_reg, pic_rtx));
-	  if (TARGET_ARM)
-	    emit_insn (gen_pic_add_dot_plus_eight (pic_reg, pic_reg, labelno));
-	  else
-	    emit_insn (gen_pic_add_dot_plus_four (pic_reg, pic_reg, labelno));
+	  emit_insn (gen_pic_load_addr_unified (pic_reg, pic_rtx, labelno));
 	}
       else /* TARGET_THUMB1 */
 	{
@@ -5396,10 +5404,10 @@
 				     thumb_find_work_register (saved_regs));
 	      emit_insn (gen_pic_load_addr_thumb1 (pic_tmp, pic_rtx));
 	      emit_insn (gen_movsi (pic_offset_table_rtx, pic_tmp));
+	      emit_insn (gen_pic_add_dot_plus_four (pic_reg, pic_reg, labelno));
 	    }
 	  else
-	    emit_insn (gen_pic_load_addr_thumb1 (pic_reg, pic_rtx));
-	  emit_insn (gen_pic_add_dot_plus_four (pic_reg, pic_reg, labelno));
+	    emit_insn (gen_pic_load_addr_unified (pic_reg, pic_rtx, labelno));
 	}
     }
 
@@ -5429,20 +5437,7 @@
                                UNSPEC_SYMBOL_OFFSET);
   offset_rtx = gen_rtx_CONST (Pmode, offset_rtx);
 
-  if (TARGET_32BIT)
-    {
-      emit_insn (gen_pic_load_addr_32bit (reg, offset_rtx));
-      if (TARGET_ARM)
-        insn = emit_insn (gen_pic_add_dot_plus_eight (reg, reg, labelno));
-      else
-        insn = emit_insn (gen_pic_add_dot_plus_four (reg, reg, labelno));
-    }
-  else /* TARGET_THUMB1 */
-    {
-      emit_insn (gen_pic_load_addr_thumb1 (reg, offset_rtx));
-      insn = emit_insn (gen_pic_add_dot_plus_four (reg, reg, labelno));
-    }
-
+  insn = emit_insn (gen_pic_load_addr_unified (reg, offset_rtx, labelno));
   return insn;
 }
 
@@ -5485,7 +5480,7 @@
 will_be_in_index_register (const_rtx x)
 {
   /* arm.md: calculate_pic_address will split this into a register.  */
-  return GET_CODE (x) == UNSPEC && XINT (x, 1) == UNSPEC_PIC_SYM;
+  return GET_CODE (x) == UNSPEC && (XINT (x, 1) == UNSPEC_PIC_SYM);
 }
 
 /* Return nonzero if X is a valid ARM state address operand.  */
@@ -7233,6 +7228,15 @@
 	*total = COSTS_N_INSNS (4);
       return true;
 
+    case UNSPEC:
+      /* We cost this as high as our memory costs to allow this to
+	 be hoisted from loops.  */
+      if (XINT (x, 1) == UNSPEC_PIC_UNIFIED)
+	{
+	  *total = COSTS_N_INSNS (2 + ARM_NUM_REGS (mode));
+	}
+      return true;
+
     default:
       *total = COSTS_N_INSNS (4);
       return false;
@@ -9426,7 +9430,8 @@
 arm_note_pic_base (rtx *x, void *date ATTRIBUTE_UNUSED)
 {
   if (GET_CODE (*x) == UNSPEC
-      && XINT (*x, 1) == UNSPEC_PIC_BASE)
+      && (XINT (*x, 1) == UNSPEC_PIC_BASE
+	  || XINT (*x, 1) == UNSPEC_PIC_UNIFIED))
     return 1;
   return 0;
 }
@@ -9812,6 +9817,9 @@
   rtx base_reg_rtx = NULL;
   int i, stm_case;
 
+  /* Write back of base register is currently only supported for Thumb 1.  */
+  int base_writeback = TARGET_THUMB1;
+
   /* Can only handle up to MAX_LDM_STM_OPS insns at present, though could be
      easily extended if required.  */
   gcc_assert (nops >= 2 && nops <= MAX_LDM_STM_OPS);
@@ -9869,7 +9877,9 @@
 	  /* If it isn't an integer register, then we can't do this.  */
 	  if (unsorted_regs[i] < 0
 	      || (TARGET_THUMB1 && unsorted_regs[i] > LAST_LO_REGNUM)
-	      || (TARGET_THUMB2 && unsorted_regs[i] == base_reg)
+	      /* The effects are unpredictable if the base register is
+		 both updated and stored.  */
+	      || (base_writeback && unsorted_regs[i] == base_reg)
 	      || (TARGET_THUMB2 && unsorted_regs[i] == SP_REGNUM)
 	      || unsorted_regs[i] > 14)
 	    return 0;
@@ -19571,39 +19581,34 @@
   emit_move_insn (mem, tmp2);
 }
 
-/* Set up operands for a register copy from src to dest, taking care not to
-   clobber registers in the process.
-   FIXME: This has rather high polynomial complexity (O(n^3)?) but shouldn't
-   be called with a large N, so that should be OK.  */
+/* Set up OPERANDS for a register copy from SRC to DEST, taking care
+   not to early-clobber SRC registers in the process.
 
+   We assume that the operands described by SRC and DEST represent a
+   decomposed copy of OPERANDS[1] into OPERANDS[0].  COUNT is the
+   number of components into which the copy has been decomposed.  */
 void
 neon_disambiguate_copy (rtx *operands, rtx *dest, rtx *src, unsigned int count)
 {
-  unsigned int copied = 0, opctr = 0;
-  unsigned int done = (1 << count) - 1;
-  unsigned int i, j;
+  unsigned int i;
 
-  while (copied != done)
+  if (!reg_overlap_mentioned_p (operands[0], operands[1])
+      || REGNO (operands[0]) < REGNO (operands[1]))
     {
       for (i = 0; i < count; i++)
-        {
-          int good = 1;
-
-          for (j = 0; good && j < count; j++)
-            if (i != j && (copied & (1 << j)) == 0
-                && reg_overlap_mentioned_p (src[j], dest[i]))
-              good = 0;
-
-          if (good)
-            {
-              operands[opctr++] = dest[i];
-              operands[opctr++] = src[i];
-              copied |= 1 << i;
-            }
-        }
+	{
+	  operands[2 * i] = dest[i];
+	  operands[2 * i + 1] = src[i];
+	}
     }
-
-  gcc_assert (opctr == count * 2);
+  else
+    {
+      for (i = 0; i < count; i++)
+	{
+	  operands[2 * i] = dest[count - i - 1];
+	  operands[2 * i + 1] = src[count - i - 1];
+	}
+    }
 }
 
 /* Expand an expression EXP that calls a built-in function,
@@ -20859,6 +20864,8 @@
   gcc_assert (amount >= 0);
   if (amount)
     {
+      emit_insn (gen_blockage ());
+
       if (amount < 512)
 	emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,
 			       GEN_INT (amount)));
Index: gcc/config/arm/arm.md
===================================================================
--- gcc/config/arm/arm.md	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/config/arm/arm.md	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -104,6 +104,7 @@
    (UNSPEC_SYMBOL_OFFSET 27) ; The offset of the start of the symbol from
                              ; another symbolic address.
    (UNSPEC_MEMORY_BARRIER 28) ; Represent a memory barrier.
+   (UNSPEC_PIC_UNIFIED 29)  ; Create a common pic addressing form.
   ]
 )
 
@@ -3272,7 +3273,7 @@
     bool need_else;
 
     if (which_alternative != 0 || operands[3] != const0_rtx
-        || (code != PLUS && code != MINUS && code != IOR && code != XOR))
+        || (code != PLUS && code != IOR && code != XOR))
       need_else = true;
     else
       need_else = false;
@@ -5257,6 +5258,30 @@
   "operands[3] = can_create_pseudo_p () ? gen_reg_rtx (SImode) : operands[0];"
 )
 
+;; operand1 is the memory address to go into 
+;; pic_load_addr_32bit.
+;; operand2 is the PIC label to be emitted 
+;; from pic_add_dot_plus_eight.
+;; We do this to allow hoisting of the entire insn.
+(define_insn_and_split "pic_load_addr_unified"
+  [(set (match_operand:SI 0 "s_register_operand" "=r,r,l")
+	(unspec:SI [(match_operand:SI 1 "" "mX,mX,mX") 
+		    (match_operand:SI 2 "" "")] 
+		    UNSPEC_PIC_UNIFIED))]
+ "flag_pic"
+ "#"
+ "&& reload_completed"
+ [(set (match_dup 0) (unspec:SI [(match_dup 1)] UNSPEC_PIC_SYM))
+  (set (match_dup 0) (unspec:SI [(match_dup 0) (match_dup 3)
+       		     		 (match_dup 2)] UNSPEC_PIC_BASE))]
+ "operands[3] = TARGET_THUMB ? GEN_INT (4) : GEN_INT (8);"
+ [(set_attr "type" "load1,load1,load1")
+  (set_attr "pool_range" "4096,4096,1024")
+  (set_attr "neg_pool_range" "4084,0,0")
+  (set_attr "arch"  "a,t2,t1")    
+  (set_attr "length" "8,6,4")]
+)
+
 ;; The rather odd constraints on the following are to force reload to leave
 ;; the insn alone, and to force the minipool generation pass to then move
 ;; the GOT symbol to memory.
@@ -7346,7 +7371,7 @@
 	(not:SI (match_operator:SI 1 "arm_comparison_operator"
 		 [(match_operand 2 "cc_register" "") (const_int 0)])))]
   "TARGET_ARM"
-  "mov%D1\\t%0, #0\;mvn%d1\\t%0, #1"
+  "mvn%D1\\t%0, #0\;mvn%d1\\t%0, #1"
   [(set_attr "conds" "use")
    (set_attr "insn" "mov")
    (set_attr "length" "8")]
Index: gcc/config/pa/pa.c
===================================================================
--- gcc/config/pa/pa.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/config/pa/pa.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1863,6 +1863,11 @@
   /* Handle the most common case: storing into a register.  */
   else if (register_operand (operand0, mode))
     {
+      /* Legitimize TLS symbol references.  This happens for references
+	 that aren't a legitimate constant.  */
+      if (PA_SYMBOL_REF_TLS_P (operand1))
+	operand1 = legitimize_tls_address (operand1);
+
       if (register_operand (operand1, mode)
 	  || (GET_CODE (operand1) == CONST_INT
 	      && cint_ok_for_move (INTVAL (operand1)))
Index: gcc/config/pa/pa.h
===================================================================
--- gcc/config/pa/pa.h	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/config/pa/pa.h	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -848,6 +848,9 @@
    && (NEW_HP_ASSEMBLER						\
        || TARGET_GAS						\
        || GET_CODE (X) != LABEL_REF)				\
+   && (!PA_SYMBOL_REF_TLS_P (X)					\
+       || (SYMBOL_REF_TLS_MODEL (X) != TLS_MODEL_GLOBAL_DYNAMIC		\
+	   && SYMBOL_REF_TLS_MODEL (X) != TLS_MODEL_LOCAL_DYNAMIC))	\
    && (!TARGET_64BIT						\
        || GET_CODE (X) != CONST_DOUBLE)				\
    && (!TARGET_64BIT						\
Index: gcc/config/mips/mips.md
===================================================================
--- gcc/config/mips/mips.md	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/config/mips/mips.md	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -4707,7 +4707,7 @@
 ;; of _gp from the start of this function.  Operand 1 is the incoming
 ;; function address.
 (define_insn_and_split "loadgp_newabi_<mode>"
-  [(set (match_operand:P 0 "register_operand" "=d")
+  [(set (match_operand:P 0 "register_operand" "=&d")
 	(unspec:P [(match_operand:P 1)
 		   (match_operand:P 2 "register_operand" "d")]
 		  UNSPEC_LOADGP))]
Index: gcc/cfgrtl.c
===================================================================
--- gcc/cfgrtl.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/cfgrtl.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1642,9 +1642,10 @@
       putc ('\n', outf);
     }
 
-  for (insn = BB_HEAD (bb), last = NEXT_INSN (BB_END (bb)); insn != last;
-       insn = NEXT_INSN (insn))
-    print_rtl_single (outf, insn);
+  if (bb->index != ENTRY_BLOCK && bb->index != EXIT_BLOCK)
+    for (insn = BB_HEAD (bb), last = NEXT_INSN (BB_END (bb)); insn != last;
+	 insn = NEXT_INSN (insn))
+      print_rtl_single (outf, insn);
 
   if (df)
     {
Index: gcc/reload1.c
===================================================================
--- gcc/reload1.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ gcc/reload1.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -3899,6 +3899,10 @@
     if (XEXP (x, 0))
       set_label_offsets (XEXP (x, 0), NULL_RTX, 1);
 
+  for (x = nonlocal_goto_handler_labels; x; x = XEXP (x, 1))
+    if (XEXP (x, 0))
+      set_label_offsets (XEXP (x, 0), NULL_RTX, 1);
+
   for_each_eh_label (set_initial_eh_label_offset);
 }
 
Index: zlib/configure
===================================================================
--- zlib/configure	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ zlib/configure	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -8600,7 +8600,7 @@
       ;;
 
     # Unfortunately, older versions of FreeBSD 2 do not have this feature.
-    freebsd2*)
+    freebsd2.*)
       archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
       hardcode_direct=yes
       hardcode_minus_L=yes
@@ -9516,7 +9516,7 @@
     objformat=`/usr/bin/objformat`
   else
     case $host_os in
-    freebsd[123]*) objformat=aout ;;
+    freebsd[23].*) objformat=aout ;;
     *) objformat=elf ;;
     esac
   fi
@@ -9534,7 +9534,7 @@
   esac
   shlibpath_var=LD_LIBRARY_PATH
   case $host_os in
-  freebsd2*)
+  freebsd2.*)
     shlibpath_overrides_runpath=yes
     ;;
   freebsd3.[01]* | freebsdelf3.[01]*)
Index: zlib/ChangeLog
===================================================================
--- zlib/ChangeLog	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ zlib/ChangeLog	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1,3 +1,7 @@
+2011-11-20  Andreas Tobler  <andreast@fgznet.ch>
+
+	* configure: Regenerate.
+
 2011-10-26  Release Manager
 
 	* GCC 4.6.2 released.
Index: libstdc++-v3/configure
===================================================================
--- libstdc++-v3/configure	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libstdc++-v3/configure	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -9698,7 +9698,7 @@
       ;;
 
     # Unfortunately, older versions of FreeBSD 2 do not have this feature.
-    freebsd2*)
+    freebsd2.*)
       archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
       hardcode_direct=yes
       hardcode_minus_L=yes
@@ -10614,7 +10614,7 @@
     objformat=`/usr/bin/objformat`
   else
     case $host_os in
-    freebsd[123]*) objformat=aout ;;
+    freebsd[23].*) objformat=aout ;;
     *) objformat=elf ;;
     esac
   fi
@@ -10632,7 +10632,7 @@
   esac
   shlibpath_var=LD_LIBRARY_PATH
   case $host_os in
-  freebsd2*)
+  freebsd2.*)
     shlibpath_overrides_runpath=yes
     ;;
   freebsd3.[01]* | freebsdelf3.[01]*)
@@ -12522,7 +12522,7 @@
         esac
         ;;
 
-      freebsd[12]*)
+      freebsd2.*)
         # C++ shared libraries reported to be fairly broken before
 	# switch to ELF
         ld_shlibs_CXX=no
@@ -14297,7 +14297,7 @@
     objformat=`/usr/bin/objformat`
   else
     case $host_os in
-    freebsd[123]*) objformat=aout ;;
+    freebsd[23].*) objformat=aout ;;
     *) objformat=elf ;;
     esac
   fi
@@ -14315,7 +14315,7 @@
   esac
   shlibpath_var=LD_LIBRARY_PATH
   case $host_os in
-  freebsd2*)
+  freebsd2.*)
     shlibpath_overrides_runpath=yes
     ;;
   freebsd3.[01]* | freebsdelf3.[01]*)
Index: libstdc++-v3/include/debug/unordered_map
===================================================================
--- libstdc++-v3/include/debug/unordered_map	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libstdc++-v3/include/debug/unordered_map	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -276,6 +276,10 @@
       }
 
       iterator
+      erase(iterator __it)
+      { return erase(const_iterator(__it)); }
+
+      iterator
       erase(const_iterator __first, const_iterator __last)
       {
 	__glibcxx_check_erase_range(__first, __last);
@@ -558,6 +562,10 @@
       }
 
       iterator
+      erase(iterator __it)
+      { return erase(const_iterator(__it)); }
+
+      iterator
       erase(const_iterator __first, const_iterator __last)
       {
 	__glibcxx_check_erase_range(__first, __last);
Index: libstdc++-v3/include/debug/unordered_set
===================================================================
--- libstdc++-v3/include/debug/unordered_set	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libstdc++-v3/include/debug/unordered_set	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -269,6 +269,10 @@
       }
 
       iterator
+      erase(iterator __it)
+      { return erase(const_iterator(__it)); }
+
+      iterator
       erase(const_iterator __first, const_iterator __last)
       {
 	__glibcxx_check_erase_range(__first, __last);
@@ -539,6 +543,10 @@
       }
 
       iterator
+      erase(iterator __it)
+      { return erase(const_iterator(__it)); }
+
+      iterator
       erase(const_iterator __first, const_iterator __last)
       {
 	__glibcxx_check_erase_range(__first, __last);
Index: libstdc++-v3/include/debug/map.h
===================================================================
--- libstdc++-v3/include/debug/map.h	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libstdc++-v3/include/debug/map.h	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -273,6 +273,10 @@
 	this->_M_invalidate_if(_Equal(__position.base()));
 	return iterator(_Base::erase(__position.base()), this);
       }
+
+      iterator
+      erase(iterator __position)
+      { return erase(const_iterator(__position)); }
 #else
       void
       erase(iterator __position)
Index: libstdc++-v3/include/debug/multimap.h
===================================================================
--- libstdc++-v3/include/debug/multimap.h	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libstdc++-v3/include/debug/multimap.h	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -254,6 +254,10 @@
 	this->_M_invalidate_if(_Equal(__position.base()));
 	return iterator(_Base::erase(__position.base()), this);
       }
+
+      iterator
+      erase(iterator __position)
+      { return erase(const_iterator(__position)); }
 #else
       void
       erase(iterator __position)
Index: libstdc++-v3/include/std/condition_variable
===================================================================
--- libstdc++-v3/include/std/condition_variable	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libstdc++-v3/include/std/condition_variable	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -198,10 +198,25 @@
       void
       wait(_Lock& __lock)
       {
-        unique_lock<mutex> __my_lock(_M_mutex);
-        __lock.unlock();
-        _M_cond.wait(__my_lock);
-        __lock.lock();
+	// scoped unlock - unlocks in ctor, re-locks in dtor
+	struct _Unlock {
+	  explicit _Unlock(_Lock& __lk) : _M_lock(__lk) { __lk.unlock(); }
+	  ~_Unlock() noexcept(false)
+	  {
+	    if (uncaught_exception())
+	      __try { _M_lock.lock(); } __catch(...) { }
+	    else
+	      _M_lock.lock();
+	  }
+	  _Lock& _M_lock;
+	};
+
+	unique_lock<mutex> __my_lock(_M_mutex);
+	_Unlock __unlock(__lock);
+	// _M_mutex must be unlocked before re-locking __lock so move
+	// ownership of _M_mutex lock to an object with shorter lifetime.
+	unique_lock<mutex> __my_lock2(std::move(__my_lock));
+	_M_cond.wait(__my_lock2);
       }
       
 
Index: libstdc++-v3/include/std/complex
===================================================================
--- libstdc++-v3/include/std/complex	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libstdc++-v3/include/std/complex	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1,7 +1,7 @@
 // The template and inlines for the -*- C++ -*- complex number classes.
 
 // Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
-// 2006, 2007, 2008, 2009, 2010
+// 2006, 2007, 2008, 2009, 2010, 2011
 // Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
@@ -1695,12 +1695,9 @@
     std::complex<_Tp>
     __complex_acosh(const std::complex<_Tp>& __z)
     {
-      std::complex<_Tp> __t((__z.real() - __z.imag())
-			    * (__z.real() + __z.imag()) - _Tp(1.0),
-			    _Tp(2.0) * __z.real() * __z.imag());
-      __t = std::sqrt(__t);
-
-      return std::log(__t + __z);
+      // Kahan's formula.
+      return _Tp(2.0) * std::log(std::sqrt(_Tp(0.5) * (__z + _Tp(1.0)))
+				 + std::sqrt(_Tp(0.5) * (__z - _Tp(1.0))));
     }
 
 #if _GLIBCXX_USE_C99_COMPLEX_TR1
Index: libstdc++-v3/include/ext/type_traits.h
===================================================================
--- libstdc++-v3/include/ext/type_traits.h	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libstdc++-v3/include/ext/type_traits.h	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1,6 +1,7 @@
 // -*- C++ -*-
 
-// Copyright (C) 2005, 2006, 2007, 2009 Free Software Foundation, Inc.
+// Copyright (C) 2005, 2006, 2007, 2009, 2010, 2011
+// Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the terms
@@ -161,44 +162,50 @@
     struct __promote
     { typedef double __type; };
 
+  // No nested __type member for non-integer non-floating point types,
+  // allows this type to be used for SFINAE to constrain overloads in
+  // <cmath> and <complex> to only the intended types.
   template<typename _Tp>
     struct __promote<_Tp, false>
-    { typedef _Tp __type; };
+    { };
 
-  template<typename _Tp, typename _Up>
+  template<>
+    struct __promote<long double>
+    { typedef long double __type; };
+
+  template<>
+    struct __promote<double>
+    { typedef double __type; };
+
+  template<>
+    struct __promote<float>
+    { typedef float __type; };
+
+  template<typename _Tp, typename _Up,
+           typename _Tp2 = typename __promote<_Tp>::__type,
+           typename _Up2 = typename __promote<_Up>::__type>
     struct __promote_2
     {
-    private:
-      typedef typename __promote<_Tp>::__type __type1;
-      typedef typename __promote<_Up>::__type __type2;
-
-    public:
-      typedef __typeof__(__type1() + __type2()) __type;
+      typedef __typeof__(_Tp2() + _Up2()) __type;
     };
 
-  template<typename _Tp, typename _Up, typename _Vp>
+  template<typename _Tp, typename _Up, typename _Vp,
+           typename _Tp2 = typename __promote<_Tp>::__type,
+           typename _Up2 = typename __promote<_Up>::__type,
+           typename _Vp2 = typename __promote<_Vp>::__type>
     struct __promote_3
     {
-    private:
-      typedef typename __promote<_Tp>::__type __type1;
-      typedef typename __promote<_Up>::__type __type2;
-      typedef typename __promote<_Vp>::__type __type3;
-
-    public:
-      typedef __typeof__(__type1() + __type2() + __type3()) __type;
+      typedef __typeof__(_Tp2() + _Up2() + _Vp2()) __type;
     };
 
-  template<typename _Tp, typename _Up, typename _Vp, typename _Wp>
+  template<typename _Tp, typename _Up, typename _Vp, typename _Wp,
+           typename _Tp2 = typename __promote<_Tp>::__type,
+           typename _Up2 = typename __promote<_Up>::__type,
+           typename _Vp2 = typename __promote<_Vp>::__type,
+           typename _Wp2 = typename __promote<_Wp>::__type>
     struct __promote_4
     {
-    private:
-      typedef typename __promote<_Tp>::__type __type1;
-      typedef typename __promote<_Up>::__type __type2;
-      typedef typename __promote<_Vp>::__type __type3;
-      typedef typename __promote<_Wp>::__type __type4;
-
-    public:
-      typedef __typeof__(__type1() + __type2() + __type3() + __type4()) __type;
+      typedef __typeof__(_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;
     };
 
 _GLIBCXX_END_NAMESPACE_VERSION
Index: libstdc++-v3/include/profile/map.h
===================================================================
--- libstdc++-v3/include/profile/map.h	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libstdc++-v3/include/profile/map.h	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -326,6 +326,10 @@
         __profcxx_map_to_unordered_map_erase(this, size(), 1);
         return __i;
       }
+
+      iterator
+      erase(iterator __position)
+      { return erase(const_iterator(__position)); }
 #else
       void
       erase(iterator __position)
Index: libstdc++-v3/include/profile/multimap.h
===================================================================
--- libstdc++-v3/include/profile/multimap.h	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libstdc++-v3/include/profile/multimap.h	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -225,6 +225,10 @@
       iterator
       erase(const_iterator __position)
       { return iterator(_Base::erase(__position)); }
+
+      iterator
+      erase(iterator __position)
+      { return iterator(_Base::erase(__position)); }
 #else
       void
       erase(iterator __position)
Index: libstdc++-v3/include/bits/hashtable.h
===================================================================
--- libstdc++-v3/include/bits/hashtable.h	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libstdc++-v3/include/bits/hashtable.h	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -440,6 +440,11 @@
       iterator
       erase(const_iterator);
 
+      // LWG 2059.
+      iterator
+      erase(iterator __it)
+      { return erase(const_iterator(__it)); }
+
       size_type
       erase(const key_type&);
 
Index: libstdc++-v3/include/bits/shared_ptr.h
===================================================================
--- libstdc++-v3/include/bits/shared_ptr.h	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libstdc++-v3/include/bits/shared_ptr.h	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -100,6 +100,8 @@
       constexpr shared_ptr()
       : __shared_ptr<_Tp>() { }
 
+      shared_ptr(const shared_ptr&) = default; // never throws
+
       /**
        *  @brief  Construct a %shared_ptr that owns the pointer @a __p.
        *  @param  __p  A pointer that is convertible to element_type*.
@@ -264,6 +266,8 @@
       constexpr shared_ptr(nullptr_t __p)
       : __shared_ptr<_Tp>(__p) { }
 
+      shared_ptr& operator=(const shared_ptr&) = default;
+
       template<typename _Tp1>
 	shared_ptr&
 	operator=(const shared_ptr<_Tp1>& __r) // never throws
Index: libstdc++-v3/include/bits/stl_map.h
===================================================================
--- libstdc++-v3/include/bits/stl_map.h	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libstdc++-v3/include/bits/stl_map.h	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -612,6 +612,11 @@
       iterator
       erase(const_iterator __position)
       { return _M_t.erase(__position); }
+
+      // LWG 2059.
+      iterator
+      erase(iterator __position)
+      { return _M_t.erase(__position); }
 #else
       /**
        *  @brief Erases an element from a %map.
Index: libstdc++-v3/include/bits/stl_multimap.h
===================================================================
--- libstdc++-v3/include/bits/stl_multimap.h	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libstdc++-v3/include/bits/stl_multimap.h	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -533,6 +533,11 @@
       iterator
       erase(const_iterator __position)
       { return _M_t.erase(__position); }
+
+      // LWG 2059.
+      iterator
+      erase(iterator __position)
+      { return _M_t.erase(__position); }
 #else
       /**
        *  @brief Erases an element from a %multimap.
Index: libstdc++-v3/include/bits/stl_numeric.h
===================================================================
--- libstdc++-v3/include/bits/stl_numeric.h	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libstdc++-v3/include/bits/stl_numeric.h	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -222,10 +222,10 @@
   /**
    *  @brief  Return list of partial sums
    *
-   *  Accumulates the values in the range [first,last) using operator+().
+   *  Accumulates the values in the range [first,last) using the @c + operator.
    *  As each successive input value is added into the total, that partial sum
-   *  is written to @a result.  Therefore, the first value in result is the
-   *  first value of the input, the second value in result is the sum of the
+   *  is written to @p result.  Therefore, the first value in @p result is the
+   *  first value of the input, the second value in @p result is the sum of the
    *  first and second input values, and so on.
    *
    *  @param  first  Start of input range.
@@ -261,15 +261,16 @@
   /**
    *  @brief  Return list of partial sums
    *
-   *  Accumulates the values in the range [first,last) using operator+().
+   *  Accumulates the values in the range [first,last) using @p binary_op.
    *  As each successive input value is added into the total, that partial sum
-   *  is written to @a result.  Therefore, the first value in result is the
-   *  first value of the input, the second value in result is the sum of the
+   *  is written to @a result.  Therefore, the first value in @p result is the
+   *  first value of the input, the second value in @p result is the sum of the
    *  first and second input values, and so on.
    *
    *  @param  first  Start of input range.
    *  @param  last  End of input range.
    *  @param  result  Output to write sums to.
+   *  @param  binary_op  Function object.
    *  @return  Iterator pointing just beyond the values written to result.
    */
   template<typename _InputIterator, typename _OutputIterator,
Index: libstdc++-v3/include/bits/stl_uninitialized.h
===================================================================
--- libstdc++-v3/include/bits/stl_uninitialized.h	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libstdc++-v3/include/bits/stl_uninitialized.h	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1,7 +1,7 @@
 // Raw memory manipulators -*- C++ -*-
 
 // Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-// 2009, 2010
+// 2009, 2010, 2011
 // Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
@@ -530,7 +530,22 @@
 	__uninit_default_n(__first, __n);
     }
 
+ template<typename _Tp, typename _Allocator>
+   inline auto
+   _Construct_default_a_impl(_Tp* __ptr, _Allocator& __alloc, void*)
+   -> decltype(__alloc.construct(__ptr))
+   { return __alloc.construct(__ptr); }
 
+  template<typename _Tp, typename _Allocator>
+   inline void
+   _Construct_default_a_impl(_Tp* __ptr, _Allocator& __alloc, ...)
+   { _Construct(__ptr); }
+
+  template<typename _Tp, typename _Allocator>
+   inline void
+   _Construct_default_a(_Tp* __ptr, _Allocator& __alloc)
+   { _Construct_default_a_impl(__ptr, __alloc, nullptr); }
+
   // __uninitialized_default_a
   // Fills [first, last) with std::distance(first, last) default
   // constructed value_types(s), constructed with the allocator alloc.
@@ -544,7 +559,7 @@
       __try
 	{
 	  for (; __cur != __last; ++__cur)
-	    __alloc.construct(std::__addressof(*__cur));
+	    _Construct_default_a(std::__addressof(*__cur), __alloc);
 	}
       __catch(...)
 	{
@@ -573,7 +588,7 @@
       __try
 	{
 	  for (; __n > 0; --__n, ++__cur)
-	    __alloc.construct(std::__addressof(*__cur));
+	    _Construct_default_a(std::__addressof(*__cur), __alloc);
 	}
       __catch(...)
 	{
Index: libstdc++-v3/include/bits/shared_ptr_base.h
===================================================================
--- libstdc++-v3/include/bits/shared_ptr_base.h	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libstdc++-v3/include/bits/shared_ptr_base.h	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -799,7 +799,8 @@
 	: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws
 	{ }
 
-      //  generated copy constructor, assignment, destructor are fine.
+      __shared_ptr(const __shared_ptr&) = default; // never throws
+      __shared_ptr& operator=(const __shared_ptr&) = default; // never throws
 
       template<typename _Tp1, typename = typename
 	       std::enable_if<std::is_convertible<_Tp1*, _Tp*>::value>::type>
Index: libstdc++-v3/include/bits/regex.h
===================================================================
--- libstdc++-v3/include/bits/regex.h	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libstdc++-v3/include/bits/regex.h	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -2219,7 +2219,7 @@
 		  regex_constants::match_flag_type __flags
 		  = regex_constants::match_default)
     {
-      std::string __result;
+      basic_string<_Ch_type> __result;
       regex_replace(std::back_inserter(__result),
 		    __s.begin(), __s.end(), __e, __fmt, __flags);
       return __result;
Index: libstdc++-v3/include/bits/stl_tree.h
===================================================================
--- libstdc++-v3/include/bits/stl_tree.h	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libstdc++-v3/include/bits/stl_tree.h	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -760,6 +760,16 @@
 	_M_erase_aux(__position);
 	return __result._M_const_cast();
       }
+
+      // LWG 2059.
+      iterator
+      erase(iterator __position)
+      {
+	iterator __result = __position;
+	++__result;
+	_M_erase_aux(__position);
+	return __result;
+      }
 #else
       void
       erase(iterator __position)
Index: libstdc++-v3/include/c_global/cmath
===================================================================
--- libstdc++-v3/include/c_global/cmath	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libstdc++-v3/include/c_global/cmath	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1,7 +1,7 @@
 // -*- C++ -*- C forwarding header.
 
 // Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
-// 2006, 2007, 2008, 2009, 2010
+// 2006, 2007, 2008, 2009, 2010, 2011
 // Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
@@ -156,10 +156,7 @@
 
   template<typename _Tp, typename _Up>
     inline
-    typename __gnu_cxx::__promote_2<
-    typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value
-				    && __is_arithmetic<_Up>::__value,
-				    _Tp>::__type, _Up>::__type
+    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
     atan2(_Tp __y, _Up __x)
     {
       typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
@@ -374,10 +371,7 @@
 
   template<typename _Tp, typename _Up>
     inline
-    typename __gnu_cxx::__promote_2<
-    typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value
-				    && __is_arithmetic<_Up>::__value,
-				    _Tp>::__type, _Up>::__type
+    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
     pow(_Tp __x, _Up __y)
     {
       typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
Index: libstdc++-v3/include/tr1/complex
===================================================================
--- libstdc++-v3/include/tr1/complex	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libstdc++-v3/include/tr1/complex	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -185,12 +185,9 @@
     std::complex<_Tp>
     __complex_acosh(const std::complex<_Tp>& __z)
     {
-      std::complex<_Tp> __t((__z.real() - __z.imag())
-			    * (__z.real() + __z.imag()) - _Tp(1.0),
-			    _Tp(2.0) * __z.real() * __z.imag());
-      __t = std::sqrt(__t);
-
-      return std::log(__t + __z);
+      // Kahan's formula.
+      return _Tp(2.0) * std::log(std::sqrt(_Tp(0.5) * (__z + _Tp(1.0)))
+				 + std::sqrt(_Tp(0.5) * (__z - _Tp(1.0))));
     }
 
 #if _GLIBCXX_USE_C99_COMPLEX_TR1
Index: libstdc++-v3/include/tr1/poly_hermite.tcc
===================================================================
--- libstdc++-v3/include/tr1/poly_hermite.tcc	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libstdc++-v3/include/tr1/poly_hermite.tcc	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1,6 +1,6 @@
 // Special functions -*- C++ -*-
 
-// Copyright (C) 2006, 2007, 2008, 2009, 2010
+// Copyright (C) 2006, 2007, 2008, 2009, 2010, 2011
 // Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
@@ -84,7 +84,7 @@
       unsigned int __i;
       for  (__H_nm2 = __H_0, __H_nm1 = __H_1, __i = 2; __i <= __n; ++__i)
         {
-          __H_n = 2 * (__x * __H_nm1 + (__i - 1) * __H_nm2);
+          __H_n = 2 * (__x * __H_nm1 - (__i - 1) * __H_nm2);
           __H_nm2 = __H_nm1;
           __H_nm1 = __H_n;
         }
Index: libstdc++-v3/ChangeLog
===================================================================
--- libstdc++-v3/ChangeLog	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libstdc++-v3/ChangeLog	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1,3 +1,131 @@
+2012-01-03  Chase Douglas  <chase.douglas@canonical.com>
+	    Jonathan Wakely  <jwakely.gcc@gmail.com>
+
+	* include/bits/shared_ptr.h: Default copy ctor and assignment.
+	* include/bits/shared_ptr_base.h: Likewise.
+	* testsuite/20_util/shared_ptr/cons/43820_neg.cc: Adjust dg-error
+	line numbers.
+	* testsuite/20_util/weak_ptr/comparison/cmp_neg.cc: Likewise.
+
+2011-12-30  Paolo Carlini  <paolo.carlini@oracle.com>
+
+	PR libstdc++/51711
+	* include/bits/regex.h (regex_replace): Fix thinko.
+	* testsuite/28_regex/algorithms/regex_replace/char/51711.cc: New.
+	* testsuite/28_regex/algorithms/regex_replace/wchar_t/51711.cc:
+	Likewise.
+
+2011-12-19  Jonathan Wakely  <jwakely.gcc@gmail.com>
+
+	PR libstdc++/51626
+	* include/bits/stl_uninitialized.h (_Construct_default_a_impl): Define
+	overloaded functions to conditionally use allocator::construct.
+	(_Construct_default_a): Define to dispatch to appropriate
+	_Construct_default_a_impl overload.
+	(__uninitialized_default_a, __uninitialized_default_n_a): Use
+	_Construct_default_a.
+	* testsuite/20_util/allocator/51626.cc: New.
+
+2011-12-19  Jonathan Wakely  <jwakely.gcc@gmail.com>
+
+	* testsuite/ext/type_traits/remove_unsigned_integer_neg.cc: Adjust
+	dg-error line numbers.
+	* testsuite/ext/type_traits/add_unsigned_floating_neg.cc: Likewise.
+	* testsuite/ext/type_traits/remove_unsigned_floating_neg.cc: Likewise.
+	* testsuite/ext/type_traits/add_unsigned_integer_neg.cc: Likewise.
+
+2011-12-19  Jonathan Wakely  <jwakely.gcc@gmail.com>
+
+	* include/c_global/cmath: Update copyright years.
+	* include/ext/type_traits.h: Likewise.
+
+2011-12-19  Jonathan Wakely  <jwakely.gcc@gmail.com>
+
+	Backport from mainline
+	2011-11-13  Paolo Carlini  <paolo.carlini@oracle.com>
+
+	* include/c_global/cmath (atan2, pow): Simplify constraining on the
+	return type.
+
+	Backport from mainline
+	2011-11-12  Jonathan Wakely  <jwakely.gcc@gmail.com>
+
+	PR libstdc++/51083
+	* include/ext/type_traits.h (__promote): Only define __type member
+	for integral and floating point types, to prevent math functions
+	participating in overload resolution for other types.
+	(__promote_2, __promote_3, __promote_4): Use __promote in default
+	template argument values, so deduction only succeeds for integral and
+	floating point types.
+	* testsuite/26_numerics/cmath/51083.cc: New.
+	* testsuite/26_numerics/complex/51083.cc: New.
+	* testsuite/tr1/8_c_compatibility/cmath/51083.cc: New.
+	* testsuite/tr1/8_c_compatibility/complex/51083.cc: New.
+
+2011-12-19  Jonathan Wakely  <jwakely.gcc@gmail.com>
+
+	PR libstdc++/50862
+	* include/std/condition_variable (condition_variable_any::wait): Fix
+	deadlock and ensure _Lock::lock() is called on exit.
+	* testsuite/30_threads/condition_variable_any/50862.cc: New.
+
+2011-12-18  Jonathan Wakely  <jwakely.gcc@gmail.com>
+
+	PR libstdc++/51540
+	* include/bits/stl_numeric.h (partial_sum): Adjust doxygen comments.
+
+2011-11-20  Andreas Tobler  <andreast@fgznet.ch>
+
+	* configure: Regenerate.
+
+2011-11-16  Paolo Carlini  <paolo.carlini@oracle.com>
+
+	PR libstdc++/51142
+	* include/debug/unordered_map (unordered_map<>::erase(iterator),
+	unordered_multimap<>::erase(iterator)): Add, consistently with
+	LWG 2059.
+	* include/debug/unordered_set (unordered_set<>::erase(iterator),
+	unordered_multiset<>::erase(iterator)): Likewise.
+	* include/debug/map.h (map<>::erase(iterator)): Likewise.
+	* include/debug/multimap.h (multimap<>::erase(iterator)): Likewise.
+	* include/profile/map.h (map<>::erase(iterator)): Likewise.
+	* include/profile/multimap.h (multimap<>::erase(iterator)): Likewise.
+	* include/bits/hashtable.h (_Hashtable<>::erase(iterator)): Likewise.
+	* include/bits/stl_map.h (map<>::erase(iterator)): Likewise.
+	* include/bits/stl_multimap.h (multimap<>::erase(iterator)): Likewise.
+	* include/bits/stl_tree.h (_Rb_tree<>::erase(iterator)): Likewise.
+	* testsuite/23_containers/unordered_map/erase/51142.cc: New.
+	* testsuite/23_containers/multimap/modifiers/erase/51142.cc: Likewise.
+	* testsuite/23_containers/set/modifiers/erase/51142.cc: Likewise.
+	* testsuite/23_containers/unordered_multimap/erase/51142.cc: Likewise.
+	* testsuite/23_containers/unordered_set/erase/51142.cc: Likewise.
+	* testsuite/23_containers/multiset/modifiers/erase/51142.cc: Likewise.
+	* testsuite/23_containers/unordered_multiset/erase/51142.cc: Likewise.
+	* testsuite/23_containers/map/modifiers/erase/51142.cc: Likewise.
+
+2011-11-15  Jason Dick  <dickphd@gmail.com>
+
+	PR libstdc++/51133
+	* include/tr1/poly_hermite.tcc (__poly_hermite_recursion): Fix
+	wrong sign in recursion relation.
+
+2011-11-02  Richard B. Kreckel  <kreckel@ginac.de>
+	    Paolo Carlini  <paolo.carlini@oracle.com>
+
+	PR libstdc++/50880
+	* include/std/complex (__complex_acosh): Fix in a better way,
+	use Kahan's formula.
+	* include/tr1/complex (__complex_acosh): Likewise.
+
+2011-11-02  Richard B. Kreckel  <kreckel@ginac.de>
+	    Paolo Carlini  <paolo.carlini@oracle.com>
+
+	PR libstdc++/50880
+	* include/std/complex (__complex_acosh): Fix for __z.real() < 0.
+	* include/tr1/complex (__complex_acosh): Likewise.
+	* testsuite/26_numerics/complex/50880.cc: New.
+	* testsuite/tr1/8_c_compatibility/complex/50880.cc: Likewise.
+
 2011-10-26  Release Manager
 
 	* GCC 4.6.2 released.
Index: libstdc++-v3/testsuite/28_regex/algorithms/regex_replace/wchar_t/51711.cc
===================================================================
--- libstdc++-v3/testsuite/28_regex/algorithms/regex_replace/wchar_t/51711.cc	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ libstdc++-v3/testsuite/28_regex/algorithms/regex_replace/wchar_t/51711.cc	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,31 @@
+// { dg-options "-std=gnu++0x" }
+// { dg-do compile }
+
+// Copyright (C) 2011 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+//
+
+#include <regex>
+#include <string>
+
+// libstdc++/51711
+void test01()
+{
+  std::wstring toProcess(L"Bug\r\n");
+  std::wstring result __attribute__((unused))
+    = std::regex_replace(toProcess, std::wregex(L"\\r"), std::wstring(L"\\r"));
+}
Index: libstdc++-v3/testsuite/28_regex/algorithms/regex_replace/char/51711.cc
===================================================================
--- libstdc++-v3/testsuite/28_regex/algorithms/regex_replace/char/51711.cc	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ libstdc++-v3/testsuite/28_regex/algorithms/regex_replace/char/51711.cc	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,31 @@
+// { dg-options "-std=gnu++0x" }
+// { dg-do compile }
+
+// Copyright (C) 2011 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+//
+
+#include <regex>
+#include <string>
+
+// libstdc++/51711
+void test01()
+{
+  std::string toProcess("Bug\r\n");
+  std::string result __attribute__((unused))
+    = std::regex_replace(toProcess, std::regex("\\r"), std::string("\\r"));
+}
Index: libstdc++-v3/testsuite/26_numerics/complex/51083.cc
===================================================================
--- libstdc++-v3/testsuite/26_numerics/complex/51083.cc	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ libstdc++-v3/testsuite/26_numerics/complex/51083.cc	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,54 @@
+// { dg-options "-std=gnu++0x" }
+//
+// Copyright (C) 2011 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <complex>
+
+namespace a
+{
+  template<typename> class Mat { };
+
+  template<typename T> struct Mat2 : Mat<T> { };
+
+  template<typename T> int arg(Mat<T>) { return 1; }
+  template<typename T> int conj(Mat<T>) { return 1; }
+  template<typename T> int imag(Mat<T>) { return 1; }
+  template<typename T> int norm(Mat<T>) { return 1; }
+  template<typename T> int proj(Mat<T>) { return 1; }
+  template<typename T> int real(Mat<T>) { return 1; }
+
+  template<typename T, typename U> int pow(Mat<T>, U) { return 1; }
+  template<typename T, typename U> int pow(T, Mat<U>) { return 1; }
+}
+
+int main()
+{
+  int __attribute__((unused)) i;
+
+  using namespace std;
+
+  a::Mat2< std::complex<double> > c;
+  i = arg(c);
+  i = conj(c);
+  i = imag(c);
+  i = norm(c);
+  i = proj(c);
+  i = real(c);
+  i = pow(std::complex<float>(), c);
+  i = pow(c, std::complex<float>());
+}
Index: libstdc++-v3/testsuite/26_numerics/complex/50880.cc
===================================================================
--- libstdc++-v3/testsuite/26_numerics/complex/50880.cc	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ libstdc++-v3/testsuite/26_numerics/complex/50880.cc	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,53 @@
+// { dg-options "-std=gnu++0x" }
+//
+// Copyright (C) 2011 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <complex>
+#include <testsuite_hooks.h> 
+
+template<typename T>
+  void test01_do()
+  {
+    bool test __attribute__((unused)) = true;
+
+    const std::complex<T> ca(T(-2), T(2));
+    const std::complex<T> cb(T(-2), T(0));
+    const std::complex<T> cc(T(-2), T(-2));
+
+    std::complex<T> cra = std::acosh(ca);
+    std::complex<T> crb = std::acosh(cb);
+    std::complex<T> crc = std::acosh(cc);
+
+    VERIFY( cra.real() > T(0) );
+    VERIFY( crb.real() > T(0) );
+    VERIFY( crc.real() > T(0) );
+  }
+
+// libstdc++/50880
+void test01()
+{
+  test01_do<float>();
+  test01_do<double>();
+  test01_do<long double>();
+}
+
+int main()
+{
+  test01();
+  return 0;
+}
Index: libstdc++-v3/testsuite/26_numerics/cmath/51083.cc
===================================================================
--- libstdc++-v3/testsuite/26_numerics/cmath/51083.cc	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ libstdc++-v3/testsuite/26_numerics/cmath/51083.cc	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,62 @@
+// { dg-options "-std=gnu++0x" }
+//
+// Copyright (C) 2011 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <cmath>
+
+namespace a
+{
+  template<typename> class Mat { };
+
+  template<typename T> struct Mat2 : Mat<T> { };
+
+  template<typename T>
+    int fdim(Mat<T>) { return 1; }
+
+  template<typename T, typename U>
+    int floor(Mat<T>, U) { return 1; }
+  template<typename T, typename U>
+    int floor(T, Mat<U>) { return 1; }
+
+  template<typename T, typename U, typename V>
+    int fma(Mat<T>, U, V) { return 1; }
+  template<typename T, typename U, typename V>
+    int fma(T, Mat<U>, V) { return 1; }
+  template<typename T, typename U, typename V>
+    int fma(T, U, Mat<V>) { return 1; }
+}
+
+int main()
+{
+  int __attribute__((unused)) i;
+
+  using namespace std;
+
+  a::Mat2<double> c;
+  i = fdim(c);
+  i = floor(c, 0.);
+  i = floor(0., c);
+  i = floor(c, 1);
+  i = floor(1, c);
+  i = fma(c, 0., 1.);
+  i = fma(0., c, 1.);
+  i = fma(0., 1., c);
+  i = fma(c, 0., 1);
+  i = fma(0., c, 1);
+  i = fma(0., 1, c);
+}
Index: libstdc++-v3/testsuite/30_threads/condition_variable_any/50862.cc
===================================================================
--- libstdc++-v3/testsuite/30_threads/condition_variable_any/50862.cc	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ libstdc++-v3/testsuite/30_threads/condition_variable_any/50862.cc	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,80 @@
+// { dg-do run { target *-*-freebsd* *-*-netbsd* *-*-linux* *-*-solaris* *-*-cygwin *-*-darwin* alpha*-*-osf* mips-sgi-irix6* } }
+// { dg-options " -std=gnu++0x -pthread" { target *-*-freebsd* *-*-netbsd* *-*-linux* alpha*-*-osf* mips-sgi-irix6* } }
+// { dg-options " -std=gnu++0x -pthreads" { target *-*-solaris* } }
+// { dg-options " -std=gnu++0x " { target *-*-cygwin *-*-darwin* } }
+// { dg-require-cstdint "" }
+// { dg-require-gthreads "" }
+// { dg-require-sched-yield "" }
+ 
+// Copyright (C) 2011 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>. 
+
+#include <condition_variable>
+#include <thread>
+#include <mutex>
+#include <array>
+#include <sstream>
+
+struct scoped_thread
+{
+  ~scoped_thread() { if (t.joinable()) t.join(); }
+  std::thread t;
+};
+
+int main()
+{
+  typedef std::unique_lock<std::mutex> Lock;
+
+  std::mutex                  m;
+  std::condition_variable_any cond;
+  unsigned int                product = 0;
+  const unsigned int          count = 10;
+
+  // writing to stream causes timing changes which makes deadlock easier
+  // to reproduce - do not remove
+  std::ostringstream out;
+
+  // create consumers
+  std::array<scoped_thread, 2> threads;
+  for (std::size_t i = 0; i < threads.size(); ++i)
+    threads[i].t
+      = std::thread( [&]
+		     {
+		       for (unsigned int i = 0; i < count; ++i)
+			 {
+			   std::this_thread::yield();
+			   Lock lock(m);
+			   while(product == 0)
+			     cond.wait(lock);
+			   out << "got product "
+			       << std::this_thread::get_id()
+			       << ' ' << product << std::endl;
+			   --product;
+			 }
+		     } );
+
+  // single producer
+  for (std::size_t i = 0; i < threads.size() * count; ++i)
+    {
+      std::this_thread::yield();
+      Lock lock(m);
+      ++product;
+      out << "setting product " << std::this_thread::get_id()
+	  << ' ' << product << std::endl;
+      cond.notify_one();
+    }
+}
Index: libstdc++-v3/testsuite/ext/type_traits/remove_unsigned_integer_neg.cc
===================================================================
--- libstdc++-v3/testsuite/ext/type_traits/remove_unsigned_integer_neg.cc	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libstdc++-v3/testsuite/ext/type_traits/remove_unsigned_integer_neg.cc	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -36,4 +36,4 @@
 }
 
 // { dg-error "invalid use of incomplete" "" { target *-*-* } 28 } 
-// { dg-error "declaration of" "" { target *-*-* } 106 }
+// { dg-error "declaration of" "" { target *-*-* } 107 }
Index: libstdc++-v3/testsuite/ext/type_traits/add_unsigned_floating_neg.cc
===================================================================
--- libstdc++-v3/testsuite/ext/type_traits/add_unsigned_floating_neg.cc	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libstdc++-v3/testsuite/ext/type_traits/add_unsigned_floating_neg.cc	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -35,4 +35,4 @@
 }
 
 // { dg-error "instantiated from" "" { target *-*-* } 28 } 
-// { dg-error "no type" "" { target *-*-* } 69 } 
+// { dg-error "no type" "" { target *-*-* } 70 } 
Index: libstdc++-v3/testsuite/ext/type_traits/remove_unsigned_floating_neg.cc
===================================================================
--- libstdc++-v3/testsuite/ext/type_traits/remove_unsigned_floating_neg.cc	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libstdc++-v3/testsuite/ext/type_traits/remove_unsigned_floating_neg.cc	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -35,4 +35,4 @@
 }
 
 // { dg-error "instantiated from" "" { target *-*-* } 28 }
-// { dg-error "no type" "" { target *-*-* } 112 }
+// { dg-error "no type" "" { target *-*-* } 113 }
Index: libstdc++-v3/testsuite/ext/type_traits/add_unsigned_integer_neg.cc
===================================================================
--- libstdc++-v3/testsuite/ext/type_traits/add_unsigned_integer_neg.cc	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libstdc++-v3/testsuite/ext/type_traits/add_unsigned_integer_neg.cc	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -36,4 +36,4 @@
 }
 
 // { dg-error "invalid use of incomplete" "" { target *-*-* } 28 } 
-// { dg-error "declaration of" "" { target *-*-* } 63 }
+// { dg-error "declaration of" "" { target *-*-* } 64 }
Index: libstdc++-v3/testsuite/tr1/8_c_compatibility/complex/51083.cc
===================================================================
--- libstdc++-v3/testsuite/tr1/8_c_compatibility/complex/51083.cc	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ libstdc++-v3/testsuite/tr1/8_c_compatibility/complex/51083.cc	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,54 @@
+// { dg-options "-std=gnu++0x" }
+//
+// Copyright (C) 2011 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <tr1/complex>
+
+namespace a
+{
+  template<typename> class Mat { };
+
+  template<typename T> struct Mat2 : Mat<T> { };
+
+  template<typename T> int arg(Mat<T>) { return 1; }
+  template<typename T> int conj(Mat<T>) { return 1; }
+  template<typename T> int imag(Mat<T>) { return 1; }
+  template<typename T> int norm(Mat<T>) { return 1; }
+  template<typename T> int proj(Mat<T>) { return 1; }
+  template<typename T> int real(Mat<T>) { return 1; }
+
+  template<typename T, typename U> int pow(Mat<T>, U) { return 1; }
+  template<typename T, typename U> int pow(T, Mat<U>) { return 1; }
+}
+
+int main()
+{
+  int __attribute__((unused)) i;
+
+  using namespace std::tr1;
+
+  a::Mat2< std::complex<double> > c;
+  i = arg(c);
+  i = conj(c);
+  i = imag(c);
+  i = norm(c);
+  i = proj(c);
+  i = real(c);
+  i = pow(std::complex<float>(), c);
+  i = pow(c, std::complex<float>());
+}
Index: libstdc++-v3/testsuite/tr1/8_c_compatibility/complex/50880.cc
===================================================================
--- libstdc++-v3/testsuite/tr1/8_c_compatibility/complex/50880.cc	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ libstdc++-v3/testsuite/tr1/8_c_compatibility/complex/50880.cc	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,51 @@
+// Copyright (C) 2011 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <tr1/complex>
+#include <testsuite_hooks.h> 
+
+template<typename T>
+  void test01_do()
+  {
+    bool test __attribute__((unused)) = true;
+
+    const std::complex<T> ca(T(-2), T(2));
+    const std::complex<T> cb(T(-2), T(0));
+    const std::complex<T> cc(T(-2), T(-2));
+
+    std::complex<T> cra = std::tr1::acosh(ca);
+    std::complex<T> crb = std::tr1::acosh(cb);
+    std::complex<T> crc = std::tr1::acosh(cc);
+
+    VERIFY( cra.real() > T(0) );
+    VERIFY( crb.real() > T(0) );
+    VERIFY( crc.real() > T(0) );
+  }
+
+// libstdc++/50880
+void test01()
+{
+  test01_do<float>();
+  test01_do<double>();
+  test01_do<long double>();
+}
+
+int main()
+{
+  test01();
+  return 0;
+}
Index: libstdc++-v3/testsuite/tr1/8_c_compatibility/cmath/51083.cc
===================================================================
--- libstdc++-v3/testsuite/tr1/8_c_compatibility/cmath/51083.cc	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ libstdc++-v3/testsuite/tr1/8_c_compatibility/cmath/51083.cc	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,62 @@
+// { dg-options "-std=gnu++0x" }
+//
+// Copyright (C) 2011 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <tr1/cmath>
+
+namespace a
+{
+  template<typename> class Mat { };
+
+  template<typename T> struct Mat2 : Mat<T> { };
+
+  template<typename T>
+    int fdim(Mat<T>) { return 1; }
+
+  template<typename T, typename U>
+    int floor(Mat<T>, U) { return 1; }
+  template<typename T, typename U>
+    int floor(T, Mat<U>) { return 1; }
+
+  template<typename T, typename U, typename V>
+    int fma(Mat<T>, U, V) { return 1; }
+  template<typename T, typename U, typename V>
+    int fma(T, Mat<U>, V) { return 1; }
+  template<typename T, typename U, typename V>
+    int fma(T, U, Mat<V>) { return 1; }
+}
+
+int main()
+{
+  int __attribute__((unused)) i;
+
+  using namespace std::tr1;
+
+  a::Mat2<double> c;
+  i = fdim(c);
+  i = floor(c, 0.);
+  i = floor(0., c);
+  i = floor(c, 1);
+  i = floor(1, c);
+  i = fma(c, 0., 1.);
+  i = fma(0., c, 1.);
+  i = fma(0., 1., c);
+  i = fma(c, 0., 1);
+  i = fma(0., c, 1);
+  i = fma(0., 1, c);
+}
Index: libstdc++-v3/testsuite/23_containers/unordered_map/erase/51142.cc
===================================================================
--- libstdc++-v3/testsuite/23_containers/unordered_map/erase/51142.cc	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ libstdc++-v3/testsuite/23_containers/unordered_map/erase/51142.cc	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,38 @@
+// Copyright (C) 2011 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+//
+
+// { dg-do compile }
+// { dg-options "-std=gnu++0x" }
+
+#include <unordered_map>
+
+struct X
+{
+  template<typename T>
+  X(T&) {}
+};
+
+bool operator==(const X&, const X&) { return false; }
+
+// LWG 2059.
+void erasor(std::unordered_map<X, int>& s, X x)
+{
+  std::unordered_map<X, int>::iterator it = s.find(x);
+  if (it != s.end())
+    s.erase(it);
+}
Index: libstdc++-v3/testsuite/23_containers/multimap/modifiers/erase/51142.cc
===================================================================
--- libstdc++-v3/testsuite/23_containers/multimap/modifiers/erase/51142.cc	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ libstdc++-v3/testsuite/23_containers/multimap/modifiers/erase/51142.cc	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,38 @@
+// Copyright (C) 2011 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+//
+
+// { dg-do compile }
+// { dg-options "-std=gnu++0x" }
+
+#include <map>
+
+struct X
+{
+  template<typename T>
+  X(T&) {}
+};
+
+bool operator<(const X&, const X&) { return false; }
+
+// LWG 2059.
+void erasor(std::multimap<X, int>& s, X x)
+{
+  std::multimap<X, int>::iterator it = s.find(x);
+  if (it != s.end())
+    s.erase(it);
+}
Index: libstdc++-v3/testsuite/23_containers/set/modifiers/erase/51142.cc
===================================================================
--- libstdc++-v3/testsuite/23_containers/set/modifiers/erase/51142.cc	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ libstdc++-v3/testsuite/23_containers/set/modifiers/erase/51142.cc	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,38 @@
+// Copyright (C) 2011 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+//
+
+// { dg-do compile }
+// { dg-options "-std=gnu++0x" }
+
+#include <set>
+
+struct X
+{
+  template<typename T>
+  X(T&) {}
+};
+
+bool operator<(const X&, const X&) { return false; }
+
+// LWG 2059.
+void erasor(std::set<X>& s, X x)
+{
+  std::set<X>::iterator it = s.find(x);
+  if (it != s.end())
+    s.erase(it);
+}
Index: libstdc++-v3/testsuite/23_containers/unordered_multimap/erase/51142.cc
===================================================================
--- libstdc++-v3/testsuite/23_containers/unordered_multimap/erase/51142.cc	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ libstdc++-v3/testsuite/23_containers/unordered_multimap/erase/51142.cc	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,38 @@
+// Copyright (C) 2011 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+//
+
+// { dg-do compile }
+// { dg-options "-std=gnu++0x" }
+
+#include <unordered_map>
+
+struct X
+{
+  template<typename T>
+  X(T&) {}
+};
+
+bool operator==(const X&, const X&) { return false; }
+
+// LWG 2059.
+void erasor(std::unordered_multimap<X, int>& s, X x)
+{
+  std::unordered_multimap<X, int>::iterator it = s.find(x);
+  if (it != s.end())
+    s.erase(it);
+}
Index: libstdc++-v3/testsuite/23_containers/unordered_set/erase/51142.cc
===================================================================
--- libstdc++-v3/testsuite/23_containers/unordered_set/erase/51142.cc	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ libstdc++-v3/testsuite/23_containers/unordered_set/erase/51142.cc	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,38 @@
+// Copyright (C) 2011 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+//
+
+// { dg-do compile }
+// { dg-options "-std=gnu++0x" }
+
+#include <unordered_set>
+
+struct X
+{
+  template<typename T>
+  X(T&) {}
+};
+
+bool operator==(const X&, const X&) { return false; }
+
+// LWG 2059.
+void erasor(std::unordered_set<X>& s, X x)
+{
+  std::unordered_set<X>::iterator it = s.find(x);
+  if (it != s.end())
+    s.erase(it);
+}
Index: libstdc++-v3/testsuite/23_containers/multiset/modifiers/erase/51142.cc
===================================================================
--- libstdc++-v3/testsuite/23_containers/multiset/modifiers/erase/51142.cc	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ libstdc++-v3/testsuite/23_containers/multiset/modifiers/erase/51142.cc	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,38 @@
+// Copyright (C) 2011 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+//
+
+// { dg-do compile }
+// { dg-options "-std=gnu++0x" }
+
+#include <set>
+
+struct X
+{
+  template<typename T>
+  X(T&) {}
+};
+
+bool operator<(const X&, const X&) { return false; }
+
+// LWG 2059.
+void erasor(std::multiset<X>& s, X x)
+{
+  std::multiset<X>::iterator it = s.find(x);
+  if (it != s.end())
+    s.erase(it);
+}
Index: libstdc++-v3/testsuite/23_containers/unordered_multiset/erase/51142.cc
===================================================================
--- libstdc++-v3/testsuite/23_containers/unordered_multiset/erase/51142.cc	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ libstdc++-v3/testsuite/23_containers/unordered_multiset/erase/51142.cc	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,38 @@
+// Copyright (C) 2011 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+//
+
+// { dg-do compile }
+// { dg-options "-std=gnu++0x" }
+
+#include <unordered_set>
+
+struct X
+{
+  template<typename T>
+  X(T&) {}
+};
+
+bool operator==(const X&, const X&) { return false; }
+
+// LWG 2059.
+void erasor(std::unordered_multiset<X>& s, X x)
+{
+  std::unordered_multiset<X>::iterator it = s.find(x);
+  if (it != s.end())
+    s.erase(it);
+}
Index: libstdc++-v3/testsuite/23_containers/map/modifiers/erase/51142.cc
===================================================================
--- libstdc++-v3/testsuite/23_containers/map/modifiers/erase/51142.cc	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ libstdc++-v3/testsuite/23_containers/map/modifiers/erase/51142.cc	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,38 @@
+// Copyright (C) 2011 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+//
+
+// { dg-do compile }
+// { dg-options "-std=gnu++0x" }
+
+#include <map>
+
+struct X
+{
+  template<typename T>
+  X(T&) {}
+};
+
+bool operator<(const X&, const X&) { return false; }
+
+// LWG 2059.
+void erasor(std::map<X, int>& s, X x)
+{
+  std::map<X, int>::iterator it = s.find(x);
+  if (it != s.end())
+    s.erase(it);
+}
Index: libstdc++-v3/testsuite/20_util/shared_ptr/cons/43820_neg.cc
===================================================================
--- libstdc++-v3/testsuite/20_util/shared_ptr/cons/43820_neg.cc	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libstdc++-v3/testsuite/20_util/shared_ptr/cons/43820_neg.cc	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -35,6 +35,6 @@
   // { dg-error "incomplete" "" { target *-*-* } 766 }
 
   std::shared_ptr<X> p9(ap());  // { dg-error "here" }
-  // { dg-error "incomplete" "" { target *-*-* } 858 }
+  // { dg-error "incomplete" "" { target *-*-* } 859 }
 
 }
Index: libstdc++-v3/testsuite/20_util/allocator/51626.cc
===================================================================
--- libstdc++-v3/testsuite/20_util/allocator/51626.cc	(.../tags/gcc_4_6_2_release)	(wersja 0)
+++ libstdc++-v3/testsuite/20_util/allocator/51626.cc	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -0,0 +1,66 @@
+// Copyright (C) 2011 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++0x" }
+
+#include <memory>
+#include <vector>
+#include <testsuite_hooks.h>
+
+int count = 0;
+
+template <class T>
+  struct allocator98 : std::allocator<T>
+  {
+    template <class U> struct rebind { typedef allocator98<U> other; };
+
+    allocator98() { }
+
+    template <class U> allocator98(const allocator98<U>&) { };
+
+    void construct(T* p, const T& val)
+    {
+      ++count;
+      std::allocator<T>::construct(p, val);
+    }
+  };
+
+template <class T>
+  struct allocator11 : std::allocator<T>
+  {
+    template <class U> struct rebind { typedef allocator11<U> other; };
+
+    allocator11() { }
+
+    template <class U> allocator11(const allocator11<U>&) { };
+
+    template<typename... Args>
+      void construct(T* p, Args&&... args)
+      {
+	++count;
+	std::allocator<T>::construct(p, std::forward<Args>(args)...);
+      }
+  };
+
+int main()
+{
+  std::vector< int, allocator98<int> > v98(1);
+  VERIFY( count == 0 );
+
+  std::vector< int, allocator11<int> > v11(1);
+  VERIFY( count == 1 );
+}
Index: libstdc++-v3/testsuite/20_util/weak_ptr/comparison/cmp_neg.cc
===================================================================
--- libstdc++-v3/testsuite/20_util/weak_ptr/comparison/cmp_neg.cc	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libstdc++-v3/testsuite/20_util/weak_ptr/comparison/cmp_neg.cc	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -42,8 +42,8 @@
   return 0;
 }
 
-// { dg-warning "note" "" { target *-*-* } 354 }
-// { dg-warning "note" "" { target *-*-* } 1085 }
+// { dg-warning "note" "" { target *-*-* } 358 }
+// { dg-warning "note" "" { target *-*-* } 1086 }
 // { dg-warning "note" "" { target *-*-* } 468 }
 // { dg-warning "note" "" { target *-*-* } 586 }
 // { dg-warning "note" "" { target *-*-* } 1049 }
Index: configure.ac
===================================================================
--- configure.ac	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ configure.ac	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -2428,10 +2428,6 @@
     extra_arflags_for_target=" -X32_64"
     extra_nmflags_for_target=" -B -X32_64"
     ;;
-  *-*-darwin[[3-9]]*)
-    # ranlib before Darwin10 requires the -c flag to look at common symbols.
-    extra_ranlibflags_for_target=" -c"
-    ;;
   mips*-*-pe | sh*-*-pe | *arm-wince-pe)
     target_makefile_frag="config/mt-wince"
     ;;
Index: libobjc/configure
===================================================================
--- libobjc/configure	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libobjc/configure	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -8797,7 +8797,7 @@
       ;;
 
     # Unfortunately, older versions of FreeBSD 2 do not have this feature.
-    freebsd2*)
+    freebsd2.*)
       archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
       hardcode_direct=yes
       hardcode_minus_L=yes
@@ -9713,7 +9713,7 @@
     objformat=`/usr/bin/objformat`
   else
     case $host_os in
-    freebsd[123]*) objformat=aout ;;
+    freebsd[23].*) objformat=aout ;;
     *) objformat=elf ;;
     esac
   fi
@@ -9731,7 +9731,7 @@
   esac
   shlibpath_var=LD_LIBRARY_PATH
   case $host_os in
-  freebsd2*)
+  freebsd2.*)
     shlibpath_overrides_runpath=yes
     ;;
   freebsd3.[01]* | freebsdelf3.[01]*)
Index: libobjc/ChangeLog
===================================================================
--- libobjc/ChangeLog	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libobjc/ChangeLog	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1,3 +1,7 @@
+2011-11-20  Andreas Tobler  <andreast@fgznet.ch>
+
+	* configure: Regenerate.
+
 2011-10-26  Release Manager
 
 	* GCC 4.6.2 released.
Index: libgfortran/configure
===================================================================
--- libgfortran/configure	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libgfortran/configure	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -10326,7 +10326,7 @@
       ;;
 
     # Unfortunately, older versions of FreeBSD 2 do not have this feature.
-    freebsd2*)
+    freebsd2.*)
       archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
       hardcode_direct=yes
       hardcode_minus_L=yes
@@ -11242,7 +11242,7 @@
     objformat=`/usr/bin/objformat`
   else
     case $host_os in
-    freebsd[123]*) objformat=aout ;;
+    freebsd[23].*) objformat=aout ;;
     *) objformat=elf ;;
     esac
   fi
@@ -11260,7 +11260,7 @@
   esac
   shlibpath_var=LD_LIBRARY_PATH
   case $host_os in
-  freebsd2*)
+  freebsd2.*)
     shlibpath_overrides_runpath=yes
     ;;
   freebsd3.[01]* | freebsdelf3.[01]*)
@@ -14162,7 +14162,7 @@
       ;;
 
     # Unfortunately, older versions of FreeBSD 2 do not have this feature.
-    freebsd2*)
+    freebsd2.*)
       archive_cmds_FC='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
       hardcode_direct_FC=yes
       hardcode_minus_L_FC=yes
@@ -14870,7 +14870,7 @@
     objformat=`/usr/bin/objformat`
   else
     case $host_os in
-    freebsd[123]*) objformat=aout ;;
+    freebsd[23].*) objformat=aout ;;
     *) objformat=elf ;;
     esac
   fi
@@ -14888,7 +14888,7 @@
   esac
   shlibpath_var=LD_LIBRARY_PATH
   case $host_os in
-  freebsd2*)
+  freebsd2.*)
     shlibpath_overrides_runpath=yes
     ;;
   freebsd3.[01]* | freebsdelf3.[01]*)
Index: libgfortran/ChangeLog
===================================================================
--- libgfortran/ChangeLog	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libgfortran/ChangeLog	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1,3 +1,7 @@
+2011-11-20  Andreas Tobler  <andreast@fgznet.ch>
+
+	* configure: Regenerate.
+
 2011-10-26  Release Manager
 
 	* GCC 4.6.2 released.
Index: Makefile.def
===================================================================
--- Makefile.def	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ Makefile.def	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -353,6 +353,7 @@
 dependencies = { module=install-gcc ; on=install-fixincludes; };
 dependencies = { module=install-gcc ; on=install-lto-plugin; };
 dependencies = { module=install-strip-gcc ; on=install-strip-fixincludes; };
+dependencies = { module=install-strip-gcc ; on=install-strip-lto-plugin; };
 
 dependencies = { module=configure-libcpp; on=configure-libiberty; hard=true; };
 dependencies = { module=configure-libcpp; on=configure-intl; };
Index: libada/Makefile.in
===================================================================
--- libada/Makefile.in	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libada/Makefile.in	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -70,6 +70,7 @@
 version := $(shell cat $(srcdir)/../gcc/BASE-VER)
 libsubdir := $(libdir)/gcc/$(target_noncanonical)/$(version)$(MULTISUBDIR)
 ADA_RTS_DIR=$(GCC_DIR)/ada/rts$(subst /,_,$(MULTISUBDIR))
+ADA_RTS_SUBDIR=./rts$(subst /,_,$(MULTISUBDIR))
 
 # exeext should not be used because it's the *host* exeext.  We're building
 # a *target* library, aren't we?!?  Likewise for CC.  Still, provide bogus
@@ -96,10 +97,10 @@
         "CFLAGS=$(CFLAGS) $(WARN_CFLAGS)"
 
 # Rules to build gnatlib.
-.PHONY: gnatlib gnatlib-plain gnatlib-sjlj gnatlib-zcx gnatlib-shared oscons
+.PHONY: gnatlib gnatlib-plain gnatlib-sjlj gnatlib-zcx gnatlib-shared osconstool
 gnatlib: @default_gnatlib_target@
 
-gnatlib-plain: oscons $(GCC_DIR)/ada/Makefile
+gnatlib-plain: osconstool $(GCC_DIR)/ada/Makefile
 	test -f stamp-libada || \
 	$(MAKE) -C $(GCC_DIR)/ada $(LIBADA_FLAGS_TO_PASS) gnatlib \
 	&& touch stamp-libada
@@ -108,7 +109,7 @@
 	$(LN_S) $(ADA_RTS_DIR) adainclude
 	$(LN_S) $(ADA_RTS_DIR) adalib
 
-gnatlib-sjlj gnatlib-zcx gnatlib-shared: oscons $(GCC_DIR)/ada/Makefile
+gnatlib-sjlj gnatlib-zcx gnatlib-shared: osconstool $(GCC_DIR)/ada/Makefile
 	test -f stamp-libada || \
 	$(MAKE) -C $(GCC_DIR)/ada $(LIBADA_FLAGS_TO_PASS) $@ \
 	&& touch stamp-libada
@@ -117,8 +118,8 @@
 	$(LN_S) $(ADA_RTS_DIR) adainclude
 	$(LN_S) $(ADA_RTS_DIR) adalib
 
-oscons:
-	$(MAKE) -C $(GCC_DIR) $(LIBADA_FLAGS_TO_PASS) ada/s-oscons.ads
+osconstool:
+	$(MAKE) -C $(GCC_DIR)/ada $(LIBADA_FLAGS_TO_PASS) ./bldtools/oscons/xoscons
 
 install-gnatlib: $(GCC_DIR)/ada/Makefile
 	$(MAKE) -C $(GCC_DIR)/ada $(LIBADA_FLAGS_TO_PASS) install-gnatlib
Index: libada/ChangeLog
===================================================================
--- libada/ChangeLog	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libada/ChangeLog	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1,3 +1,9 @@
+2011-11-13  Iain Sandoe  <iains@gcc.gnu.org>
+
+	Backport from mainline r181319
+	Makefile.in: Change dependency on oscons to depend on the generator
+	tool.
+
 2011-10-26  Release Manager
 
 	* GCC 4.6.2 released.
Index: libmudflap/configure
===================================================================
--- libmudflap/configure	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libmudflap/configure	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -8818,7 +8818,7 @@
       ;;
 
     # Unfortunately, older versions of FreeBSD 2 do not have this feature.
-    freebsd2*)
+    freebsd2.*)
       archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
       hardcode_direct=yes
       hardcode_minus_L=yes
@@ -9731,7 +9731,7 @@
     objformat=`/usr/bin/objformat`
   else
     case $host_os in
-    freebsd[123]*) objformat=aout ;;
+    freebsd[23].*) objformat=aout ;;
     *) objformat=elf ;;
     esac
   fi
@@ -9749,7 +9749,7 @@
   esac
   shlibpath_var=LD_LIBRARY_PATH
   case $host_os in
-  freebsd2*)
+  freebsd2.*)
     shlibpath_overrides_runpath=yes
     ;;
   freebsd3.[01]* | freebsdelf3.[01]*)
Index: libmudflap/ChangeLog
===================================================================
--- libmudflap/ChangeLog	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libmudflap/ChangeLog	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1,3 +1,7 @@
+2011-11-20  Andreas Tobler  <andreast@fgznet.ch>
+
+	* configure: Regenerate.
+
 2011-10-26  Release Manager
 
 	* GCC 4.6.2 released.
Index: boehm-gc/ChangeLog
===================================================================
--- boehm-gc/ChangeLog	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ boehm-gc/ChangeLog	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1,3 +1,7 @@
+2011-11-20  Andreas Tobler  <andreast@fgznet.ch>
+
+	* configure: Regenerate.
+
 2011-10-26  Release Manager
 
 	* GCC 4.6.2 released.
Index: boehm-gc/configure
===================================================================
--- boehm-gc/configure	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ boehm-gc/configure	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -9604,7 +9604,7 @@
       ;;
 
     # Unfortunately, older versions of FreeBSD 2 do not have this feature.
-    freebsd2*)
+    freebsd2.*)
       archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
       hardcode_direct=yes
       hardcode_minus_L=yes
@@ -10520,7 +10520,7 @@
     objformat=`/usr/bin/objformat`
   else
     case $host_os in
-    freebsd[123]*) objformat=aout ;;
+    freebsd[23].*) objformat=aout ;;
     *) objformat=elf ;;
     esac
   fi
@@ -10538,7 +10538,7 @@
   esac
   shlibpath_var=LD_LIBRARY_PATH
   case $host_os in
-  freebsd2*)
+  freebsd2.*)
     shlibpath_overrides_runpath=yes
     ;;
   freebsd3.[01]* | freebsdelf3.[01]*)
@@ -12428,7 +12428,7 @@
         esac
         ;;
 
-      freebsd[12]*)
+      freebsd2.*)
         # C++ shared libraries reported to be fairly broken before
 	# switch to ELF
         ld_shlibs_CXX=no
@@ -14203,7 +14203,7 @@
     objformat=`/usr/bin/objformat`
   else
     case $host_os in
-    freebsd[123]*) objformat=aout ;;
+    freebsd[23].*) objformat=aout ;;
     *) objformat=elf ;;
     esac
   fi
@@ -14221,7 +14221,7 @@
   esac
   shlibpath_var=LD_LIBRARY_PATH
   case $host_os in
-  freebsd2*)
+  freebsd2.*)
     shlibpath_overrides_runpath=yes
     ;;
   freebsd3.[01]* | freebsdelf3.[01]*)
Index: libiberty/ChangeLog
===================================================================
--- libiberty/ChangeLog	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libiberty/ChangeLog	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1,3 +1,17 @@
+2011-11-13  Iain Sandoe  <iains@gcc.gnu.org>
+
+	PR target/48108
+	Backport from mainline r180523
+	* simple-object-mach-o.c  (GNU_WRAPPER_SECTS, GNU_WRAPPER_INDEX,
+	GNU_WRAPPER_NAMES): New macros.
+	(simple_object_mach_o_segment): Handle wrapper scheme.
+	(simple_object_mach_o_write_section_header): Allow the segment name
+	to be supplied.
+	(simple_object_mach_o_write_segment): Handle wrapper scheme.  Ensure
+	that the top-level segment name in the load command is empty.
+	(simple_object_mach_o_write_to_file): Determine the number of
+	sections during segment output, use that in writing the header.
+
 2011-10-26  Release Manager
 
 	* GCC 4.6.2 released.
Index: libiberty/simple-object-mach-o.c
===================================================================
--- libiberty/simple-object-mach-o.c	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libiberty/simple-object-mach-o.c	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1,5 +1,5 @@
 /* simple-object-mach-o.c -- routines to manipulate Mach-O object files.
-   Copyright 2010 Free Software Foundation, Inc.
+   Copyright 2010, 2011 Free Software Foundation, Inc.
    Written by Ian Lance Taylor, Google.
 
 This program is free software; you can redistribute it and/or modify it
@@ -174,6 +174,15 @@
 
 #define GNU_SECTION_NAMES "__section_names"
 
+/* A GNU-specific extension to wrap multiple sections using three
+   mach-o sections within a given segment.  The section '__wrapper_sects'
+   is subdivided according to the index '__wrapper_index' and each sub
+   sect is named according to the names supplied in '__wrapper_names'.  */
+
+#define GNU_WRAPPER_SECTS "__wrapper_sects"
+#define GNU_WRAPPER_INDEX "__wrapper_index"
+#define GNU_WRAPPER_NAMES "__wrapper_names"
+
 /* Private data for an simple_object_read.  */
 
 struct simple_object_mach_o_read
@@ -214,8 +223,19 @@
   unsigned int reserved;
 };
 
-/* See if we have a Mach-O file.  */
+/* See if we have a Mach-O MH_OBJECT file:
 
+   A standard MH_OBJECT (from as) will have three load commands:
+   0 - LC_SEGMENT/LC_SEGMENT64
+   1 - LC_SYMTAB
+   2 - LC_DYSYMTAB
+
+   The LC_SEGMENT/LC_SEGMENT64 will introduce a single anonymous segment
+   containing all the sections.
+
+   Files written by simple-object will have only the segment command
+   (no symbol tables).  */
+
 static void *
 simple_object_mach_o_match (
     unsigned char header[SIMPLE_OBJECT_MATCH_HEADER_LEN],
@@ -356,9 +376,30 @@
     }
 }
 
-/* Handle a segment in a Mach-O file.  Return 1 if we should continue,
-   0 if the caller should return.  */
+/* Handle a segment in a Mach-O Object file.
 
+   This will callback to the function pfn for each "section found" the meaning
+   of which depends on gnu extensions to mach-o:
+
+   If we find mach-o sections (with the segment name as specified) which also
+   contain: a 'sects' wrapper, an index, and a  name table, we expand this into
+   as many sections as are specified in the index.  In this case, there will
+   be a callback for each of these.
+
+   We will also allow an extension that permits long names (more than 16
+   characters) to be used with mach-o.  In this case, the section name has
+   a specific format embedding an index into a name table, and the file must
+   contain such name table.
+
+   Return 1 if we should continue, 0 if the caller should return.  */
+
+#define SOMO_SECTS_PRESENT 0x01
+#define SOMO_INDEX_PRESENT 0x02
+#define SOMO_NAMES_PRESENT 0x04
+#define SOMO_LONGN_PRESENT 0x08
+#define SOMO_WRAPPING (SOMO_SECTS_PRESENT | SOMO_INDEX_PRESENT \
+		       | SOMO_NAMES_PRESENT)
+
 static int
 simple_object_mach_o_segment (simple_object_read *sobj, off_t offset,
 			      const unsigned char *segbuf,
@@ -378,9 +419,20 @@
   unsigned int nsects;
   unsigned char *secdata;
   unsigned int i;
+  unsigned int gnu_sections_found;
   unsigned int strtab_index;
+  unsigned int index_index;
+  unsigned int nametab_index;
+  unsigned int sections_index;
   char *strtab;
+  char *nametab;
+  unsigned char *index;
   size_t strtab_size;
+  size_t nametab_size;
+  size_t index_size;
+  unsigned int n_wrapped_sects;
+  size_t wrapper_sect_size;
+  off_t wrapper_sect_offset;
 
   fetch_32 = (omr->is_big_endian
 	      ? simple_object_fetch_big_32
@@ -409,6 +461,8 @@
 					nsects));
     }
 
+  /* Fetch the section headers from the segment command.  */
+
   secdata = XNEWVEC (unsigned char, nsects * sechdrsize);
   if (!simple_object_internal_read (sobj->descriptor, offset + seghdrsize,
 				    secdata, nsects * sechdrsize, errmsg, err))
@@ -417,9 +471,13 @@
       return 0;
     }
 
-  /* Scan for a __section_names section.  This is in effect a GNU
-     extension that permits section names longer than 16 chars.  */
+  /* Scan for special sections that signal GNU extensions to the format.  */
 
+  gnu_sections_found = 0;
+  index_index = nsects;
+  sections_index = nsects;
+  strtab_index = nsects;
+  nametab_index = nsects;
   for (i = 0; i < nsects; ++i)
     {
       size_t nameoff;
@@ -427,19 +485,104 @@
       nameoff = i * sechdrsize + segname_offset;
       if (strcmp ((char *) secdata + nameoff, omr->segment_name) != 0)
 	continue;
+
       nameoff = i * sechdrsize + sectname_offset;
-      if (strcmp ((char *) secdata + nameoff, GNU_SECTION_NAMES) == 0)
-	break;
+      if (strcmp ((char *) secdata + nameoff, GNU_WRAPPER_NAMES) == 0)
+	{
+	  nametab_index = i;
+	  gnu_sections_found |= SOMO_NAMES_PRESENT;
+	}
+      else if (strcmp ((char *) secdata + nameoff, GNU_WRAPPER_INDEX) == 0)
+	{
+	  index_index = i;
+	  gnu_sections_found |= SOMO_INDEX_PRESENT;
+	}
+      else if (strcmp ((char *) secdata + nameoff, GNU_WRAPPER_SECTS) == 0)
+	{
+	  sections_index = i;
+	  gnu_sections_found |= SOMO_SECTS_PRESENT;
+	}
+      else if (strcmp ((char *) secdata + nameoff, GNU_SECTION_NAMES) == 0)
+	{
+	  strtab_index = i;
+	  gnu_sections_found |= SOMO_LONGN_PRESENT;
+	}
     }
 
-  strtab_index = i;
-  if (strtab_index >= nsects)
+  /* If any of the special wrapper section components is present, then
+     they all should be.  */
+
+  if ((gnu_sections_found & SOMO_WRAPPING) != 0)
     {
-      strtab = NULL;
-      strtab_size = 0;
+      off_t nametab_offset;
+      off_t index_offset;
+
+      if ((gnu_sections_found & SOMO_WRAPPING) != SOMO_WRAPPING)
+	{
+	  *errmsg = "GNU Mach-o section wrapper: required section missing";
+	  *err = 0; /* No useful errno.  */
+	  XDELETEVEC (secdata);
+	  return 0;
+	}
+
+      /* Fetch the name table.  */
+
+      simple_object_mach_o_section_info (omr->is_big_endian, is_32,
+					 secdata + nametab_index * sechdrsize,
+					 &nametab_offset, &nametab_size);
+      nametab = XNEWVEC (char, nametab_size);
+      if (!simple_object_internal_read (sobj->descriptor,
+					sobj->offset + nametab_offset,
+					(unsigned char *) nametab, nametab_size,
+					errmsg, err))
+	{
+	  XDELETEVEC (nametab);
+	  XDELETEVEC (secdata);
+	  return 0;
+	}
+
+      /* Fetch the index.  */
+
+      simple_object_mach_o_section_info (omr->is_big_endian, is_32,
+					 secdata + index_index * sechdrsize,
+					 &index_offset, &index_size);
+      index = XNEWVEC (unsigned char, index_size);
+      if (!simple_object_internal_read (sobj->descriptor,
+					sobj->offset + index_offset,
+					index, index_size,
+					errmsg, err))
+	{
+	  XDELETEVEC (index);
+	  XDELETEVEC (nametab);
+	  XDELETEVEC (secdata);
+	  return 0;
+	}
+
+      /* The index contains 4 unsigned ints per sub-section:
+	 sub-section offset/length, sub-section name/length.
+	 We fix this for both 32 and 64 bit mach-o for now, since
+	 other fields limit the maximum size of an object to 4G.  */
+      n_wrapped_sects = index_size / 16;
+
+      /* Get the parameters for the wrapper too.  */
+      simple_object_mach_o_section_info (omr->is_big_endian, is_32,
+					 secdata + sections_index * sechdrsize,
+					 &wrapper_sect_offset,
+					 &wrapper_sect_size);
     }
   else
     {
+      index = NULL;
+      index_size = 0;
+      nametab = NULL;
+      nametab_size = 0;
+      n_wrapped_sects = 0;
+    }
+
+  /* If we have a long names section, fetch it.  */
+
+  if ((gnu_sections_found & SOMO_LONGN_PRESENT) != 0)
+    {
       off_t strtab_offset;
 
       simple_object_mach_o_section_info (omr->is_big_endian, is_32,
@@ -452,52 +595,120 @@
 					errmsg, err))
 	{
 	  XDELETEVEC (strtab);
+	  XDELETEVEC (index);
+	  XDELETEVEC (nametab);
 	  XDELETEVEC (secdata);
 	  return 0;
 	}
     }
+  else
+    {
+      strtab = NULL;
+      strtab_size = 0;
+      strtab_index = nsects;
+    }
 
   /* Process the sections.  */
 
   for (i = 0; i < nsects; ++i)
     {
       const unsigned char *sechdr;
-      char namebuf[MACH_O_NAME_LEN + 1];
+      char namebuf[MACH_O_NAME_LEN * 2 + 2];
       char *name;
       off_t secoffset;
       size_t secsize;
+      int l;
 
-      if (i == strtab_index)
+      sechdr = secdata + i * sechdrsize;
+
+      /* We've already processed the long section names.  */
+
+      if ((gnu_sections_found & SOMO_LONGN_PRESENT) != 0
+	  && i == strtab_index)
 	continue;
 
-      sechdr = secdata + i * sechdrsize;
+      /* We only act on the segment named.  */
 
       if (strcmp ((char *) sechdr + segname_offset, omr->segment_name) != 0)
 	continue;
 
-      memcpy (namebuf, sechdr + sectname_offset, MACH_O_NAME_LEN);
-      namebuf[MACH_O_NAME_LEN] = '\0';
+      /* Process sections associated with the wrapper.  */
 
-      name = &namebuf[0];
-      if (strtab != NULL && name[0] == '_' && name[1] == '_')
+      if ((gnu_sections_found & SOMO_WRAPPING) != 0)
 	{
-	  unsigned long stringoffset;
+	  if (i == nametab_index || i == index_index)
+	    continue;
 
-	  if (sscanf (name + 2, "%08lX", &stringoffset) == 1)
+	  if (i == sections_index)
 	    {
-	      if (stringoffset >= strtab_size)
+	      unsigned int j;
+	      for (j = 0; j < n_wrapped_sects; ++j)
 		{
-		  *errmsg = "section name offset out of range";
-		  *err = 0;
-		  XDELETEVEC (strtab);
-		  XDELETEVEC (secdata);
-		  return 0;
+		  unsigned int subsect_offset, subsect_length, name_offset;
+		  subsect_offset = (*fetch_32) (index + 16 * j);
+		  subsect_length = (*fetch_32) (index + 16 * j + 4);
+		  name_offset = (*fetch_32) (index + 16 * j + 8);
+		  /* We don't need the name_length yet.  */
+
+		  secoffset = wrapper_sect_offset + subsect_offset;
+		  secsize = subsect_length;
+		  name = nametab + name_offset;
+
+		  if (!(*pfn) (data, name, secoffset, secsize))
+		    {
+		      *errmsg = NULL;
+		      *err = 0;
+		      XDELETEVEC (index);
+		      XDELETEVEC (nametab);
+		      XDELETEVEC (strtab);
+		      XDELETEVEC (secdata);
+		      return 0;
+		    }
 		}
-
-	      name = strtab + stringoffset;
+	      continue;
 	    }
 	}
 
+      if ((gnu_sections_found & SOMO_LONGN_PRESENT) != 0)
+	{
+	  memcpy (namebuf, sechdr + sectname_offset, MACH_O_NAME_LEN);
+	  namebuf[MACH_O_NAME_LEN] = '\0';
+
+	  name = &namebuf[0];
+	  if (strtab != NULL && name[0] == '_' && name[1] == '_')
+	    {
+	      unsigned long stringoffset;
+
+	      if (sscanf (name + 2, "%08lX", &stringoffset) == 1)
+		{
+		  if (stringoffset >= strtab_size)
+		    {
+		      *errmsg = "section name offset out of range";
+		      *err = 0;
+		      XDELETEVEC (index);
+		      XDELETEVEC (nametab);
+		      XDELETEVEC (strtab);
+		      XDELETEVEC (secdata);
+		      return 0;
+		    }
+
+		  name = strtab + stringoffset;
+		}
+	  }
+	}
+      else
+	{
+	   /* Otherwise, make a name like __segment,__section as per the
+	      convention in mach-o asm.  */
+	  name = &namebuf[0];
+	  memset (namebuf, 0, MACH_O_NAME_LEN * 2 + 2);
+	  memcpy (namebuf, (char *) sechdr + segname_offset, MACH_O_NAME_LEN);
+	  l = strlen (namebuf);
+	  namebuf[l] = ',';
+	  memcpy (namebuf + l + 1, (char *) sechdr + sectname_offset,
+		  MACH_O_NAME_LEN);
+	}
+
       simple_object_mach_o_section_info (omr->is_big_endian, is_32, sechdr,
 					 &secoffset, &secsize);
 
@@ -505,12 +716,16 @@
 	{
 	  *errmsg = NULL;
 	  *err = 0;
+	  XDELETEVEC (index);
+	  XDELETEVEC (nametab);
 	  XDELETEVEC (strtab);
 	  XDELETEVEC (secdata);
 	  return 0;
 	}
     }
 
+  XDELETEVEC (index);
+  XDELETEVEC (nametab);
   XDELETEVEC (strtab);
   XDELETEVEC (secdata);
 
@@ -724,9 +939,9 @@
 simple_object_mach_o_write_section_header (simple_object_write *sobj,
 					   int descriptor,
 					   size_t sechdr_offset,
-					   const char *name, size_t secaddr,
-					   size_t secsize, size_t offset,
-					   unsigned int align,
+					   const char *name, const char *segn,
+					   size_t secaddr, size_t secsize,
+					   size_t offset, unsigned int align,
 					   const char **errmsg, int *err)
 {
   struct simple_object_mach_o_attributes *attrs =
@@ -748,7 +963,7 @@
       strncpy ((char *) hdr + offsetof (struct mach_o_section_32, sectname),
 	       name, MACH_O_NAME_LEN);
       strncpy ((char *) hdr + offsetof (struct mach_o_section_32, segname),
-	       sobj->segment_name, MACH_O_NAME_LEN);
+	       segn, MACH_O_NAME_LEN);
       set_32 (hdr + offsetof (struct mach_o_section_32, addr), secaddr);
       set_32 (hdr + offsetof (struct mach_o_section_32, size), secsize);
       set_32 (hdr + offsetof (struct mach_o_section_32, offset), offset);
@@ -773,7 +988,7 @@
       strncpy ((char *) hdr + offsetof (struct mach_o_section_64, sectname),
 	       name, MACH_O_NAME_LEN);
       strncpy ((char *) hdr + offsetof (struct mach_o_section_64, segname),
-	       sobj->segment_name, MACH_O_NAME_LEN);
+	       segn, MACH_O_NAME_LEN);
       set_64 (hdr + offsetof (struct mach_o_section_64, addr), secaddr);
       set_64 (hdr + offsetof (struct mach_o_section_64, size), secsize);
       set_32 (hdr + offsetof (struct mach_o_section_64, offset), offset);
@@ -793,11 +1008,25 @@
 				       sechdrsize, errmsg, err);
 }
 
-/* Write out the single segment and the sections of a Mach-O file.  */
+/* Write out the single (anonymous) segment containing the sections of a Mach-O
+   Object file.
 
+   As a GNU extension to mach-o, when the caller specifies a segment name in
+   sobj->segment_name, all the sections passed will be output under a single
+   mach-o section header.  The caller's sections are indexed within this
+   'wrapper' section by a table stored in a second mach-o section.  Finally,
+   arbitrary length section names are permitted by the extension and these are
+   stored in a table in a third mach-o section.
+
+   Note that this is only likely to make any sense for the __GNU_LTO segment
+   at present.
+
+   If the wrapper extension is not in force, we assume that the section name
+   is in the form __SEGMENT_NAME,__section_name as per Mach-O asm.  */
+
 static int
 simple_object_mach_o_write_segment (simple_object_write *sobj, int descriptor,
-				    size_t nsects, const char **errmsg,
+				    size_t *nsects, const char **errmsg,
 				    int *err)
 {
   struct simple_object_mach_o_attributes *attrs =
@@ -814,6 +1043,10 @@
   simple_object_write_section *section;
   unsigned char hdrbuf[sizeof (struct mach_o_segment_command_64)];
   unsigned char *hdr;
+  size_t nsects_in;
+  unsigned int *index;
+  char *snames;
+  unsigned int sect;
 
   set_32 = (attrs->is_big_endian
 	    ? simple_object_set_big_32
@@ -834,19 +1067,62 @@
       sechdrsize = sizeof (struct mach_o_section_64);
     }
 
+  name_offset = 0;
+  *nsects = nsects_in = 0;
+
+  /* Count the number of sections we start with.  */
+
+  for (section = sobj->sections; section != NULL; section = section->next)
+    nsects_in++;
+
+  if (sobj->segment_name != NULL)
+    {
+      /* We will only write 3 sections: wrapped data, index and names.  */
+
+      *nsects = 3;
+
+      /* The index has four entries per wrapped section:
+	   Section Offset, length,  Name offset, length.
+	 Where the offsets are based at the start of the wrapper and name
+	 sections respectively.
+	 The values are stored as 32 bit int for both 32 and 64 bit mach-o
+	 since the size of a mach-o MH_OBJECT cannot exceed 4G owing to
+	 other constraints.  */
+
+      index = XNEWVEC (unsigned int, nsects_in * 4);
+
+      /* We now need to figure out the size of the names section.  This just
+	 stores the names as null-terminated c strings, packed without any
+	 alignment padding.  */
+
+      for (section = sobj->sections, sect = 0; section != NULL;
+	   section = section->next, sect++)
+	{
+	  index[sect*4+2] = name_offset;
+	  index[sect*4+3] = strlen (section->name) + 1;
+	  name_offset += strlen (section->name) + 1;
+	}
+      snames = XNEWVEC (char, name_offset);
+    }
+  else
+    {
+      *nsects = nsects_in;
+      index = NULL;
+      snames = NULL;
+    }
+
   sechdr_offset = hdrsize + seghdrsize;
-  cmdsize = seghdrsize + nsects * sechdrsize;
+  cmdsize = seghdrsize + *nsects * sechdrsize;
   offset = hdrsize + cmdsize;
-  name_offset = 0;
   secaddr = 0;
 
-  for (section = sobj->sections; section != NULL; section = section->next)
+  for (section = sobj->sections, sect = 0;
+       section != NULL; section = section->next, sect++)
     {
       size_t mask;
       size_t new_offset;
       size_t secsize;
       struct simple_object_write_section_buffer *buffer;
-      char namebuf[MACH_O_NAME_LEN + 1];
 
       mask = (1U << section->align) - 1;
       new_offset = offset + mask;
@@ -877,39 +1153,126 @@
 	  secsize += buffer->size;
 	}
 
-      snprintf (namebuf, sizeof namebuf, "__%08X", name_offset);
+      if (sobj->segment_name != NULL)
+	{
+	  index[sect*4+0] = (unsigned int) offset;
+	  index[sect*4+1] = secsize;
+	  /* Stash the section name in our table.  */
+	  memcpy (snames + index[sect * 4 + 2], section->name,
+		  index[sect * 4 + 3]);
+	}
+      else
+	{
+	  char namebuf[MACH_O_NAME_LEN + 1];
+	  char segnbuf[MACH_O_NAME_LEN + 1];
+	  char *comma;
+
+	  /* Try to extract segment,section from the input name.  */
+
+	  memset (namebuf, 0, sizeof namebuf);
+	  memset (segnbuf, 0, sizeof segnbuf);
+	  comma = strchr (section->name, ',');
+	  if (comma != NULL)
+	    {
+	      int len = comma - section->name;
+	      len = len > MACH_O_NAME_LEN ? MACH_O_NAME_LEN : len;
+	      strncpy (namebuf, section->name, len);
+	      strncpy (segnbuf, comma + 1, MACH_O_NAME_LEN);
+	    }
+	  else /* just try to copy the name, leave segment blank.  */
+	    strncpy (namebuf, section->name, MACH_O_NAME_LEN);
+
+	  if (!simple_object_mach_o_write_section_header (sobj, descriptor,
+							  sechdr_offset,
+							  namebuf, segnbuf,
+							  secaddr, secsize,
+							  offset,
+							  section->align,
+							  errmsg, err))
+	    return 0;
+	  sechdr_offset += sechdrsize;
+	}
+
+      offset += secsize;
+      secaddr += secsize;
+    }
+
+  if (sobj->segment_name != NULL)
+    {
+      size_t secsize;
+      unsigned int i;
+
+      /* Write the section header for the wrapper.  */
+      /* Account for any initial aligment - which becomes the alignment for this
+	 created section.  */
+
+      secsize = (offset - index[0]);
       if (!simple_object_mach_o_write_section_header (sobj, descriptor,
-						      sechdr_offset, namebuf,
-						      secaddr, secsize, offset,
-						      section->align,
+						      sechdr_offset,
+						      GNU_WRAPPER_SECTS,
+						      sobj->segment_name,
+						      0 /*secaddr*/,
+						      secsize, index[0],
+						      sobj->sections->align,
 						      errmsg, err))
 	return 0;
 
+      /* Subtract the wrapper section start from the begining of each sub
+	 section.  */
+
+      for (i = 1; i < nsects_in; ++i)
+	index[4 * i] -= index[0];
+      index[0] = 0;
+
       sechdr_offset += sechdrsize;
-      offset += secsize;
-      name_offset += strlen (section->name) + 1;
-      secaddr += secsize;
-    }
 
-  /* Write out the section names.  */
+      /* Write out the section names.
+	 ... the header ...
+	 name_offset contains the length of the section.  It is not aligned.  */
 
-  if (!simple_object_mach_o_write_section_header (sobj, descriptor,
-						  sechdr_offset,
-						  GNU_SECTION_NAMES, secaddr,
-						  name_offset, offset, 0,
-						  errmsg, err))
-    return 0;
+      if (!simple_object_mach_o_write_section_header (sobj, descriptor,
+						      sechdr_offset,
+						      GNU_WRAPPER_NAMES,
+						      sobj->segment_name,
+						      0 /*secaddr*/,
+						      name_offset,
+						      offset,
+						      0, errmsg, err))
+	return 0;
 
-  for (section = sobj->sections; section != NULL; section = section->next)
-    {
-      size_t namelen;
+      /* ... and the content.. */
+      if (!simple_object_internal_write (descriptor, offset,
+					 (const unsigned char *) snames,
+					 name_offset, errmsg, err))
+	return 0;
 
-      namelen = strlen (section->name) + 1;
+      sechdr_offset += sechdrsize;
+      secaddr += name_offset;
+      offset += name_offset;
+
+      /* Now do the index, we'll align this to 4 bytes although the read code
+	 will handle unaligned.  */
+
+      offset += 3;
+      offset &= ~0x03;
+      if (!simple_object_mach_o_write_section_header (sobj, descriptor,
+						      sechdr_offset,
+						      GNU_WRAPPER_INDEX,
+						      sobj->segment_name,
+						      0 /*secaddr*/,
+						      nsects_in * 16,
+						      offset,
+						      2, errmsg, err))
+	return 0;
+
+      /* ... and the content.. */
       if (!simple_object_internal_write (descriptor, offset,
-					 (const unsigned char *) section->name,
-					 namelen, errmsg, err))
+					 (const unsigned char *) index,
+					 nsects_in*16, errmsg, err))
 	return 0;
-      offset += namelen;
+
+      XDELETEVEC (index);
+      XDELETEVEC (snames);
     }
 
   /* Write out the segment header.  */
@@ -923,9 +1286,8 @@
 	      MACH_O_LC_SEGMENT);
       set_32 (hdr + offsetof (struct mach_o_segment_command_32, cmdsize),
 	      cmdsize);
-      strncpy (((char *) hdr
-		+ offsetof (struct mach_o_segment_command_32, segname)),
-	       sobj->segment_name, MACH_O_NAME_LEN);
+     /* MH_OBJECTS have a single, anonymous, segment - so the segment name
+	 is left empty.  */
       /* vmaddr left as zero.  */
       /* vmsize left as zero.  */
       set_32 (hdr + offsetof (struct mach_o_segment_command_32, fileoff),
@@ -935,7 +1297,7 @@
       /* maxprot left as zero.  */
       /* initprot left as zero.  */
       set_32 (hdr + offsetof (struct mach_o_segment_command_32, nsects),
-	      nsects);
+	      *nsects);
       /* flags left as zero.  */
     }
   else
@@ -951,9 +1313,8 @@
 	      MACH_O_LC_SEGMENT);
       set_32 (hdr + offsetof (struct mach_o_segment_command_64, cmdsize),
 	      cmdsize);
-      strncpy (((char *) hdr
-		+ offsetof (struct mach_o_segment_command_64, segname)),
-	       sobj->segment_name, MACH_O_NAME_LEN);
+      /* MH_OBJECTS have a single, anonymous, segment - so the segment name
+	 is left empty.  */
       /* vmaddr left as zero.  */
       /* vmsize left as zero.  */
       set_64 (hdr + offsetof (struct mach_o_segment_command_64, fileoff),
@@ -963,7 +1324,7 @@
       /* maxprot left as zero.  */
       /* initprot left as zero.  */
       set_32 (hdr + offsetof (struct mach_o_segment_command_64, nsects),
-	      nsects);
+	      *nsects);
       /* flags left as zero.  */
 #endif
     }
@@ -978,23 +1339,17 @@
 simple_object_mach_o_write_to_file (simple_object_write *sobj, int descriptor,
 				    int *err)
 {
-  size_t nsects;
-  simple_object_write_section *section;
+  size_t nsects = 0;
   const char *errmsg;
 
-  /* Start at 1 for symbol_names section.  */
-  nsects = 1;
-  for (section = sobj->sections; section != NULL; section = section->next)
-    ++nsects;
+  if (!simple_object_mach_o_write_segment (sobj, descriptor, &nsects,
+					   &errmsg, err))
+    return errmsg;
 
   if (!simple_object_mach_o_write_header (sobj, descriptor, nsects,
 					  &errmsg, err))
     return errmsg;
 
-  if (!simple_object_mach_o_write_segment (sobj, descriptor, nsects,
-					   &errmsg, err))
-    return errmsg;
-
   return NULL;
 }
 
Index: ChangeLog
===================================================================
--- ChangeLog	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ ChangeLog	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1,3 +1,23 @@
+2012-01-02  Richard Guenther  <rguenther@suse.de>
+
+	PR bootstrap/51686
+	* Makefile.def (install-strip-gcc): Depend on install-strip-lto-plugin.
+	* Makefile.in: Regenerate.
+
+2011-12-18  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* configure: Regenerate.
+
+2011-11-20  Andreas Tobler  <andreast@fgznet.ch>
+
+	* libtool.m4: Additional FreeBSD 10 fixes.
+
+2011-11-18  Iain Sandoe  <iains@gcc.gnu.org>
+
+	PR target/49992
+	* configure.ac: Remove ranlib special-casing for Darwin.
+	* configure: Regenerate.
+
 2011-10-26  Release Manager
 
 	* GCC 4.6.2 released.
Index: lto-plugin/configure
===================================================================
--- lto-plugin/configure	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ lto-plugin/configure	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -622,6 +622,7 @@
 GREP
 SED
 LIBTOOL
+ac_lto_plugin_warn_cflags
 am__fastdepCC_FALSE
 am__fastdepCC_TRUE
 CCDEPMODE
@@ -4040,6 +4041,45 @@
   fi
 fi
 
+ac_lto_plugin_warn_cflags=
+save_CFLAGS="$CFLAGS"
+for option in -Wall; do
+  as_acx_Woption=`$as_echo "acx_cv_prog_cc_warning_$option" | $as_tr_sh`
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CC supports $option" >&5
+$as_echo_n "checking whether $CC supports $option... " >&6; }
+if { as_var=$as_acx_Woption; eval "test \"\${$as_var+set}\" = set"; }; then :
+  $as_echo_n "(cached) " >&6
+else
+  CFLAGS="$option"
+    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  eval "$as_acx_Woption=yes"
+else
+  eval "$as_acx_Woption=no"
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+fi
+eval ac_res=\$$as_acx_Woption
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+  if test `eval 'as_val=${'$as_acx_Woption'};$as_echo "$as_val"'` = yes; then :
+  ac_lto_plugin_warn_cflags="$ac_lto_plugin_warn_cflags${ac_lto_plugin_warn_cflags:+ }$option"
+fi
+  done
+CFLAGS="$save_CFLAGS"
+
 case `pwd` in
   *\ * | *\	*)
     { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Libtool does not cope well with whitespace in \`pwd\`" >&5
@@ -8733,7 +8773,7 @@
       ;;
 
     # Unfortunately, older versions of FreeBSD 2 do not have this feature.
-    freebsd2*)
+    freebsd2.*)
       archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
       hardcode_direct=yes
       hardcode_minus_L=yes
@@ -9646,7 +9686,7 @@
     objformat=`/usr/bin/objformat`
   else
     case $host_os in
-    freebsd[123]*) objformat=aout ;;
+    freebsd[23].*) objformat=aout ;;
     *) objformat=elf ;;
     esac
   fi
@@ -9664,7 +9704,7 @@
   esac
   shlibpath_var=LD_LIBRARY_PATH
   case $host_os in
-  freebsd2*)
+  freebsd2.*)
     shlibpath_overrides_runpath=yes
     ;;
   freebsd3.[01]* | freebsdelf3.[01]*)
@@ -10498,7 +10538,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 10501 "configure"
+#line 10541 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -10604,7 +10644,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 10607 "configure"
+#line 10647 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
Index: lto-plugin/Makefile.in
===================================================================
--- lto-plugin/Makefile.in	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ lto-plugin/Makefile.in	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -47,6 +47,7 @@
 	$(top_srcdir)/../config/lead-dot.m4 \
 	$(top_srcdir)/../config/lthostflags.m4 \
 	$(top_srcdir)/../config/override.m4 \
+	$(top_srcdir)/../config/warnings.m4 \
 	$(top_srcdir)/../libtool.m4 $(top_srcdir)/../ltoptions.m4 \
 	$(top_srcdir)/../ltsugar.m4 $(top_srcdir)/../ltversion.m4 \
 	$(top_srcdir)/../lt~obsolete.m4 $(top_srcdir)/configure.ac
@@ -167,6 +168,7 @@
 abs_top_srcdir = @abs_top_srcdir@
 ac_ct_CC = @ac_ct_CC@
 ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+ac_lto_plugin_warn_cflags = @ac_lto_plugin_warn_cflags@
 am__include = @am__include@
 am__leading_dot = @am__leading_dot@
 am__quote = @am__quote@
@@ -227,7 +229,7 @@
 gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)
 libexecsubdir := $(libexecdir)/gcc/$(target_noncanonical)/$(gcc_version)
 AM_CPPFLAGS = -I$(top_srcdir)/../include $(DEFS)
-AM_CFLAGS = -Wall -Werror
+AM_CFLAGS = @ac_lto_plugin_warn_cflags@
 AM_LIBTOOLFLAGS = --tag=disable-static
 libexecsub_LTLIBRARIES = liblto_plugin.la
 gcc_build_dir = ../$(host_subdir)/gcc
Index: lto-plugin/configure.ac
===================================================================
--- lto-plugin/configure.ac	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ lto-plugin/configure.ac	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -6,6 +6,7 @@
 AM_MAINTAINER_MODE
 AC_PROG_CC
 AC_SYS_LARGEFILE
+ACX_PROG_CC_WARNING_OPTS([-Wall], [ac_lto_plugin_warn_cflags])
 AM_PROG_LIBTOOL
 ACX_LT_HOST_FLAGS
 AC_SUBST(target_noncanonical)
Index: lto-plugin/ChangeLog
===================================================================
--- lto-plugin/ChangeLog	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ lto-plugin/ChangeLog	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1,3 +1,20 @@
+2012-01-03  Richard Guenther  <rguenther@suse.de>
+
+	Backport from mainline
+	2011-08-10  Richard Guenther  <rguenther@suse.de>
+
+	PR bootstrap/49907
+	lto-plugin/
+	* configure.ac: Use ACX_PROG_CC_WARNING_OPTS to detect -Wall presence.
+	* Makefile.am (AM_CFLAGS): Adjust.  Do not build with -Werror.
+	* configure: Regenerate.
+	* Makefile.in: Likewise.
+	* aclocal.m4: Likewise.
+
+2011-11-20  Andreas Tobler  <andreast@fgznet.ch>
+
+	* configure: Regenerate.
+
 2011-10-26  Release Manager
 
 	* GCC 4.6.2 released.
Index: lto-plugin/Makefile.am
===================================================================
--- lto-plugin/Makefile.am	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ lto-plugin/Makefile.am	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -8,7 +8,7 @@
 libexecsubdir := $(libexecdir)/gcc/$(target_noncanonical)/$(gcc_version)
 
 AM_CPPFLAGS = -I$(top_srcdir)/../include $(DEFS)
-AM_CFLAGS = -Wall -Werror
+AM_CFLAGS = @ac_lto_plugin_warn_cflags@
 AM_LIBTOOLFLAGS = --tag=disable-static
 
 libexecsub_LTLIBRARIES = liblto_plugin.la
Index: lto-plugin/aclocal.m4
===================================================================
--- lto-plugin/aclocal.m4	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ lto-plugin/aclocal.m4	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -973,6 +973,7 @@
 m4_include([../config/lead-dot.m4])
 m4_include([../config/lthostflags.m4])
 m4_include([../config/override.m4])
+m4_include([../config/warnings.m4])
 m4_include([../libtool.m4])
 m4_include([../ltoptions.m4])
 m4_include([../ltsugar.m4])
Index: libffi/configure
===================================================================
--- libffi/configure	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libffi/configure	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -9001,7 +9001,7 @@
       ;;
 
     # Unfortunately, older versions of FreeBSD 2 do not have this feature.
-    freebsd2*)
+    freebsd2.*)
       archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
       hardcode_direct=yes
       hardcode_minus_L=yes
@@ -9914,7 +9914,7 @@
     objformat=`/usr/bin/objformat`
   else
     case $host_os in
-    freebsd[123]*) objformat=aout ;;
+    freebsd[23].*) objformat=aout ;;
     *) objformat=elf ;;
     esac
   fi
@@ -9932,7 +9932,7 @@
   esac
   shlibpath_var=LD_LIBRARY_PATH
   case $host_os in
-  freebsd2*)
+  freebsd2.*)
     shlibpath_overrides_runpath=yes
     ;;
   freebsd3.[01]* | freebsdelf3.[01]*)
Index: libffi/ChangeLog
===================================================================
--- libffi/ChangeLog	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libffi/ChangeLog	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1,3 +1,7 @@
+2011-11-20  Andreas Tobler  <andreast@fgznet.ch>
+
+	* configure: Regenerate.
+
 2011-10-26  Release Manager
 
 	* GCC 4.6.2 released.
Index: libssp/configure
===================================================================
--- libssp/configure	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libssp/configure	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -8864,7 +8864,7 @@
       ;;
 
     # Unfortunately, older versions of FreeBSD 2 do not have this feature.
-    freebsd2*)
+    freebsd2.*)
       archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
       hardcode_direct=yes
       hardcode_minus_L=yes
@@ -9780,7 +9780,7 @@
     objformat=`/usr/bin/objformat`
   else
     case $host_os in
-    freebsd[123]*) objformat=aout ;;
+    freebsd[23].*) objformat=aout ;;
     *) objformat=elf ;;
     esac
   fi
@@ -9798,7 +9798,7 @@
   esac
   shlibpath_var=LD_LIBRARY_PATH
   case $host_os in
-  freebsd2*)
+  freebsd2.*)
     shlibpath_overrides_runpath=yes
     ;;
   freebsd3.[01]* | freebsdelf3.[01]*)
Index: libssp/ChangeLog
===================================================================
--- libssp/ChangeLog	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libssp/ChangeLog	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1,3 +1,7 @@
+2011-11-20  Andreas Tobler  <andreast@fgznet.ch>
+
+	* configure: Regenerate.
+
 2011-10-26  Release Manager
 
 	* GCC 4.6.2 released.
Index: config/ChangeLog
===================================================================
--- config/ChangeLog	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ config/ChangeLog	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1,3 +1,7 @@
+2011-12-18  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* acx.m4 (Test for GNAT): Update comment and add quotes in final test.
+
 2011-10-26  Release Manager
 
 	* GCC 4.6.2 released.
Index: config/acx.m4
===================================================================
--- config/acx.m4	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ config/acx.m4	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -356,9 +356,9 @@
 ac_c_preproc_warn_flag=yes])# AC_PROG_CPP_WERROR
 
 # Test for GNAT.
-# We require the gnatbind program, and a compiler driver that
-# understands Ada.  We use the user's CC setting, already found,
-# and possibly add $1 to the command-line parameters.
+# We require the gnatbind & gnatmake programs, as well as a compiler driver
+# that understands Ada.  We use the user's CC setting, already found, and
+# possibly add $1 to the command-line parameters.
 #
 # Sets the shell variable have_gnat to yes or no as appropriate, and
 # substitutes GNATBIND and GNATMAKE.
@@ -387,7 +387,7 @@
 fi
 rm -f conftest.*])
 
-if test x$GNATBIND != xno && test x$GNATMAKE != xno && test x$acx_cv_cc_gcc_supports_ada != xno; then
+if test "x$GNATBIND" != xno && test "x$GNATMAKE" != xno && test x$acx_cv_cc_gcc_supports_ada != xno; then
   have_gnat=yes
 else
   have_gnat=no
Index: libjava/libltdl/configure
===================================================================
--- libjava/libltdl/configure	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libjava/libltdl/configure	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -7355,7 +7355,7 @@
       ;;
 
     # Unfortunately, older versions of FreeBSD 2 do not have this feature.
-    freebsd2*)
+    freebsd2.*)
       archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
       hardcode_direct=yes
       hardcode_minus_L=yes
@@ -7968,7 +7968,7 @@
   esac
   shlibpath_var=LD_LIBRARY_PATH
   case $host_os in
-  freebsd2*)
+  freebsd2.*)
     shlibpath_overrides_runpath=yes
     ;;
   freebsd3.[01]* | freebsdelf3.[01]*)
Index: libjava/libltdl/ChangeLog
===================================================================
--- libjava/libltdl/ChangeLog	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libjava/libltdl/ChangeLog	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1,3 +1,8 @@
+2011-11-20  Andreas Tobler  <andreast@fgznet.ch>
+
+	* acinclude.m4: Additional FreeBSD 10 fixes.
+	* configure: Regenerate.
+
 2011-10-26  Release Manager
 
 	* GCC 4.6.2 released.
Index: libjava/libltdl/acinclude.m4
===================================================================
--- libjava/libltdl/acinclude.m4	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libjava/libltdl/acinclude.m4	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1377,7 +1377,7 @@
   esac
   shlibpath_var=LD_LIBRARY_PATH
   case $host_os in
-  freebsd2*)
+  freebsd2.*)
     shlibpath_overrides_runpath=yes
     ;;
   freebsd3.[[01]]* | freebsdelf3.[[01]]*)
@@ -3035,7 +3035,7 @@
 	;;
     esac
     ;;
-  freebsd[[12]]*)
+  freebsd2.*)
     # C++ shared libraries reported to be fairly broken before switch to ELF
     _LT_AC_TAGVAR(ld_shlibs, $1)=no
     ;;
@@ -5669,7 +5669,7 @@
       ;;
 
     # Unfortunately, older versions of FreeBSD 2 do not have this feature.
-    freebsd2*)
+    freebsd2.*)
       _LT_AC_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
       _LT_AC_TAGVAR(hardcode_direct, $1)=yes
       _LT_AC_TAGVAR(hardcode_minus_L, $1)=yes
Index: libjava/configure.ac
===================================================================
--- libjava/configure.ac	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libjava/configure.ac	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1060,7 +1060,7 @@
      *-*-cygwin*)
 	# Don't set THREADLIBS here.  Cygwin doesn't have -lpthread.
 	;;
-     *-*-freebsd[[1234]]*)
+     *-*-freebsd[[34]].*)
 	# Before FreeBSD 5, it didn't have -lpthread (or any library which
 	# merely adds pthread_* functions) but it does have a -pthread switch
 	# which is required at link-time to select -lc_r *instead* of -lc.
Index: libjava/classpath/config.rpath
===================================================================
--- libjava/classpath/config.rpath	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libjava/classpath/config.rpath	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -361,7 +361,7 @@
       hardcode_libdir_flag_spec='-R$libdir'
       hardcode_direct=yes
       ;;
-    freebsd2*)
+    freebsd2.*)
       hardcode_direct=yes
       hardcode_minus_L=yes
       ;;
@@ -533,7 +533,7 @@
     ;;
   freebsd* | dragonfly*)
     case "$host_os" in
-      freebsd[123]*)
+      freebsd[23].*)
         library_names_spec='$libname$shrext$versuffix' ;;
       *)
         library_names_spec='$libname$shrext' ;;
Index: libjava/classpath/configure
===================================================================
--- libjava/classpath/configure	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libjava/classpath/configure	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -10025,7 +10025,7 @@
       ;;
 
     # Unfortunately, older versions of FreeBSD 2 do not have this feature.
-    freebsd2*)
+    freebsd2.*)
       archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
       hardcode_direct=yes
       hardcode_minus_L=yes
@@ -10941,7 +10941,7 @@
     objformat=`/usr/bin/objformat`
   else
     case $host_os in
-    freebsd[123]*) objformat=aout ;;
+    freebsd[23].*) objformat=aout ;;
     *) objformat=elf ;;
     esac
   fi
@@ -10959,7 +10959,7 @@
   esac
   shlibpath_var=LD_LIBRARY_PATH
   case $host_os in
-  freebsd2*)
+  freebsd2.*)
     shlibpath_overrides_runpath=yes
     ;;
   freebsd3.[01]* | freebsdelf3.[01]*)
@@ -14225,7 +14225,7 @@
         esac
         ;;
 
-      freebsd[12]*)
+      freebsd2.*)
         # C++ shared libraries reported to be fairly broken before
 	# switch to ELF
         ld_shlibs_CXX=no
@@ -16000,7 +16000,7 @@
     objformat=`/usr/bin/objformat`
   else
     case $host_os in
-    freebsd[123]*) objformat=aout ;;
+    freebsd[23].*) objformat=aout ;;
     *) objformat=elf ;;
     esac
   fi
@@ -16018,7 +16018,7 @@
   esac
   shlibpath_var=LD_LIBRARY_PATH
   case $host_os in
-  freebsd2*)
+  freebsd2.*)
     shlibpath_overrides_runpath=yes
     ;;
   freebsd3.[01]* | freebsdelf3.[01]*)
Index: libjava/classpath/ChangeLog.gcj
===================================================================
--- libjava/classpath/ChangeLog.gcj	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libjava/classpath/ChangeLog.gcj	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1,3 +1,9 @@
+2011-11-29  Andreas Tobler  <andreast@fgznet.ch>
+
+	* config.rpath (ld_shlibs): Fix detection of FreeBSD-10 and up.
+	(libname_spec): Likewise.
+	* configure: Regenerate with autoconf -I ../../.
+
 2011-02-13  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>
 
 	* config.rpath, ltcf-c.sh, ltcf-gcj.sh, ltconfig: Remove
Index: libjava/ChangeLog
===================================================================
--- libjava/ChangeLog	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libjava/ChangeLog	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1,3 +1,16 @@
+2011-11-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR bootstrap/50888
+	* prims.cc: Don't include ctype.h.
+	(c_isspace): Define.
+	(next_property_key, next_property_value): Use it instead
+	of isspace.
+
+2011-11-20  Andreas Tobler  <andreast@fgznet.ch>
+
+	* configure.ac: Fix FreeBSD 10 detection.
+	* configure: Regenerate.
+
 2011-10-26  Release Manager
 
 	* GCC 4.6.2 released.
Index: libjava/prims.cc
===================================================================
--- libjava/prims.cc	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libjava/prims.cc	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -38,7 +38,6 @@
 #endif
 
 #ifndef DISABLE_GETENV_PROPERTIES
-#include <ctype.h>
 #include <java-props.h>
 #define PROCESS_GCJ_PROPERTIES process_gcj_properties()
 #else
@@ -985,6 +984,8 @@
 
 #ifndef DISABLE_GETENV_PROPERTIES
 
+#define c_isspace(c) (memchr (" \t\n\r\v\f", c, 6) != NULL)
+
 static char *
 next_property_key (char *s, size_t *length)
 {
@@ -993,7 +994,7 @@
   JvAssert (s);
 
   // Skip over whitespace
-  while (isspace (*s))
+  while (c_isspace (*s))
     s++;
 
   // If we've reached the end, return NULL.  Also return NULL if for
@@ -1005,7 +1006,7 @@
 
   // Determine the length of the property key.
   while (s[l] != 0
-	 && ! isspace (s[l])
+	 && ! c_isspace (s[l])
 	 && s[l] != ':'
 	 && s[l] != '=')
     {
@@ -1027,19 +1028,19 @@
 
   JvAssert (s);
 
-  while (isspace (*s))
+  while (c_isspace (*s))
     s++;
 
   if (*s == ':'
       || *s == '=')
     s++;
 
-  while (isspace (*s))
+  while (c_isspace (*s))
     s++;
 
   // Determine the length of the property value.
   while (s[l] != 0
-	 && ! isspace (s[l])
+	 && ! c_isspace (s[l])
 	 && s[l] != ':'
 	 && s[l] != '=')
     {
Index: libjava/configure
===================================================================
--- libjava/configure	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ libjava/configure	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -11560,7 +11560,7 @@
       ;;
 
     # Unfortunately, older versions of FreeBSD 2 do not have this feature.
-    freebsd2*)
+    freebsd2.*)
       archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
       hardcode_direct=yes
       hardcode_minus_L=yes
@@ -12476,7 +12476,7 @@
     objformat=`/usr/bin/objformat`
   else
     case $host_os in
-    freebsd[123]*) objformat=aout ;;
+    freebsd[23].*) objformat=aout ;;
     *) objformat=elf ;;
     esac
   fi
@@ -12494,7 +12494,7 @@
   esac
   shlibpath_var=LD_LIBRARY_PATH
   case $host_os in
-  freebsd2*)
+  freebsd2.*)
     shlibpath_overrides_runpath=yes
     ;;
   freebsd3.[01]* | freebsdelf3.[01]*)
@@ -14384,7 +14384,7 @@
         esac
         ;;
 
-      freebsd[12]*)
+      freebsd2.*)
         # C++ shared libraries reported to be fairly broken before
 	# switch to ELF
         ld_shlibs_CXX=no
@@ -16159,7 +16159,7 @@
     objformat=`/usr/bin/objformat`
   else
     case $host_os in
-    freebsd[123]*) objformat=aout ;;
+    freebsd[23].*) objformat=aout ;;
     *) objformat=elf ;;
     esac
   fi
@@ -16177,7 +16177,7 @@
   esac
   shlibpath_var=LD_LIBRARY_PATH
   case $host_os in
-  freebsd2*)
+  freebsd2.*)
     shlibpath_overrides_runpath=yes
     ;;
   freebsd3.[01]* | freebsdelf3.[01]*)
@@ -18520,7 +18520,7 @@
       ;;
 
     # Unfortunately, older versions of FreeBSD 2 do not have this feature.
-    freebsd2*)
+    freebsd2.*)
       archive_cmds_GCJ='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
       hardcode_direct_GCJ=yes
       hardcode_minus_L_GCJ=yes
@@ -20715,7 +20715,7 @@
      *-*-cygwin*)
 	# Don't set THREADLIBS here.  Cygwin doesn't have -lpthread.
 	;;
-     *-*-freebsd[1234]*)
+     *-*-freebsd[34].*)
 	# Before FreeBSD 5, it didn't have -lpthread (or any library which
 	# merely adds pthread_* functions) but it does have a -pthread switch
 	# which is required at link-time to select -lc_r *instead* of -lc.
Index: maintainer-scripts/ChangeLog
===================================================================
--- maintainer-scripts/ChangeLog	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ maintainer-scripts/ChangeLog	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -1,3 +1,8 @@
+2011-11-23  Gerald Pfeifer  <gerald@pfeifer.com>
+
+	* update_web_docs_svn: Make $DOCSDIR group writable after
+	creating it.
+
 2011-10-26  Release Manager
 
 	* GCC 4.6.2 released.
Index: maintainer-scripts/update_web_docs_svn
===================================================================
--- maintainer-scripts/update_web_docs_svn	(.../tags/gcc_4_6_2_release)	(wersja 183790)
+++ maintainer-scripts/update_web_docs_svn	(.../branches/gcc-4_6-branch)	(wersja 183790)
@@ -93,6 +93,7 @@
 
 if [ ! -d $DOCSDIR ]; then
   mkdir $DOCSDIR
+  chmod g+w $DOCSDIR
 fi
 
 if [ -z "$RELEASE" ]; then
