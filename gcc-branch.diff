Index: libgomp/env.c
===================================================================
--- libgomp/env.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ libgomp/env.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,4 +1,5 @@
-/* Copyright (C) 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
+/* Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010
+   Free Software Foundation, Inc.
    Contributed by Richard Henderson <rth@redhat.com>.
 
    This file is part of the GNU OpenMP Library (libgomp).
@@ -145,7 +146,7 @@
    present and it was successfully parsed.  */
 
 static bool
-parse_unsigned_long (const char *name, unsigned long *pvalue)
+parse_unsigned_long (const char *name, unsigned long *pvalue, bool allow_zero)
 {
   char *env, *end;
   unsigned long value;
@@ -161,7 +162,7 @@
 
   errno = 0;
   value = strtoul (env, &end, 10);
-  if (errno || (long) value <= 0)
+  if (errno || (long) value <= 0 - allow_zero)
     goto invalid;
 
   while (isspace ((unsigned char) *end))
@@ -481,8 +482,9 @@
   parse_schedule ();
   parse_boolean ("OMP_DYNAMIC", &gomp_global_icv.dyn_var);
   parse_boolean ("OMP_NESTED", &gomp_global_icv.nest_var);
-  parse_unsigned_long ("OMP_MAX_ACTIVE_LEVELS", &gomp_max_active_levels_var);
-  parse_unsigned_long ("OMP_THREAD_LIMIT", &gomp_thread_limit_var);
+  parse_unsigned_long ("OMP_MAX_ACTIVE_LEVELS", &gomp_max_active_levels_var,
+		       true);
+  parse_unsigned_long ("OMP_THREAD_LIMIT", &gomp_thread_limit_var, false);
   if (gomp_thread_limit_var != ULONG_MAX)
     gomp_remaining_threads_count = gomp_thread_limit_var - 1;
 #ifndef HAVE_SYNC_BUILTINS
@@ -490,7 +492,8 @@
 #endif
   gomp_init_num_threads ();
   gomp_available_cpus = gomp_global_icv.nthreads_var;
-  if (!parse_unsigned_long ("OMP_NUM_THREADS", &gomp_global_icv.nthreads_var))
+  if (!parse_unsigned_long ("OMP_NUM_THREADS", &gomp_global_icv.nthreads_var,
+			    false))
     gomp_global_icv.nthreads_var = gomp_available_cpus;
   if (parse_affinity ())
     gomp_init_affinity ();
@@ -632,7 +635,7 @@
 void
 omp_set_max_active_levels (int max_levels)
 {
-  if (max_levels > 0)
+  if (max_levels >= 0)
     gomp_max_active_levels_var = max_levels;
 }
 
Index: libgomp/ChangeLog
===================================================================
--- libgomp/ChangeLog	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ libgomp/ChangeLog	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,3 +1,18 @@
+2010-03-22  Jakub Jelinek  <jakub@redhat.com>
+
+	PR libgomp/42942
+	* env.c (parse_unsigned_long): Add ALLOW_ZERO argument.
+	(initialize_env): Adjust callers.
+	(omp_set_max_active_levels): Set gomp_max_active_levels_var even
+	when the argument is 0.
+
+	* testsuite/libgomp.c/pr42942.c: New test.
+
+2010-01-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/42866
+	* testsuite/libgomp.fortran/allocatable5.f90: New test.
+
 2010-01-21  Release Manager
 
 	* GCC 4.4.3 released.
Index: libgomp/testsuite/libgomp.fortran/allocatable5.f90
===================================================================
--- libgomp/testsuite/libgomp.fortran/allocatable5.f90	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ libgomp/testsuite/libgomp.fortran/allocatable5.f90	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,17 @@
+! PR fortran/42866
+! { dg-do run }
+
+program pr42866
+  integer, allocatable :: a(:)
+  allocate (a(16))
+  a = 0
+  !$omp parallel
+    !$omp sections reduction(+:a)
+      a = a + 1
+    !$omp section
+      a = a + 2
+    !$omp end sections
+  !$omp end parallel
+  if (any (a.ne.3)) call abort
+  deallocate (a)
+end
Index: libgomp/testsuite/libgomp.c/pr42942.c
===================================================================
--- libgomp/testsuite/libgomp.c/pr42942.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ libgomp/testsuite/libgomp.c/pr42942.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,61 @@
+/* PR libgomp/42942 */
+/* { dg-do run } */
+
+#include <omp.h>
+#include <stdlib.h>
+
+int
+main (void)
+{
+  int e = 0;
+  omp_set_dynamic (0);
+  omp_set_nested (1);
+  omp_set_max_active_levels (1);
+  if (omp_get_max_active_levels () != 1)
+    abort ();
+#pragma omp parallel num_threads(2) reduction(|:e)
+  if (!omp_in_parallel ()
+      || omp_get_num_threads () != 2)
+    e = 1;
+  else
+#pragma omp parallel num_threads(2) reduction(|:e)
+    if (!omp_in_parallel ()
+	|| omp_get_num_threads () != 1)
+      e = 1;
+  if (e)
+    abort ();
+  omp_set_max_active_levels (0);
+  if (omp_get_max_active_levels () != 0)
+    abort ();
+#pragma omp parallel num_threads(2) reduction(|:e)
+  if (omp_in_parallel ()
+      || omp_get_num_threads () != 1)
+    e = 1;
+  else
+#pragma omp parallel num_threads(2) reduction(|:e)
+    if (omp_in_parallel ()
+	|| omp_get_num_threads () != 1)
+      e = 1;
+  if (e)
+    abort ();
+  omp_set_max_active_levels (2);
+  if (omp_get_max_active_levels () != 2)
+    abort ();
+#pragma omp parallel num_threads(2) reduction(|:e)
+  if (!omp_in_parallel ()
+      || omp_get_num_threads () != 2)
+    e = 1;
+  else
+#pragma omp parallel num_threads(2) reduction(|:e)
+    if (!omp_in_parallel ()
+	|| omp_get_num_threads () != 2)
+      e = 1;
+    else
+#pragma omp parallel num_threads(2) reduction(|:e)
+      if (!omp_in_parallel ()
+	  || omp_get_num_threads () != 1)
+	e = 1;
+  if (e)
+    abort ();
+  return 0;
+}
Index: gcc/attribs.c
===================================================================
--- gcc/attribs.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/attribs.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,6 +1,6 @@
 /* Functions dealing with attribute handling, used by most front ends.
    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
-   2002, 2003, 2004, 2005, 2007, 2008 Free Software Foundation, Inc.
+   2002, 2003, 2004, 2005, 2007, 2008, 2010 Free Software Foundation, Inc.
 
 This file is part of GCC.
 
@@ -277,6 +277,7 @@
       tree *anode = node;
       const struct attribute_spec *spec = lookup_attribute_spec (name);
       bool no_add_attrs = 0;
+      int fn_ptr_quals = 0;
       tree fn_ptr_tmp = NULL_TREE;
 
       if (spec == NULL)
@@ -344,6 +345,7 @@
 		 This would all be simpler if attributes were part of the
 		 declarator, grumble grumble.  */
 	      fn_ptr_tmp = TREE_TYPE (*anode);
+	      fn_ptr_quals = TYPE_QUALS (*anode);
 	      anode = &fn_ptr_tmp;
 	      flags &= ~(int) ATTR_FLAG_TYPE_IN_PLACE;
 	    }
@@ -440,6 +442,8 @@
 	  /* Rebuild the function pointer type and put it in the
 	     appropriate place.  */
 	  fn_ptr_tmp = build_pointer_type (fn_ptr_tmp);
+	  if (fn_ptr_quals)
+	    fn_ptr_tmp = build_qualified_type (fn_ptr_tmp, fn_ptr_quals);
 	  if (DECL_P (*node))
 	    TREE_TYPE (*node) = fn_ptr_tmp;
 	  else
Index: gcc/loop-unswitch.c
===================================================================
--- gcc/loop-unswitch.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/loop-unswitch.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,5 +1,5 @@
 /* Loop unswitching for GNU compiler.
-   Copyright (C) 2002, 2003, 2004, 2005, 2007, 2008
+   Copyright (C) 2002, 2003, 2004, 2005, 2007, 2008, 2010
    Free Software Foundation, Inc.
 
 This file is part of GCC.
@@ -121,7 +121,7 @@
       op0 = force_operand (op0, NULL_RTX);
       op1 = force_operand (op1, NULL_RTX);
       do_compare_rtx_and_jump (op0, op1, comp, 0,
-			       mode, NULL_RTX, NULL_RTX, label);
+			       mode, NULL_RTX, NULL_RTX, label, -1);
       jump = get_last_insn ();
       JUMP_LABEL (jump) = label;
       LABEL_NUSES (label)++;
Index: gcc/tree-loop-linear.c
===================================================================
--- gcc/tree-loop-linear.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/tree-loop-linear.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,5 +1,5 @@
 /* Linear Loop transforms
-   Copyright (C) 2003, 2004, 2005, 2007, 2008, 2009
+   Copyright (C) 2003, 2004, 2005, 2007, 2008, 2009, 2010
    Free Software Foundation, Inc.
    Contributed by Daniel Berlin <dberlin@dberlin.org>.
 
@@ -246,9 +246,10 @@
 	res = cmp < 0 ?
 	  estimated_loop_iterations (loop_j, false, &nb_iter):
 	  estimated_loop_iterations (loop_i, false, &nb_iter);
-	large = double_int_mul (large, nb_iter);
 
-	if (res && double_int_ucmp (large, l1_cache_size) < 0)
+	if (res
+	    && double_int_ucmp (double_int_mul (large, nb_iter),
+				l1_cache_size) < 0)
 	  continue;
 
 	if (dependence_steps_i < dependence_steps_j 
Index: gcc/optabs.c
===================================================================
--- gcc/optabs.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/optabs.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,6 +1,6 @@
 /* Expand the basic unary and binary arithmetic operations, for GNU compiler.
    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010
    Free Software Foundation, Inc.
 
 This file is part of GCC.
@@ -1149,7 +1149,7 @@
 
   NO_DEFER_POP;
   do_compare_rtx_and_jump (cmp1, cmp2, cmp_code, false, op1_mode,
-			   0, 0, subword_label);
+			   0, 0, subword_label, -1);
   OK_DEFER_POP;
 
   if (!expand_superword_shift (binoptab, outof_input, superword_op1,
@@ -3498,7 +3498,7 @@
   NO_DEFER_POP;
 
   do_compare_rtx_and_jump (target, CONST0_RTX (mode), GE, 0, mode,
-			   NULL_RTX, NULL_RTX, op1);
+			   NULL_RTX, NULL_RTX, op1, -1);
 
   op0 = expand_unop (mode, result_unsignedp ? neg_optab : negv_optab,
                      target, target, 0);
Index: gcc/DATESTAMP
===================================================================
--- gcc/DATESTAMP	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/DATESTAMP	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1 +1 @@
-20100121
+20100328
Index: gcc/builtins.c
===================================================================
--- gcc/builtins.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/builtins.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,6 +1,6 @@
 /* Expand builtin functions.
    Copyright (C) 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
-   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
+   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
    Free Software Foundation, Inc.
 
 This file is part of GCC.
@@ -2275,6 +2275,8 @@
   /* Before working hard, check whether the instruction is available.  */
   if (icode != CODE_FOR_nothing)
     {
+      rtx last = get_last_insn ();
+      tree orig_arg = arg;
       /* Make a suitable register to place result in.  */
       if (!target
 	  || GET_MODE (target) != TYPE_MODE (TREE_TYPE (exp)))
@@ -2295,8 +2297,10 @@
 
       /* Compute into TARGET.
 	 Set TARGET to wherever the result comes back.  */
-      emit_unop_insn (icode, target, op0, UNKNOWN);
-      return target;
+      if (maybe_emit_unop_insn (icode, target, op0, UNKNOWN))
+	return target;
+      delete_insns_since (last);
+      CALL_EXPR_ARG (exp, 0) = orig_arg;
     }
 
   /* If there is no optab, try generic code.  */
@@ -2987,7 +2991,10 @@
 	  && ((flag_unsafe_math_optimizations
 	       && optimize_insn_for_speed_p ()
 	       && powi_cost (n/2) <= POWI_MAX_MULTS)
-	      || n == 1))
+	      /* Even the c==0.5 case cannot be done unconditionally
+	         when we need to preserve signed zeros, as
+		 pow (-0, 0.5) is +0, while sqrt(-0) is -0.  */
+	      || (!HONOR_SIGNED_ZEROS (mode) && n == 1)))
 	{
 	  tree call_expr = build_call_expr (fn, 1, narg0);
 	  /* Use expand_expr in case the newly built call expression
@@ -5834,9 +5841,11 @@
   icode = signbit_optab->handlers [(int) fmode].insn_code;
   if (icode != CODE_FOR_nothing)
     {
+      rtx last = get_last_insn ();
       target = gen_reg_rtx (TYPE_MODE (TREE_TYPE (exp)));
-      emit_unop_insn (icode, target, temp, UNKNOWN);
-      return target;
+      if (maybe_emit_unop_insn (icode, target, temp, UNKNOWN))
+	return target;
+      delete_insns_since (last);
     }
 
   /* For floating point formats without a sign bit, implement signbit
Index: gcc/omp-low.c
===================================================================
--- gcc/omp-low.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/omp-low.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -4606,7 +4606,7 @@
   l2_bb = region->exit;
   if (exit_reachable)
     {
-      if (single_pred (l2_bb) == l0_bb)
+      if (single_pred_p (l2_bb) && single_pred (l2_bb) == l0_bb)
 	l2 = gimple_block_label (l2_bb);
       else
 	{
Index: gcc/DEV-PHASE
===================================================================
--- gcc/DEV-PHASE	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/DEV-PHASE	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1 @@
+prerelease
Index: gcc/ChangeLog
===================================================================
--- gcc/ChangeLog	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/ChangeLog	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,3 +1,381 @@
+2010-03-27  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
+
+	Backport:
+	2009-06-16  J"orn Rennecke  <joern.rennecke@arc.com>
+		    Janis Johnson  <janis187@us.ibm.com>
+
+	PR target/39254
+	* config/rs6000/rs6000.c (rs6000_emit_move): Don't emit a USE
+	for the symbol ref of a constant that is the source of a move
+	- nor for any other not-obvious-label-ref constants.
+
+2010-03-27  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/42113
+	* config/alpha/alpha.md (*cmp_sadd_si): Change mode
+	of scratch register to DImode.  Split to DImode comparison operator.
+	Use SImode subreg of scratch register in the multiplication.
+	(*cmp_sadd_sidi): Ditto.
+	(*cmp_ssub_si): Ditto.
+	(*cmp_ssub_sidi): Ditto.
+
+2010-03-27  Joseph Myers  <joseph@codesourcery.com>
+
+	PR c/43381
+	* c-decl.c (get_parm_info): Assert that decl going in OTHERS has a
+	nested binding iff it is a FUNCTION_DECL.
+	(store_parm_decls_newstyle): Pass nested=true to bind for
+	FUNCTION_DECLs amongst parameters.
+
+2010-03-25  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/43385
+	* gimplify.c (gimple_boolify): Only recurse on __builtin_expect
+	argument if the argument is truth_value_p.
+
+2010-03-23  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	Backport from mainline:
+	2010-01-08  DJ Delorie  <dj@redhat.com>
+
+	* config/sh/sh.c (sh_expand_epilogue): Fix interrupt handler
+	register popping order.
+
+2010-03-22  James E. Wilson  <wilson@codesourcery.com>
+
+	PR target/43348
+	* ia64.md (call_nogp, call_value_nogp, sibcall_nogp, call_gp,
+	call_value_gp,sibcall_gp): Use 's' constraint not 'i'.
+
+2010-03-22  Richard Guenther  <rguenther@suse.de>
+
+	Backport from mainline:
+	2010-03-19  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/43415
+	* tree-ssa-pre.c (phi_translate): Split out worker to ...
+	(phi_translate_1): ... this.
+	(phi_translate): Move all caching here.  Cache all NARY
+	and REFERENCE translations.
+
+2010-03-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline:
+	2010-03-20  Richard Guenther  <rguenther@suse.de>
+
+	PR rtl-optimization/43438
+	* combine.c (make_extraction): Properly zero-/sign-extend an
+	extraction of the low part of a CONST_INT.  Also handle
+	CONST_DOUBLE.
+
+	2010-03-19  Michael Matz  <matz@suse.de>
+
+	PR c++/43116
+	* attribs.c (decl_attributes): When rebuilding a function pointer
+	type use the same qualifiers as the original pointer type.
+
+	PR target/43305
+	* builtins.c (expand_builtin_interclass_mathfn,
+	expand_builtin_signbit): Use maybe_emit_unop_insn, emit libcalls
+	if that fails.
+
+	2010-03-18  Michael Matz  <matz@suse.de>
+
+	PR middle-end/43419
+	* builtins.c (expand_builtin_pow): Don't transform pow(x, 0.5)
+	into sqrt(x) if we need to preserve signed zeros.
+
+2010-03-21  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	PR middle-end/42718
+	* pa.md (movmemsi): Set align to one if zero.
+	(movmemdi): Likewise.
+
+2010-03-21  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	Backport from mainline:
+	2009-05-12  Paolo Bonzini  <bonzini@gnu.org>
+
+	PR target/43417
+	* config/sh/sh.md (cbranchdi4_i): Use an "I08" constraint
+	instead of "i" constraint.
+
+2010-03-18  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline:
+	2010-03-18  Steven Bosscher  <steven@gcc.gnu.org>
+		    Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR rtl-optimization/43360
+	* loop-invariant.c (move_invariant_reg): Remove the REG_EQUAL
+	note if we don't know its invariant status.
+
+2010-03-08  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline:
+	2010-03-04  Andrew Pinski  <andrew_pinski@caviumnetworks.com>
+
+	PR c/43248
+	* c-decl.c (build_compound_literal): Return early if init is
+	an error_mark_node.
+
+2010-03-08  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline:
+	2010-02-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/42233
+	* dojump.c (do_jump) <case TRUTH_NOT_EXPR>: Invert priority.
+
+	PR bootstrap/43121
+	* except.c (sjlj_emit_function_enter): Don't call
+	add_reg_br_prob_note, instead add REG_BR_PROB note to the last insn
+	directly.
+	* rtl.h (add_reg_br_prob_note): Remove prototype.
+
+	PR middle-end/42233
+	* loop-doloop.c (add_test): Adjust do_compare_rtx_and_jump caller.
+
+	PR middle-end/42233
+	* expr.h (jumpifnot, jumpifnot_1, jumpif, jumpif_1, do_jump,
+	do_jump_1, do_compare_rtx_and_jump): Add PROB argument.
+	* dojump.c: Include output.h.
+	(inv): New inline function.
+	(jumpifnot, jumpifnot_1, jumpif, jumpif_1, do_jump_1, do_jump,
+	do_jump_by_parts_greater_rtx, do_jump_by_parts_greater,
+	do_jump_by_parts_zero_rtx, do_jump_by_parts_equality_rtx,
+	do_jump_by_parts_equality, do_compare_and_jump): Add PROB
+	argument, pass it down to other calls.
+	(do_compare_rtx_and_jump): Likewise.  If PROB is not -1,
+	add REG_BR_PROB note to the conditional jump.
+	* cfgexpand.c (add_reg_br_prob_note): Removed.
+	(expand_gimple_cond): Don't call it, add the probability
+	as last argument to jumpif_1/jumpifnot_1.
+	* Makefile.in (dojump.o): Depend on output.h.
+	* builtins.c (expand_errno_check): Adjust do_compare_rtx_and_jump
+	callers.
+	* expmed.c (emit_store_flag_force, do_cmp_and_jump): Likewise.
+	* stmt.c (do_jump_if_equal): Likewise.
+	* cfgrtl.c (rtl_lv_add_condition_to_bb): Likewise.
+	* loop-unswitch.c (compare_and_jump_seq): Likewise.
+	* config/rs6000/rs6000.c (rs6000_aix_emit_builtin_unwind_init):
+	Likewise.
+	* optabs.c (expand_doubleword_shift, expand_abs): Likewise.
+	* expr.c (expand_expr_real_1): Adjust do_jump, jumpifnot and
+	jumpifnot_1 callers.
+	(expand_expr_real_2): Adjust jumpifnot_1 and do_compare_rtx_and_jump
+	callers.
+	(store_expr): Adjust jumpifnot caller.
+	(store_constructor): Adjust jumpif caller.
+
+	PR middle-end/42233
+	* gimplify.c (gimple_boolify): For __builtin_expect call
+	gimple_boolify also on its first argument.
+
+2010-03-02  Uros Bizjak  <ubizjak@gmail.com>
+
+	* config/alpha/alpha.c (override_options): Fix -mtune error message.
+
+2010-03-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline:
+	2010-03-01  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/43220
+	* tree-ssa-ccp.c (optimize_stack_restore): Do not optimize
+	BUILT_IN_STACK_{SAVE,RESTORE} around alloca.
+
+2010-02-24  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	Backport from trunk
+	2009-07-10  Mark Mitchell  <mark@codesourcery.com>
+
+	* config/arm/thumb2.md (thumb2_cbz): Correct computation of length
+	attribute.
+	(thumb2_cbnz): Likewise.
+
+2010-02-22  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>
+
+	* config/s390/s390.md ("movqi"): Re-add the mem->mem alternative.
+	(QI to BLKmode splitter): New splitter.
+
+2010-02-18  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	* config/spu/spu-c.c (spu_resolve_overloaded_builtin): Call
+	lang_hooks.types_compatible_p instead of comptypes.
+
+2010-02-18  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	PR target/40887
+	Backport from trunk.
+	2009-12-24  Julian Brown  <julian@codesourcery.com>
+		    Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	* config/arm/arm.c (output_call_mem): Remove armv5 support.
+	* config/arm/arm.md (*call_mem): Disable for armv5. Add note.
+	(*call_value_mem): Likewise.
+
+2010-02-17  Mikael Pettersson  <mikpe@it.uu.se>
+
+	* config/sparc/gas.h: New file.  Restore
+	TARGET_ASM_NAMED_SECTION to its ELF default.
+	* config/sparc/sysv4.h (TARGET_ASM_NAMED_SECTION): Do not
+	check !HAVE_GNU_AS.
+	* config/sparc/sparc.c (sparc_elf_asm_named_section):
+	Likewise.  Add ATTRIBUTE_UNUSED to prototype.
+	* config.gcc (sparc*-*-linux*): Include sparc/gas.h
+	after sparc/sysv4.h.
+
+2010-02-17  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	Backport from trunk.
+	2009-12-07  Julian Brown  <julian@codesourcery.com>
+
+	* config/arm/constraints.md (Ps, Pt): New constraint letters.
+	* config/arm/thumb2.md (*thumb2_addsi_short): Tighten constraints.
+
+2010-02-16  Ira Rosen <irar@il.ibm.com>
+
+	PR tree-optimization/43074
+	* tree-vect-analyze.c (vect_detect_hybrid_slp_stmts): Add
+	vectorizable cycles in hybrid SLP check.
+
+2010-02-14  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>
+
+	* config/s390/s390.c (s390_sched_init): New function.
+	(TARGET_SCHED_INIT): Target hook defined.
+
+2010-02-13  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/42871
+	* tree-ssa-pre.c (phi_translate_set): Make sure to retain
+	leaders.
+
+2010-02-10  Daniel Gutson  <dgutson@codesourcery.com>
+
+	* config/arm/lib1funcs.asm (__ARM_ARCH__): __ARM_ARCH_7EM__
+	added to the preprocessor condition.
+
+2010-02-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/43010
+	* dwarf2out.c (retry_incomplete_types): Don't call gen_type_die
+	if no debug info should be emitted for it.
+
+2010-02-09  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline:
+	2010-01-13  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/42705
+	* tree-ssa-reassoc.c (build_and_add_sum): Insert stmts after
+	labels.
+
+2010-02-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/42890
+	* tree-inline.c (delete_unreachable_blocks_update_callgraph): New
+	function backported from the trunk.
+	(tree_function_versioning): Call it instead of
+	delete_unreachable_blocks.
+
+	PR tree-optimization/42931
+	* tree-loop-linear.c (try_interchange_loops): Don't call
+	double_int_mul if estimated_loop_iterations failed.
+
+2010-02-08  Richard Guenther  <rguenther@suse.de>
+
+	PR middle-end/42995
+	* tree-inline.c (estimate_move_cost): Assert we are not called
+	with a void type.
+	(estimate_num_insns): Do not count the terminating void_type_node
+	of a function argument type list.
+
+	Backport from mainline:
+	2010-01-06  Richard Guenther  <rguenther@suse.de>
+
+	* ipa-inline.c (cgraph_decide_inlining_incrementally): Do
+	not inline regular functions into always-inline functions.
+
+	2010-01-05  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/42462
+	* ipa-inline.c (compute_inline_parameters): Pass node->decl instead of
+	current_function_decl to helper functions and macros.
+
+2010-02-04  Richard Guenther  <rguenther@suse.de>
+
+	PR rtl-optimization/42952
+	* dse.c (const_or_frame_p): Remove MEM handling.
+
+2010-01-31  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR middle-end/42898
+	Backport from mainline:
+	2009-04-23  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gimplify.c (gimplify_modify_expr_rhs) <VAR_DECL>: Do not do a direct
+	assignment from the constructor either if the target is volatile.
+
+2010-01-31  Richard Guenther  <rguenther@suse.de>
+
+	PR middle-end/42898
+	* gimplify.c (gimplify_init_constructor): For volatile LHS
+	initialize a temporary.
+
+2010-01-26  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* config/sparc/sparc.c (sparc_elf_asm_named_section): Test for
+	HAVE_GNU_AS value.
+	* config/sparc/sysv4.h [HAVE_GNU_AS] (TARGET_ASM_NAMED_SECTION):
+	Test for HAVE_GNU_AS value.
+
+2010-01-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/42866
+	* omp-low.c (expand_omp_sections): Only use single_pred if
+	l2_bb is single_pred_p.
+
+2010-01-25  Christian Bruel  <christian.bruel@st.com>
+
+	PR target/42841
+	* config/sh/sh.c (find_barrier): Increase length for non delayed
+	conditional branches.
+	(sh_insn_length_adjustment): Use JUMP_TABLE_DATA_P.
+
+2010-01-25  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	Backport from trunk.
+	2010-01-19  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	PR target/38697
+	* config/arm/neon-testgen.m (emit_automatics): New parameter
+	features. Adjust for Fixed_return_reg feature.
+	(test_intrinsic): Call emit_automatics with new feature.
+	* config/arm/neon.ml: Update copyright years.
+	(features): New Fixed_return_reg feature.
+	(ops): Update feature for Vget_low.
+
+2010-01-24  David S. Miller  <davem@davemloft.net>
+
+	* config/sparc/sysv4.h (TARGET_ASM_NAMED_SECTION): Only
+	define if not using GAS.
+	* config/sparc/sparc.c (sparc_elf_asm_named_section):
+	Likewise.  Delete SECTION_MERGE code, which is only applicable
+	when using GAS.
+
+2010-01-21  Felyza Wishbringer  <fwishbringer@gmail.com>
+
+	PR bootstrap/42786
+	* config.gcc (i[34567]86-*-*): Fix handling of athlon64 and athlon-fx
+	cpu types.  Add support for *-sse3 cpu types.
+	(x86_64-*-*): Ditto.
+
+2010-01-21  Jakub Jelinek  <jakub@redhat.com>
+
+	* BASE-VER: Set to 4.4.4.
+	* DEV-PHASE: Set to prerelease.
+
 2010-01-21  Release Manager
 
 	* GCC 4.4.3 released.
@@ -108,9 +486,9 @@
 	* Backport from mainline
 	2010-01-12  Julian Brown  <julian@codesourcery.com>
 
-        * config/arm/neon-schedgen.ml (Utils): Don't try to
+	* config/arm/neon-schedgen.ml (Utils): Don't try to
 	open missing module.
-        (find_with_result): New.
+	(find_with_result): New.
 
 2010-01-12  Jakub Jelinek  <jakub@redhat.com>
 
Index: gcc/testsuite/gcc.c-torture/execute/pr43438.c
===================================================================
--- gcc/testsuite/gcc.c-torture/execute/pr43438.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/execute/pr43438.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,23 @@
+extern void abort (void);
+
+static unsigned char g_2 = 1;
+static int g_9;
+static int *l_8 = &g_9;
+
+static void func_12(int p_13)
+{
+  int * l_17 = &g_9;
+  *l_17 &= 0 < p_13;
+}
+
+int main(void)
+{
+  unsigned char l_11 = 254;
+  *l_8 |= g_2;
+  l_11 |= *l_8;
+  func_12(l_11);
+  if (g_9 != 1)
+    abort ();
+  return 0;
+} 
+
Index: gcc/testsuite/gcc.c-torture/execute/pr43269.c
===================================================================
--- gcc/testsuite/gcc.c-torture/execute/pr43269.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/execute/pr43269.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,31 @@
+int g_21;
+int g_211;
+int g_261;
+
+static void __attribute__((noinline,noclone))
+func_32 (int b)
+{
+  if (b) {
+lbl_370:
+      g_21 = 1;
+  }
+
+  for (g_261 = -1; g_261 > -2; g_261--) {
+      if (g_211 + 1) {
+	  return;
+      } else {
+	  g_21 = 1;
+	  goto lbl_370;
+      }
+  }
+}
+
+extern void abort (void);
+
+int main(void)
+{
+  func_32(0);
+  if (g_261 != -1)
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr43220.c
===================================================================
--- gcc/testsuite/gcc.c-torture/execute/pr43220.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/execute/pr43220.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,28 @@
+void *volatile p;
+
+int
+main (void)
+{
+  int n = 0;
+lab:;
+    {
+      int x[n % 1000 + 1];
+      x[0] = 1;
+      x[n % 1000] = 2;
+      p = x;
+      n++;
+    }
+
+    {
+      int x[n % 1000 + 1];
+      x[0] = 1;
+      x[n % 1000] = 2;
+      p = x;
+      n++;
+    }
+
+  if (n < 1000000)
+    goto lab;
+
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr43385.c
===================================================================
--- gcc/testsuite/gcc.c-torture/execute/pr43385.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/execute/pr43385.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,59 @@
+/* PR c/43385 */
+
+extern void abort (void);
+
+int e;
+
+__attribute__((noinline)) void
+foo (int x, int y)
+{
+  if (__builtin_expect (x, 0) && y != 0)
+    e++;
+}
+
+__attribute__((noinline)) int
+bar (int x, int y)
+{
+  if (__builtin_expect (x, 0) && y != 0)
+    return 1;
+  else
+    return 0;
+}
+
+int
+main (void)
+{
+  int z = 0;
+  asm ("" : "+r" (z));
+  foo (z + 2, z + 1);
+  if (e != 1)
+    abort ();
+  foo (z + 2, z);
+  if (e != 1)
+    abort ();
+  foo (z + 1, z + 1);
+  if (e != 2)
+    abort ();
+  foo (z + 1, z);
+  if (e != 2)
+    abort ();
+  foo (z, z + 1);
+  if (e != 2)
+    abort ();
+  foo (z, z);
+  if (e != 2)
+    abort ();
+  if (bar (z + 2, z + 1) != 1)
+    abort ();
+  if (bar (z + 2, z) != 0)
+    abort ();
+  if (bar (z + 1, z + 1) != 1)
+    abort ();
+  if (bar (z + 1, z) != 0)
+    abort ();
+  if (bar (z, z + 1) != 0)
+    abort ();
+  if (bar (z, z) != 0)
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr43008.c
===================================================================
--- gcc/testsuite/gcc.c-torture/execute/pr43008.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/execute/pr43008.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,23 @@
+int i;
+struct X {
+  int *p;
+};
+struct X * __attribute__((malloc))
+my_alloc (void)
+{
+  struct X *p = __builtin_malloc (sizeof (struct X));
+  p->p = &i;
+  return p;
+}
+extern void abort (void);
+int main()
+{
+  struct X *p, *q;
+  p = my_alloc ();
+  q = my_alloc ();
+  *(p->p) = 1;
+  *(q->p) = 0;
+  if (*(p->p) != 0)
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr42248.c
===================================================================
--- gcc/testsuite/gcc.c-torture/execute/pr42248.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/execute/pr42248.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,27 @@
+typedef struct {
+  _Complex double a;
+  _Complex double b;
+} Scf10;
+
+Scf10 g1s;
+
+void
+check (Scf10 x, _Complex double y)
+{
+  if (x.a != y) __builtin_abort ();
+}
+
+void
+init (Scf10 *p, _Complex double y)
+{
+  p->a = y;
+}
+
+int
+main ()
+{
+  init (&g1s, (_Complex double)1);
+  check (g1s, (_Complex double)1);
+
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/20100209-1.c
===================================================================
--- gcc/testsuite/gcc.c-torture/execute/20100209-1.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/execute/20100209-1.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,12 @@
+int bar(int foo)
+{
+  return (int)(((unsigned long long)(long long)foo) / 8);
+}
+extern void abort (void);
+int main()
+{
+  if (sizeof (long long) > sizeof (int)
+      && bar(-1) != -1)
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr42512.c
===================================================================
--- gcc/testsuite/gcc.c-torture/execute/pr42512.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/execute/pr42512.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,13 @@
+extern void abort (void);
+
+short g_3;
+
+int main (void)
+{
+    int l_2;
+    for (l_2 = -1; l_2 != 0; l_2 = (unsigned char)(l_2 - 1))
+      g_3 |= l_2;
+    if (g_3 != -1)
+      abort ();
+    return 0;
+}
Index: gcc/testsuite/gcc.c-torture/compile/20000804-1.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/20000804-1.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/testsuite/gcc.c-torture/compile/20000804-1.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,8 +1,7 @@
 /* This does not work on m68hc11 or h8300 due to the use of an asm
    statement to force a 'long long' (64-bits) to go in a register.  */
 /* { dg-do assemble } */
-/* { dg-skip-if "" { { i?86-*-* x86_64-*-* } && ilp32 } { "-fpic" "-fPIC" } { "" } } */
-/* { dg-skip-if "PIC default" { { i?86-*-darwin*  x86_64-*-darwin* } && ilp32 } { "*" } { "" } } */
+/* { dg-skip-if "" { { i?86-*-* x86_64-*-* } && { ilp32 && { ! nonpic } } } { "*" } { "" } } */
 /* { dg-skip-if "No 64-bit registers" { m32c-*-* } { "*" } { "" } } */
 /* { dg-xfail-if "" { m6811-*-* m6812-*-* h8300-*-* } { "*" } { "" } } */
 
Index: gcc/testsuite/gcc.c-torture/compile/pr42703.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr42703.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr42703.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,12 @@
+__extension__ typedef unsigned long long int uint64_t;
+typedef uint64_t ScmUInt64;
+void swapb64(ScmUInt64 *loc) 
+{
+    union {
+        ScmUInt64 l;
+        unsigned char c[4];
+    } dd;
+    unsigned char t;
+    dd.l = *loc;
+    (t = dd.c[3], dd.c[3] = dd.c[4], dd.c[4] = t);
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr42730.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr42730.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr42730.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,14 @@
+union bzz
+{
+  unsigned *pa;
+  void *pv;
+};
+
+void foo (void)
+{
+  union bzz u;
+  void **x;
+  void *y = 0;
+  x = &u.pv;
+  *x = y;
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr42705.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr42705.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr42705.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,58 @@
+typedef int GLint;
+typedef unsigned char GLubyte;
+typedef unsigned int uint32_t;
+struct radeon_bo {
+    void *ptr;
+    uint32_t flags;
+};
+struct radeon_renderbuffer {
+    struct radeon_bo *bo;
+    unsigned int cpp;
+    int has_surface;
+};
+static inline
+GLint r600_1d_tile_helper(const struct radeon_renderbuffer * rrb,
+			  GLint x, GLint y, GLint is_depth, GLint is_stencil)
+{
+  GLint element_bytes = rrb->cpp;
+  GLint num_samples = 1;
+  GLint tile_width = 8;
+  GLint tile_height = 8;
+  GLint tile_thickness = 1;
+  GLint tile_bytes;
+  GLint tiles_per_row;
+  GLint slice_offset;
+  GLint tile_row_index;
+  GLint tile_column_index;
+  GLint tile_offset;
+  GLint pixel_number = 0;
+  GLint element_offset;
+  GLint offset = 0;
+  tile_bytes = tile_width * tile_height * tile_thickness
+      * element_bytes * num_samples;
+  tile_column_index = x / tile_width;
+  tile_offset = ((tile_row_index * tiles_per_row)
+		 + tile_column_index) * tile_bytes;
+  if (is_depth) {
+  }
+  else {
+      GLint sample_offset;
+      switch (element_bytes) {
+	  case 1:       pixel_number |= ((x >> 0) & 1) << 0;
+      }
+      element_offset = sample_offset + (pixel_number * element_bytes);
+  }
+  offset = slice_offset + tile_offset + element_offset;
+  return offset;
+}
+GLubyte *r600_ptr_color(const struct radeon_renderbuffer * rrb,
+			GLint x, GLint y)
+{
+  GLubyte *ptr = rrb->bo->ptr;
+  uint32_t mask = 1 | 2;
+  GLint offset;
+  if (rrb->has_surface || !(rrb->bo->flags & mask)) {
+      offset = r600_1d_tile_helper(rrb, x, y, 0, 0);
+  }
+  return &ptr[offset];
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr42708-1.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr42708-1.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr42708-1.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,10 @@
+typedef __SIZE_TYPE__ size_t;
+void *malloc(size_t);
+typedef union YYSTYPE {
+    char *id;
+}  YYSTYPE;
+extern YYSTYPE yylval;
+void yylex (int b)
+{
+  yylval = (YYSTYPE) (b ? 0 : (char *) malloc (4));
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr42716.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr42716.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr42716.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,18 @@
+static short foo (long long si1, short si2)
+{
+  return si1 > 0 && si2 > 0 || si1 < 0
+      && si2 < 0 && si1 < 1 - si2 ? : si1 + si2;
+}
+
+int g_13;
+unsigned g_17;
+
+int safe (int, int);
+
+void bar (short p_51, short * p_52)
+{
+  int *const l_55 = &g_13;
+  if (safe (*p_52, g_13 != foo (*p_52 & *l_55 == g_13 && g_17 >= 1, 0)))
+    {
+    }
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr43367.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr43367.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr43367.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,30 @@
+unsigned char g_17;
+
+const unsigned char func_39 (unsigned char p_40, unsigned char * p_41)
+{
+  return 0;
+}
+
+void int327 (const unsigned char p_48, unsigned char p_49)
+{
+  unsigned l_52;
+  unsigned char l_58[2];
+  int i, j;
+  if (func_39 (l_52, &p_49), p_48) {
+      unsigned char *l_60;
+      unsigned char *l = &l_58[1];
+      for (j; j; j++) {
+lbl_59:
+	  break;
+      }
+      for (l = 0; 1; l += 1) {
+	  for (p_49 = 1; p_49; p_49 += 0) {
+	      unsigned char **l_61[1][6];
+	      for (j = 0; j < 1; j++)
+		l_61[i][j] = &l_60;
+	      goto lbl_59;
+	  }
+      }
+  }
+}
+
Index: gcc/testsuite/gcc.c-torture/compile/pr42927.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr42927.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr42927.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,32 @@
+typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
+typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
+typedef enum { READ_SHARED = 0, WRITE_EXCLUSIVE = 1,
+    READ_EXCLUSIVE = 2, EXCLUSIVE_ACCESS = 3 } scsires_access_mode;
+struct scsires_extent_elem {
+    scsires_access_mode mode;
+    unsigned relative_address;
+    u_int32_t first_block;
+    u_int32_t length;
+};
+typedef struct scsires_extent_elem scsires_extent_elem_t;
+struct scsires_extent {
+    u_int8_t num_elements;
+    scsires_extent_elem_t *elements;
+};
+typedef struct scsires_extent scsires_extent_t;
+unsigned char buf[512];
+void scsires_issue_reservation(scsires_extent_t * new_extent)
+{
+  int i;
+  for (i = 0; i < new_extent->num_elements; i++)
+    {
+      buf[(i * 8)] = new_extent->elements[i].mode;
+      buf[(i * 8) + 1] = ((new_extent->elements[i].length >> 16) & 0xff); 
+      buf[(i * 8) + 2] = ((new_extent->elements[i].length >> 8) & 0xff);
+      buf[(i * 8) + 3] = (new_extent->elements[i].length & 0xff);
+      buf[(i * 8) + 4] = ((new_extent->elements[i].first_block >> 24) & 0xff); 
+      buf[(i * 8) + 5] = ((new_extent->elements[i].first_block >> 16) & 0xff);
+      buf[(i * 8) + 6] = ((new_extent->elements[i].first_block >> 8) & 0xff);
+      buf[(i * 8) + 7] = (new_extent->elements[i].first_block & 0xff);
+    }
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr42749.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr42749.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr42749.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,5 @@
+struct pdf_object { int val; };
+int pdf_count_size_object (struct pdf_object * p_obj)
+{
+    return pdf_count_size_object(p_obj) + 2 * sizeof(struct pdf_object);
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr43415.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr43415.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr43415.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,36 @@
+int main()                                                                      
+{                                                                               
+  unsigned long long table[256];                                          
+  unsigned int i;
+  for (i=0; i<256; ++i) {
+      unsigned long long j;
+      unsigned char x=i;
+      for (j=0; j<5; ++j) {
+	  x += x<<1;
+	  x ^= x>>1;
+      }
+      for (j=0; j<5; ++j) {
+	  x += x<<1;
+	  x ^= x>>1;
+      }
+      for (j=0; j<5; ++j) {
+	  x += x<<1;
+	  x ^= x>>1;
+      }
+      for (j=0; j<5; ++j) {
+	  x += x<<1;
+	  x ^= x>>1;
+      }
+      for (j=0; j<5; ++j) {
+	  x += x<<1;
+	  x ^= x>>1;
+      }
+      table[i] ^= (((unsigned long long)x)<<16);
+  }
+  for (i=0; i<256; ++i) {
+      if ((table[i]&0xff)==i)
+	return 1;
+  }
+  return 0;
+}
+
Index: gcc/testsuite/gcc.c-torture/compile/pr43164.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr43164.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr43164.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,16 @@
+struct S0
+{
+  unsigned char f0;
+  int:0;
+};
+
+struct S1
+{
+  struct S0 f0;
+};
+
+struct S1 func_34 (void)
+{
+  struct S1 l_221 = { { 1 } };
+  return l_221;
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr43066.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr43066.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr43066.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,14 @@
+struct S {
+  struct { } empty[1];
+  int i;
+};
+
+int foo(int i, ...)
+{
+  struct S s;
+  __builtin_va_list va;
+  __builtin_va_start(va, i);
+  s = __builtin_va_arg(va, struct S);
+  __builtin_va_end(va);
+  return s.i;
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr43191.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr43191.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr43191.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,46 @@
+struct S0
+{
+};
+
+struct S1
+{
+  unsigned f0:27;
+  const unsigned:0;
+};
+
+struct S2
+{
+  unsigned f2:1;
+};
+
+unsigned char g_4[1][8][3][1][1][1];
+unsigned char *g_17;
+unsigned char **g_16[1][10][7];
+
+struct S2 g_35 = {
+  0
+};
+
+struct S2 *g_34 = &g_35;
+
+struct S1 func_86 (unsigned char p_87, struct S2 **p_89)
+{
+  struct S1 l_92[6][8][1][1] = {
+    16143586
+  }
+  ;
+  return l_92[0][0][0][0];
+}
+
+void func_28 (struct S1 p_30, const struct S1 p_32)
+{
+}
+
+void func_70 (unsigned char p_72)
+{
+  unsigned char *const *l_93 = &g_17;
+  struct S2 **l_94;
+  unsigned char *const *l_97 = &g_17;
+  func_28 (func_86 (p_72, 0),
+           func_86 (p_72, &g_34));
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr43255.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr43255.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr43255.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,33 @@
+int safe (int);
+
+static unsigned foo (unsigned ui1, unsigned ui2)
+{
+  return ui1 + ui2;
+}
+
+int g_22;
+int *volatile g_23 = &g_22;
+int **g_282[8][10][1];
+int *g_330 = &g_22;
+volatile unsigned g_348;
+int g_397;
+
+void int32func (const unsigned char p_10)
+{
+  if (foo
+      (~
+       (p_10 |
+	(*g_282[(unsigned long) g_397 % 8][(unsigned) g_22 % 10][g_348 % 1]) ==
+	(*g_282[(unsigned long) g_397 % 8][(unsigned) g_22 % 10][g_348 % 1])),
+       1))
+    {
+    }
+  else if (*g_330 >=
+	   safe (*g_23 ^
+		 (**g_282[(unsigned long) g_397 % 8][(unsigned) g_22 % 10]
+		  [g_348 % 1])) & **g_282[8][10][1], 1)
+    {
+    }
+}
+
+
Index: gcc/testsuite/gcc.c-torture/compile/pr42717.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr42717.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr42717.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,30 @@
+static signed char
+foo (signed char si1, unsigned char si2)
+{
+  return (si1 ^ si2) & (-si2 ^ si2) ? : si1 - si2;
+}
+
+struct S0
+{
+};
+
+unsigned char g_21;
+
+struct S0 g_34;
+
+void
+bar (unsigned char p_20)
+{
+  unsigned char *l_22 = &g_21;
+  unsigned char l_23 = 0;
+  struct S0 *l = &g_34;
+  goto lbl_42;
+  for (; l_23; l_23 = foo (l_23, 1))
+    {
+      for (p_20 = 0; 0; p_20 = foo (p_20, 1))
+	lbl_42:;
+      (l == &g_34) ? 0 : "";
+lbl_85:*l_22 = p_20;
+    }
+  goto lbl_85;
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr42998.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr42998.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr42998.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,15 @@
+void foo(void *);
+void bar(void *);
+void ndisc_fill_addr_option(unsigned char *opt, int data_len,
+			    unsigned short addr_type) 
+{
+  int pad;
+  if (addr_type == 32)
+    pad = 2;
+  else
+    pad = 0;
+  __builtin_memset(opt + 2, 0, pad);
+  opt += pad;
+  __builtin_constant_p(data_len) ? foo (opt+2) : bar (opt+2);
+}
+
Index: gcc/testsuite/gcc.c-torture/compile/pr43188.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr43188.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr43188.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,6 @@
+int *__attribute__((__aligned__(16))) *p;
+
+int main (void)
+{
+  return **p;
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr43288.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr43288.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr43288.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1 @@
+static int a __attribute__ ((common));
Index: gcc/testsuite/gcc.target/arm/neon/vget_lowp8.c
===================================================================
--- gcc/testsuite/gcc.target/arm/neon/vget_lowp8.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/testsuite/gcc.target/arm/neon/vget_lowp8.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -9,7 +9,7 @@
 
 void test_vget_lowp8 (void)
 {
-  poly8x8_t out_poly8x8_t;
+  register poly8x8_t out_poly8x8_t asm ("d18");
   poly8x16_t arg0_poly8x16_t;
 
   out_poly8x8_t = vget_low_p8 (arg0_poly8x16_t);
Index: gcc/testsuite/gcc.target/arm/neon/vget_lows64.c
===================================================================
--- gcc/testsuite/gcc.target/arm/neon/vget_lows64.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/testsuite/gcc.target/arm/neon/vget_lows64.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -15,5 +15,4 @@
   out_int64x1_t = vget_low_s64 (arg0_int64x2_t);
 }
 
-/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
Index: gcc/testsuite/gcc.target/arm/neon/vget_lowu64.c
===================================================================
--- gcc/testsuite/gcc.target/arm/neon/vget_lowu64.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/testsuite/gcc.target/arm/neon/vget_lowu64.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -15,5 +15,4 @@
   out_uint64x1_t = vget_low_u64 (arg0_uint64x2_t);
 }
 
-/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
Index: gcc/testsuite/gcc.target/arm/neon/vget_lowp16.c
===================================================================
--- gcc/testsuite/gcc.target/arm/neon/vget_lowp16.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/testsuite/gcc.target/arm/neon/vget_lowp16.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -9,7 +9,7 @@
 
 void test_vget_lowp16 (void)
 {
-  poly16x4_t out_poly16x4_t;
+  register poly16x4_t out_poly16x4_t asm ("d18");
   poly16x8_t arg0_poly16x8_t;
 
   out_poly16x4_t = vget_low_p16 (arg0_poly16x8_t);
Index: gcc/testsuite/gcc.target/arm/neon/vget_lows8.c
===================================================================
--- gcc/testsuite/gcc.target/arm/neon/vget_lows8.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/testsuite/gcc.target/arm/neon/vget_lows8.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -9,7 +9,7 @@
 
 void test_vget_lows8 (void)
 {
-  int8x8_t out_int8x8_t;
+  register int8x8_t out_int8x8_t asm ("d18");
   int8x16_t arg0_int8x16_t;
 
   out_int8x8_t = vget_low_s8 (arg0_int8x16_t);
Index: gcc/testsuite/gcc.target/arm/neon/vget_lowu8.c
===================================================================
--- gcc/testsuite/gcc.target/arm/neon/vget_lowu8.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/testsuite/gcc.target/arm/neon/vget_lowu8.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -9,7 +9,7 @@
 
 void test_vget_lowu8 (void)
 {
-  uint8x8_t out_uint8x8_t;
+  register uint8x8_t out_uint8x8_t asm ("d18");
   uint8x16_t arg0_uint8x16_t;
 
   out_uint8x8_t = vget_low_u8 (arg0_uint8x16_t);
Index: gcc/testsuite/gcc.target/arm/neon/vget_lows32.c
===================================================================
--- gcc/testsuite/gcc.target/arm/neon/vget_lows32.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/testsuite/gcc.target/arm/neon/vget_lows32.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -9,7 +9,7 @@
 
 void test_vget_lows32 (void)
 {
-  int32x2_t out_int32x2_t;
+  register int32x2_t out_int32x2_t asm ("d18");
   int32x4_t arg0_int32x4_t;
 
   out_int32x2_t = vget_low_s32 (arg0_int32x4_t);
Index: gcc/testsuite/gcc.target/arm/neon/vget_lows16.c
===================================================================
--- gcc/testsuite/gcc.target/arm/neon/vget_lows16.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/testsuite/gcc.target/arm/neon/vget_lows16.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -9,7 +9,7 @@
 
 void test_vget_lows16 (void)
 {
-  int16x4_t out_int16x4_t;
+  register int16x4_t out_int16x4_t asm ("d18");
   int16x8_t arg0_int16x8_t;
 
   out_int16x4_t = vget_low_s16 (arg0_int16x8_t);
Index: gcc/testsuite/gcc.target/arm/neon/vget_lowu32.c
===================================================================
--- gcc/testsuite/gcc.target/arm/neon/vget_lowu32.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/testsuite/gcc.target/arm/neon/vget_lowu32.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -9,7 +9,7 @@
 
 void test_vget_lowu32 (void)
 {
-  uint32x2_t out_uint32x2_t;
+  register uint32x2_t out_uint32x2_t asm ("d18");
   uint32x4_t arg0_uint32x4_t;
 
   out_uint32x2_t = vget_low_u32 (arg0_uint32x4_t);
Index: gcc/testsuite/gcc.target/arm/neon/vget_lowu16.c
===================================================================
--- gcc/testsuite/gcc.target/arm/neon/vget_lowu16.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/testsuite/gcc.target/arm/neon/vget_lowu16.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -9,7 +9,7 @@
 
 void test_vget_lowu16 (void)
 {
-  uint16x4_t out_uint16x4_t;
+  register uint16x4_t out_uint16x4_t asm ("d18");
   uint16x8_t arg0_uint16x8_t;
 
   out_uint16x4_t = vget_low_u16 (arg0_uint16x8_t);
Index: gcc/testsuite/gcc.target/arm/neon/vget_lowf32.c
===================================================================
--- gcc/testsuite/gcc.target/arm/neon/vget_lowf32.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/testsuite/gcc.target/arm/neon/vget_lowf32.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -9,7 +9,7 @@
 
 void test_vget_lowf32 (void)
 {
-  float32x2_t out_float32x2_t;
+  register float32x2_t out_float32x2_t asm ("d18");
   float32x4_t arg0_float32x4_t;
 
   out_float32x2_t = vget_low_f32 (arg0_float32x4_t);
Index: gcc/testsuite/gcc.target/arm/sibcall-1.c
===================================================================
--- gcc/testsuite/gcc.target/arm/sibcall-1.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/testsuite/gcc.target/arm/sibcall-1.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -30,5 +30,6 @@
   return result;
 }
 
-/* { dg-final { scan-assembler "\tb\tfunc2\n" } } */
+/* The PLT marker may appear if the test is run with -fpic/-fPIC.  */
+/* { dg-final { scan-assembler "\tb\tfunc2(\\(PLT\\))?\n" } } */
 
Index: gcc/testsuite/gcc.target/arm/thumb2-cbnz.c
===================================================================
--- gcc/testsuite/gcc.target/arm/thumb2-cbnz.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/arm/thumb2-cbnz.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,110 @@
+/* { dg-do assemble } */
+/* { dg-options "-O1 -mthumb -march=armv7-a" } */
+
+typedef short int int16_t;
+typedef unsigned char uint8_t;
+struct component
+{
+  float *Q_table;
+};
+static inline unsigned char descale_and_clamp(int x, int shift)
+{
+  x += (1UL<<(shift-1));
+  if (x<0)
+    x = (x >> shift) | ((~(0UL)) << (32-(shift)));
+    x >>= shift;
+  x += 128;
+  if (x>255)
+    return 255;
+  else if (x<0)
+    return 0;
+    return x;
+}
+void
+tinyjpeg_idct_float (struct component *compptr, uint8_t *output_buf, int stride)
+{
+  float tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;
+  float tmp10, tmp11, tmp12, tmp13;
+  float z5, z10, z11, z12, z13;
+  int16_t *inptr;
+  float *quantptr;
+  float *wsptr;
+  uint8_t *outptr;
+  int ctr;
+  float workspace[(8*8)];
+  quantptr = compptr->Q_table;
+  wsptr = workspace;
+  for (ctr = 8; ctr > 0; ctr--) {
+    if (inptr[8*1] == 0 && inptr[8*2] == 0 &&
+ inptr[8*3] == 0 && inptr[8*4] == 0 &&
+ inptr[8*5] == 0 && inptr[8*6] == 0 &&
+ inptr[8*7] == 0) {
+      float dcval = (((float) (inptr[8*0])) * (quantptr[8*0]));
+      wsptr[8*0] = dcval;
+      wsptr[8*1] = dcval;
+      wsptr[8*2] = dcval;
+      wsptr[8*3] = dcval;
+      wsptr[8*4] = dcval;
+      wsptr[8*5] = dcval;
+      wsptr[8*6] = dcval;
+      wsptr[8*7] = dcval;
+      inptr++;
+      quantptr++;
+      wsptr++;
+      continue;
+    }
+    tmp0 = (((float) (inptr[8*0])) * (quantptr[8*0]));
+    tmp1 = (((float) (inptr[8*2])) * (quantptr[8*2]));
+    tmp2 = (((float) (inptr[8*4])) * (quantptr[8*4]));
+    tmp3 = (((float) (inptr[8*6])) * (quantptr[8*6]));
+    tmp10 = tmp0 + tmp2;
+    tmp11 = tmp0 - tmp2;
+    tmp13 = tmp1 + tmp3;
+    tmp12 = (tmp1 - tmp3) * ((float) 1.414213562) - tmp13;
+    tmp0 = tmp10 + tmp13;
+    tmp3 = tmp10 - tmp13;
+    tmp1 = tmp11 + tmp12;
+    tmp2 = tmp11 - tmp12;
+    tmp4 = (((float) (inptr[8*1])) * (quantptr[8*1]));
+    tmp5 = (((float) (inptr[8*3])) * (quantptr[8*3]));
+    tmp6 = (((float) (inptr[8*5])) * (quantptr[8*5]));
+    tmp7 = (((float) (inptr[8*7])) * (quantptr[8*7]));
+    z13 = tmp6 + tmp5;
+    z10 = tmp6 - tmp5;
+    z11 = tmp4 + tmp7;
+    z12 = tmp4 - tmp7;
+    tmp7 = z11 + z13;
+    tmp11 = (z11 - z13) * ((float) 1.414213562);
+    z5 = (z10 + z12) * ((float) 1.847759065);
+    tmp10 = ((float) 1.082392200) * z12 - z5;
+    tmp12 = ((float) -2.613125930) * z10 + z5;
+    tmp6 = tmp12 - tmp7;
+    tmp5 = tmp11 - tmp6;
+    tmp4 = tmp10 + tmp5;
+    wsptr[8*0] = tmp0 + tmp7;
+    wsptr[8*7] = tmp0 - tmp7;
+    wsptr[8*1] = tmp1 + tmp6;
+    wsptr[8*2] = tmp2 + tmp5;
+    wsptr[8*5] = tmp2 - tmp5;
+    wsptr[8*4] = tmp3 + tmp4;
+    wsptr[8*3] = tmp3 - tmp4;
+    inptr++;
+    quantptr++;
+    wsptr++;
+  }
+  for (ctr = 0; ctr < 8; ctr++) {
+    tmp11 = wsptr[0] - wsptr[4];
+    tmp12 = (wsptr[2] - wsptr[6]) * ((float) 1.414213562) - tmp13;
+    tmp0 = tmp10 + tmp13;
+    tmp1 = tmp11 + tmp12;
+    z10 = wsptr[5] - wsptr[3];
+    tmp12 = ((float) -2.613125930) * z10 + z5;
+    tmp6 = tmp12 - tmp7;
+    outptr[0] = descale_and_clamp((int)(tmp0 + tmp7), 3);
+    outptr[7] = descale_and_clamp((int)(tmp0 - tmp7), 3);
+    outptr[1] = descale_and_clamp((int)(tmp1 + tmp6), 3);
+    outptr[6] = descale_and_clamp((int)(tmp1 - tmp6), 3);
+    outptr[2] = descale_and_clamp((int)(tmp2 + tmp5), 3);
+    outptr += stride;
+  }
+}
Index: gcc/testsuite/gcc.target/arm/pr40887.c
===================================================================
--- gcc/testsuite/gcc.target/arm/pr40887.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/arm/pr40887.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,9 @@
+/* { dg-options "-O2 -march=armv5te" }  */
+/* { dg-final { scan-assembler "blx" } } */
+
+int (*indirect_func)();
+
+int indirect_call()
+{
+    return indirect_func();
+}
Index: gcc/testsuite/gcc.target/powerpc/ppc-sdata-2.c
===================================================================
--- gcc/testsuite/gcc.target/powerpc/ppc-sdata-2.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/testsuite/gcc.target/powerpc/ppc-sdata-2.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,5 +1,6 @@
 /* { dg-do compile { target { { powerpc*-*-linux* && ilp32 } || { powerpc-*-eabi* } } } } */
 /* { dg-options "-O2 -fno-common -G 8 -msdata=sysv" } */
+/* { dg-require-effective-target nonpic } */
 /* { dg-final { scan-assembler "\\.section\[ \t\]\\.sdata," } } */
 /* { dg-final { scan-assembler-not "\\.section\[ \t\]\\.sdata2," } } */
 /* { dg-final { scan-assembler "sdat@sdarel\\(13\\)" } } */
Index: gcc/testsuite/gcc.target/powerpc/ppc-sdata-1.c
===================================================================
--- gcc/testsuite/gcc.target/powerpc/ppc-sdata-1.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/testsuite/gcc.target/powerpc/ppc-sdata-1.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,5 +1,6 @@
 /* { dg-do compile { target { { powerpc*-*-linux* && ilp32 } || { powerpc-*-eabi* } } } } */
 /* { dg-options "-O2 -fno-common -G 8 -meabi -msdata=eabi" } */
+/* { dg-require-effective-target nonpic } */
 /* { dg-final { scan-assembler "\\.section\[ \t\]\\.sdata," } } */
 /* { dg-final { scan-assembler "\\.section\[ \t\]\\.sdata2," } } */
 /* { dg-final { scan-assembler "sdat@sda21\\((13|0)\\)" } } */
Index: gcc/testsuite/gcc.target/i386/pr42881.c
===================================================================
--- gcc/testsuite/gcc.target/i386/pr42881.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/i386/pr42881.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,13 @@
+/* PR target/42881 */
+/* { dg-do run } */
+/* { dg-options "-O0 -msse2" } */
+#include "sse2-check.h"
+static void
+sse2_test (void)
+{
+  double a[2];
+  __m128d x = _mm_set1_pd(3);
+  _mm_storeu_pd(a,x);
+  if (a[0] != 3.0 || a[1] != 3.0)
+    __builtin_abort ();
+}
Index: gcc/testsuite/gcc.target/i386/clobbers.c
===================================================================
--- gcc/testsuite/gcc.target/i386/clobbers.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/testsuite/gcc.target/i386/clobbers.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,7 +1,6 @@
 /* Test asm clobbers on x86. */
 
 /* { dg-do run } */
-/* { dg-skip-if "" { ilp32 } { "-fpic" "-fPIC" } { "" } } */
 
 extern void abort (void);
 
@@ -13,11 +12,15 @@
                 abort ();
 	/* On darwin you can't call external functions from non-pic code,
 	   however, clobbering ebx isn't valid in pic code. Instead of
-	   disabling the whole test, just disable the ebx clobbering part.  */
+	   disabling the whole test, just disable the ebx clobbering part.
+	   Ditto for any x86 system that is ilp32 && pic.
+	*/
 #if !(defined (__MACH__))
+#if ! defined (__PIC__) || defined (__LP64__)
         __asm__ ("movl $1,%0\n\txorl %%ebx,%%ebx" : "=r" (i) : : "ebx");
         if (i != 1)
                 abort ();
+#endif /* ! pic || lp64 */
 #endif
         __asm__ ("movl $1,%0\n\txorl %%ecx,%%ecx" : "=r" (i) : : "ecx");
         if (i != 1)
Index: gcc/testsuite/gcc.target/i386/pr43107.c
===================================================================
--- gcc/testsuite/gcc.target/i386/pr43107.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/i386/pr43107.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,20 @@
+/* PR target/43107 */
+/* { dg-do compile } */
+/* { dg-options "-O3 -mavx" } */
+
+extern void bar (float b[4][4]);
+
+void
+foo ()
+{
+  float a[4][4], b[4][4];
+  int i, j;
+  for (i = 0; i < 4; i++)
+    {
+      for (j = 0; j < 4; j++)
+	a[i][j] = 0;
+      for (j = 0; j < 4; j++)
+	b[i][j] = a[i][j];
+    }
+  bar (b);
+}
Index: gcc/testsuite/gcc.target/i386/pr42891.c
===================================================================
--- gcc/testsuite/gcc.target/i386/pr42891.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/i386/pr42891.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+union B { int i; float f; };
+
+extern void bar (void);
+
+void
+foo (union B x, union B y)
+{
+  if (!(y.f > x.i))
+    bar ();
+}
Index: gcc/testsuite/gnat.dg/thin_pointer.adb
===================================================================
--- gcc/testsuite/gnat.dg/thin_pointer.adb	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/testsuite/gnat.dg/thin_pointer.adb	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,11 +0,0 @@
--- { dg-do compile }
--- { dg-options "-O" }
-
-package body Thin_Pointer is
-
-   procedure Set_Buffer (AD : Buf_Ptr; Buffer : Stream_ptr) is
-   begin
-      AD.B.A := Buffer (Buffer'First)'Address;
-   end Set_Buffer;
-
-end Thin_Pointer;
Index: gcc/testsuite/gnat.dg/thin_pointer.ads
===================================================================
--- gcc/testsuite/gnat.dg/thin_pointer.ads	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/testsuite/gnat.dg/thin_pointer.ads	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,22 +0,0 @@
-with System;
-
-package Thin_Pointer is
-
-   type Stream is array (Integer range <>) of Character;
-
-   type Stream_Ptr is access Stream;
-   for Stream_Ptr'Size use Standard'Address_Size;
-
-   type Buf is record
-      A : System.Address;
-   end record;
-
-   type Buf_Wrapper is record
-      B : Buf;
-   end record;
-
-   type Buf_Ptr is access Buf_Wrapper;
-
-   procedure Set_Buffer (AD : Buf_Ptr; Buffer : Stream_ptr);
-
-end Thin_Pointer;
Index: gcc/testsuite/gnat.dg/thin_pointer1.adb
===================================================================
--- gcc/testsuite/gnat.dg/thin_pointer1.adb	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gnat.dg/thin_pointer1.adb	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,11 @@
+-- { dg-do compile }
+-- { dg-options "-O" }
+
+package body Thin_Pointer1 is
+
+   procedure Set_Buffer (AD : Buf_Ptr; Buffer : Stream_ptr) is
+   begin
+      AD.B.A := Buffer (Buffer'First)'Address;
+   end Set_Buffer;
+
+end Thin_Pointer1;
Index: gcc/testsuite/gnat.dg/thin_pointer1.ads
===================================================================
--- gcc/testsuite/gnat.dg/thin_pointer1.ads	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gnat.dg/thin_pointer1.ads	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,22 @@
+with System;
+
+package Thin_Pointer1 is
+
+   type Stream is array (Integer range <>) of Character;
+
+   type Stream_Ptr is access Stream;
+   for Stream_Ptr'Size use Standard'Address_Size;
+
+   type Buf is record
+      A : System.Address;
+   end record;
+
+   type Buf_Wrapper is record
+      B : Buf;
+   end record;
+
+   type Buf_Ptr is access Buf_Wrapper;
+
+   procedure Set_Buffer (AD : Buf_Ptr; Buffer : Stream_ptr);
+
+end Thin_Pointer1;
Index: gcc/testsuite/gnat.dg/thin_pointer2_pkg.adb
===================================================================
--- gcc/testsuite/gnat.dg/thin_pointer2_pkg.adb	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gnat.dg/thin_pointer2_pkg.adb	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,18 @@
+package body Thin_Pointer2_Pkg is
+
+   type SB is access constant String;
+
+   function Inner (S : SB) return Character is
+   begin
+      if S /= null and then S'Length > 0 then
+         return S (S'First);
+      end if;
+      return '*';
+   end;
+
+   function F return Character is
+   begin
+      return Inner (SB (S));
+   end;
+
+end Thin_Pointer2_Pkg;
Index: gcc/testsuite/gnat.dg/thin_pointer2_pkg.ads
===================================================================
--- gcc/testsuite/gnat.dg/thin_pointer2_pkg.ads	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gnat.dg/thin_pointer2_pkg.ads	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,9 @@
+package Thin_Pointer2_Pkg is
+
+   type SA is access String;
+   for SA'Size use Standard'Address_Size;
+   S : SA;
+
+   function F return Character;
+
+end Thin_Pointer2_Pkg;
Index: gcc/testsuite/gnat.dg/thin_pointer2.adb
===================================================================
--- gcc/testsuite/gnat.dg/thin_pointer2.adb	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gnat.dg/thin_pointer2.adb	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,13 @@
+-- PR ada/42253
+-- Testcase by Duncan Sands <baldrick@gcc.gnu.org>
+
+-- { dg-do run }
+
+with Thin_Pointer2_Pkg; use Thin_Pointer2_Pkg;
+
+procedure Thin_Pointer2 is
+begin
+   if F /= '*' then
+      raise Program_Error;
+   end if;
+end;
Index: gcc/testsuite/ada/acats/run_all.sh
===================================================================
--- gcc/testsuite/ada/acats/run_all.sh	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/testsuite/ada/acats/run_all.sh	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -129,6 +129,7 @@
 
 cp $testdir/tests/cd/*.c $dir/support
 cp $testdir/tests/cxb/*.c $dir/support
+grep -v '^#' $testdir/norun.lst | sort > $dir/support/norun.lst
 
 rm -rf $dir/run
 mv $dir/tests $dir/tests.$$ 2> /dev/null
@@ -206,7 +207,7 @@
 
    cd $dir/tests/$chapter
    ls *.a *.ada *.adt *.am *.dep 2> /dev/null | sed -e 's/\(.*\)\..*/\1/g' | \
-   cut -c1-7 | sort | uniq | comm -23 - $testdir/norun.lst \
+   cut -c1-7 | sort | uniq | comm -23 - $dir/support/norun.lst \
      > $dir/tests/$chapter/${chapter}.lst 
    countn=`wc -l < $dir/tests/$chapter/${chapter}.lst`
    glob_countn=`expr $glob_countn + $countn`
Index: gcc/testsuite/gcc.dg/Wunreachable-2.c
===================================================================
--- gcc/testsuite/gcc.dg/Wunreachable-2.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/testsuite/gcc.dg/Wunreachable-2.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,19 +0,0 @@
-/* { dg-do compile } */
-/* { dg-options "-O2 -Wunreachable-code" } */
-
-extern int foo (const char *);
-extern void baz (void);
-const char *a[] = { "one", "two" };
-
-void bar (void)
-{
-  int i;
-
-  for (i = 0; i < 2; i++)
-    if (! foo (a[i]))
-      return;
-
-  baz ();	/* { dg-bogus "will never be executed" } */
-  baz ();
-  baz ();
-}
Index: gcc/testsuite/gcc.dg/inline-33.c
===================================================================
--- gcc/testsuite/gcc.dg/inline-33.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/testsuite/gcc.dg/inline-33.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,6 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-O3 -fdump-tree-optimized"  } */
-/* { dg-options "-O3 -fdump-tree-optimized -fpie" { target { ! nonpic } } } */
+/* { dg-add-options bind_pic_locally } */
 
 int i;
 
Index: gcc/testsuite/gcc.dg/parm-impl-decl-3.c
===================================================================
--- gcc/testsuite/gcc.dg/parm-impl-decl-3.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/parm-impl-decl-3.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,28 @@
+/* Like parm-impl-decl-1.c, but with -g.  PR 43381.  */
+/* Origin: Joseph Myers <joseph@codesourcery.com> */
+/* { dg-do compile } */
+/* { dg-options "-g" } */
+
+int
+foo (int __attribute__ ((__mode__ (vector_size(8)))) i) /* { dg-warning "'__mode__' attribute ignored" } */
+{
+  return (long long) i;
+}
+
+int f (int [sizeof(g())]);
+int f1 (int [sizeof(g1())]);
+
+int g () { return 1; }
+
+int
+h (int (*p)[sizeof(i())])
+{
+  int g2 (), g3 ();
+  return (*p)[0] + g3() + g2();
+}
+
+int i () { return 2; }
+
+int f2 (int [sizeof(g2())]);
+int f3 (int [sizeof(g3())]);
+int g3 () { return 4; }
Index: gcc/testsuite/gcc.dg/errno-1.c
===================================================================
--- gcc/testsuite/gcc.dg/errno-1.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/errno-1.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,17 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+#include <errno.h>
+#include <stdlib.h>
+
+int main()
+{
+  void *p;
+  errno = 0;
+  p = malloc (-1);
+  if (errno != 0)
+    do_not_optimize_away ();
+  return 0;
+}
+
+/* { dg-final { scan-assembler "do_not_optimize_away" } } */
Index: gcc/testsuite/gcc.dg/pr42427.c
===================================================================
--- gcc/testsuite/gcc.dg/pr42427.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/pr42427.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,21 @@
+/* { dg-do assemble } */
+/* { dg-options "-O2 -fexceptions -fnon-call-exceptions -fpeel-loops" } */
+/* { dg-require-effective-target ilp32 } */
+
+#include <complex.h>
+
+extern double myabs (complex double);
+
+void
+test (double *help, complex double *wm, long nz)
+{
+  long k;
+  double znew;
+  double zold;
+  for (k = 0; k < nz; k++)
+    {
+      znew = myabs (wm[k]);
+      zold = help[k];
+      help[k] = znew;
+    }
+}
Index: gcc/testsuite/gcc.dg/pr43300.c
===================================================================
--- gcc/testsuite/gcc.dg/pr43300.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/pr43300.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,17 @@
+/* { dg-do compile } */
+/* { dg-options "-Os -w" } */
+typedef float V2SF __attribute__ ((vector_size (128)));
+
+V2SF
+foo (int x, V2SF a)
+{
+  V2SF b;
+  if (x & 42)
+    b = a;
+  else
+    b = a + (V2SF) {1.0f/0.0f - 1.0f/0.0f, 1.0f/0.0f - 1.0f/0.0f};
+  while (x--)
+    a += b;
+      
+  return a;
+}
Index: gcc/testsuite/gcc.dg/pr43211.c
===================================================================
--- gcc/testsuite/gcc.dg/pr43211.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/pr43211.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+
+struct T;
+
+struct S {
+  void (*bar)(struct S);
+};
+
+void bar(struct T t) {} /* { dg-error "" }  */
+
+void foo(struct S *s)
+{
+  s->bar = bar;
+}
+
Index: gcc/testsuite/gcc.dg/vla-22.c
===================================================================
--- gcc/testsuite/gcc.dg/vla-22.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/vla-22.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,22 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+extern void bar (int *);
+
+static inline __attribute__((always_inline))
+int
+foo (int i)
+{
+  struct S {
+    int ar[1][i];
+  } s;
+
+  s.ar[0][0] = 0;
+  bar (&s.ar[0][0]);
+}
+
+void
+baz (int i)
+{
+  foo (i + 2);
+}
Index: gcc/testsuite/gcc.dg/fold-div-3.c
===================================================================
--- gcc/testsuite/gcc.dg/fold-div-3.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/fold-div-3.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+/* { dg-options "-O -fdump-tree-original" } */
+
+unsigned int
+apply_frontend_param (unsigned int spi_bias)
+{
+  static const int ppm = 8000;
+  spi_bias /= 1000ULL + ppm/1000;
+  return spi_bias;
+}
+
+/* Make sure we perform the division in the narrower type.  */
+
+/* { dg-final { scan-tree-dump "spi_bias = spi_bias / 1008;" "original" } } */
+/* { dg-final { cleanup-tree-dump "original" } } */
Index: gcc/testsuite/gcc.dg/pr43402.c
===================================================================
--- gcc/testsuite/gcc.dg/pr43402.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/pr43402.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,58 @@
+/* { dg-do run } */
+/* { dg-options "-O1 -fno-inline" } */
+extern void abort (void);
+
+static int something;
+
+static int * converterData[2]={
+    &something, &something,
+};
+
+static struct {
+  const char *name;
+  int type;
+} const cnvNameType[] = {
+  { "bocu1", 1 },
+  { "utf7", 1 },
+  { "utf8", 1 }
+};
+
+
+const int * getAlgorithmicTypeFromName(const char *realName);
+const int *
+getAlgorithmicTypeFromName(const char *realName)
+{
+    unsigned mid, start, limit;
+    unsigned lastMid;
+    int result;
+    start = 0;
+    limit = sizeof(cnvNameType)/sizeof(cnvNameType[0]);
+    mid = limit;
+    lastMid = 0xffffffff;
+
+    for (;;) {
+        mid = (start + limit) / 2;
+        if (lastMid == mid) {   /* Have we moved? */
+            break;  /* We haven't moved, and it wasn't found. */
+        }
+        lastMid = mid;
+        result = __builtin_strcmp(realName, cnvNameType[mid].name);
+
+        if (result < 0) {
+            limit = mid;
+        } else if (result > 0) {
+            start = mid;
+        } else {
+            return converterData[cnvNameType[mid].type];
+        }
+    }
+
+    return 0;
+}
+
+int main (void)
+{
+  if (!getAlgorithmicTypeFromName ("utf8"))
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/torture/pr42952.c
===================================================================
--- gcc/testsuite/gcc.dg/torture/pr42952.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/torture/pr42952.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,19 @@
+/* { dg-do run } */
+/* { dg-options "-fno-tree-ccp -fno-tree-fre" } */
+
+extern void abort (void);
+
+static int g[1];
+
+static int * const p = &g[0];
+static int * const q = &g[0];
+
+int main(void)
+{
+  g[0] = 1;
+  *p = 0;
+  *p = *q;
+  if (g[0] != 0)
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/torture/pr43002.c
===================================================================
--- gcc/testsuite/gcc.dg/torture/pr43002.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/torture/pr43002.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+/* { dg-options "-Wall -fwrapv" } */
+
+long A[4], B[100];
+
+void foo(void)
+{
+  int i, j, k = 3;
+  while (A[k] && k > 0) k--; /* k = {0, 1, 2, 3} */
+  for (i = 3 - k; i >= 0; i--) /* i = {0..3-k} */
+    for (j = 0; j <= k; j++) { /* line 8; j = {0..k} */
+	B[i + j] = 0; /* line 9; i + j = {0..3-k+k} = {0..3} */
+	for (j = 0; j <= k; j++); /* only one iteration is done, with j == 0 */
+    }
+}
+
Index: gcc/testsuite/gcc.dg/torture/pr43360.c
===================================================================
--- gcc/testsuite/gcc.dg/torture/pr43360.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/torture/pr43360.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,20 @@
+/* { dg-do run } */
+
+int l_5_5_2 = 4;
+int g_3[1][1];
+
+void func_1 (void)
+{
+  for (g_3[0][0] = 1; g_3[0][0] < 8; g_3[0][0] += 7) {
+    int *l_6 = &g_3[0][0];
+    *l_6 = l_5_5_2;
+  }
+}
+
+int main (void)
+{
+  func_1 ();
+  if (g_3[0][0] != 11)
+      __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/torture/pr42898-2.c
===================================================================
--- gcc/testsuite/gcc.dg/torture/pr42898-2.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/torture/pr42898-2.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,25 @@
+/* { dg-do compile } */
+/* { dg-options "-fdump-tree-optimized" } */
+
+struct hardware {
+  int parm1:8;
+  int :4;
+  int parm2:4;
+  int parm3:15;
+  int parm4:1;
+};
+
+const struct hardware h = {
+  .parm1=42,
+  .parm2=13,
+  .parm3=11850,
+  .parm4=1,
+};
+
+void f1(volatile struct hardware *ptr)
+{
+  *ptr = h;
+}
+
+/* { dg-final { scan-tree-dump-times "\\*ptr" 1 "optimized" } } */
+/* { dg-final { cleanup-tree-dump "optimized" } } */
Index: gcc/testsuite/gcc.dg/torture/pr42898.c
===================================================================
--- gcc/testsuite/gcc.dg/torture/pr42898.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/torture/pr42898.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,23 @@
+/* { dg-do compile } */
+/* { dg-options "-fdump-tree-optimized" } */
+
+struct hardware {
+  int parm1:8;
+  int :4;
+  int parm2:4;
+  int parm3:15;
+  int parm4:1;
+};
+
+void f1(volatile struct hardware *ptr)
+{
+  *ptr=(struct hardware) {
+    .parm1=42,
+    .parm2=13,
+    .parm3=11850,
+    .parm4=1,
+  };
+}
+
+/* { dg-final { scan-tree-dump-times "\\*ptr" 1 "optimized" } } */
+/* { dg-final { cleanup-tree-dump "optimized" } } */
Index: gcc/testsuite/gcc.dg/torture/pr42363.c
===================================================================
--- gcc/testsuite/gcc.dg/torture/pr42363.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/torture/pr42363.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,84 @@
+/* PR middle-end/pr42363, extended from the test for PR middle-end/37913.  */
+/* { dg-do compile } */
+/* { dg-options "-g" } */
+
+void foo (void) __attribute__ ((noreturn));
+
+static int __attribute__ ((noreturn))
+bar (void)
+{
+  foo ();
+}
+
+int
+baz (void)
+{
+  int i = bar ();
+  return i + 1;
+}
+
+int fooz (void) __attribute__ ((noreturn));
+
+static int __attribute__ ((noreturn))
+bart (void)
+{
+  return fooz (); /* { dg-warning "noreturn" } */
+}
+
+int bazr (void)
+{
+  int i = bart ();
+  return i + 1;
+}
+
+static inline int
+bard (void)
+{
+  return fooz ();
+}
+
+int bizr (void)
+{
+  int i, j;
+
+  i = j = bard ();
+
+  return i + 1;
+}
+
+/* This might be regarded as pure and folded, rather than inlined.
+   It's pure evil.  */
+static int __attribute__ ((pure, const, noreturn))
+barf (void)
+{
+} /* { dg-warning "does return" } */
+
+static int __attribute__ ((pure, const))
+bark (void)
+{
+  barf ();
+}
+
+int buzr (void)
+{
+  int i, j;
+
+  i = j = bark () + bark ();
+
+  return i + 1;
+}
+
+int buzt (void)
+{
+  int i, j;
+
+  i = j = barf () + barf ();
+
+  return i + 1;
+}
+
+void bust (void)
+{
+  while (barf ())
+    ;
+}
Index: gcc/testsuite/gcc.dg/torture/pr43000.c
===================================================================
--- gcc/testsuite/gcc.dg/torture/pr43000.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/torture/pr43000.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,24 @@
+/* { dg-do run } */
+/* { dg-options "-fwrapv" } */
+
+int __attribute__((noinline))
+foo (long i, long j)
+{
+  if (i >= 1)
+    if (j > -(long)(((unsigned long)(long)-1)>>1))
+      {
+        long x;
+	j--;
+	x = i + j;
+	if (x >= 0)
+	  return 1;
+      }
+  return 0;
+}
+extern void abort (void);
+int main()
+{
+  if (foo (1, 1) != 1)
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/torture/pr43165.c
===================================================================
--- gcc/testsuite/gcc.dg/torture/pr43165.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/torture/pr43165.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,17 @@
+/* PR debug/43165 */
+/* { dg-options "-g" } */
+
+struct __attribute__((packed)) S
+{
+  unsigned char a;
+  unsigned short b;
+  unsigned short c;
+  unsigned d : 24;
+};
+
+void 
+foo (struct S p)
+{
+  for (; p.c; p.c++)
+    ;
+}
Index: gcc/testsuite/gcc.dg/tree-ssa/ivopts-4.c
===================================================================
--- gcc/testsuite/gcc.dg/tree-ssa/ivopts-4.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/tree-ssa/ivopts-4.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,8 @@
+/* { dg-do compile } */
+/* { dg-options "-O1" } */
+void foo(int *p, long i, int j)
+{
+  do {
+      p[i]++;
+  } while (i += j);
+}
Index: gcc/testsuite/gcc.dg/tree-ssa/pr42585.c
===================================================================
--- gcc/testsuite/gcc.dg/tree-ssa/pr42585.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/tree-ssa/pr42585.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,37 @@
+/* { dg-do compile } */
+/* { dg-options "-O1 -fdump-tree-optimized" } */
+
+struct _fat_ptr
+{
+  unsigned char *curr;
+  unsigned char *base;
+  unsigned char *last_plus_one;
+};
+int Cyc_string_ungetc (int ignore, struct _fat_ptr *sptr);
+int
+Cyc_string_ungetc (int ignore, struct _fat_ptr *sptr)
+{
+  struct _fat_ptr *_T0;
+  struct _fat_ptr *_T1;
+  struct _fat_ptr _T2;
+  int _T3;
+  struct _fat_ptr _ans;
+  int _change;
+
+  {
+    _T0 = sptr;
+    _T1 = sptr;
+    _T2 = *sptr;
+    _T3 = -1;
+    _ans = _T2;
+    _change = -1;
+    _ans.curr += 4294967295U;
+    *sptr = _ans;
+    return (0);
+  }
+}
+
+/* The local aggregates . */
+/* { dg-final { scan-tree-dump-times "struct _fat_ptr _ans" 0 "optimized"} } */
+/* { dg-final { scan-tree-dump-times "struct _fat_ptr _T2" 0 "optimized"} } */
+/* { dg-final { cleanup-tree-dump "optimized" } } */
Index: gcc/testsuite/gcc.dg/tree-ssa/inline-4.c
===================================================================
--- gcc/testsuite/gcc.dg/tree-ssa/inline-4.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/tree-ssa/inline-4.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,27 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-einline2" } */
+/* { dg-add-options bind_pic_locally } */
+
+extern int rand(void);
+
+int get_data_for (int id)
+{
+  return rand();
+}
+
+int my_id;
+
+int main()
+{
+  int res = get_data_for (my_id);
+  switch (res)
+    {
+      case 0:
+	  return 666;
+      default:
+	  return -1;
+    }
+}
+
+/* { dg-final { scan-tree-dump "Inlining get_data_for into main" "einline2" } } */
+/* { dg-final { cleanup-tree-dump "einline2" } } */
Index: gcc/testsuite/gcc.dg/compound-literal-1.c
===================================================================
--- gcc/testsuite/gcc.dg/compound-literal-1.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/compound-literal-1.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+
+/* PR c/43248 */
+
+int foo(__SIZE_TYPE__ i)
+{
+  i ? : (void *){}; /* { dg-error "" } */
+}
+
Index: gcc/testsuite/gcc.dg/pr43280.c
===================================================================
--- gcc/testsuite/gcc.dg/pr43280.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/pr43280.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,30 @@
+/* { dg-do run } */
+/* { dg-require-effective-target stdint_types } */
+/* { dg-options "-O2" } */
+
+#include <stdint.h>
+
+extern void abort (void);
+
+uint64_t __attribute__((noinline))
+byteswap64(uint64_t x)
+{
+  uint32_t a = x >> 32;
+  uint32_t b = (uint32_t) x;
+  return ((uint64_t) ((((((b)) >> (8)) | (((b)) << (32 - (8)))) & 0xff00ff00L)
+		      | (((((b)) << (8)) | (((b)) >> (32 - (8)))) & 0x00ff00ffL)) << 32)
+          | (uint64_t) ((((((a)) >> (8)) | (((a)) << (32 - (8)))) & 0xff00ff00L)
+			| (((((a)) << (8)) | (((a)) >> (32 - (8)))) & 0x00ff00ffL));
+}
+
+int
+main ()
+{
+  uint64_t in = (uint64_t)0x01020304 << 32 | 0x05060708;
+  uint64_t cmp = (uint64_t)0x08070605 << 32 | 0x04030201;
+
+  if (cmp != byteswap64 (in))
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/debug/dwarf2/pr43237.c
===================================================================
--- gcc/testsuite/gcc.dg/debug/dwarf2/pr43237.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/debug/dwarf2/pr43237.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,31 @@
+/* PR debug/43237 */
+/* { dg-do compile } */
+/* { dg-options "-g -O2 -dA -fno-merge-debug-strings" } */
+
+struct S
+{
+  int *a;
+  int b;
+  int **c;
+  int d;
+};
+
+void foo (struct S *);
+void bar (struct S *);
+
+int
+baz (void)
+{
+  struct S s;
+  foo (&s);
+  {
+    int a[s.b];
+    int *c[s.d];
+    s.a = a;
+    s.c = c;
+    bar (&s);
+  }
+  return 0;
+}
+
+/* { dg-final { scan-assembler-not "LLST\[^\\r\\n\]*DW_AT_upper_bound" } } */
Index: gcc/testsuite/gcc.dg/pr42715.c
===================================================================
--- gcc/testsuite/gcc.dg/pr42715.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/pr42715.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,59 @@
+/* { dg-do compile { target fpic } } */
+/* { dg-options "-fPIC -g -O2 -w" } */
+/* var-tracking failed to clobber the reg holding v at the asm insn,
+   so v ended up bound to an intermediate PIC expression.  */
+
+struct A { unsigned a1; char a2[15]; };
+struct B { long b1; unsigned char b2; long b3; };
+struct C { void *c1; unsigned c2; unsigned c3; };
+
+static struct A v1;
+struct A *const v2 = &v1;
+
+static inline
+int foo (void)
+{
+  int *v;
+  __asm__ __volatile__ ("" : "=r" (v));
+  return v[1];
+}
+
+static void
+bar (struct C *x)
+{
+  if (x->c2 == x->c3 && x->c1)
+    f1 (foo (), x->c1, x->c3 * sizeof (x->c1[0]));
+}
+
+void
+baz (struct B *y)
+{
+  int i;
+  const char *j;
+  char *k;
+  char x[64];
+  for (i = 0; i < sizeof (struct B); i++, y)
+    {
+      switch (y->b2)
+        {
+        case 0x20:
+          if (__builtin_strchr (j, '='))
+            continue;
+        }
+      switch (y->b2)
+        {
+        case 0x80:
+          bar (&x);
+          f2 (y->b3);
+        case 0x2e:
+        case 0x4e:
+          break;
+        default:
+          if (v2->a1)
+            f2 (y->b2);
+        }
+      k[0] = '\0';
+      if (v2->a1)
+        f2 (y->b1);
+    }
+}
Index: gcc/testsuite/gcc.dg/pr43419.c
===================================================================
--- gcc/testsuite/gcc.dg/pr43419.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/pr43419.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,19 @@
+/* { dg-do run } */
+/* { dg-options "-O1" } */
+/* { dg-options "-mieee -O1" { target alpha*-*-* sh*-*-* } } */
+#include <math.h>
+
+extern void abort (void);
+void __attribute__((noinline)) f (double x)
+{
+  double pluszero = pow (x, 0.5);
+  double minuszero = sqrt (x);
+  if (signbit (pluszero) == signbit (minuszero))
+    abort ();
+}
+
+int main(void)
+{
+  f (-0.0);
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/ipa/ipacost-2.c
===================================================================
--- gcc/testsuite/gcc.dg/ipa/ipacost-2.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/testsuite/gcc.dg/ipa/ipacost-2.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,6 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-O3 -fipa-cp -fipa-cp-clone -fdump-ipa-cp -fno-early-inlining -fdump-tree-optimized"  } */
-/* { dg-options "-O3 -fipa-cp -fipa-cp-clone -fdump-ipa-cp -fno-early-inlining -fdump-tree-optimized -fpie" { target { ! nonpic } } } */
+/* { dg-add-options bind_pic_locally } */
 
 int array[100];
 
Index: gcc/testsuite/gcc.dg/ipa/ipa-1.c
===================================================================
--- gcc/testsuite/gcc.dg/ipa/ipa-1.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/testsuite/gcc.dg/ipa/ipa-1.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,6 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-O3 -fipa-cp -fipa-cp-clone -fdump-ipa-cp -fno-early-inlining"  } */
-/* { dg-skip-if "PR 25442" { "*-*-*" } { "-fpic" "-fPIC" } { "" } } */
+/* { dg-add-options bind_pic_locally } */
 
 #include <stdio.h>
 int g (int b, int c)
Index: gcc/testsuite/gcc.dg/ipa/ipa-2.c
===================================================================
--- gcc/testsuite/gcc.dg/ipa/ipa-2.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/testsuite/gcc.dg/ipa/ipa-2.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,6 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-O3 -fipa-cp -fipa-cp-clone -fdump-ipa-cp -fno-early-inlining"  } */
-/* { dg-skip-if "PR 25442" { "*-*-*" } { "-fpic" "-fPIC" } { "" } } */
+/* { dg-add-options bind_pic_locally } */
 
 #include <stdio.h>
 int g (int b, int c)
Index: gcc/testsuite/gcc.dg/ipa/ipa-3.c
===================================================================
--- gcc/testsuite/gcc.dg/ipa/ipa-3.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/testsuite/gcc.dg/ipa/ipa-3.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,6 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-O3 -fipa-cp -fipa-cp-clone -fdump-ipa-cp -fno-early-inlining"  } */
-/* { dg-skip-if "PR 25442" { "*-*-*" } { "-fpic" "-fPIC" } { "" } } */
+/* { dg-add-options bind_pic_locally } */
 
 
 /* Double constants.  */
Index: gcc/testsuite/gcc.dg/ipa/ipa-4.c
===================================================================
--- gcc/testsuite/gcc.dg/ipa/ipa-4.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/testsuite/gcc.dg/ipa/ipa-4.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,6 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-O3 -fipa-cp -fipa-cp-clone -fdump-ipa-cp"  } */
-/* { dg-skip-if "PR 25442" { "*-*-*" } { "-fpic" "-fPIC" } { "" } } */
+/* { dg-add-options bind_pic_locally } */
 
 #include <stdio.h>
 int g (int b, int c)
Index: gcc/testsuite/gcc.dg/ipa/ipa-5.c
===================================================================
--- gcc/testsuite/gcc.dg/ipa/ipa-5.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/testsuite/gcc.dg/ipa/ipa-5.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,6 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-O3 -fipa-cp -fipa-cp-clone -fdump-ipa-cp -fno-early-inlining"  } */
-/* { dg-skip-if "PR 25442" { "*-*-*" } { "-fpic" "-fPIC" } { "" } } */
+/* { dg-add-options bind_pic_locally } */
 
 /* Float & short constants.  */
 
Index: gcc/testsuite/gcc.dg/ipa/ipa-7.c
===================================================================
--- gcc/testsuite/gcc.dg/ipa/ipa-7.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/testsuite/gcc.dg/ipa/ipa-7.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,6 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-O3 -fipa-cp -fipa-cp-clone -fdump-ipa-cp -fno-early-inlining"  } */
-/* { dg-skip-if "PR 25442" { "*-*-*" } { "-fpic" "-fPIC" } { "" } } */
+/* { dg-add-options bind_pic_locally } */
 
 #include <stdio.h>
 void send_addr (int *);
Index: gcc/testsuite/gcc.dg/pr42388.c
===================================================================
--- gcc/testsuite/gcc.dg/pr42388.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/pr42388.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,67 @@
+/* { dg-do compile { target powerpc*-*-* ia64-*-* x86_64-*-* } } */
+/* { dg-options "-O2 -fselective-scheduling -fmodulo-sched" } */
+
+enum rtx_code
+{
+  INSN, ADDR_VEC, ADDR_DIFF_VEC, CALL_INSN, CODE_LABEL, BARRIER, NOTE
+};
+typedef union rtunion_def
+{
+  int rtint;
+  char *rtstr;
+  struct rtx_def *rtx;
+  struct rtvec_def *rtvec;
+}
+rtunion;
+typedef struct rtx_def
+{
+  unsigned short code;
+  rtunion fld[1];
+}
+ *rtx;
+typedef struct rtvec_def
+{
+  unsigned num_elem;
+  rtunion elem[1];
+}
+ *rtvec;
+extern rtx emit_barrier (void);
+extern rtx emit_note (char *);
+
+static void
+copy_loop_body (rtx *map)
+{
+  int i;
+  rtx insn, copy;
+  rtx pat = copy->fld[3].rtx;
+
+  switch (insn->code)
+    {
+    case INSN:
+      if (insn->fld[7].rtx)
+	{
+	}
+      else if (pat->code == ADDR_VEC || pat->code == ADDR_DIFF_VEC)
+	{
+	  int diff_vec_p = pat->code == ADDR_DIFF_VEC;
+	  int len = pat->fld[diff_vec_p].rtvec->num_elem;
+	  for (i = 0; i < len; i++)
+	    pat->fld[diff_vec_p].rtvec->elem[i].rtx->fld[5].rtint++;
+	}
+    case CALL_INSN:
+      for (i = 0; i < 64; i++)
+	map[i] = 0;
+    case CODE_LABEL:
+    case BARRIER:
+      copy = emit_barrier ();
+    case NOTE:
+      copy = emit_note ("x");
+    }
+}
+void
+unroll_loop (int insn_count, rtx *map)
+{
+  if (insn_count > 50)
+    copy_loop_body (map);
+}
+
Index: gcc/testsuite/gcc.dg/pr42250.c
===================================================================
--- gcc/testsuite/gcc.dg/pr42250.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/pr42250.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,68 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fipa-type-escape" } */
+
+extern double log10 (double __x);
+extern double ceil (double __x);
+extern double floor (double __x);
+extern void free (void *__ptr);
+extern void *my_malloc (unsigned int);
+extern int num_rr_nodes;
+static float get_cblock_trans (int *num_inputs_to_cblock,
+			       int max_inputs_to_cblock,
+			       float trans_cblock_to_lblock_buf,
+			       float trans_sram_bit);
+static float trans_per_mux (int num_inputs, float trans_sram_bit);
+void
+count_routing_transistors (int num_switch, float R_minW_nmos,
+			   float R_minW_pmos)
+{
+  int *num_inputs_to_cblock;
+  int iswitch, i, j, iseg, max_inputs_to_cblock;
+  float input_cblock_trans;
+  const float trans_sram_bit = 6.;
+  float trans_cblock_to_lblock_buf;
+  input_cblock_trans =
+    get_cblock_trans (num_inputs_to_cblock, max_inputs_to_cblock,
+		      trans_cblock_to_lblock_buf, trans_sram_bit);
+}
+
+static float
+get_cblock_trans (int *num_inputs_to_cblock, int max_inputs_to_cblock,
+		  float trans_cblock_to_lblock_buf, float trans_sram_bit)
+{
+  float *trans_per_cblock;
+  float trans_count;
+  int i, num_inputs;
+
+  trans_per_cblock =
+    (float *) my_malloc ((max_inputs_to_cblock + 1) * sizeof (float));
+  for (i = 1; i <= max_inputs_to_cblock; i++)
+    trans_per_cblock[i] =
+      trans_per_mux (i, trans_sram_bit) + trans_cblock_to_lblock_buf;
+  for (i = 0; i < num_rr_nodes; i++)
+    {
+      num_inputs = num_inputs_to_cblock[i];
+      trans_count += trans_per_cblock[num_inputs];
+    }
+  free (trans_per_cblock);
+  return (trans_count);
+}
+
+static float
+trans_per_mux (int num_inputs, float trans_sram_bit)
+{
+  int nlevels, ilevel, current_inps;
+  float ntrans = 0;
+
+  if (num_inputs <= 1)
+    return (0);
+  nlevels = ceil (log10 (num_inputs) / log10 (2.) - 0.00001);
+  current_inps = num_inputs;
+  for (ilevel = 1; ilevel <= nlevels; ilevel++)
+    {
+      ntrans += 2 * floor (current_inps / 2.);
+      current_inps = ceil (current_inps / 2.);
+    }
+  ntrans += trans_sram_bit * nlevels;
+  return (ntrans);
+}
Index: gcc/testsuite/gcc.dg/pr43379.c
===================================================================
--- gcc/testsuite/gcc.dg/pr43379.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/pr43379.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -ftracer -w" } */
+
+void *foo(int i, int *p)
+{
+lab:
+  if (p) *p = i;
+  goto *p;
+  return &&lab;
+}
+
Index: gcc/testsuite/gcc.dg/pr43299.c
===================================================================
--- gcc/testsuite/gcc.dg/pr43299.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/pr43299.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,28 @@
+/* PR debug/43299 */
+/* { dg-do assemble } */
+/* { dg-options "-g -O2" } */
+
+extern void *emit_insn (void *);
+
+__attribute__((noinline))
+void *gen_load_locked_si (void *x, void *y)
+{
+  return x;
+}
+
+__attribute__((noinline))
+void *gen_load_locked_di (void *x, void *y)
+{
+  return x;
+}
+
+void
+emit_load_locked (int mode, void *reg, void *mem)
+{
+  void * (*fn) (void *, void *) = ((void *)0);
+  if (mode == 9)
+    fn = gen_load_locked_si;
+  else if (mode == 10)
+    fn = gen_load_locked_di;
+  emit_insn (fn (reg, mem));
+}
Index: gcc/testsuite/gcc.dg/pr43305.c
===================================================================
--- gcc/testsuite/gcc.dg/pr43305.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/pr43305.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+/* { dg-options "-Os -ffast-math" } */
+extern int ilogbl(long double);
+extern int printf(const char *format, ...);
+
+__attribute__((noinline))
+int foo(long double x)
+{
+  return ilogbl(x);
+}
+
+int main()
+{
+  printf("%d\n", foo(100));
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/vect/pr42604.c
===================================================================
--- gcc/testsuite/gcc.dg/vect/pr42604.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/vect/pr42604.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,35 @@
+/* PR debug/42604 */
+/* { dg-do compile } */
+/* { dg-options "-O3 -ftree-vectorize -g -ffast-math" } */
+
+unsigned *d;
+unsigned short e;
+int f;
+float h[3][4];
+
+void
+test (unsigned short *b)
+{
+  int a, c, i;
+  float g[3];
+  unsigned j[32] = { 10, 0x63707274 };
+  for (i = 0; i < (int) j[0]; i++)
+    {
+      j[i * 3 + 2] = d[0];
+      d[0] += (j[i * 3 + 3] + 3) & -4;
+    }
+  for (a = 0; a < e; a++)
+    {
+      g[0] = g[1] = g[2] = 0;
+      for (c = 0; c < f; c++)
+	{
+	  g[0] += h[0][c] * b[c];
+	  g[1] += h[1][c] * b[c];
+	}
+      for (c = 0; c < 3; c++)
+	b[c] = 0 > ((int) g[c] < 65535 ? ((int) g[c]) : 65535)
+	  ? 0 : ((int) g[c]) < 65535 ? (int) g[c] : 65535;
+    }
+}
+
+/* { dg-final { cleanup-tree-dump "vect" } } */
Index: gcc/testsuite/gcc.dg/vect/pr42395.c
===================================================================
--- gcc/testsuite/gcc.dg/vect/pr42395.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/vect/pr42395.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,10 @@
+/* PR debug/42395 */
+/* { dg-do compile } */
+/* { dg-options "-O3 -ftree-vectorize -g" } */
+
+void foo(int j, int *A)
+{
+  int i;
+  for (i = 0; i < j; i ++) A[i] = i;
+  for (; i < 4096; i ++) A[i] = 0;
+}
Index: gcc/testsuite/gcc.dg/vect/fast-math-pr43074.c
===================================================================
--- gcc/testsuite/gcc.dg/vect/fast-math-pr43074.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/vect/fast-math-pr43074.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+
+float
+pvslockprocess(float *fout, float *fin, int framesize)
+{
+  int i;
+  float mag=0.0f, diff;
+  for (i = 0; i < framesize; i += 2) {
+      mag += fin[i];
+      fout[i] = fin[i];
+      fout[i+1] = fin[i+1];
+  }
+  return mag;
+}
+
+/* { dg-final { cleanup-tree-dump "vect" } } */
Index: gcc/testsuite/gcc.dg/vect/pr42709.c
===================================================================
--- gcc/testsuite/gcc.dg/vect/pr42709.c	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/vect/pr42709.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,28 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target vect_int } */
+
+#include <stdarg.h>
+#include "tree-vect.h"
+
+#define N 128 
+
+int *res[N];
+
+int
+main1 (int *a, int *b, int *c, int *d, int dummy)
+{
+  int i;
+
+  for (i = 0; i < N/2; i+=4)
+    {
+      res[i] = a + 16;
+      res[i+1] = b + 16;
+      res[i+2] = c + 16;
+      res[i+3] = d + 16;
+      if (dummy == 32)
+        abort ();
+    } 
+}
+
+/* { dg-final { cleanup-tree-dump "vect" } } */
+  
Index: gcc/testsuite/ChangeLog
===================================================================
--- gcc/testsuite/ChangeLog	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/testsuite/ChangeLog	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,3 +1,733 @@
+2010-03-27  Joseph Myers  <joseph@codesourcery.com>
+
+	PR c/43381
+	* gcc.dg/parm-impl-decl-3.c: New test.
+
+2010-03-26  Volker Reichelt  <reichelt@gcc.gnu.org>
+
+	PR c++/43024
+	* g++.dg/opt/ice1.C: New.
+
+2010-03-25  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR libfortran/43517
+	* gfortran.dg/read_eof_7.f90: New test.
+
+2010-03-25  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline:
+	2010-03-22  Jason Merrill  <jason@redhat.com>
+
+	PR c++/43333
+	* g++.dg/ext/is_pod_98.C: New.
+
+	2010-03-22  Michael Matz  <matz@suse.de>
+
+	PR middle-end/43475
+	* gfortran.dg/pr43475.f90: New testcase.
+
+	2010-03-22  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/43390
+	* gfortran.fortran-torture/execute/pr43390.f90: New testcase.
+
+	2010-03-20  Dodji Seketeli  <dodji@redhat.com>
+
+	PR c++/43375
+	* g++.dg/abi/mangle42.C: New test.
+
+	2010-03-19  Andrew Pinski  <andrew_pinski@caviumnetworks.com>
+
+	PR C/43211
+	* gcc.dg/pr43211.c: New test.
+
+	2010-03-18  Martin Jambor  <mjambor@suse.cz>
+
+	PR middle-end/42450
+	* g++.dg/torture/pr42450.C: New test.
+
+	2010-03-18  Michael Matz  <matz@suse.de>
+
+	PR tree-optimization/43402
+	* gcc.dg/pr43402.c: New testcase.
+
+	2010-03-17  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/42427
+	* gcc.dg/pr42427.c: New test.
+
+	2010-03-16  Richard Guenther  <rguenther@suse.de>
+
+	PR middle-end/43379
+	* gcc.dg/pr43379.c: New testcase.
+
+	2010-03-15  Michael Matz  <matz@suse.de>
+
+	PR middle-end/43300
+	* gcc.dg/pr43300.c: New testcase.
+
+	2010-03-15  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/43367
+	* gcc.c-torture/compile/pr43367.c: New testcase.
+
+2010-03-25  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/43385
+	* gcc.c-torture/execute/pr43385.c: New test.
+
+2010-03-22  Richard Guenther  <rguenther@suse.de>
+
+	Backport from mainline:
+	2010-03-19  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/43415
+	* gcc.c-torture/compile/pr43415.c: New testcase.
+
+2010-03-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline:
+	2010-03-20  Richard Guenther  <rguenther@suse.de>
+
+	PR rtl-optimization/43438
+	* gcc.c-torture/execute/pr43438.c: New testcase.
+
+	2010-03-19  Michael Matz  <matz@suse.de>
+
+	PR c++/43116
+	* g++.dg/other/pr43116.C: New testcase.
+
+	PR target/43305
+	* gcc.dg/pr43305.c: New testcase.
+
+	2010-03-18  Michael Matz  <matz@suse.de>
+
+	PR middle-end/43419
+	* gcc.dg/pr43419.c: New testcase.
+
+2010-03-21  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
+
+	* gcc.target/powerpc/ppc-sdata-1.c: Require nonpic.
+	* gcc.target/powerpc/ppc-sdata-2.c: Likewise.
+
+2010-03-18  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline:
+	2010-03-18  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR rtl-optimization/43360
+	* gcc.dg/torture/pr43360.c: New.
+
+2010-03-17  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR libfortran/43265
+	* gfortran.dg/read_empty_file.f: New test.
+	* gfortran.dg/read_eof_all.f90: New test.
+	* gfortran.dg/namelist_27.f90: Eliminate infinite loop posibility.
+	* gfortran.dg/namelist_28.f90: Eliminate infinite loop posibility.
+
+2010-03-13  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline:
+	2010-03-11  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/43257
+	* g++.dg/torture/pr43257.C: New test.
+
+	2010-03-11  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/43255
+	* gcc.c-torture/compile/pr43255.c: New testcase.
+
+	2010-03-11  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>
+
+	* gcc.dg/pr43280.c: New testcase.
+
+	2010-03-10  Jan Hubicka   <jh@suse.cz>
+
+	* gcc.c-torture/compile/pr43288.c: New test.
+
+	2010-03-10  Andrey Belevantsev  <abel@ispras.ru>
+
+	PR middle-end/42859
+	* g++.dg/eh/pr42859.C: New test.
+
+	2010-03-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/43299
+	* gcc.dg/pr43299.c: New test.
+
+	2010-03-08  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/43269
+	* gcc.c-torture/execute/pr43269.c: New testcase.
+
+	2010-03-04  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/43164
+	PR tree-optimization/43191
+	* gcc.c-torture/compile/pr43164.c: New test.
+	* gcc.c-torture/compile/pr43191.c: Likewise.
+
+	2010-03-04  Changpeng Fang  <changpeng.fang@amd.com>
+
+	PR middle-end/43209
+	* gcc.dg/tree-ssa/ivopts-4.c: New.
+
+	2010-03-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/43229
+	* gfortran.dg/pr43229.f90: New test.
+
+	PR debug/43237
+	* gcc.dg/debug/dwarf2/pr43237.c: New test.
+
+	2010-03-02  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/43180
+	* gfortran.dg/internal_pack_10.f90: New test.
+
+	2010-02-26  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/43188
+	* gcc.c-torture/compile/pr43188.c: New testcase.
+
+	2010-02-25  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/43166
+	* gfortran.dg/debug/pr43166.f: New test.
+
+	PR debug/43165
+	* gcc.dg/torture/pr43165.c: New test.
+
+	2010-02-23  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/43107
+	* gcc.target/i386/pr43107.c: New test.
+
+2010-03-12  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
+
+	* gcc.target/arm/sibcall-1.c: Allow PLT to appear with pic code.
+
+2010-03-12  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR libfortran/43320
+	PR libfortran/43265
+	* gfortran.dg/read_eof_6.f: New test
+	* gfortran.dg/read_x_eof.f90: New test.
+	* gfortran.dg/read_x_past.f: Update test.
+
+2010-03-11  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/43228
+	* gfortran.dg/namelist_61.f90: New test.
+	
+2010-03-11  Janis Johnson  <janis187@us.ibm.com>
+
+	* lib/target-supports-dg.exp (check-flags): Provide defaults for
+	include-opts and exclude-opts; skip checking the flags if arguments
+	are the same as the defaults.
+	(dg-xfail-if): Verify the number of arguments, supply defaults
+	for unspecified optional arguments.
+	(dg-skip-if, dg-xfail-run-if): Verify the number of arguments.
+
+2010-03-11  Tobias Burnus  <burnus@net-b.de
+
+	PR fortran/43303
+	* gfortran.dg/c_assoc_3.f90: New test.
+
+2010-03-10  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
+
+	* g++.old-deja/g++.pt/asm1.C: Don't detect pic via looking for the
+	-fpic/-fPIC flags.
+	* g++.old-deja/g++.pt/asm2.C: Likewise.
+	* gcc.c-torture/compile/20000804-1.c: Likewise.
+	* gcc.target/i386/clobbers.c: Likewise.
+
+2010-03-08  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline:
+	2010-03-04  Andrew Pinski  <andrew_pinski@caviumnetworks.com>
+
+	PR c/43248
+	* gcc.dg/compound-literal-1.c: New testcase.
+
+2010-03-05  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
+
+	Backport:
+	2009-10-15  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
+	* lib/target-supports.exp (add_options_for_bind_pic_locally): New.
+	
+	2009-10-16  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
+	* g++.dg/ipa/iinline-1.C: Use dg-add-options bind_pic_locally.
+	* g++.dg/other/first-global.C: Likewise.
+	* g++.dg/parse/attr-externally-visible-1.C: Likewise.
+	* g++.dg/tree-ssa/nothrow-1.C: Likewise.
+	* gcc.dg/inline-33.c: Likewise.
+	* gcc.dg/ipa/ipa-1.c: Likewise.
+	* gcc.dg/ipa/ipa-2.c: Likewise.
+	* gcc.dg/ipa/ipa-3.c: Likewise.
+	* gcc.dg/ipa/ipa-4.c: Likewise.
+	* gcc.dg/ipa/ipa-5.c: Likewise.
+	* gcc.dg/ipa/ipa-7.c: Likewise.
+	* gcc.dg/ipa/ipacost-2.c: Likewise.
+	
+	2010-02-09  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
+	* gcc.dg/tree-ssa/inline-4.c: Bind pic locally.
+
+2010-03-05  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* lib/gnat.exp (gnat_init): Remove GNAT_UNDER_TEST_ORIG.
+	(gnat_target_compile): Likewise.
+	Reinitialize GNAT_UNDER_TEST if target changes.
+	Set ADA_INCLUDE_PATH, ADA_OBJECTS_PATH in environment.
+	(local_find_gnatmake): Pass full --GCC to gnatlink.
+	Remove --LINK.
+
+2010-03-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline:
+	2010-03-01  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/43220
+	* gcc.c-torture/execute/pr43220.c: New testcase.
+
+2010-02-27  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/thin_pointer.ad[sb]: Rename into...
+	* gnat.dg/thin_pointer1.ad[sb]: ...this.
+	* gnat.dg/thin_pointer2.adb: New test.
+	* gnat.dg/thin_pointer2_pkg.ad[sb]: New helper.
+
+2010-02-24  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	* gcc.target/arm/thumb2-cbnz.c: New test.
+
+2010-02-23  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline:
+	2010-02-22  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/42749
+	* gcc.c-torture/compile/pr42749.c: New testcase.
+
+	2010-02-21  Dodji Seketeli  <dodji@redhat.com>
+
+	PR c++/42824
+	* g++.dg/template/memclass4.C: New test.
+
+	2010-02-20  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/43111
+	* gfortran.dg/internal_pack_8.f90: New test.
+
+	2010-02-18  Jason Merrill  <jason@redhat.com>
+
+	PR c++/43109
+	* g++.dg/parse/namespace12.C: New.
+
+	2010-02-18  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/43066
+	* gcc.c-torture/compile/pr43066.c: New test.
+
+	2010-02-17  Jason Merrill  <jason@redhat.com>
+
+	PR c++/43069
+	* g++.dg/parse/namespace11.C: New.
+
+	PR c++/43093
+	* g++.dg/ext/attrib37.C: New.
+
+	PR c++/43079
+	* g++.dg/template/ptrmem20.C: New.
+
+	2010-02-16  Jason Merrill  <jason@redhat.com>
+
+	PR c++/43031
+	* g++.dg/ext/attrib36.C: New.
+
+	2010-02-15  Richard Guenther  <rguenther@suse.de>
+
+	PR middle-end/43068
+	* g++.dg/torture/pr43068.C: New testcase.
+
+	2010-02-11  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/42998
+	* gcc.c-torture/compile/pr42998.c: New testcase.
+
+	2010-02-10  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/43017
+	* gcc.dg/torture/pr43017.c: New testcase.
+
+	2010-02-10  Richard Guenther  <rguenther@suse.de>
+
+	PR c/43007
+	* gcc.c-torture/execute/20100209-1.c: New testcase.
+	* gcc.dg/fold-div-3.c: Likewise.
+
+	2010-02-09  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR fortran/42999
+	* gfortran.dg/array_constructor_35.f90: New test.
+
+	2010-02-09  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/43008
+	* gcc.c-torture/execute/pr43008.c: New testcase.
+
+	2010-02-09  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/43000
+	* gcc.dg/torture/pr43000.c: New testcase.
+	* gcc.dg/torture/pr43002.c: Likewise.
+
+	2010-02-06  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR libfortran/42742
+	* gfortran.dg/fmt_cache_2.f: New test.
+
+	2010-02-03  Jason Merrill  <jason@redhat.com>
+
+	PR c++/42870
+	* g++.dg/ext/dllexport3.C: New.
+
+2010-02-18  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	PR target/40887
+	Backport from trunk.
+	2009-12-24  Julian Brown  <julian@codesourcery.com>
+		    Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	* gcc.target/arm/pr40887.c: New test.
+
+2010-02-16  Ira Rosen <irar@il.ibm.com>
+
+	PR tree-optimization/43074
+	* gcc.dg/vect/fast-math-pr43074.c: New test.
+
+2010-02-16  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/41869
+	* gfortran.dg/module_write_1.f90: New test.
+
+2010-02-13  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/42871
+	* g++.dg/torture/pr42871.C: New testcase.
+
+2010-02-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/43033
+	* g++.dg/other/default3.C: Xfail g4 test.
+
+2010-02-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/43010
+	* g++.dg/debug/pr43010.C: New test.
+
+2010-02-09  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
+
+	* gcc.dg/tree-ssa/inline-4.c: Bind pic locally.
+
+2010-02-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/42890
+	* g++.dg/torture/pr42890.C: New test.
+
+2010-02-08  Richard Guenther  <rguenther@suse.de>
+
+	Backport from mainline:
+	2010-01-05  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/42462
+	* gcc.dg/tree-ssa/inline-4.c: New testcase.
+	* gcc.dg/Wunreachable-2.c: Remove.
+
+2010-02-08  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* gcc.dg/ipa/pr42706.c: Removed.
+
+2010-02-06  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline:
+	2010-02-05  Dodji Seketeli  <dodji@redhat.com>
+
+	PR c++/42915
+	* g++.dg/other/crash-9.C: New test.
+
+	2010-02-03  Jason Merrill  <jason@redhat.com>
+
+	PR c++/40138
+	* g++.dg/ext/builtin11.C: New.
+
+	2010-02-03  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/42944
+	* gcc.dg/errno-1.c: New testcase.
+
+	2010-02-03  Richard Guenther  <rguenther@suse.de>
+
+	PR middle-end/42927
+	* gcc.c-torture/compile/pr42927.c: New testcase.
+
+	2010-01-29  Dodji Seketeli  <dodji@redhat.com>
+
+	PR c++/42758
+	PR c++/42634
+	PR c++/42336
+	PR c++/42797
+	PR c++/42880
+	* g++.dg/other/crash-5.C: New test.
+	* g++.dg/other/crash-7.C: New test.
+	* g++.dg/other/crash-8.C: New test.
+
+	2010-01-28  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/42891
+	* gcc.target/i386/pr42891.c: New test.
+
+	2010-01-28  Richard Guenther  <rguenther@suse.de>
+
+	PR middle-end/42883
+	* g++.dg/torture/pr42883.C: New testcase.
+
+	2010-01-28  Michael Matz  <matz@suse.de>
+
+	* gcc.target/i386/pr42881.c: New test.
+
+	2010-01-28  Dodji Seketeli  <dodji@redhat.com>
+
+	PR c++/42713
+	PR c++/42820
+	* g++.dg/template/typedef27.C: New test case.
+	* g++.dg/template/typedef28.C: New test case.
+
+	2010-01-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/42874
+	* gcc.dg/vla-22.c: New test.
+
+	2010-01-26  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/42250
+	* gcc.dg/pr42250.c: New testcase.
+
+	2010-01-25  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/42858
+	* gfortran.dg/generic_21.f90: New test.
+
+	2010-01-21  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/42585
+	* gcc.dg/tree-ssa/pr42585.c: New test.
+
+	2010-01-20  Alexandre Oliva  <aoliva@redhat.com>
+
+	PR debug/42715
+	* gcc.dg/pr42715.c: New.
+
+	2010-01-20  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/42717
+	* gcc.c-torture/compile/pr42717.c: New testcase.
+
+	2010-01-19  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/42783
+	* gfortran.dg/bounds_check_15.f90 : New test.
+
+	2010-01-18  Dodji Seketeli  <dodji@redhat.com>
+
+	PR c++/42766
+	* g++.dg/conversion/op6.C: New test.
+
+	2010-01-18  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/42781
+	* gfortran.fortran-torture/compile/pr42781.f90: New testcase.
+
+	2010-01-17  Richard Guenther  <rguenther@suse.de>
+
+	PR middle-end/42248
+	* gcc.c-torture/execute/pr42248.c: New testcase.
+
+	2010-01-17  Janus Weil  <janus@gcc.gnu.org>
+
+	PR fortran/42677
+	* gfortran.dg/interface_assignment_5.f90: New test.
+
+	2010-01-15  Richard Guenther  <rguenther@suse.de>
+
+	PR middle-end/42739
+	* g++.dg/torture/pr42739.C: New testcase.
+
+	2010-01-14 Jerry DeLisle <jvdelisle@gcc.gnu.org>
+
+	PR fortran/42684
+	* gfortran.dg/interface_31.f90: New test.
+
+	2010-01-14  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/42706
+	* gcc.dg/ipa/pr42706.c: New testcase.
+
+	2010-01-14  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/42714
+	* g++.dg/torture/pr42714.C: New test.
+
+	2010-01-14  Alexander Monakov  <amonakov@ispras.ru>
+
+	PR rtl-optimization/42388
+	* gcc.dg/pr42388.c: New.
+
+	2010-01-14  Alexander Monakov <amonakov@ispras.ru>
+
+	PR rtl-optimization/42294
+	* gfortran.dg/pr42294.f: New.
+
+	2010-01-14  Ira Rosen  <irar@il.ibm.com>
+
+	PR tree-optimization/42709
+	* gcc.dg/vect/pr42709.c: New test.
+
+	2010-01-13  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/42730
+	* gcc.c-torture/compile/pr42730.c: New testcase.
+
+	2010-01-13  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/42704
+	* g++.dg/torture/pr42704.C: New test.
+
+	2010-01-13  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/42703
+	* gcc.c-torture/compile/pr42703.c: New test.
+
+	2010-01-13  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/42705
+	* gcc.c-torture/compile/pr42705.c: New testcase.
+
+	2010-01-13  Richard Guenther  <rguenther@suse.de>
+
+	PR middle-end/42716
+	* gcc.c-torture/compile/pr42716.c: New testcase.
+
+	2010-01-12  Joseph Myers  <joseph@codesourcery.com>
+
+	PR c/42708
+	* gcc.c-torture/compile/pr42708-1.c: New test.
+
+	2010-01-09  Alexandre Oliva  <aoliva@redhat.com>
+
+	PR middle-end/42363
+	* gcc.dg/torture/pr42363.c: New.
+
+	2010-01-09  Alexandre Oliva  <aoliva@redhat.com>
+
+	PR debug/42604
+	PR debug/42395
+	* gcc.dg/vect/pr42604.c: New.
+	* gcc.dg/vect/pr42395.c: New.
+
+	2010-01-09  Richard Guenther  <rguenther@suse.de>
+
+	PR middle-end/42512
+	* gcc.c-torture/execute/pr42512.c: New testcase.
+
+2010-02-06  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/42309
+	* gfortran.dg/subref_array_pointer_4.f90 : New test.
+
+2010-02-04  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR libfortran/42901
+	* gfortran.dg/namelist_60.f90: New test.
+	* gfortran.dg/namelist_59.f90: New test.
+
+2010-02-04  Richard Guenther  <rguenther@suse.de>
+
+	PR rtl-optimization/42952
+	* gcc.dg/torture/pr42952.c: New testcase.
+
+2010-02-02  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/42650
+	* gfortran.dg/func_result_5.f90: New test.
+
+2010-02-01  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline:
+	2009-12-17  Uros Bizjak  <ubizjak@gmail.com>
+
+	* objc/execute/forward-1.x: XFAIL for -fgnu-runtime on
+	x86_64-*-darwin*, powerpc*-*-darwin* and alpha*-*-linux* targets.
+
+2010-01-31  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR middle-end/42898
+	* gcc.dg/torture/pr42898-2.c: New test.
+
+2010-01-31  Richard Guenther  <rguenther@suse.de>
+
+	PR middle-end/42898
+	* gcc.dg/torture/pr42898.c: New testcase.
+
+2010-01-31  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/38324
+	* gfortran.dg/alloc_comp_basics_1.f90: Remove option -O2.
+	* gfortran.dg/alloc_comp_bounds_1.f90: New test.
+
+2010-01-30  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/41044
+	* gfortran.dg/parameter_array_ref_2.f90 : New test.
+
+	PR fortran/41167
+	* gfortran.dg/char_array_arg_1.f90 : New test.
+
+2010-01-27  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/42736
+	* gfortran.dg/dependency_25.f90 : New test.
+
+2010-01-26  Jakub Jelinek  <jakub@redhat.com>
+
+	* ada/acats/run_all.sh: Make sure norun.lst is sorted using the
+	current collation.
+
+	Backport from mainline:
+	2009-12-17  Arnaud Charlet  <charlet@adacore.com>
+
+	* ada/acats/run_all.sh: Strip comments from norun.lst.
+
+2010-01-25  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	Backport from mainline.
+	2010-01-19  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	PR target/38697.
+	* gcc.target/arm/neon/vget_lowf32.c: Regenerate.
+	* gcc.target/arm/neon/vget_lowp16.c: Likewise.
+	* gcc.target/arm/neon/vget_lowp8.c:  Likewise.
+	* gcc.target/arm/neon/vget_lows16.c: Likewise.
+	* gcc.target/arm/neon/vget_lows32.c: Likewise.
+	* gcc.target/arm/neon/vget_lows64.c: Likewise.
+	* gcc.target/arm/neon/vget_lows8.c: Likewise.
+	* gcc.target/arm/neon/vget_lowu16.c: Likewise.
+	* gcc.target/arm/neon/vget_lowu32.c: Likewise.
+	* gcc.target/arm/neon/vget_lowu64.c: Likewise.
+	* gcc.target/arm/neon/vget_lowu8.c: Likewise.
+
 2010-01-21  Release Manager
 
 	* GCC 4.4.3 released.
Index: gcc/testsuite/g++.old-deja/g++.pt/asm1.C
===================================================================
--- gcc/testsuite/g++.old-deja/g++.pt/asm1.C	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/testsuite/g++.old-deja/g++.pt/asm1.C	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,6 +1,6 @@
 // { dg-do assemble { target i?86-*-linux* x86_64-*-linux* } }
-// We'd use ebx with -fpic/-fPIC, so skip.
-// { dg-skip-if "" { ilp32 } { "-fpic" "-fPIC" } { "" } }
+// We'd use ebx with 32-bit pic code, so skip.
+// { dg-skip-if "" { ilp32 && { ! nonpic } } { "*" } { "" } }
 // Origin: "Weidmann, Nicholas" <nicholas.weidmann@swx.ch>
 
 template<int i> int foo(int v)
Index: gcc/testsuite/g++.old-deja/g++.pt/asm2.C
===================================================================
--- gcc/testsuite/g++.old-deja/g++.pt/asm2.C	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/testsuite/g++.old-deja/g++.pt/asm2.C	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,7 +1,7 @@
 // { dg-do assemble { target i?86-*-linux* x86_64-*-linux* } }
 // { dg-require-effective-target ilp32 }
-// We'd use ebx with -fpic/-fPIC, so skip.
-// { dg-skip-if "" { *-*-* } { "-fpic" "-fPIC" } { "" } }
+// We'd use ebx with 32-bit pic code, so require nonpic.
+// { dg-require-effective-target nonpic }
 // Origin: "Weidmann, Nicholas" <nicholas.weidmann@swx.ch>
 
 typedef void (function_ptr)(int);
Index: gcc/testsuite/gfortran.fortran-torture/execute/pr43390.f90
===================================================================
--- gcc/testsuite/gfortran.fortran-torture/execute/pr43390.f90	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gfortran.fortran-torture/execute/pr43390.f90	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,9 @@
+   logical :: l1(4)
+   logical :: l2(4)
+   l1 = (/.TRUE.,.FALSE.,.TRUE.,.FALSE./)
+   l2 = (/.FALSE.,.TRUE.,.FALSE.,.TRUE./)
+   if (dot_product (l1, l2)) call abort ()
+   l2 = .TRUE.
+   if (.not.dot_product (l1, l2)) call abort ()
+end
+
Index: gcc/testsuite/gfortran.fortran-torture/compile/pr42781.f90
===================================================================
--- gcc/testsuite/gfortran.fortran-torture/compile/pr42781.f90	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gfortran.fortran-torture/compile/pr42781.f90	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,59 @@
+! ICE with gfortran 4.5 at -O1:
+!gfcbug98.f90: In function ‘convert_cof’:
+!gfcbug98.f90:36:0: internal compiler error: in pt_solutions_same_restrict_base,
+!at tree-ssa-structalias.c:5072
+module foo
+  implicit none
+  type t_time
+     integer :: secs = 0
+  end type t_time
+contains
+  elemental function time_cyyyymmddhh (cyyyymmddhh) result (time)
+    type (t_time)                :: time
+    character(len=10),intent(in) :: cyyyymmddhh
+  end function time_cyyyymmddhh
+
+  function nf90_open(path, mode, ncid)
+    character(len = *), intent(in) :: path
+    integer, intent(in)  :: mode
+    integer, intent(out) :: ncid
+    integer              :: nf90_open
+  end function nf90_open
+end module foo
+!==============================================================================
+module gfcbug98
+  use foo
+  implicit none
+
+  type t_fileinfo
+     character(len=10) :: atime = ' '
+  end type t_fileinfo
+
+  type t_body
+     real         :: bg(10)
+  end type t_body
+contains
+  subroutine convert_cof (ifile)
+    character(len=*) ,intent(in) :: ifile
+
+    character(len=5)         :: version
+    type(t_fileinfo)         :: gattr
+    type(t_time)             :: atime
+    type(t_body),allocatable :: tmp_dat(:)
+    real        ,allocatable :: BDA(:, :, :)
+
+    call open_input
+    call convert_data
+  contains
+    subroutine open_input
+      integer             :: i,j
+      version = ''
+      j = nf90_open(ifile, 1, i)
+    end subroutine open_input
+    !--------------------------------------------------------------------------
+    subroutine convert_data
+      BDA(1,:,1) = tmp_dat(1)% bg(:)
+      atime = time_cyyyymmddhh (gattr% atime)
+    end subroutine convert_data
+  end subroutine convert_cof
+end module gfcbug98
Index: gcc/testsuite/g++.dg/other/pr43116.C
===================================================================
--- gcc/testsuite/g++.dg/other/pr43116.C	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/other/pr43116.C	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+extern "C" int rpl_open (const char *filename, int flags, ...) __attribute__
+((__nonnull__ (1)));
+
+namespace gnulib
+{
+    int (*const open) (const char *filename, int flags, ...) __attribute__
+	((__nonnull__ (1))) = rpl_open;
+}
Index: gcc/testsuite/g++.dg/other/first-global.C
===================================================================
--- gcc/testsuite/g++.dg/other/first-global.C	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/testsuite/g++.dg/other/first-global.C	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-fpie" { target { ! nonpic } } } */
+/* { dg-add-options bind_pic_locally } */
 /* { dg-final { scan-assembler "_GLOBAL__I(_|_65535_0_)foobar" } } */
 
 struct foo { foo (); };
Index: gcc/testsuite/g++.dg/other/crash-5.C
===================================================================
--- gcc/testsuite/g++.dg/other/crash-5.C	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/other/crash-5.C	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,16 @@
+// Origin: PR c++/42758
+// { dg-do compile }
+
+template<class T> struct less {};
+
+template<class T, typename U = less<T> > struct set {};
+
+struct int_less_than {};
+
+void assert_fail (const char*);
+
+int f(const set<int, int_less_than>&)
+{
+    assert_fail (__PRETTY_FUNCTION__);
+
+}
Index: gcc/testsuite/g++.dg/other/crash-9.C
===================================================================
--- gcc/testsuite/g++.dg/other/crash-9.C	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/other/crash-9.C	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,15 @@
+// Origin: PR c++/42915
+// { dg-do compile }
+
+template <typename T>
+class A
+{
+  template <typename U>
+  class B
+  {
+    B foo();
+  };
+};
+template <typename T> template <typename U>
+A<T>::B<U> A<T>::B<U>::foo() {}
+
Index: gcc/testsuite/g++.dg/other/default3.C
===================================================================
--- gcc/testsuite/g++.dg/other/default3.C	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/testsuite/g++.dg/other/default3.C	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -25,7 +25,7 @@
 template<typename> void g3(int = 0, int);    // { dg-error "default" }
 
 template<typename> void g4(int, int);
-template<typename> void g4(int = 0, int) {}  // { dg-error "default" }
+template<typename> void g4(int = 0, int) {}  // { dg-error "default" "" { xfail *-*-* } }
 
 template<typename> void g5();
 template<typename> void g5(int = 0, int);    // { dg-error "default" }
Index: gcc/testsuite/g++.dg/other/crash-7.C
===================================================================
--- gcc/testsuite/g++.dg/other/crash-7.C	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/other/crash-7.C	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,19 @@
+// Origin: PR c++/42336
+// { dg-options "-std=c++0x -O2 -g" }
+// { dg-do compile }
+
+struct X {
+      void func() {}
+};
+
+template<typename T, void (X::*P)() = &T::func>
+void b(T) {}
+
+int main() {
+      b(X()); /* line 9 */
+        X().func();
+
+          return 0;
+}
+
+
Index: gcc/testsuite/g++.dg/other/crash-8.C
===================================================================
--- gcc/testsuite/g++.dg/other/crash-8.C	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/other/crash-8.C	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,109 @@
+// Origin: PR c++/42797
+// { dg-options "-g -O2 -std=c++0x" }
+
+template<typename _Tp, _Tp __v>     struct integral_constant     {
+    static const _Tp value = __v;
+};
+
+template<typename _Tp>     _Tp declval();
+
+template<typename _Tp, typename... _Args>
+class __is_constructible_helper  {
+};
+
+template<typename _Tp, typename _Arg>
+class __is_constructible_helper<_Tp, _Arg>  {
+
+    template<typename _Tp1, typename _Arg1>
+    static decltype(static_cast<_Tp1>(declval<_Arg1>()), char())  __test(int);
+public:
+    static const bool __value = sizeof(__test<_Tp, _Arg>(0)) == 1;
+};
+
+template<typename _Tp, typename... _Args>
+struct is_constructible     : public integral_constant<bool,__is_constructible_helper<_Tp, _Args...>::__value>     { };
+
+template<bool, typename _Tp = void>
+struct enable_if  { };
+
+template<typename _Tp>
+struct enable_if<true, _Tp>     {
+    typedef _Tp type;
+};
+
+template<class _T1, class _T2>     struct pair     {
+    _T1 first;
+    _T2 second;
+
+    template<class _U2, class = typename  enable_if<is_constructible<_T2, _U2&&>::value>::type>
+    pair(const _T1& __x, _U2&& __y)  : first(__x),
+                                       second(__y) { }
+};
+
+namespace __gnu_cxx {
+template<typename _Tp>
+class new_allocator     {
+public:
+    new_allocator() throw() { }
+    new_allocator(const new_allocator&) throw() { }
+};
+}
+
+template<typename _Tp>
+class allocator: public __gnu_cxx::new_allocator<_Tp>     {
+public:
+
+    template<typename _Tp1>
+    struct rebind  {
+        typedef allocator<_Tp1> other;
+    };
+};
+
+
+template<typename _Tp, typename _Alloc>     struct _Vector_base     {
+    typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;
+
+    struct _Vector_impl       : public _Tp_alloc_type   {
+        _Vector_impl()
+        { }
+    };
+public:
+
+    _Vector_impl _M_impl;
+};
+
+template<typename _Tp, typename _Alloc = allocator<_Tp> >
+class vector : protected _Vector_base<_Tp, _Alloc> {
+    typedef _Alloc allocator_type;
+public:
+    vector()       { }
+    explicit       vector(int, const allocator_type& __a = allocator_type())
+    {
+    }
+};
+
+
+template <typename _Key, typename _Tp>
+class map {
+    typedef _Key key_type;
+    typedef _Tp mapped_type;
+    typedef pair<const _Key, _Tp> value_type;
+public:
+
+    void insert(const value_type& __x)
+    {
+    }
+
+    mapped_type&       operator[](const key_type& __k)       {
+        insert(value_type(__k, mapped_type()));
+    }
+
+};
+
+struct Foo {
+    Foo() {}      template<typename Tp>     Foo(Tp *p) {} };
+void foo() {
+    map <int, vector<Foo>> the_map;
+    the_map[1] = vector<Foo>();
+}
+
Index: gcc/testsuite/g++.dg/tree-ssa/nothrow-1.C
===================================================================
--- gcc/testsuite/g++.dg/tree-ssa/nothrow-1.C	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/testsuite/g++.dg/tree-ssa/nothrow-1.C	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,6 +1,7 @@
 /* { dg-do compile } */
 /* { dg-options "-O1 -fdump-tree-cfg" } */
-/* { dg-skip-if "" { "*-*-*" } { "-fpic" "-fPIC" } { "" } } */
+/* { dg-add-options bind_pic_locally } */
+
 double a;
 void t()
 {
Index: gcc/testsuite/g++.dg/conversion/op6.C
===================================================================
--- gcc/testsuite/g++.dg/conversion/op6.C	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/conversion/op6.C	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,18 @@
+// Origin: PR c++/42766
+// { dg-do compile }
+
+template<class T> class smart_pointer {
+public:
+    operator T* () const { }
+    operator bool () const { }
+    operator bool () { }
+};
+class Context { };
+typedef smart_pointer<Context> ContextP;
+class SvnClient  {
+    ~SvnClient();
+    ContextP svnContext;
+};
+SvnClient::~SvnClient() {
+    delete svnContext;
+}
Index: gcc/testsuite/g++.dg/debug/pr43010.C
===================================================================
--- gcc/testsuite/g++.dg/debug/pr43010.C	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/debug/pr43010.C	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,8 @@
+// PR debug/43010
+// { dg-do compile }
+// { dg-options "-g -femit-struct-debug-baseonly" }
+# 1 "foo.C"
+# 1 "bar.h" 1
+typedef struct { int i; } S __attribute__((aligned));
+typedef struct { struct { int i; } j; } T __attribute__((aligned));
+# 1 "foo.C" 2
Index: gcc/testsuite/g++.dg/ext/attrib36.C
===================================================================
--- gcc/testsuite/g++.dg/ext/attrib36.C	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/ext/attrib36.C	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,20 @@
+// PR c++/43031
+// { dg-do compile { target { { i?86-*-* x86_64-*-* } && ilp32 } } }
+
+class T;
+class L { };
+class P : public L
+{
+  typedef void (__attribute__((__stdcall__)) T::*F) (L*);
+  void f(bool aAdd);
+};
+class T
+{
+public:
+    virtual void __attribute__((__stdcall__)) A(L *listener) = 0;
+    virtual void __attribute__((__stdcall__)) R(L *listener) = 0;
+};
+void P::f(bool aAdd)
+{
+  F addRemoveEventListener = (aAdd ? &T::A : &T::R);
+}
Index: gcc/testsuite/g++.dg/ext/attrib37.C
===================================================================
--- gcc/testsuite/g++.dg/ext/attrib37.C	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/ext/attrib37.C	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,14 @@
+// PR c++/43093
+// { dg-do compile { target { { i?86-*-* x86_64-*-* } && ilp32 } } }
+
+struct S {
+  int x;
+  S(const S &s) {}
+};
+
+S __attribute__((__stdcall__)) getS();
+
+void test()
+{
+  S s = getS();
+}
Index: gcc/testsuite/g++.dg/ext/dllexport3.C
===================================================================
--- gcc/testsuite/g++.dg/ext/dllexport3.C	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/ext/dllexport3.C	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,19 @@
+// PR c++/42870
+// { dg-do compile { target i?86-*-cygwin *-*-mingw* } }
+// { dg-final { scan-assembler "-export:_ZN2SaD1Ev" } }
+
+#define ATTRIBUTE __attribute__ ((dllexport))
+class ATTRIBUTE Sa {
+ public:
+  Sa()
+    {}
+  ~Sa();
+};
+ATTRIBUTE Sa::~Sa()
+{return;}
+
+bool DllMain(void *a,void*b,int)
+{
+  Sa s;
+  return true;
+}
Index: gcc/testsuite/g++.dg/ext/builtin11.C
===================================================================
--- gcc/testsuite/g++.dg/ext/builtin11.C	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/ext/builtin11.C	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,9 @@
+// PR c++/40138
+// { dg-options "-Wall" }
+
+void foo(int i, ...)
+{
+  V v;				// { dg-error "not declared|expected" }
+  __builtin_va_start(v, i);	// { dg-error "not declared" }
+  i = __builtin_va_arg(v, int);
+}
Index: gcc/testsuite/g++.dg/ext/is_pod_98.C
===================================================================
--- gcc/testsuite/g++.dg/ext/is_pod_98.C	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/ext/is_pod_98.C	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,16 @@
+// PR c++/43333
+// { dg-options "-std=c++98" }
+// { dg-do run }
+
+struct strPOD
+{
+  const char *const foo;
+  const char *const bar;
+};
+extern "C" void abort (void);
+int main ()
+{
+  if (!__is_pod (strPOD))
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/g++.dg/opt/ice1.C
===================================================================
--- gcc/testsuite/g++.dg/opt/ice1.C	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/opt/ice1.C	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,41 @@
+// PR c++/43024
+// { dg-options "-O2" }
+
+void foo();
+
+template<int> struct X
+{
+  enum { e };
+  typedef int Y;
+};
+
+template<int N = 0> struct A
+{
+  ~A() { foo(); }
+  A() { a<0>(0); }
+  template<int> void a(typename X<!X<N>::e>::Y);
+  struct B b();
+};
+
+struct B
+{
+  A<> b0, b1, b2, b3;
+  B operator+ (const B&);
+};
+
+struct C
+{
+  A<> c0, c1, c2, c3, c4, c5, c6, c7, c8;
+};
+
+inline void bar(int i)
+{
+  A<> a0, a1;
+  if (i) a0.b() + a0.b() + a0.b() + a0.b();
+}
+
+void baz()
+{
+  C c;
+  bar(0);
+}
Index: gcc/testsuite/g++.dg/parse/attr-externally-visible-1.C
===================================================================
--- gcc/testsuite/g++.dg/parse/attr-externally-visible-1.C	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/testsuite/g++.dg/parse/attr-externally-visible-1.C	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,6 +1,6 @@
 // { dg-do compile }
 // { dg-options "-O3 -fwhole-program" }
-// { dg-options "-O3 -fwhole-program -fpie" { target { ! nonpic } } }
+// { dg-add-options bind_pic_locally }
 // { dg-final { scan-assembler "foo1" } }
 // { dg-final { scan-assembler "foo2" } }
 // { dg-final { scan-assembler "foo3" } }
Index: gcc/testsuite/g++.dg/parse/namespace11.C
===================================================================
--- gcc/testsuite/g++.dg/parse/namespace11.C	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/parse/namespace11.C	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,7 @@
+// PR c++/43069
+
+namespace std {
+  template < typename >
+  void swap ();
+}
+template std::swap		// { dg-error "" }
Index: gcc/testsuite/g++.dg/parse/namespace12.C
===================================================================
--- gcc/testsuite/g++.dg/parse/namespace12.C	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/parse/namespace12.C	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,7 @@
+// PR c++/43109
+
+namespace std {
+ namespace {
+   struct S {};
+ }
+}
Index: gcc/testsuite/g++.dg/abi/mangle42.C
===================================================================
--- gcc/testsuite/g++.dg/abi/mangle42.C	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/abi/mangle42.C	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,14 @@
+// Origin: PR c++/43375
+// { dg-do compile { target i?86-*-* x86_64-*-* } }
+// { dg-options "-msse2 -std=gnu++0x" }
+
+typedef float __v4sf __attribute__ ((__vector_size__ (16)));
+typedef int __v4si __attribute__ ((__vector_size__ (16)));
+__v4sf my_asin(__v4sf x)
+{
+  static const __v4si g_Mask{0x7fffffff,
+			     0x00000000,
+			     0x7fffffff,
+			     0x7fffffff };
+  return __builtin_ia32_andnps ((__v4sf) g_Mask, x);
+}
Index: gcc/testsuite/g++.dg/eh/pr42859.C
===================================================================
--- gcc/testsuite/g++.dg/eh/pr42859.C	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/eh/pr42859.C	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,23 @@
+// { dg-do compile }
+
+void start (void);
+void
+ptw32_terminate (void)
+{
+  try
+  {
+    try
+    {
+      start ();
+    }
+    catch (int)
+    {
+    }
+    catch (int)
+    {
+    }
+  }
+  catch (int)
+  {
+  }
+}
Index: gcc/testsuite/g++.dg/torture/pr42704.C
===================================================================
--- gcc/testsuite/g++.dg/torture/pr42704.C	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/torture/pr42704.C	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,44 @@
+/* { dg-do compile } */
+
+typedef int PRInt32;
+class nsTreeRows {
+    class Subtree { };
+    enum { kMaxDepth = 32 };
+    struct Link {
+        Subtree* mParent;
+        PRInt32 mChildIndex;
+        Link&         operator=(const Link& aLink) {
+            mParent = aLink.mParent;
+            mChildIndex = aLink.mChildIndex;
+        }
+    };
+    class iterator {
+        PRInt32 mTop;
+        PRInt32 mRowIndex;
+        Link mLink[kMaxDepth];
+    public:
+        iterator() : mTop(-1), mRowIndex(-1) { }
+        iterator& operator=(const iterator& aIterator);
+    };
+    Subtree*     EnsureSubtreeFor(Subtree* aParent, PRInt32 aChildIndex);
+    Subtree*     GetSubtreeFor(const Subtree* aParent,
+PRInt32 aChildIndex,                   PRInt32* aSubtreeSize = 0);
+    void     InvalidateCachedRow() {
+        mLastRow = iterator();
+    }
+    iterator mLastRow;
+};
+nsTreeRows::Subtree* nsTreeRows::EnsureSubtreeFor(Subtree* aParent,
+                     PRInt32 aChildIndex) {
+    Subtree* subtree = GetSubtreeFor(aParent, aChildIndex);
+    if (! subtree) {
+        InvalidateCachedRow();
+    }
+}
+nsTreeRows::iterator& nsTreeRows::iterator::operator=(const iterator&
+aIterator) {
+    mTop = aIterator.mTop;
+    for (PRInt32 i = mTop;
+         i >= 0;
+         --i)         mLink[i] = aIterator.mLink[i];
+}
Index: gcc/testsuite/g++.dg/torture/pr43257.C
===================================================================
--- gcc/testsuite/g++.dg/torture/pr43257.C	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/torture/pr43257.C	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,30 @@
+/* { dg-do assemble } */
+
+class A {};
+class B {};
+
+static void *func (int n)
+{
+  void *p;
+  if (p == 0) throw ::A ();
+}
+
+static void *func (int n, B const &)
+{
+  try {
+      return func (n);
+  }
+  catch (::A const &) {
+  }
+  return func (n);
+}
+
+void *f1 (int n)
+{
+  return func (n, B());
+}
+
+void *f2 (int n)
+{
+  return func (n, B());
+}
Index: gcc/testsuite/g++.dg/torture/pr42883.C
===================================================================
--- gcc/testsuite/g++.dg/torture/pr42883.C	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/torture/pr42883.C	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,63 @@
+// { dg-do compile }
+
+typedef __SIZE_TYPE__ size_t;
+namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {
+    template<typename _Tp>     class new_allocator     {
+    public:
+	typedef size_t size_type;
+	typedef _Tp* pointer;
+	typedef _Tp& reference;
+	void       deallocate(pointer __p, size_type)       {
+	    ::operator delete(__p);
+	}
+    };
+}
+namespace std __attribute__ ((__visibility__ ("default"))) {
+    template<typename _Tp>     class allocator: public __gnu_cxx::new_allocator<_Tp>     {
+    public:
+	template<typename _Tp1>         struct rebind         {
+	    typedef allocator<_Tp1> other;
+	};
+    };
+    template<typename _Tp, typename _Alloc>     struct _Vector_base     {
+	typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;
+	struct _Vector_impl       : public _Tp_alloc_type       {
+	    typename _Tp_alloc_type::pointer _M_start;
+	    typename _Tp_alloc_type::pointer _M_end_of_storage;
+	};
+	~_Vector_base()       {
+	    _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage         - this->_M_impl._M_start);
+	}
+	_Vector_impl _M_impl;
+	void       _M_deallocate(typename _Tp_alloc_type::pointer __p, size_t __n)       {
+	    if (__p)    _M_impl.deallocate(__p, __n);
+	}
+    };
+    template<typename _Tp, typename _Alloc = std::allocator<_Tp> >     class vector : protected _Vector_base<_Tp, _Alloc>     {
+	typedef _Vector_base<_Tp, _Alloc> _Base;
+	typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
+    public:
+	typedef typename _Tp_alloc_type::reference reference;
+	typedef size_t size_type;
+	size_type       size() const       {
+	}
+	reference       operator[](size_type __n)       {
+	}
+    };
+};
+class vtkConvexPointSet  {
+public:
+    static vtkConvexPointSet *New();
+};
+void MakeInternalMesh() {
+    std::vector< int > tempFaces[2];
+    std::vector< int > firstFace;
+    int i, j, k;
+    for(i = 0; i < 1000; i++)     {
+	for(int pointCount = 0; pointCount < 1000; pointCount++) 	{
+	    for(j = 0; j < (int)tempFaces[0].size(); k++)
+	      if(tempFaces[0][j] == tempFaces[1][k]) 		break;
+	}
+	vtkConvexPointSet::New();
+    }
+}
Index: gcc/testsuite/g++.dg/torture/pr42450.C
===================================================================
--- gcc/testsuite/g++.dg/torture/pr42450.C	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/torture/pr42450.C	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,112 @@
+/* { dg-do compile } */
+
+template < typename > class basic_stringstream;
+
+struct basic_string {
+  basic_string();
+};
+
+struct ios_base {
+  virtual ~ios_base();
+};
+
+class ostream:ios_base {};
+class istream:virtual ios_base {};
+
+template < typename > struct basic_iostream:public istream, ostream {
+  ~basic_iostream () {}
+};
+extern template class basic_iostream < char >;
+
+template < typename > struct basic_stringstream:public basic_iostream < char > {
+    basic_string _M_stringbuf;
+    ~basic_stringstream () {}
+};
+extern template class basic_stringstream < char >;
+
+template < typename > struct AnyMatrixBase;
+template < typename, int _Rows, int _Cols, int = _Rows, int = _Cols > class Matrix;
+template < typename > class CwiseNullaryOp;
+
+template < typename Derived > struct MatrixBase:public AnyMatrixBase < Derived > {
+  typedef CwiseNullaryOp < Derived > ConstantReturnType;
+  ConstantReturnType Constant ();
+  template < typename > Derived cast ();
+  static CwiseNullaryOp < Derived > Random (int);
+};
+
+template < typename Derived > struct AnyMatrixBase {
+  Derived derived () {}
+  Derived & derived () const {}
+};
+
+template < typename, int > struct ei_matrix_storage {};
+
+template < typename _Scalar, int, int, int _MaxRows, int _MaxCols > struct Matrix:MatrixBase < Matrix < _Scalar, _MaxRows, _MaxCols > > {
+  typedef MatrixBase < Matrix > Base;
+  ei_matrix_storage < int, _MaxCols > m_storage;
+  Matrix operator= (const Matrix other) {
+    _resize_to_match (other);
+    lazyAssign (other.derived ());
+  }
+  template < typename OtherDerived > Matrix lazyAssign (MatrixBase < OtherDerived > other) {
+    _resize_to_match (other);
+    return Base (other.derived ());
+  }
+  Matrix ();
+  template < typename OtherDerived > Matrix (const MatrixBase < OtherDerived > &other) {
+    *this = other;
+  }
+  template < typename OtherDerived > void _resize_to_match (const MatrixBase < OtherDerived > &) {
+    throw 1;
+  }
+};
+
+template < typename MatrixType > class CwiseNullaryOp:
+public MatrixBase < CwiseNullaryOp < MatrixType > > {};
+
+int f()
+{
+  bool align_cols;
+  if (align_cols) {
+    basic_stringstream<char> sstr;
+    f();
+  }
+}
+
+template < typename > struct AutoDiffScalar;
+template < typename Functor > struct AutoDiffJacobian:Functor {
+  AutoDiffJacobian (Functor);
+  typedef typename Functor::InputType InputType;
+  typedef typename Functor::ValueType ValueType;
+  typedef Matrix < int, Functor::InputsAtCompileTime, 1 > DerivativeType;
+  typedef AutoDiffScalar < DerivativeType > ActiveScalar;
+  typedef Matrix < ActiveScalar, Functor::InputsAtCompileTime, 1 > ActiveInput;
+  void operator () (InputType x, ValueType *) {
+    ActiveInput ax = x.template cast < ActiveScalar > ();
+  }
+};
+
+template < int NX, int NY > struct TestFunc1 {
+  enum  {
+    InputsAtCompileTime = NX
+  };
+  typedef Matrix < float, NX, 1 > InputType;
+  typedef Matrix < float, NY, 1 > ValueType;
+  typedef Matrix < float, NY, NX > JacobianType;
+  int inputs ();
+};
+
+template < typename Func > void forward_jacobian (Func f) {
+  typename Func::InputType x = Func::InputType::Random (f.inputs ());
+  typename Func::ValueType y;
+  typename Func::JacobianType jref = jref.Constant ();
+  AutoDiffJacobian < Func > autoj (f);
+  autoj (x, &y);
+}
+
+void test_autodiff_scalar ()
+{
+  forward_jacobian (TestFunc1 < 2, 2 > ());
+  forward_jacobian (TestFunc1 < 3, 2 > ());
+}
Index: gcc/testsuite/g++.dg/torture/pr42714.C
===================================================================
--- gcc/testsuite/g++.dg/torture/pr42714.C	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/torture/pr42714.C	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,37 @@
+struct QVectorData {
+    static QVectorData shared_null;
+};
+template <typename T> class QVector {
+    union {
+        QVectorData *d;
+    };
+public:
+    inline QVector() : d(&QVectorData::shared_null) { }
+    inline QVector(const QVector<T> &v) : d(v.d) { }
+};
+class QXmlStreamAttribute { };
+class QXmlStreamAttributes : public QVector<QXmlStreamAttribute> { };
+class __attribute__ ((visibility("default"))) Smoke {
+public:
+    union StackItem;
+    typedef StackItem* Stack;
+    typedef short Index;
+};
+class SmokeBinding { };
+namespace __smokeqt {
+    class x_QXmlStreamAttributes : public QXmlStreamAttributes {
+        SmokeBinding* _binding;
+    public:
+        static void x_11(Smoke::Stack x) {
+            x_QXmlStreamAttributes* xret = new x_QXmlStreamAttributes();
+        }
+        explicit x_QXmlStreamAttributes() : QXmlStreamAttributes() { }
+    };
+    void xcall_QXmlStreamAttributes(Smoke::Index xi, void *obj,
+                                    Smoke::Stack args)
+      {
+        switch(xi) {
+            case 11: x_QXmlStreamAttributes::x_11(args);
+        }
+      }
+}
Index: gcc/testsuite/g++.dg/torture/pr43068.C
===================================================================
--- gcc/testsuite/g++.dg/torture/pr43068.C	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/torture/pr43068.C	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-freorder-blocks -ftracer} */
+
+struct A {
+    virtual A *f();
+};
+struct B : virtual A {
+    virtual B *f();
+};
+B *B::f() { return 0; }
Index: gcc/testsuite/g++.dg/torture/pr42871.C
===================================================================
--- gcc/testsuite/g++.dg/torture/pr42871.C	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/torture/pr42871.C	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,40 @@
+struct C
+{
+  ~C ();
+  int c3;
+};
+
+C *b2;
+
+static void
+b1 (const C &x, unsigned b3, unsigned b4)
+{
+  unsigned i = 0;
+  for (; i < b3; i++)
+    if (i < b4)
+      {
+        b2[0].c3 = x.c3;
+        return;
+      }
+}
+
+int a ();
+
+void
+bar (unsigned b3, unsigned b4)
+{
+  C c[100];
+  for (int i = 0; i < 100; i++)
+    {
+      c[i].c3 = i;
+      for (int j = 0; j < b3; j++)
+        if (j < b4)
+          {
+            b2[0].c3 = 0;
+            break;
+          }
+      b1 (c[i], b3, b4);
+      a ();
+    }
+}
+
Index: gcc/testsuite/g++.dg/torture/pr42890.C
===================================================================
--- gcc/testsuite/g++.dg/torture/pr42890.C	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/torture/pr42890.C	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,25 @@
+// PR tree-optimization/42890
+// { dg-do compile }
+
+extern "C" int puts (const char *) throw ();
+
+struct S
+{
+  const char *a;
+  const char **b;
+  S (const char *s) { a = s; b = &a; }
+  ~S () { puts (a); }
+};
+
+void
+foo (int (*fn) (const char *))
+{
+  S a ("foo");
+  fn ("bar");
+}
+
+int
+main ()
+{
+  foo (puts);
+}
Index: gcc/testsuite/g++.dg/torture/pr42739.C
===================================================================
--- gcc/testsuite/g++.dg/torture/pr42739.C	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/torture/pr42739.C	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+
+struct s { ~s() { s(); } };
+
+int f()
+{
+  M:
+    s o = s();
+    f();
+    f();
+
+  L:
+    goto *(f() ? &&L : &&M);
+
+    return 0;
+}
Index: gcc/testsuite/g++.dg/ipa/iinline-1.C
===================================================================
--- gcc/testsuite/g++.dg/ipa/iinline-1.C	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/testsuite/g++.dg/ipa/iinline-1.C	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -2,7 +2,7 @@
    inlining..  */
 /* { dg-do compile } */
 /* { dg-options "-O3 -fdump-ipa-inline -fno-early-inlining"  } */
-/* { dg-options "-O3 -fdump-ipa-inline -fno-early-inlining -fpie" { target { ! nonpic } } } */
+/* { dg-add-options bind_pic_locally } */
 
 extern void non_existent (const char *, int);
 
Index: gcc/testsuite/g++.dg/template/typedef27.C
===================================================================
--- gcc/testsuite/g++.dg/template/typedef27.C	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/template/typedef27.C	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,55 @@
+// Origin: PR c++/42713
+// { dg-do compile }
+
+template<class T>
+struct S
+{
+};
+
+template<class T>
+struct S0
+{
+    typedef T TT;
+};
+
+template<class U, class V>
+struct super_struct : S0<V>
+{
+    typedef S0<V> super;
+};
+
+template<class U, class V, class W>
+struct S1 : super_struct<U, V>
+{
+    typedef super_struct<U, V> super;
+    typedef typename super::super Super2;
+    typedef typename Super2::TT Super2TT;
+    void
+    foo()
+    {
+        S<Super2TT> s1;
+    }
+};
+
+template<class U, class V>
+struct S2 : super_struct<U, V>
+{
+    typedef super_struct<U, V> super;
+    typedef typename super::super Super2;
+    typedef typename Super2::TT Super2TT;
+    void
+    foo()
+    {
+        S<Super2TT> s1;
+    }
+};
+
+int
+main()
+{
+    S1<int, S<int>, int> s1;
+    s1.foo();
+    S2<int, S<int> > s2;
+    s2.foo();
+}
+
Index: gcc/testsuite/g++.dg/template/typedef28.C
===================================================================
--- gcc/testsuite/g++.dg/template/typedef28.C	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/template/typedef28.C	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,28 @@
+// Origin: PR c++/42820
+// { dg-do compile }
+
+
+template <class T> struct vector{};
+struct Traits{struct Primitive{struct Id{};};};
+
+template <class Tree, class Polyhedron> struct Tree_vs_naive
+{
+  typedef typename Tree::Primitive Primitive;
+
+  void f() const
+  {
+	  typedef vector<typename Primitive::Id> Id_vector;
+  }
+};
+
+template <class Tree> void test_hint_strategies()
+{
+  vector<typename Tree::Primitive::Id> v;
+}
+
+int main(void)
+{
+  test_hint_strategies<Traits>();
+}
+
+
Index: gcc/testsuite/g++.dg/template/ptrmem20.C
===================================================================
--- gcc/testsuite/g++.dg/template/ptrmem20.C	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/template/ptrmem20.C	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,16 @@
+// PR c++/43079
+
+struct A {};
+
+struct B
+{
+  void foo() const;
+  void foo();
+};
+
+template<void (A::*)()> void bar();
+
+void baz()
+{
+  bar<&B::foo>();  // { dg-error "not a valid template argument|no match" }
+}
Index: gcc/testsuite/g++.dg/template/memclass4.C
===================================================================
--- gcc/testsuite/g++.dg/template/memclass4.C	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/template/memclass4.C	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,70 @@
+// Origin: PR c++/42824
+// { dg-do compile }
+
+template<int T>
+class int_ {
+};
+
+template<int T, int T2>
+class Unit {
+public:
+    Unit(const Unit<T, T2>& other) {}
+};
+
+template<int T>
+class Quan {
+public:
+    Quan(void) {}
+
+    template<int T2>
+    Quan(double value, Unit<T, T2> unit) {}
+};
+typedef Quan<0> Scalar;
+
+template<int T>
+class hlp {
+public:
+   typedef Quan<T> type;
+};
+
+class Mtrl {
+public:
+    template<int T>
+    struct AssoType {
+        typedef typename hlp<T>::type type;
+    };
+};
+
+template<class T>
+class Eval {
+public:
+    Eval(const T& object){}
+
+    template<int V>
+    void eval() {
+        eval<V> (int_<0>());
+    }
+private:
+    template<typename U> struct Wrap {};
+
+    template<int V, int V2>
+    void value(Wrap<Quan<V2> >) {}
+
+    template<int V>
+    void value(Wrap<Scalar>) {}
+
+    template<int V>
+    void eval(int_<0>) {
+        typedef typename T::template AssoType<V>::type Type;
+        value<V>(Wrap<Type>());
+    }
+};
+
+class Foo {
+public:
+    static void eval(const Mtrl& mtrl) {
+        Eval<Mtrl> h(mtrl);
+        h.eval<0> ();
+    }
+};
+
Index: gcc/testsuite/lib/gnat.exp
===================================================================
--- gcc/testsuite/lib/gnat.exp	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/testsuite/lib/gnat.exp	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,4 +1,4 @@
-# Copyright (C) 2006, 2007, 2008 Free Software Foundation, Inc.
+# Copyright (C) 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
 
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
@@ -83,7 +83,6 @@
     global gluefile wrap_flags
     global gnat_initialized
     global GNAT_UNDER_TEST
-    global GNAT_UNDER_TEST_ORIG
     global TOOL_EXECUTABLE
     global gnat_libgcc_s_path
     global gnat_target_current
@@ -98,7 +97,6 @@
 	} else {
 	    set GNAT_UNDER_TEST "[local_find_gnatmake]"
 	}
-        set GNAT_UNDER_TEST_ORIG "$GNAT_UNDER_TEST"
     }
 
     if ![info exists tmpdir] then {
@@ -129,22 +127,31 @@
     global gluefile wrap_flags
     global srcdir
     global GNAT_UNDER_TEST
-    global GNAT_UNDER_TEST_ORIG
     global TOOL_OPTIONS
     global ld_library_path
     global gnat_libgcc_s_path
     global gnat_target_current
 
-    # If we detect a change of target we need to recompute
-    # the appropriate RTS by calling get_multilibs.
+    # If we detect a change of target, we need to recompute both
+    # GNAT_UNDER_TEST and the appropriate RTS.
     if { $gnat_target_current!="[current_target_name]" } {
-       set gnat_target_current "[current_target_name]"
-       if [info exists TOOL_OPTIONS] {
-           set gnat_rts_opt "--RTS=[get_multilibs ${TOOL_OPTIONS}]/libada"
-       } else {
-           set gnat_rts_opt "--RTS=[get_multilibs]/libada"
-       }
-        set GNAT_UNDER_TEST "$GNAT_UNDER_TEST_ORIG $gnat_rts_opt"
+	set gnat_target_current "[current_target_name]"
+	if [info exists TOOL_OPTIONS] {
+	    set rtsdir "[get_multilibs ${TOOL_OPTIONS}]/libada"
+	} else {
+	    set rtsdir "[get_multilibs]/libada"
+	}
+	if [info exists TOOL_EXECUTABLE] {
+	    set GNAT_UNDER_TEST "$TOOL_EXECUTABLE"
+	} else {
+	    set GNAT_UNDER_TEST "[local_find_gnatmake]"
+	}
+        set GNAT_UNDER_TEST "$GNAT_UNDER_TEST --RTS=$rtsdir"
+
+	# gnatlink looks for system.ads itself and has no --RTS option, so
+	# specify via environment
+	setenv ADA_INCLUDE_PATH "$rtsdir/adainclude"
+	setenv ADA_OBJECTS_PATH "$rtsdir/adainclude"
     }
 
     set ld_library_path ".:${gnat_libgcc_s_path}"
@@ -263,7 +270,13 @@
         }
         if { $file != "" } {
     	set root [file dirname $file]
-    	set CC "$file --GCC=$root/xgcc --GNATBIND=$root/gnatbind --GNATLINK=$root/gnatlink -cargs -B$root -largs --LINK=$root/xgcc -B$root -margs";
+	# Need to pass full --GCC, including multilib flags, to gnatlink,
+	# otherwise gcc from PATH is invoked.
+	set dest [target_info name]
+	set gnatlink_gcc "--GCC=$root/xgcc -B$root [board_info $dest multilib_flags]"
+	# Escape blanks to get them through DejaGnu's exec machinery.
+	regsub -all {\s} "$gnatlink_gcc" {\\&} gnatlink_gcc
+    	set CC "$file --GCC=$root/xgcc --GNATBIND=$root/gnatbind --GNATLINK=$root/gnatlink -cargs -B$root -largs $gnatlink_gcc -margs";
         } else {
     	set CC [transform gnatmake]
         }
Index: gcc/testsuite/lib/target-supports-dg.exp
===================================================================
--- gcc/testsuite/lib/target-supports-dg.exp	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/testsuite/lib/target-supports-dg.exp	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -235,10 +235,27 @@
 	append compiler_flags "[board_info $dest multilib_flags] "
     }
 
-    # The target list might be an effective-target keyword, so replace
-    # the original list with "*-*-*", since we already know it matches.
-    set result [check_conditional_xfail [lreplace $args 1 1 "*-*-*"]]
+    # The next two arguments are optional.  If they were not specified,
+    # use the defaults.
+    if { [llength $args] == 2 } {
+	lappend $args [list "*"]
+    }
+    if { [llength $args] == 3 } {
+	lappend $args [list ""]
+    }
 
+    # If the option strings are the defaults, or the same as the
+    # defaults, there is no need to call check_conditional_xfail to
+    # compare them to the actual options.
+    if { [string compare [lindex $args 2] "*"] == 0
+	 && [string compare [lindex $args 3] "" ] == 0 } {
+	set result 1    
+    } else {
+	# The target list might be an effective-target keyword, so replace
+	# the original list with "*-*-*", since we already know it matches.
+	set result [check_conditional_xfail [lreplace $args 1 1 "*-*-*"]]
+    }
+
     # Any value in this variable was left over from an earlier test.
     set compiler_flags ""
 
@@ -256,14 +273,18 @@
 # group of tests or flags specified with a previous dg-options command.
 
 proc dg-skip-if { args } {
+    # Verify the number of arguments.  The last two are optional.
+    set args [lreplace $args 0 0]
+    if { [llength $args] < 2 || [llength $args] > 4 } {
+	error "dg-skip-if 2: need 2, 3, or 4 arguments"
+    }
+
     # Don't bother if we're already skipping the test.
     upvar dg-do-what dg-do-what
     if { [lindex ${dg-do-what} 1] == "N" } {
       return
     }
 
-    set args [lreplace $args 0 0]
-
     set selector [list target [lindex $args 1]]
     if { [dg-process-target $selector] == "S" } {
 	if [check-flags $args] {
@@ -276,31 +297,53 @@
 # Like check_conditional_xfail, but callable from a dg test.
 
 proc dg-xfail-if { args } {
+    # Verify the number of arguments.  The last three are optional.
+    set args [lreplace $args 0 0]
+    if { [llength $args] < 2 || [llength $args] > 4 } {
+	error "dg-xfail-if: need 2, 3, or 4 arguments"
+    }
+
     # Don't change anything if we're already skipping the test.
     upvar dg-do-what dg-do-what
     if { [lindex ${dg-do-what} 1] == "N" } {
       return
     }
 
-    set args [lreplace $args 0 0]
     set selector [list target [lindex $args 1]]
     if { [dg-process-target $selector] == "S" } {
 	global compiler_conditional_xfail_data
-	set compiler_conditional_xfail_data [lreplace $args 1 1 "*-*-*"]
+
+	# The target list might be an effective-target keyword.  Replace
+	# the original list with "*-*-*", since we already know it matches.
+	set args [lreplace $args 1 1 "*-*-*"]
+
+	# Supply default values for unspecified optional arguments.
+	if { [llength $args] == 2 } {
+	    lappend $args [list "*"]
+	}
+	if { [llength $args] == 3 } {
+	    lappend $args [list ""]
+	}
+
+	set compiler_conditional_xfail_data $args
     }
 }
 
 # Like dg-xfail-if but for the execute step.
 
 proc dg-xfail-run-if { args } {
+    # Verify the number of arguments.  The last two are optional.
+    set args [lreplace $args 0 0]
+    if { [llength $args] < 2 || [llength $args] > 4 } {
+	error "dg-xfail-run-if: need 2, 3, or 4 arguments"
+    }
+
     # Don't bother if we're already skipping the test.
     upvar dg-do-what dg-do-what
     if { [lindex ${dg-do-what} 1] == "N" } {
       return
     }
 
-    set args [lreplace $args 0 0]
-
     set selector [list target [lindex $args 1]]
     if { [dg-process-target $selector] == "S" } {
 	if [check-flags $args] {
Index: gcc/testsuite/lib/target-supports.exp
===================================================================
--- gcc/testsuite/lib/target-supports.exp	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/testsuite/lib/target-supports.exp	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -2787,6 +2787,28 @@
     return $flags
 }
 
+# Add to FLAGS the flags needed to enable functions to bind locally
+# when using pic/PIC passes in the testsuite.
+
+proc add_options_for_bind_pic_locally { flags } {
+    if {[check_no_compiler_messages using_pic2 assembly {
+        #if __PIC__ != 2
+        #error FOO
+        #endif
+    }]} {
+	return "$flags -fPIE"
+    }
+    if {[check_no_compiler_messages using_pic1 assembly {
+        #if __PIC__ != 1
+        #error FOO
+        #endif
+    }]} {
+	return "$flags -fpie"
+    }
+
+    return $flags
+}
+
 # Return 1 if the target provides a full C99 runtime.
 
 proc check_effective_target_c99_runtime { } {
Index: gcc/testsuite/gfortran.dg/interface_assignment_5.f90
===================================================================
--- gcc/testsuite/gfortran.dg/interface_assignment_5.f90	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/interface_assignment_5.f90	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,49 @@
+! { dg-do compile }
+!
+! PR 42677: [4.5 Regression] Bogus Error: Ambiguous interfaces '...' in intrinsic assignment operator
+!
+! Contributed by Harald Anlauf <anlauf@gmx.de>
+
+module mod1
+  implicit none
+  type t_m
+     integer :: i = 0
+  end type t_m
+!------------------------------------------------------------------------------
+  interface assignment (=)
+     module procedure assign_m
+  end interface
+!------------------------------------------------------------------------------
+contains
+  subroutine assign_m (y, x)
+    type(t_m) ,intent(inout) :: y
+    type(t_m) ,intent(in)    :: x
+  end subroutine assign_m
+end module mod1
+!==============================================================================
+module mod2
+  use mod1, only: t_m, assignment(=)
+  implicit none
+  type t_atm
+     integer :: k
+  end type t_atm
+!------------------------------------------------------------------------------
+  interface assignment(=)
+     module procedure assign_to_atm
+  end interface
+!------------------------------------------------------------------------------
+  interface
+     pure subroutine delete_m (x)
+       use mod1
+       type(t_m) ,intent(in) :: x
+     end subroutine delete_m
+  end interface
+!------------------------------------------------------------------------------
+contains
+  subroutine assign_to_atm (atm, r)
+    type(t_atm) ,intent(inout) :: atm
+    integer     ,intent(in)    :: r
+  end subroutine assign_to_atm
+end module mod2
+ 
+! { dg-final { cleanup-modules "mod1 mod2" } }
Index: gcc/testsuite/gfortran.dg/read_empty_file.f
===================================================================
--- gcc/testsuite/gfortran.dg/read_empty_file.f	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/read_empty_file.f	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,7 @@
+! { dg-do run }
+! PR43320 Missing EOF on read from empty file.
+      open(8,status='scratch',form='formatted')  ! Create empty file
+      read(8,'(a80)', end=123)  ! Reading from an empty file should be an EOF
+      call abort
+123   continue
+      end
Index: gcc/testsuite/gfortran.dg/alloc_comp_bounds_1.f90
===================================================================
--- gcc/testsuite/gfortran.dg/alloc_comp_bounds_1.f90	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/alloc_comp_bounds_1.f90	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,50 @@
+! { dg-do run }
+! Test the fix for PR38324, in which the bounds were not set correctly for
+! constructor assignments with allocatable components.
+!
+! Contributed by Dominique d'Humieres <dominiq@lps.ens.fr>
+!
+  integer, parameter :: ik4 = 4
+  integer, parameter :: ik8 = 8
+  integer, parameter :: from = -1, to = 2
+  call foo
+  call bar
+contains
+  subroutine foo
+    type :: struct
+      integer(4), allocatable :: ib(:)
+    end type struct
+    integer(ik4), allocatable :: ia(:)
+    type(struct) :: x
+    allocate(ia(from:to))
+    if (any(lbound(ia) .ne. -1) .or. any(ubound(ia) .ne. 2)) call abort
+    if (any(lbound(ia(:)) .ne. 1) .or. any(ubound(ia(:)) .ne. 4)) call abort
+    if (any(lbound(ia(from:to)) .ne. 1) .or. any(ubound(ia(from:to)) .ne. 4)) call abort
+    x=struct(ia)
+    if (any(lbound(x%ib) .ne. -1) .or. any(ubound(x%ib) .ne. 2)) call abort
+    x=struct(ia(:))
+    if (any(lbound(x%ib) .ne. 1) .or. any(ubound(x%ib) .ne. 4)) call abort
+    x=struct(ia(from:to))
+    if (any(lbound(x%ib) .ne. 1) .or. any(ubound(x%ib) .ne. 4)) call abort
+    deallocate(ia)
+  end subroutine
+  subroutine bar
+    type :: struct
+      integer(4), allocatable :: ib(:)
+    end type struct
+    integer(ik8), allocatable :: ia(:)
+    type(struct) :: x
+    allocate(ia(from:to))
+    if (any(lbound(ia) .ne. -1) .or. any(ubound(ia) .ne. 2)) call abort
+    if (any(lbound(ia(:)) .ne. 1) .or. any(ubound(ia(:)) .ne. 4)) call abort
+    if (any(lbound(ia(from:to)) .ne. 1) .or. any(ubound(ia(from:to)) .ne. 4)) call abort
+    x=struct(ia)
+    if (any(lbound(x%ib) .ne. -1) .or. any(ubound(x%ib) .ne. 2)) call abort
+    x=struct(ia(:))
+    if (any(lbound(x%ib) .ne. 1) .or. any(ubound(x%ib) .ne. 4)) call abort
+    x=struct(ia(from:to))
+    if (any(lbound(x%ib) .ne. 1) .or. any(ubound(x%ib) .ne. 4)) call abort
+    deallocate(ia)
+  end subroutine
+end
+
Index: gcc/testsuite/gfortran.dg/interface_31.f90
===================================================================
--- gcc/testsuite/gfortran.dg/interface_31.f90	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/interface_31.f90	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,41 @@
+! { dg-do compile }
+! PR42684 (42680) Ice with Interface.
+MODULE mod1
+  IMPLICIT NONE  
+  TYPE ta
+    INTEGER i
+  END TYPE ta
+  INTERFACE OPERATOR(+)
+    MODULE PROCEDURE add_a
+  END INTERFACE OPERATOR(+)  
+CONTAINS  
+  FUNCTION add_a(lhs, rhs) RESULT(r)
+    TYPE(ta), INTENT(IN) :: lhs
+    TYPE(ta), INTENT(IN) :: rhs
+    TYPE(ta) :: r
+    !****
+    r%i = lhs%i + rhs%i
+  END FUNCTION add_a  
+END MODULE mod1
+
+MODULE mod2
+  IMPLICIT NONE 
+  TYPE tb
+    INTEGER j
+  END TYPE tb
+  INTERFACE OPERATOR(+)
+    MODULE PROCEDURE add_b
+  END INTERFACE OPERATOR(+)  
+CONTAINS  
+  SUBROUTINE other_proc()
+    USE mod1    ! Causes ICE
+  END SUBROUTINE other_proc  
+  FUNCTION add_b(lhs, rhs) RESULT(r)
+    TYPE(tb), INTENT(IN) :: lhs
+    TYPE(tb), INTENT(IN) :: rhs
+    TYPE(tb) :: r
+    !****
+    r%j = lhs%j + rhs%j
+  END FUNCTION add_b  
+END MODULE mod2
+! { dg-final { cleanup-modules "mod1 mod2" } }
Index: gcc/testsuite/gfortran.dg/parameter_array_ref_2.f90
===================================================================
--- gcc/testsuite/gfortran.dg/parameter_array_ref_2.f90	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/parameter_array_ref_2.f90	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,39 @@
+! { dg-do compile }
+! Test the fix for the problems in PR41044
+!
+! Contributed by <ros@rzg.mpg.de>
+! Reduced by Joos VandeVondele <jv244@cam.ac.uk>
+!
+  Subroutine PS_INIT (bkgd, punit, pform, psize, rot90, bbox, clip, eps,  &
+                        caller)
+    type psfd                          ! paper size and frame defaults
+      character(3)                     :: n
+      real                             :: p(2)
+      real                             :: f(4)
+    end type psfd
+    character(4)                       :: fn, orich, pfmt
+    type(psfd), parameter              :: pfd(0:11)=(/  &
+         psfd('   ',(/   0.0,   0.0/),(/200.,120.,800.,560./)), &    ! A0_L
+         psfd('A0 ',(/ 840.9,1189.2/),(/140., 84.,560.,400./)), &    ! A0_P
+         psfd('A1 ',(/ 594.6, 840.9/),(/100., 60.,400.,280./)), &    ! A1_P
+         psfd('A2 ',(/ 420.4, 594.6/),(/ 70., 42.,280.,200./)), &    ! A2_P
+         psfd('A3 ',(/ 297.3, 420.4/),(/ 50., 30.,200.,140./)), &    ! A3_P
+         psfd('A4 ',(/ 210.2, 297.3/),(/ 35., 21.,140.,100./)), &    ! A4_P
+         psfd('A5 ',(/ 148.7, 210.2/),(/ 25., 15.,100., 70./)), &    ! A5_P
+         psfd('A6 ',(/ 105.1, 148.7/),(/ 18., 11., 70., 50./)), &    ! A6_P
+         psfd('   ',(/   0.0,   0.0/),(/ 50., 30.,200.,140./)), &    ! Letter_L
+         psfd('LET',(/ 215.9, 279.4/),(/ 35., 21.,140.,100./)), &    ! Letter_P
+         psfd('   ',(/   0.0,   0.0/),(/ 50., 30.,200.,140./)), &    ! Legal_L
+         psfd('LEG',(/ 215.9, 355.6/),(/ 35., 21.,140.,100./))/)     ! Legal_P
+    if (len_trim(pfmt) > 0) then       ! set paper format
+      idx=sum(maxloc(index(pfd%n,pfmt(1:3))))-1
+    end if
+  end subroutine PS_INIT
+
+! This, additional problem, was posted as comment #8 by Tobias Burnus <burnus@gcc.gnu.org>
+  type t
+    integer :: i
+  end type t
+  type(t), parameter :: a(1) = t(4) ! [t(4)] worked OK
+  real(a(1)%i) :: b
+end
Index: gcc/testsuite/gfortran.dg/pr43475.f90
===================================================================
--- gcc/testsuite/gfortran.dg/pr43475.f90	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/pr43475.f90	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,14 @@
+! PR middle-end/43475
+! { dg-do compile }
+! { dg-options "-O2" }
+subroutine ss(w)
+  implicit none
+  integer :: w(:)
+  integer :: b,c,d
+  b = w(8)
+  c = 5
+  d = 3
+  call s1(c)
+  call s2(b+c)
+  call s3(w(b))
+end subroutine ss
Index: gcc/testsuite/gfortran.dg/pr42294.f
===================================================================
--- gcc/testsuite/gfortran.dg/pr42294.f	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/pr42294.f	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,41 @@
+C PR rtl-optimization/42294
+C { dg-do compile { target powerpc*-*-* ia64-*-* x86_64-*-* } }
+C { dg-options "-O2 -fselective-scheduling2 -fsel-sched-pipelining -funroll-all-loops" }
+
+      SUBROUTINE ORIEN(IW,NATOT,NTOTORB,NATORB,P,T)
+      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
+      DIMENSION NATORB(NATOT),P(NTOTORB*(NTOTORB+1)/2)
+      DIMENSION T(NTOTORB,NTOTORB)
+      DO 9000 IATOM=1,NATOT
+         ILAST = NTOTORB
+         IF (IATOM.NE.NATOT) ILAST=NATORB(IATOM+1)-1
+         DO 8000 IAOI=NATORB(IATOM),ILAST
+            DO 7000 IAOJ = IAOI+1,ILAST
+               R2 = 0.0D+00
+               R3 = 0.0D+00
+               DO 6000 INOTA=1,NATOT
+                  DO 5000 IK=NATORB(INOTA),NTOTORB
+                     IMAI=MAX(IK,IAOI)
+                     IMII=MIN(IK,IAOI)
+                     IMAJ=MAX(IK,IAOJ)
+                     IMIJ=MIN(IK,IAOJ)
+                     IKI=(IMAI*(IMAI-1))/2 + IMII
+                     IKJ=(IMAJ*(IMAJ-1))/2 + IMIJ
+                     PIKI=P(IKI)
+                     PIKJ=P(IKJ)
+                     R2 = R2 + (PIKI**4)-6*(PIKI*PIKI*PIKJ*PIKJ)+(PIKJ)
+ 5000             CONTINUE
+ 6000          CONTINUE
+               R2 = (R2/4.0D+00)
+               Q = SQRT(R2*R2 + R3*R3)
+               IF (Q.LT.1.0D-08) GO TO 7000
+               A = COS(THETA)
+               B = -SIN(THETA)
+               CALL ROT1INT(NTOTORB,IAOI,IAOJ,A,B,P)
+ 7000       CONTINUE
+ 8000    CONTINUE
+ 9000 CONTINUE
+      RETURN
+      END
+
+
Index: gcc/testsuite/gfortran.dg/namelist_60.f90
===================================================================
--- gcc/testsuite/gfortran.dg/namelist_60.f90	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/namelist_60.f90	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,27 @@
+! { dg-do run }
+! PR42901  Reading array of structures from namelist
+! Test case derived from the reporters test case.
+program test_nml
+type field_descr
+  integer number
+end type
+type fsetup
+  type (field_descr), dimension(3) :: vel ! 3 velocity components
+end type
+type (fsetup) field_setup
+namelist /nl_setup/ field_setup
+field_setup%vel%number = 0
+! write(*,nml=nl_setup)
+open(10, status="scratch")
+write(10,'(a)') "&nl_setup"
+write(10,'(a)') " field_setup%vel(1)%number=  3,"
+write(10,'(a)') " field_setup%vel(2)%number=  9,"
+write(10,'(a)') " field_setup%vel(3)%number=  27,"
+write(10,'(a)') "/"
+rewind(10)
+read(10,nml=nl_setup)
+if (field_setup%vel(1)%number .ne. 3) call abort
+if (field_setup%vel(2)%number .ne. 9) call abort
+if (field_setup%vel(3)%number .ne. 27) call abort
+! write(*,nml=nl_setup)
+end program test_nml
Index: gcc/testsuite/gfortran.dg/bounds_check_15.f90
===================================================================
--- gcc/testsuite/gfortran.dg/bounds_check_15.f90	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/bounds_check_15.f90	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,33 @@
+! { dg-do run }
+! { dg-options "-fbounds-check" }
+! Test the fix for PR42783, in which a bogus array bounds violation
+! with missing optional array argument.
+!
+! Contributed by Harald Anlauf <anlauf@gmx.de>
+!
+program gfcbug99
+  implicit none
+  character(len=8), parameter :: mnem_list(2) = "A"
+
+  call foo (mnem_list)  ! This call succeeds
+  call foo ()           ! This call fails
+contains
+  subroutine foo (mnem_list)
+    character(len=8) ,intent(in) ,optional :: mnem_list(:)
+
+    integer            :: i,j
+    character(len=256) :: ml
+    ml = ''
+    j = 0
+    if (present (mnem_list)) then
+       do i = 1, size (mnem_list)
+          if (mnem_list(i) /= "") then
+             j = j + 1
+             if (j > len (ml)/8) call abort ()
+             ml((j-1)*8+1:(j-1)*8+8) = mnem_list(i)
+          end if
+       end do
+    end if
+    if (j > 0) print *, trim (ml(1:8))
+  end subroutine foo
+end program gfcbug99
Index: gcc/testsuite/gfortran.dg/internal_pack_10.f90
===================================================================
--- gcc/testsuite/gfortran.dg/internal_pack_10.f90	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/internal_pack_10.f90	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,41 @@
+! { dg-do run }
+! Test the fix for PR43180, in which patch which reduced the use of
+! internal_pack/unpack messed up the passing of ru(1)%c as the actual
+! argument at line 23 in this testcase.
+!
+! Contributed by Harald Anlauf <anlauf@gmx.de>
+! further reduced by Tobias Burnus <burnus@gcc.gnu.org>
+!
+module mo_obs_rules
+  type t_set
+     integer :: use = 42
+  end type t_set
+  type t_rules
+     character(len=40) :: comment
+     type(t_set)       :: c (1)
+  end type t_rules
+  type (t_rules), save :: ru (1)
+contains
+  subroutine get_rule (c)
+    type(t_set) :: c (:)
+    ru(1)%c(:)%use = 99
+    if (any (c(:)%use .ne. 42)) call abort
+    call set_set_v (ru(1)%c, c)
+    if (any (c(:)%use .ne. 99)) call abort
+  contains
+    subroutine set_set_v (src, dst)
+      type(t_set), intent(in)    :: src(1)
+      type(t_set), intent(inout) :: dst(1)
+    if (any (src%use .ne. 99)) call abort
+    if (any (dst%use .ne. 42)) call abort
+      dst = src
+    end subroutine set_set_v
+  end subroutine get_rule
+end module mo_obs_rules
+
+program test
+  use mo_obs_rules
+  type(t_set) :: c (1)
+  call get_rule (c)
+end program test
+! { dg-final { cleanup-modules "mo_obs_rules" } }
Index: gcc/testsuite/gfortran.dg/fmt_cache_2.f
===================================================================
--- gcc/testsuite/gfortran.dg/fmt_cache_2.f	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/fmt_cache_2.f	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,36 @@
+! { dg-do run }
+! PR42742 Handle very large format strings correctly
+! Test derived from example developed by Manfred Schwarb.
+      character(12) bufarr(74)
+      character(74*13+30) fmtstr,fmtstr2
+      character(1) delim
+      integer i,j,dat(5),pindx, loopcounter
+      character(983) big_string ! any less and this test fails.
+
+      do i=1,74
+        write(bufarr(i),'(i12)') i
+      enddo
+
+      delim=" "
+      dat(1)=2009
+      dat(2)=10
+      dat(3)=31
+      dat(4)=3
+      dat(5)=0
+      fmtstr="(i2,i6,4(a1,i2.2)"
+      open(10, status="scratch")
+      do j=1,74
+        fmtstr=fmtstr(1:len_trim(fmtstr))//",a1,a12"
+        fmtstr2=fmtstr(1:len_trim(fmtstr))//")"
+c        write(0,*) "interation ",j,": ",len_trim(fmtstr2)
+        do i=1,10
+          write(10,fmtstr2)
+     &           i,dat(1),"-",dat(2),"-",dat(3),
+     &           delim,dat(4),":",dat(5),
+     &           (delim,bufarr(pindx),pindx=1,j)
+        enddo
+        loopcounter = j
+      enddo
+      close(10)
+      if (loopcounter /= 74) call abort
+      end
Index: gcc/testsuite/gfortran.dg/module_write_1.f90
===================================================================
--- gcc/testsuite/gfortran.dg/module_write_1.f90	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/module_write_1.f90	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,59 @@
+! { dg-do compile }
+!
+! PR fortran/41869
+!
+! Was ICEing while module write of symbol 'vs_str' in m_dom_dom
+! because of "len" being private in fox_m_fsys_format.
+!
+module fox_m_fsys_array_str
+contains
+  pure function str_vs(vs) result(s)
+    character, dimension(:), intent(in) :: vs
+    character(len=size(vs)) :: s
+    s = transfer(vs, s)
+  end function str_vs
+  pure function vs_str(s) result(vs)
+    character(len=*), intent(in) :: s
+    character, dimension(len(s)) :: vs
+    vs = transfer(s, vs)
+  end function vs_str
+end module fox_m_fsys_array_str
+
+module fox_m_fsys_format
+  private
+  interface str
+    module procedure  str_logical_array
+  end interface str
+  interface len
+    module procedure str_logical_array_len
+  end interface
+  public :: str
+contains
+  pure function str_logical_array_len(la) result(n)
+    logical, dimension(:), intent(in)   :: la
+  end function str_logical_array_len
+  pure function str_logical_array(la) result(s)
+    logical, dimension(:), intent(in)   :: la
+    character(len=len(la)) :: s
+  end function str_logical_array
+  pure function checkFmt(fmt) result(good)
+    character(len=*), intent(in) :: fmt
+    logical :: good
+    good = len(fmt) > 0
+  end function checkFmt
+end module fox_m_fsys_format
+
+module m_dom_dom
+  use fox_m_fsys_array_str, only: str_vs, vs_str
+end module m_dom_dom
+
+module FoX_dom
+  use fox_m_fsys_format
+  use m_dom_dom
+end module FoX_dom
+
+use FoX_dom
+implicit none
+print *, vs_str("ABC")
+end
+! { dg-final { cleanup-modules "fox_m_fsys_array_str fox_m_fsys_format m_dom_dom fox_dom" } }
Index: gcc/testsuite/gfortran.dg/namelist_28.f90
===================================================================
--- gcc/testsuite/gfortran.dg/namelist_28.f90	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/testsuite/gfortran.dg/namelist_28.f90	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,4 +1,4 @@
-! { dg-do run { target fd_truncate } }
+! { dg-do run }
 ! PR31052 Bad IOSTAT values when readings NAMELISTs past EOF.
 ! Patch derived from PR, submitted by Jerry DeLisle <jvdelisle@gcc.gnu.org>
 program gfcbug61
@@ -27,12 +27,12 @@
     character(len=*), intent(in) :: name
 
     character(len=255) :: line
-    integer            :: ios, idx
+    integer            :: ios, idx, k
     logical            :: first
 
     first = .true.
     status = 0
-    do
+    do k=1,25
        line = ""
        read (unit,'(a)',iostat=ios) line
        if (ios < 0) then
@@ -51,12 +51,13 @@
           return
        end if
     end do
+    if (k.gt.10) call abort
   end subroutine position_nml
 
   subroutine read_report (unit, status)
     integer :: unit, status
 
-    integer            :: iuse, ios
+    integer            :: iuse, ios, k
     !------------------
     ! Namelist 'REPORT'
     !------------------
@@ -66,7 +67,7 @@
     ! Loop to read namelist multiple times
     !-------------------------------------
     iuse = 0
-    do
+    do k=1,25
        !----------------------------------------
        ! Preset namelist variables with defaults
        !----------------------------------------
@@ -84,6 +85,7 @@
        if (ios /= 0) exit
        iuse = iuse + 1
     end do
+    if (k.gt.10) call abort
     status = ios
   end subroutine read_report
 
Index: gcc/testsuite/gfortran.dg/func_result_5.f90
===================================================================
--- gcc/testsuite/gfortran.dg/func_result_5.f90	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/func_result_5.f90	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,14 @@
+! { dg-do compile }
+!
+! PR fortran/42650
+!
+! Result type was not working
+!
+
+type(t) function func2() result(res)
+  type t
+    sequence
+    integer :: i = 5
+  end type t
+  res%i = 2
+end function func2
Index: gcc/testsuite/gfortran.dg/internal_pack_8.f90
===================================================================
--- gcc/testsuite/gfortran.dg/internal_pack_8.f90	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/internal_pack_8.f90	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,33 @@
+! { dg-do run }
+!
+! Test the fix for PR43111, in which necessary calls to
+! internal PACK/UNPACK were not being generated because
+! of an over agressive fix to PR41113/7.
+!
+! Contributed by Joost VandeVondele <jv244@cam.ac.uk>
+!
+SUBROUTINE S2(I)
+ INTEGER :: I(4)
+ !write(6,*) I
+ IF (ANY(I.NE.(/3,5,7,9/))) CALL ABORT()
+END SUBROUTINE S2
+
+MODULE M1
+ TYPE T1
+  INTEGER, POINTER, DIMENSION(:) :: data
+ END TYPE T1
+CONTAINS
+ SUBROUTINE S1()
+   TYPE(T1) :: d
+   INTEGER, TARGET, DIMENSION(10) :: scratch=(/(i,i=1,10)/)
+   INTEGER :: i=2
+   d%data=>scratch(1:9:2)
+!   write(6,*) d%data(i:)
+   CALL S2(d%data(i:))
+ END SUBROUTINE S1
+END MODULE M1
+
+USE M1
+CALL S1
+END
+! { dg-final { cleanup-modules "M1" } }
Index: gcc/testsuite/gfortran.dg/debug/pr43166.f
===================================================================
--- gcc/testsuite/gfortran.dg/debug/pr43166.f	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/debug/pr43166.f	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,14 @@
+C PR debug/43166
+C { dg-do compile }
+C { dg-options "-O" }
+      SUBROUTINE FOO ()
+      INTEGER V1
+      COMMON // V1
+      END
+      SUBROUTINE BAR ()
+      INTEGER V0,V1,V2,V3
+      COMMON // V1(4),V2(85,4),V3
+      DO V3=1,V1(1)
+      V0=V2(V3,1)
+      END DO
+      END
Index: gcc/testsuite/gfortran.dg/char_array_arg_1.f90
===================================================================
--- gcc/testsuite/gfortran.dg/char_array_arg_1.f90	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/char_array_arg_1.f90	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,17 @@
+! { dg-do compile }
+! Test the fix for pr41167, in which the first argument of 'pack', below,
+! was simplified incorrectly, with the results indicated.
+!
+! Contributed by Harald Anlauf <anlauf@gmx.de>
+!
+program gfcbug88
+  implicit none
+  type t
+     character(len=8) :: name
+  end type t
+  type(t) ,parameter :: obstyp(2)= (/ t ('A'), t ('B') /)
+  character(9) :: chr(1)
+
+  print *, pack (" "//obstyp(:)% name, (/ .true., .false. /))  ! Used to ICE on compilation
+  chr = pack (" "//obstyp(:)% name, (/ .true., .false. /))  ! Used to give conversion error
+end program gfcbug88
Index: gcc/testsuite/gfortran.dg/namelist_59.f90
===================================================================
--- gcc/testsuite/gfortran.dg/namelist_59.f90	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/namelist_59.f90	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,26 @@
+! { dg-do run }
+! PR41192 NAMELIST input with just a comment ("&NAME ! comment \") error 
+program cmdline
+! comment by itself causes error in gfortran
+   call process(' ')
+   call process('i=10 , j=20 k=30 ! change all three values')
+   call process(' ')
+   call process('! change no values')! before patch this failed.
+end program cmdline
+
+subroutine process(string)
+ implicit none
+ character(len=*) :: string
+ character(len=132) :: lines(3)
+ character(len=255) :: message
+ integer :: i=1,j=2,k=3
+ integer ios
+ namelist /cmd/ i,j,k
+ save cmd
+ lines(1)='&cmd'
+ lines(2)=string
+ lines(3)='/'
+
+ read(lines,nml=cmd,iostat=ios,iomsg=message)
+ if (ios.ne.0) call abort
+end subroutine process
Index: gcc/testsuite/gfortran.dg/read_eof_7.f90
===================================================================
--- gcc/testsuite/gfortran.dg/read_eof_7.f90	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/read_eof_7.f90	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,20 @@
+! { dg-do run }
+! PR43517 Spurious EOF condition when namelist read follows formatted read
+! Test case from the problem reporter - Michael Richmond
+program main
+  namelist /name/ j
+  open (10,status='scratch',form='formatted')
+  write(10,'(a)') "999999"
+  write(10,'(a)') " $name"
+  write(10,'(a)') "  j=73,"
+  write(10,'(a)') " /"
+  rewind(10)
+  i = 54321
+  idum = 6789
+  read (10,'(2i5,4x)') i, idum ! Trailing 4x was setting EOF condition
+  if (i /= 99999 .and. idum /= 9) call abort
+  j = 12345
+  read (10,name) ! EOF condition tripped here.
+  if (j /= 73) call abort
+end program main
+
Index: gcc/testsuite/gfortran.dg/read_eof_6.f
===================================================================
--- gcc/testsuite/gfortran.dg/read_eof_6.f	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/read_eof_6.f	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,7 @@
+! { dg-do run }
+! PR43320 Missing EOF on read from empty file.
+      open(8,status='scratch',form='formatted')  ! Create empty file
+      read(8,'(a80)', end=123)  ! Reading from an empty file should be an EOF
+      call abort
+123   continue
+      end
Index: gcc/testsuite/gfortran.dg/read_eof_all.f90
===================================================================
--- gcc/testsuite/gfortran.dg/read_eof_all.f90	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/read_eof_all.f90	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,71 @@
+! { dg-do run }
+! PR43265 Followup patch for miscellaneous EOF conditions.
+! Eaxamples from Tobius Burnus 
+  use iso_fortran_env
+  character(len=2) :: str, str2(2)
+  integer :: a, b, c, ios
+  str = ''
+  str2 = ''
+
+  open(99,file='test.dat',access='stream',form='unformatted', status='replace')
+  write(99) ' '
+  close(99)
+ 
+  open(99,file='test.dat')
+  read(99, '(T7,i2)') i
+  close(99, status="delete")
+  if (i /= 0) call abort
+
+  read(str(1:0), '(T7,i1)') i
+  if (i /= 0) call abort
+
+  read(str,'(i2,/,i2)',end=111) a, b
+  call abort !stop 'ERROR: Expected EOF error (1)'
+  111 continue
+
+  read(str2,'(i2,/,i2)',end=112) a, b
+
+  read(str2,'(i2,/,i2,/,i2)',end=113) a, b, c
+  call abort !stop 'ERROR: Expected EOF error (2)'
+
+  112 call abort !stop 'ERROR: Unexpected EOF (3)'
+
+  113 continue
+  read(str,'(i2,/,i2)',end=121,pad='no') a, b
+  call abort !stop 'ERROR: Expected EOF error (1)'
+  121 continue
+
+  read(str2(:),'(i2,/,i2)', end=122, pad='no') a, b
+  goto 125
+  122 call abort !stop 'ERROR: Expected no EOF error (2)'
+  125 continue
+
+  read(str2(:),'(i2,/,i2,/,i2)',end=123,pad='no') a, b, c
+  call abort !stop 'ERROR: Expected EOF error (3)'
+  123 continue
+
+  read(str(2:1),'(i2,/,i2)',end=131, pad='no') a, b
+  call abort !stop 'ERROR: Expected EOF error (1)'
+  131 continue
+
+  read(str2(:)(2:1),'(i2,/,i2)',end=132, pad='no') a, b
+  call abort !stop 'ERROR: Expected EOF error (2)'
+  132 continue
+
+  read(str2(:)(2:1),'(i2,/,i2,/,i2)',end=133,pad='no') a, b, c
+  call abort !stop 'ERROR: Expected EOF error (3)'
+  133 continue
+
+  read(str(2:1),'(i2,/,i2)',iostat=ios, pad='no') a, b
+  if (ios /= IOSTAT_END) call abort !stop 'ERROR: expected iostat /= 0  (1)'
+
+  read(str2(:)(2:1),'(i2,/,i2)',iostat=ios, pad='no') a, b
+  if (ios /= IOSTAT_END) call  abort !stop 'ERROR: expected iostat /= 0  (2)'
+
+  read(str2(:)(2:1),'(i2,/,i2,/,i2)',iostat=ios,pad='no') a, b, c
+  if (ios /= IOSTAT_END) call abort !stop 'ERROR: expected iostat /= 0  (2)'
+
+  ! print *, "success"
+  end
+
+
Index: gcc/testsuite/gfortran.dg/read_x_eof.f90
===================================================================
--- gcc/testsuite/gfortran.dg/read_x_eof.f90	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/read_x_eof.f90	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,16 @@
+! { dg-do run }
+! PR43265 No EOF condition if reading with '(x)' from an empty file
+! Test case from the reporter.
+program pr43265
+implicit none
+integer::i
+open(23,status="scratch")
+write(23,'(a)') "Line 1"
+write(23,'(a)') "Line 2"
+write(23,'(a)') "Line 3"
+rewind(23)
+do i=1,10
+  read(23,'(1x)',end=12)
+enddo
+12 if (i.ne.4) call abort
+end
Index: gcc/testsuite/gfortran.dg/read_x_past.f
===================================================================
--- gcc/testsuite/gfortran.dg/read_x_past.f	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/testsuite/gfortran.dg/read_x_past.f	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,17 +1,28 @@
-! { dg-do run { target fd_truncate } }
+! { dg-do run }
 ! { dg-options -w }
 ! PR 26661 : Test reading X's past file end with no LF or CR.
 ! PR 26880 : Tests that rewind clears the gfc_unit read_bad flag.
+! PR 43265 : Tests that no error occurs with or without X at end.
 ! Contributed by Jerry DeLisle <jvdelisle@gcc.gnu.org>.
       implicit none
       character(3) a(4)
       integer i
-      open (10)
+      open (10, status="scratch")
  10   format(A,$)  ! This is not pedantic
       write(10,10)' abc def ghi jkl'
       rewind(10)
+
+      a = ""
       read(10,20)(a(i),i=1,4)
       if (a(4).ne."jkl") call abort()
+
+      rewind(10)
+
+      a = ""
+      read(10,30)(a(i),i=1,4)
+      if (a(4).ne."jkl") call abort()
+
  20   format(1x,a3,1x,a3,1x,a3,1x,a3,10x)
-      close(10, status="delete")
+ 30   format(1x,a3,1x,a3,1x,a3,1x,a3)
+      close(10)
       end
Index: gcc/testsuite/gfortran.dg/namelist_61.f90
===================================================================
--- gcc/testsuite/gfortran.dg/namelist_61.f90	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/namelist_61.f90	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,35 @@
+! { dg-do run }
+!
+! PR fortran/43228
+!
+integer :: a(3,3)
+character(len=100) :: str
+namelist /nml/a
+
+a = -1
+str = '&nml a(1,:) = 1 2 3 /'
+read(str, nml=nml)
+if (any (a(1,:) /= [1, 2, 3])) call abort ()
+if (any (a([2,3],:) /= -1)) call abort ()
+
+a = -1
+str = '&nml a(1,1) = 1 2 3 4 /'
+read(str, nml=nml)
+if (any (a(:,1) /= [1, 2, 3])) call abort ()
+if (any (a(:,2) /= [4, -1, -1])) call abort ()
+if (any (a(:,3) /= -1)) call abort ()
+
+str = '&nml a(1,:) = 1 2 3 , &
+       &    a(2,:) = 4,5,6 &
+       &    a(3,:) = 7 8 9/'
+read(str, nml=nml)
+if (any (a(1,:) /= [1, 2, 3])) call abort ()
+if (any (a(2,:) /= [4, 5, 6])) call abort ()
+if (any (a(3,:) /= [7, 8, 9])) call abort ()
+
+!print *, a(:,1)
+!print *, a(:,2)
+!print *, a(:,3)
+end
+
+
Index: gcc/testsuite/gfortran.dg/namelist_27.f90
===================================================================
--- gcc/testsuite/gfortran.dg/namelist_27.f90	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/testsuite/gfortran.dg/namelist_27.f90	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,4 +1,4 @@
-! { dg-do run { target fd_truncate } }
+! { dg-do run }
 ! PR31052 Bad IOSTAT values when readings NAMELISTs past EOF.
 ! Patch derived from PR, submitted by Jerry DeLisle <jvdelisle@gcc.gnu.org>
 program gfcbug61
@@ -41,14 +41,14 @@
     character(len=*), intent(in) :: name
 
     character(len=255) :: line
-    integer            :: ios, idx
+    integer            :: ios, idx, k
     logical            :: first
 
     first = .true.
     status = 0
     ios = 0
     line = ""
-    do
+    do k=1,10
        read (unit,'(a)',iostat=ios) line
        if (first) then
           first = .false.
@@ -74,7 +74,7 @@
   subroutine read_report (unit, status)
     integer :: unit, status
 
-    integer            :: iuse, ios
+    integer            :: iuse, ios, k
     !------------------
     ! Namelist 'REPORT'
     !------------------
@@ -85,7 +85,7 @@
     ! Loop to read namelist multiple times
     !-------------------------------------
     iuse = 0
-    do
+    do k=1,5
        !----------------------------------------
        ! Preset namelist variables with defaults
        !----------------------------------------
@@ -103,4 +103,4 @@
     status = ios
   end subroutine read_report
 
-end program gfcbug61
\ No newline at end of file
+end program gfcbug61
Index: gcc/testsuite/gfortran.dg/c_assoc_3.f90
===================================================================
--- gcc/testsuite/gfortran.dg/c_assoc_3.f90	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/c_assoc_3.f90	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,13 @@
+! { dg-do compile }
+!
+! PR fortran/43303
+!
+! Contributed by Dennis Wassel
+!
+PROGRAM c_assoc
+  use iso_c_binding
+  type(c_ptr) :: x
+  x = c_null_ptr
+  print *, C_ASSOCIATED(x) ! <<< was ICEing here
+  if (C_ASSOCIATED(x)) call abort ()
+END PROGRAM c_assoc
Index: gcc/testsuite/gfortran.dg/alloc_comp_basics_1.f90
===================================================================
--- gcc/testsuite/gfortran.dg/alloc_comp_basics_1.f90	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/testsuite/gfortran.dg/alloc_comp_basics_1.f90	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,5 +1,5 @@
 ! { dg-do run }
-! { dg-options "-O2 -fdump-tree-original" }
+! { dg-options "-fdump-tree-original" }
 !
 ! Check some basic functionality of allocatable components, including that they
 ! are nullified when created and automatically deallocated when
Index: gcc/testsuite/gfortran.dg/dependency_25.f90
===================================================================
--- gcc/testsuite/gfortran.dg/dependency_25.f90	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/dependency_25.f90	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,95 @@
+! { dg-do run }
+! Test the fix for PR42736, in which an excessively rigorous dependency
+! checking for the assignment generated an unnecessary temporary, whose
+! rank was wrong.  When accessed by the scalarizer, a segfault ensued.
+!
+! Contributed by Tobias Burnus <burnus@gcc.gnu.org>
+! Reported by Armelius Cameron <armeliusc@gmail.com>
+!
+module UnitValue_Module
+
+  implicit none
+  private
+
+  public :: &
+    operator(*), &
+    assignment(=)
+
+  type, public :: UnitValue
+    real :: &
+      Value = 1.0
+    character(31) :: &
+      Label
+  end type UnitValue
+
+  interface operator(*)
+    module procedure ProductReal_LV
+  end interface operator(*)
+
+  interface assignment(=)
+    module procedure Assign_LV_Real
+  end interface assignment(=)
+
+contains
+
+  elemental function ProductReal_LV(Multiplier, Multiplicand) result(P_R_LV)
+
+    real, intent(in) :: &
+      Multiplier
+    type(UnitValue), intent(in) :: &
+      Multiplicand
+    type(UnitValue) :: &
+      P_R_LV
+
+    P_R_LV%Value = Multiplier * Multiplicand%Value
+    P_R_LV%Label = Multiplicand%Label
+
+  end function ProductReal_LV
+
+
+  elemental subroutine Assign_LV_Real(LeftHandSide, RightHandSide)
+
+    real, intent(inout) :: &
+      LeftHandSide
+    type(UnitValue), intent(in) :: &
+      RightHandSide
+
+    LeftHandSide = RightHandSide%Value
+
+  end subroutine Assign_LV_Real
+
+end module UnitValue_Module
+
+program TestProgram
+
+  use UnitValue_Module
+
+  implicit none
+
+  type :: TableForm
+    real, dimension(:,:), allocatable :: &
+      RealData
+  end type TableForm
+
+  type(UnitValue) :: &
+    CENTIMETER
+
+  type(TableForm), pointer :: &
+    Table
+
+  allocate(Table)
+  allocate(Table%RealData(10,5))
+
+  CENTIMETER%value = 42
+  Table%RealData = 1
+  Table%RealData(:,1) = Table%RealData(:,1) * CENTIMETER
+  Table%RealData(:,2) = Table%RealData(:,2) * CENTIMETER
+  Table%RealData(:,3) = Table%RealData(:,3) * CENTIMETER
+  Table%RealData(:,5) = Table%RealData(:,5) * CENTIMETER
+
+!  print *, Table%RealData
+  if (any (abs(Table%RealData(:,4) - 1) > epsilon(1.0))) call abort ()
+  if (any (abs(Table%RealData(:,[1,2,3,5]) - 42) > epsilon(1.0))) call abort ()
+end program TestProgram
+
+! { dg-final { cleanup-modules "UnitValue_Module" } }
Index: gcc/testsuite/gfortran.dg/array_constructor_35.f90
===================================================================
--- gcc/testsuite/gfortran.dg/array_constructor_35.f90	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/array_constructor_35.f90	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,9 @@
+! { dg-do compile }
+! PR42999  bogus error: Parameter 'i' at (1) has not been declared
+! or is a variable, which does not reduce to a constant expression
+ TYPE DD
+  INTEGER :: I
+ END TYPE DD
+ TYPE(DD) :: X(2)=(/(DD(I),I=1,2)/)
+ END
+
Index: gcc/testsuite/gfortran.dg/generic_21.f90
===================================================================
--- gcc/testsuite/gfortran.dg/generic_21.f90	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/generic_21.f90	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,33 @@
+! { dg-do compile }
+!
+! PR fortran/42858
+!
+! Contributed by Harald Anlauf
+!
+module gfcbug102
+  implicit none
+  type t_vector_segm
+     real ,pointer :: x(:) => NULL()
+  end type t_vector_segm
+
+  type t_vector
+     integer                       :: n_s     =  0
+     type (t_vector_segm) ,pointer :: s (:)   => NULL()
+  end type t_vector
+
+  interface sqrt
+     module procedure sqrt_vector
+  end interface sqrt
+
+contains
+  function sqrt_vector (x) result (y)
+    type (t_vector)             :: y
+    type (t_vector) ,intent(in) :: x
+    integer :: i
+    do i = 1, y% n_s
+       y% s(i)% x = sqrt (x% s(i)% x)
+    end do
+  end function sqrt_vector
+end module gfcbug102
+
+! { dg-final { cleanup-modules "gfcbug102" } }
Index: gcc/testsuite/gfortran.dg/subref_array_pointer_4.f90
===================================================================
--- gcc/testsuite/gfortran.dg/subref_array_pointer_4.f90	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/subref_array_pointer_4.f90	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,27 @@
+! { dg-do run }
+! Tests the fix for PR42309, in which the indexing of 'Q'
+! was off by one.
+!
+! Contributed by Gilbert Scott <gilbert.scott@easynet.co.uk>
+!
+PROGRAM X
+  TYPE T
+    INTEGER :: I
+    REAL :: X
+  END TYPE T
+  TYPE(T), TARGET :: T1(0:3)
+  INTEGER, POINTER :: P(:)
+  REAL :: SOURCE(4) = [10., 20., 30., 40.]
+
+  T1%I = [1, 2, 3, 4]
+  T1%X = SOURCE
+  P => T1%I
+  CALL Z(P)
+  IF (ANY (T1%I .NE. [999, 2, 999, 4])) CALL ABORT
+  IF (ANY (T1%X .NE. SOURCE)) CALL ABORT
+CONTAINS
+  SUBROUTINE Z(Q)
+    INTEGER, POINTER :: Q(:)
+    Q(1:3:2) = 999
+  END SUBROUTINE Z
+END PROGRAM X
Index: gcc/testsuite/gfortran.dg/pr43229.f90
===================================================================
--- gcc/testsuite/gfortran.dg/pr43229.f90	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/pr43229.f90	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,10 @@
+! PR debug/43229
+! { dg-do compile }
+! { dg-options "-g -O3 -ffast-math" }
+! { dg-options "-g -O3 -ffast-math -msse3" { target { i?86-*-* x86_64-*-* } } }
+
+function foo (c, d)
+  real(8) :: c(6), d(6), foo
+  x = sum (c * d)
+  foo = exp (-x)
+end function foo
Index: gcc/testsuite/objc/execute/forward-1.x
===================================================================
--- gcc/testsuite/objc/execute/forward-1.x	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/testsuite/objc/execute/forward-1.x	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,8 +1,6 @@
 load_lib target-supports.exp
 
 # XFAIL: PR libobjc/36610, for targets which pass arguments via registers
-# For powerpc-darwin it fails with -fgnu-runtime, passes with -fnext-runtime,
-# but that would be too ugly to handle; let it fail there.
 
 if { ([istarget x86_64-*-linux*] && [check_effective_target_lp64] )
      || [istarget powerpc*-*-linux*]
@@ -15,4 +13,21 @@
     set torture_execute_xfail "*-*-*"
 }
 
+# For darwin and alpha-linux it fails with -fgnu-runtime,
+# passes with -fnext-runtime.
+
+if { ([istarget x86_64-*-darwin*] && [check_effective_target_lp64] )
+     || [istarget powerpc*-*-darwin*]
+     || [istarget alpha*-*-linux*] } {
+    set torture_eval_before_execute {
+	global compiler_conditional_xfail_data
+	set compiler_conditional_xfail_data {
+	    "Target fails with -fgnu-runtime" \
+		"*-*-*" \
+		{ "-fgnu-runtime" } \
+		{ "" }
+	}
+    }
+}
+
 return 0
Index: gcc/cp/ChangeLog
===================================================================
--- gcc/cp/ChangeLog	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/cp/ChangeLog	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,3 +1,15 @@
+2010-02-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/43024
+	* name-lookup.h (current_binding_level): Check for null
+	cp_function_chain.
+
+2010-02-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/43033
+	* name-lookup.c (pushdecl_maybe_friend): Check default args of t
+	instead of x.
+
 2010-01-21  Release Manager
 
 	* GCC 4.4.3 released.
Index: gcc/cp/name-lookup.c
===================================================================
--- gcc/cp/name-lookup.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/cp/name-lookup.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,5 +1,5 @@
 /* Definitions for C++ name lookup routines.
-   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009
+   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
    Free Software Foundation, Inc.
    Contributed by Gabriel Dos Reis <gdr@integrable-solutions.net>
 
@@ -840,8 +840,8 @@
 	    add_decl_to_level (x, NAMESPACE_LEVEL (CP_DECL_CONTEXT (t)));
 	}
 
-      if (TREE_CODE (x) == FUNCTION_DECL || DECL_FUNCTION_TEMPLATE_P (x))
-	check_default_args (x);
+      if (TREE_CODE (t) == FUNCTION_DECL || DECL_FUNCTION_TEMPLATE_P (t))
+	check_default_args (t);
 
       if (t != x || DECL_FUNCTION_TEMPLATE_P (t))
 	POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);
Index: gcc/cp/name-lookup.h
===================================================================
--- gcc/cp/name-lookup.h	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/cp/name-lookup.h	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -263,7 +263,7 @@
 /* The binding level currently in effect.  */
 
 #define current_binding_level			\
-  (*(cfun && cp_function_chain->bindings	\
+  (*(cfun && cp_function_chain && cp_function_chain->bindings \
    ? &cp_function_chain->bindings		\
    : &scope_chain->bindings))
 
Index: gcc/tree-ssa-ccp.c
===================================================================
--- gcc/tree-ssa-ccp.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/tree-ssa-ccp.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,6 +1,6 @@
 /* Conditional constant propagation pass for the GNU compiler.
-   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
-   Free Software Foundation, Inc.
+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
+   2010  Free Software Foundation, Inc.
    Adapted from original RTL SSA-CCP by Daniel Berlin <dberlin@dberlin.org>
    Adapted to GIMPLE trees by Diego Novillo <dnovillo@redhat.com>
 
@@ -2979,7 +2979,10 @@
 	continue;
 
       callee = gimple_call_fndecl (stmt);
-      if (!callee || DECL_BUILT_IN_CLASS (callee) != BUILT_IN_NORMAL)
+      if (!callee
+	  || DECL_BUILT_IN_CLASS (callee) != BUILT_IN_NORMAL
+	  /* All regular builtins are ok, just obviously not alloca.  */
+	  || DECL_FUNCTION_CODE (callee) == BUILT_IN_ALLOCA)
 	return NULL_TREE;
 
       if (DECL_FUNCTION_CODE (callee) == BUILT_IN_STACK_RESTORE)
Index: gcc/dojump.c
===================================================================
--- gcc/dojump.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/dojump.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,6 +1,6 @@
 /* Convert tree expression to rtl instructions, for GNU compiler.
    Copyright (C) 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
-   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
+   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
    Free Software Foundation, Inc.
 
 This file is part of GCC.
@@ -35,13 +35,22 @@
 #include "langhooks.h"
 #include "ggc.h"
 #include "basic-block.h"
+#include "output.h"
 
 static bool prefer_and_bit_test (enum machine_mode, int);
-static void do_jump_by_parts_greater (tree, int, rtx, rtx);
-static void do_jump_by_parts_equality (tree, rtx, rtx);
+static void do_jump_by_parts_greater (tree, int, rtx, rtx, int);
+static void do_jump_by_parts_equality (tree, rtx, rtx, int);
 static void do_compare_and_jump	(tree, enum rtx_code, enum rtx_code, rtx,
-				 rtx);
+				 rtx, int);
 
+/* Invert probability if there is any.  -1 stands for unknown.  */
+
+static inline int
+inv (int prob)
+{
+  return prob == -1 ? -1 : REG_BR_PROB_BASE - prob;
+}
+
 /* At the start of a function, record that we have no previously-pushed
    arguments waiting to be popped.  */
 
@@ -96,17 +105,17 @@
    functions here.  */
 
 void
-jumpifnot (tree exp, rtx label)
+jumpifnot (tree exp, rtx label, int prob)
 {
-  do_jump (exp, label, NULL_RTX);
+  do_jump (exp, label, NULL_RTX, inv (prob));
 }
 
 /* Generate code to evaluate EXP and jump to LABEL if the value is nonzero.  */
 
 void
-jumpif (tree exp, rtx label)
+jumpif (tree exp, rtx label, int prob)
 {
-  do_jump (exp, NULL_RTX, label);
+  do_jump (exp, NULL_RTX, label, prob);
 }
 
 /* Used internally by prefer_and_bit_test.  */
@@ -156,10 +165,12 @@
 
    do_jump always does any pending stack adjust except when it does not
    actually perform a jump.  An example where there is no jump
-   is when EXP is `(foo (), 0)' and IF_FALSE_LABEL is null.  */
+   is when EXP is `(foo (), 0)' and IF_FALSE_LABEL is null.
 
+   PROB is probability of jump to if_true_label, or -1 if unknown.  */
+
 void
-do_jump (tree exp, rtx if_false_label, rtx if_true_label)
+do_jump (tree exp, rtx if_false_label, rtx if_true_label, int prob)
 {
   enum tree_code code = TREE_CODE (exp);
   rtx temp;
@@ -206,11 +217,12 @@
     case LROTATE_EXPR:
     case RROTATE_EXPR:
       /* These cannot change zero->nonzero or vice versa.  */
-      do_jump (TREE_OPERAND (exp, 0), if_false_label, if_true_label);
+      do_jump (TREE_OPERAND (exp, 0), if_false_label, if_true_label, prob);
       break;
 
     case TRUTH_NOT_EXPR:
-      do_jump (TREE_OPERAND (exp, 0), if_true_label, if_false_label);
+      do_jump (TREE_OPERAND (exp, 0), if_true_label, if_false_label,
+	       inv (prob));
       break;
 
     case COND_EXPR:
@@ -226,10 +238,10 @@
 	  }
 
         do_pending_stack_adjust ();
-        do_jump (TREE_OPERAND (exp, 0), label1, NULL_RTX);
-        do_jump (TREE_OPERAND (exp, 1), if_false_label, if_true_label);
+	do_jump (TREE_OPERAND (exp, 0), label1, NULL_RTX, -1);
+	do_jump (TREE_OPERAND (exp, 1), if_false_label, if_true_label, prob);
         emit_label (label1);
-        do_jump (TREE_OPERAND (exp, 2), if_false_label, if_true_label);
+	do_jump (TREE_OPERAND (exp, 2), if_false_label, if_true_label, prob);
 	break;
       }
 
@@ -261,7 +273,8 @@
             && (optab_handler (cmp_optab, TYPE_MODE (type))->insn_code
 		!= CODE_FOR_nothing))
           {
-            do_jump (fold_convert (type, exp), if_false_label, if_true_label);
+	    do_jump (fold_convert (type, exp), if_false_label, if_true_label,
+		     prob);
             break;
           }
         goto normal;
@@ -277,12 +290,14 @@
 		    != MODE_COMPLEX_INT);
 	
         if (integer_zerop (TREE_OPERAND (exp, 1)))
-          do_jump (TREE_OPERAND (exp, 0), if_true_label, if_false_label);
+          do_jump (TREE_OPERAND (exp, 0), if_true_label, if_false_label,
+		   inv (prob));
         else if (GET_MODE_CLASS (TYPE_MODE (inner_type)) == MODE_INT
                  && !can_compare_p (EQ, TYPE_MODE (inner_type), ccp_jump))
-          do_jump_by_parts_equality (exp, if_false_label, if_true_label);
+          do_jump_by_parts_equality (exp, if_false_label, if_true_label, prob);
         else
-          do_compare_and_jump (exp, EQ, EQ, if_false_label, if_true_label);
+          do_compare_and_jump (exp, EQ, EQ, if_false_label, if_true_label,
+			       prob);
         break;
       }
 
@@ -302,12 +317,14 @@
 		    != MODE_COMPLEX_INT);
 	
         if (integer_zerop (TREE_OPERAND (exp, 1)))
-          do_jump (TREE_OPERAND (exp, 0), if_false_label, if_true_label);
+          do_jump (TREE_OPERAND (exp, 0), if_false_label, if_true_label, prob);
         else if (GET_MODE_CLASS (TYPE_MODE (inner_type)) == MODE_INT
            && !can_compare_p (NE, TYPE_MODE (inner_type), ccp_jump))
-          do_jump_by_parts_equality (exp, if_true_label, if_false_label);
+          do_jump_by_parts_equality (exp, if_true_label, if_false_label,
+				     inv (prob));
         else
-          do_compare_and_jump (exp, NE, NE, if_false_label, if_true_label);
+          do_compare_and_jump (exp, NE, NE, if_false_label, if_true_label,
+			       prob);
         break;
       }
 
@@ -315,36 +332,43 @@
       mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));
       if (GET_MODE_CLASS (mode) == MODE_INT
           && ! can_compare_p (LT, mode, ccp_jump))
-        do_jump_by_parts_greater (exp, 1, if_false_label, if_true_label);
+        do_jump_by_parts_greater (exp, 1, if_false_label, if_true_label, prob);
       else
-        do_compare_and_jump (exp, LT, LTU, if_false_label, if_true_label);
+        do_compare_and_jump (exp, LT, LTU, if_false_label, if_true_label,
+			     prob);
       break;
 
     case LE_EXPR:
       mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));
       if (GET_MODE_CLASS (mode) == MODE_INT
           && ! can_compare_p (LE, mode, ccp_jump))
-        do_jump_by_parts_greater (exp, 0, if_true_label, if_false_label);
+        do_jump_by_parts_greater (exp, 0, if_true_label, if_false_label,
+				  inv (prob));
       else
-        do_compare_and_jump (exp, LE, LEU, if_false_label, if_true_label);
+        do_compare_and_jump (exp, LE, LEU, if_false_label, if_true_label,
+			     prob);
       break;
 
     case GT_EXPR:
       mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));
       if (GET_MODE_CLASS (mode) == MODE_INT
           && ! can_compare_p (GT, mode, ccp_jump))
-        do_jump_by_parts_greater (exp, 0, if_false_label, if_true_label);
+        do_jump_by_parts_greater (exp, 0, if_false_label, if_true_label,
+				  prob);
       else
-        do_compare_and_jump (exp, GT, GTU, if_false_label, if_true_label);
+        do_compare_and_jump (exp, GT, GTU, if_false_label, if_true_label,
+			     prob);
       break;
 
     case GE_EXPR:
       mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));
       if (GET_MODE_CLASS (mode) == MODE_INT
           && ! can_compare_p (GE, mode, ccp_jump))
-        do_jump_by_parts_greater (exp, 1, if_true_label, if_false_label);
+        do_jump_by_parts_greater (exp, 1, if_true_label, if_false_label,
+				  inv (prob));
       else
-        do_compare_and_jump (exp, GE, GEU, if_false_label, if_true_label);
+        do_compare_and_jump (exp, GE, GEU, if_false_label, if_true_label,
+			     prob);
       break;
 
     case UNORDERED_EXPR:
@@ -368,9 +392,10 @@
           do_rev = 1;
 
         if (! do_rev)
-          do_compare_and_jump (exp, cmp, cmp, if_false_label, if_true_label);
+          do_compare_and_jump (exp, cmp, cmp, if_false_label, if_true_label, prob);
         else
-          do_compare_and_jump (exp, rcmp, rcmp, if_true_label, if_false_label);
+          do_compare_and_jump (exp, rcmp, rcmp, if_true_label, if_false_label,
+			       inv (prob));
       }
       break;
 
@@ -415,7 +440,7 @@
         mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));
         if (can_compare_p (rcode1, mode, ccp_jump))
           do_compare_and_jump (exp, rcode1, rcode1, if_false_label,
-                               if_true_label);
+                               if_true_label, prob);
         else
           {
             tree op0 = save_expr (TREE_OPERAND (exp, 0));
@@ -429,8 +454,8 @@
 	      
             cmp0 = fold_build2 (tcode1, TREE_TYPE (exp), op0, op1);
             cmp1 = fold_build2 (tcode2, TREE_TYPE (exp), op0, op1);
-	    do_jump (cmp0, 0, if_true_label);
-	    do_jump (cmp1, if_false_label, if_true_label);
+	    do_jump (cmp0, 0, if_true_label, prob);
+	    do_jump (cmp1, if_false_label, if_true_label, prob);
           }
       break;
     }
@@ -443,6 +468,7 @@
 	{
 	  tree exp0 = TREE_OPERAND (exp, 0);
 	  rtx set_label, clr_label;
+	  int setclr_prob = prob;
 
 	  /* Strip narrowing integral type conversions.  */
 	  while (CONVERT_EXPR_P (exp0)
@@ -458,6 +484,7 @@
 	      exp0 = TREE_OPERAND (exp0, 0);
 	      clr_label = if_true_label;
 	      set_label = if_false_label;
+	      setclr_prob = inv (prob);
 	    }
 	  else
 	    {
@@ -480,7 +507,7 @@
 		    = (unsigned HOST_WIDE_INT) 1 << TREE_INT_CST_LOW (shift);
 		  do_jump (build2 (BIT_AND_EXPR, argtype, arg,
 				   build_int_cst_wide_type (argtype, mask, 0)),
-			   clr_label, set_label);
+			   clr_label, set_label, setclr_prob);
 		  break;
 		}
 	    }
@@ -503,7 +530,8 @@
           && (optab_handler (cmp_optab, TYPE_MODE (type))->insn_code
               != CODE_FOR_nothing))
         {
-          do_jump (fold_convert (type, exp), if_false_label, if_true_label);
+	  do_jump (fold_convert (type, exp), if_false_label, if_true_label,
+		   prob);
           break;
         }
 
@@ -526,13 +554,13 @@
       if (if_false_label == NULL_RTX)
         {
 	  drop_through_label = gen_label_rtx ();
-          do_jump (TREE_OPERAND (exp, 0), drop_through_label, NULL_RTX);
-          do_jump (TREE_OPERAND (exp, 1), NULL_RTX, if_true_label);
+          do_jump (TREE_OPERAND (exp, 0), drop_through_label, NULL_RTX, prob);
+          do_jump (TREE_OPERAND (exp, 1), NULL_RTX, if_true_label, prob);
 	}
       else
 	{
-	  do_jump (TREE_OPERAND (exp, 0), if_false_label, NULL_RTX);
-          do_jump (TREE_OPERAND (exp, 1), if_false_label, if_true_label);
+	  do_jump (TREE_OPERAND (exp, 0), if_false_label, NULL_RTX, prob);
+          do_jump (TREE_OPERAND (exp, 1), if_false_label, if_true_label, prob);
 	}
       break;
 
@@ -541,7 +569,7 @@
       /* High branch cost, expand as the bitwise OR of the conditions.
 	 Do the same if the RHS has side effects, because we're effectively
 	 turning a TRUTH_OR_EXPR into a TRUTH_ORIF_EXPR.  */
-      if (BRANCH_COST (optimize_insn_for_speed_p (), false)>= 4
+      if (BRANCH_COST (optimize_insn_for_speed_p (), false) >= 4
 	  || TREE_SIDE_EFFECTS (TREE_OPERAND (exp, 1)))
 	goto normal;
 
@@ -549,13 +577,13 @@
       if (if_true_label == NULL_RTX)
 	{
           drop_through_label = gen_label_rtx ();
-          do_jump (TREE_OPERAND (exp, 0), NULL_RTX, drop_through_label);
-          do_jump (TREE_OPERAND (exp, 1), if_false_label, NULL_RTX);
+          do_jump (TREE_OPERAND (exp, 0), NULL_RTX, drop_through_label, prob);
+          do_jump (TREE_OPERAND (exp, 1), if_false_label, NULL_RTX, prob);
 	}
       else
 	{
-          do_jump (TREE_OPERAND (exp, 0), NULL_RTX, if_true_label);
-          do_jump (TREE_OPERAND (exp, 1), if_false_label, if_true_label);
+          do_jump (TREE_OPERAND (exp, 0), NULL_RTX, if_true_label, prob);
+          do_jump (TREE_OPERAND (exp, 1), if_false_label, if_true_label, prob);
 	}
       break;
 
@@ -577,7 +605,7 @@
       do_compare_rtx_and_jump (temp, CONST0_RTX (GET_MODE (temp)),
 			       NE, TYPE_UNSIGNED (TREE_TYPE (exp)),
 			       GET_MODE (temp), NULL_RTX,
-			       if_false_label, if_true_label);
+			       if_false_label, if_true_label, prob);
     }
 
   if (drop_through_label)
@@ -593,7 +621,8 @@
 
 static void
 do_jump_by_parts_greater_rtx (enum machine_mode mode, int unsignedp, rtx op0,
-			      rtx op1, rtx if_false_label, rtx if_true_label)
+			      rtx op1, rtx if_false_label, rtx if_true_label,
+			      int prob)
 {
   int nwords = (GET_MODE_SIZE (mode) / UNITS_PER_WORD);
   rtx drop_through_label = 0;
@@ -625,11 +654,12 @@
       /* All but high-order word must be compared as unsigned.  */
       do_compare_rtx_and_jump (op0_word, op1_word, GT,
                                (unsignedp || i > 0), word_mode, NULL_RTX,
-                               NULL_RTX, if_true_label);
+			       NULL_RTX, if_true_label, prob);
 
       /* Consider lower words only if these are equal.  */
       do_compare_rtx_and_jump (op0_word, op1_word, NE, unsignedp, word_mode,
-                               NULL_RTX, NULL_RTX, if_false_label);
+			       NULL_RTX, NULL_RTX, if_false_label,
+			       inv (prob));
     }
 
   if (if_false_label)
@@ -645,7 +675,7 @@
 
 static void
 do_jump_by_parts_greater (tree exp, int swap, rtx if_false_label,
-			  rtx if_true_label)
+			  rtx if_true_label, int prob)
 {
   rtx op0 = expand_normal (TREE_OPERAND (exp, swap));
   rtx op1 = expand_normal (TREE_OPERAND (exp, !swap));
@@ -653,7 +683,7 @@
   int unsignedp = TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 0)));
 
   do_jump_by_parts_greater_rtx (mode, unsignedp, op0, op1, if_false_label,
-				if_true_label);
+				if_true_label, prob);
 }
 
 /* Jump according to whether OP0 is 0.  We assume that OP0 has an integer
@@ -663,7 +693,7 @@
 
 static void
 do_jump_by_parts_zero_rtx (enum machine_mode mode, rtx op0,
-			   rtx if_false_label, rtx if_true_label)
+			   rtx if_false_label, rtx if_true_label, int prob)
 {
   int nwords = GET_MODE_SIZE (mode) / UNITS_PER_WORD;
   rtx part;
@@ -685,8 +715,7 @@
   if (part != 0)
     {
       do_compare_rtx_and_jump (part, const0_rtx, EQ, 1, word_mode,
-                               NULL_RTX, if_false_label, if_true_label);
-
+			       NULL_RTX, if_false_label, if_true_label, prob);
       return;
     }
 
@@ -697,7 +726,7 @@
   for (i = 0; i < nwords; i++)
     do_compare_rtx_and_jump (operand_subword_force (op0, i, mode),
                              const0_rtx, EQ, 1, word_mode, NULL_RTX,
-                             if_false_label, NULL_RTX);
+			     if_false_label, NULL_RTX, prob);
 
   if (if_true_label)
     emit_jump (if_true_label);
@@ -713,7 +742,7 @@
 
 static void
 do_jump_by_parts_equality_rtx (enum machine_mode mode, rtx op0, rtx op1,
-			       rtx if_false_label, rtx if_true_label)
+			       rtx if_false_label, rtx if_true_label, int prob)
 {
   int nwords = (GET_MODE_SIZE (mode) / UNITS_PER_WORD);
   rtx drop_through_label = 0;
@@ -721,12 +750,14 @@
 
   if (op1 == const0_rtx)
     {
-      do_jump_by_parts_zero_rtx (mode, op0, if_false_label, if_true_label);
+      do_jump_by_parts_zero_rtx (mode, op0, if_false_label, if_true_label,
+				 prob);
       return;
     }
   else if (op0 == const0_rtx)
     {
-      do_jump_by_parts_zero_rtx (mode, op1, if_false_label, if_true_label);
+      do_jump_by_parts_zero_rtx (mode, op1, if_false_label, if_true_label,
+				 prob);
       return;
     }
 
@@ -737,7 +768,7 @@
     do_compare_rtx_and_jump (operand_subword_force (op0, i, mode),
                              operand_subword_force (op1, i, mode),
                              EQ, 0, word_mode, NULL_RTX,
-			     if_false_label, NULL_RTX);
+			     if_false_label, NULL_RTX, prob);
 
   if (if_true_label)
     emit_jump (if_true_label);
@@ -749,13 +780,14 @@
    with one insn, test the comparison and jump to the appropriate label.  */
 
 static void
-do_jump_by_parts_equality (tree exp, rtx if_false_label, rtx if_true_label)
+do_jump_by_parts_equality (tree exp, rtx if_false_label, rtx if_true_label,
+			   int prob)
 {
   rtx op0 = expand_normal (TREE_OPERAND (exp, 0));
   rtx op1 = expand_normal (TREE_OPERAND (exp, 1));
   enum machine_mode mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));
   do_jump_by_parts_equality_rtx (mode, op0, op1, if_false_label,
-				 if_true_label);
+				 if_true_label, prob);
 }
 
 /* Generate code for a comparison of OP0 and OP1 with rtx code CODE.
@@ -825,7 +857,7 @@
 void
 do_compare_rtx_and_jump (rtx op0, rtx op1, enum rtx_code code, int unsignedp,
 			 enum machine_mode mode, rtx size, rtx if_false_label,
-			 rtx if_true_label)
+			 rtx if_true_label, int prob)
 {
   rtx tem;
   int dummy_true_label = 0;
@@ -837,6 +869,7 @@
       if_true_label = if_false_label;
       if_false_label = 0;
       code = reverse_condition (code);
+      prob = inv (prob);
     }
 
   /* If one operand is constant, make it the second one.  Only do this
@@ -886,52 +919,56 @@
 	{
 	case LTU:
 	  do_jump_by_parts_greater_rtx (mode, 1, op1, op0,
-					if_false_label, if_true_label);
+					if_false_label, if_true_label, prob);
 	  break;
 
 	case LEU:
 	  do_jump_by_parts_greater_rtx (mode, 1, op0, op1,
-					if_true_label, if_false_label);
+					if_true_label, if_false_label,
+					inv (prob));
 	  break;
 
 	case GTU:
 	  do_jump_by_parts_greater_rtx (mode, 1, op0, op1,
-					if_false_label, if_true_label);
+					if_false_label, if_true_label, prob);
 	  break;
 
 	case GEU:
 	  do_jump_by_parts_greater_rtx (mode, 1, op1, op0,
-					if_true_label, if_false_label);
+					if_true_label, if_false_label,
+					inv (prob));
 	  break;
 
 	case LT:
 	  do_jump_by_parts_greater_rtx (mode, 0, op1, op0,
-					if_false_label, if_true_label);
+					if_false_label, if_true_label, prob);
 	  break;
 
 	case LE:
 	  do_jump_by_parts_greater_rtx (mode, 0, op0, op1,
-					if_true_label, if_false_label);
+					if_true_label, if_false_label,
+					inv (prob));
 	  break;
 
 	case GT:
 	  do_jump_by_parts_greater_rtx (mode, 0, op0, op1,
-					if_false_label, if_true_label);
+					if_false_label, if_true_label, prob);
 	  break;
 
 	case GE:
 	  do_jump_by_parts_greater_rtx (mode, 0, op1, op0,
-					if_true_label, if_false_label);
+					if_true_label, if_false_label,
+					inv (prob));
 	  break;
 
 	case EQ:
 	  do_jump_by_parts_equality_rtx (mode, op0, op1, if_false_label,
-					 if_true_label);
+					 if_true_label, prob);
 	  break;
 
 	case NE:
 	  do_jump_by_parts_equality_rtx (mode, op0, op1, if_true_label,
-					 if_false_label);
+					 if_false_label, inv (prob));
 	  break;
 
 	default:
@@ -939,8 +976,32 @@
 	}
     }
   else
-    emit_cmp_and_jump_insns (op0, op1, code, size, mode, unsignedp,
-			     if_true_label);
+    {
+      rtx last = get_last_insn ();
+      emit_cmp_and_jump_insns (op0, op1, code, size, mode, unsignedp,
+			       if_true_label);
+      if (prob != -1 && profile_status != PROFILE_ABSENT)
+       {
+	 for (last = NEXT_INSN (last);
+	      last && NEXT_INSN (last);
+	      last = NEXT_INSN (last))
+	   if (JUMP_P (last))
+	     break;
+	 if (!last
+	     || !JUMP_P (last)
+	     || NEXT_INSN (last)
+	     || !any_condjump_p (last))
+	   {
+	     if (dump_file)
+	       fprintf (dump_file, "Failed to add probability note\n");
+	   }
+	 else
+	   {
+	     gcc_assert (!find_reg_note (last, REG_BR_PROB, 0));
+	     add_reg_note (last, REG_BR_PROB, GEN_INT (prob));
+	   }
+       }
+    }
 
   if (if_false_label)
     emit_jump (if_false_label);
@@ -961,7 +1022,7 @@
 static void
 do_compare_and_jump (tree exp, enum rtx_code signed_code,
 		     enum rtx_code unsigned_code, rtx if_false_label,
-		     rtx if_true_label)
+		     rtx if_true_label, int prob)
 {
   rtx op0, op1;
   tree type;
@@ -1022,7 +1083,7 @@
   do_compare_rtx_and_jump (op0, op1, code, unsignedp, mode,
                            ((mode == BLKmode)
                             ? expr_size (TREE_OPERAND (exp, 0)) : NULL_RTX),
-                           if_false_label, if_true_label);
+                           if_false_label, if_true_label, prob);
 }
 
 #include "gt-dojump.h"
Index: gcc/ipa-inline.c
===================================================================
--- gcc/ipa-inline.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/ipa-inline.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1418,7 +1418,10 @@
     }
 
   /* Now do the automatic inlining.  */
-  if (mode != INLINE_ALL && mode != INLINE_ALWAYS_INLINE)
+  if (mode != INLINE_ALL && mode != INLINE_ALWAYS_INLINE
+      /* Never inline regular functions into always-inline functions
+	 during incremental inlining.  */
+      && !node->local.disregard_inline_limits)
     for (e = node->callees; e; e = e->next_callee)
       {
 	if (!e->callee->local.inlinable
@@ -1606,17 +1609,17 @@
   node->global.stack_frame_offset = 0;
 
   /* Can this function be inlined at all?  */
-  node->local.inlinable = tree_inlinable_function_p (current_function_decl);
+  node->local.inlinable = tree_inlinable_function_p (node->decl);
 
   /* Estimate the number of instructions for this function.
      ??? At -O0 we don't use this information except for the dumps, and
 	 even then only for always_inline functions.  But disabling this
 	 causes ICEs in the inline heuristics...  */
   inline_summary (node)->self_insns
-      = estimate_num_insns_fn (current_function_decl, &eni_inlining_weights);
+      = estimate_num_insns_fn (node->decl, &eni_inlining_weights);
   if (node->local.inlinable && !node->local.disregard_inline_limits)
     node->local.disregard_inline_limits
-      = DECL_DISREGARD_INLINE_LIMITS (current_function_decl);
+      = DECL_DISREGARD_INLINE_LIMITS (node->decl);
 
   /* Inlining characteristics are maintained by the cgraph_mark_inline.  */
   node->global.insns = inline_summary (node)->self_insns;
Index: gcc/dwarf2out.c
===================================================================
--- gcc/dwarf2out.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/dwarf2out.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -13222,7 +13222,9 @@
   int i;
 
   for (i = VEC_length (tree, incomplete_types) - 1; i >= 0; i--)
-    gen_type_die (VEC_index (tree, incomplete_types, i), comp_unit_die);
+    if (should_emit_struct_debug (VEC_index (tree, incomplete_types, i),
+				  DINFO_USAGE_DIR_USE))
+      gen_type_die (VEC_index (tree, incomplete_types, i), comp_unit_die);
 }
 
 /* Determine what tag to use for a record type.  */
Index: gcc/expr.c
===================================================================
--- gcc/expr.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/expr.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -4483,7 +4483,7 @@
 
       do_pending_stack_adjust ();
       NO_DEFER_POP;
-      jumpifnot (TREE_OPERAND (exp, 0), lab1);
+      jumpifnot (TREE_OPERAND (exp, 0), lab1, -1);
       store_expr (TREE_OPERAND (exp, 1), target, call_param_p,
 		  nontemporal);
       emit_jump_insn (gen_jump (lab2));
@@ -5503,7 +5503,7 @@
 		    /* Generate a conditional jump to exit the loop.  */
 		    exit_cond = build2 (LT_EXPR, integer_type_node,
 					index, hi_index);
-		    jumpif (exit_cond, loop_end);
+		    jumpif (exit_cond, loop_end, -1);
 
 		    /* Update the loop counter, and jump to the head of
 		       the loop.  */
@@ -8974,7 +8974,8 @@
 
 	temp = gen_label_rtx ();
 	do_compare_rtx_and_jump (target, cmpop1, comparison_code,
-				 unsignedp, mode, NULL_RTX, NULL_RTX, temp);
+				 unsignedp, mode, NULL_RTX, NULL_RTX, temp,
+				 -1);
       }
       emit_move_insn (target, op1);
       emit_label (temp);
@@ -9125,7 +9126,7 @@
 	emit_move_insn (target, const0_rtx);
 
       op1 = gen_label_rtx ();
-      jumpifnot (exp, op1);
+      jumpifnot (exp, op1, -1);
 
       if (target)
 	emit_move_insn (target, const1_rtx);
@@ -9194,7 +9195,7 @@
        NO_DEFER_POP;
        op0 = gen_label_rtx ();
        op1 = gen_label_rtx ();
-       jumpifnot (TREE_OPERAND (exp, 0), op0);
+       jumpifnot (TREE_OPERAND (exp, 0), op0, -1);
        store_expr (TREE_OPERAND (exp, 1), temp,
  		  modifier == EXPAND_STACK_PARM,
 		  false);
@@ -9240,7 +9241,7 @@
 	    int value = TREE_CODE (rhs) == BIT_IOR_EXPR;
 	    do_jump (TREE_OPERAND (rhs, 1),
 		     value ? label : 0,
-		     value ? 0 : label);
+		     value ? 0 : label, -1);
 	    expand_assignment (lhs, build_int_cst (TREE_TYPE (rhs), value),
 			       MOVE_NONTEMPORAL (exp));
 	    do_pending_stack_adjust ();
@@ -9924,7 +9925,7 @@
   emit_move_insn (target, invert ? const0_rtx : const1_rtx);
   label = gen_label_rtx ();
   do_compare_rtx_and_jump (op0, op1, code, unsignedp, operand_mode, NULL_RTX,
-			   NULL_RTX, label);
+			   NULL_RTX, label, -1);
 
   emit_move_insn (target, invert ? const1_rtx : const0_rtx);
   emit_label (label);
Index: gcc/expr.h
===================================================================
--- gcc/expr.h	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/expr.h	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,6 +1,6 @@
 /* Definitions for code generation pass of GNU compiler.
    Copyright (C) 1987, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
    Free Software Foundation, Inc.
 
 This file is part of GCC.
@@ -564,20 +564,20 @@
 extern tree string_constant (tree, tree *);
 
 /* Generate code to evaluate EXP and jump to LABEL if the value is zero.  */
-extern void jumpifnot (tree, rtx);
+extern void jumpifnot (tree, rtx, int);
 
 /* Generate code to evaluate EXP and jump to LABEL if the value is nonzero.  */
-extern void jumpif (tree, rtx);
+extern void jumpif (tree, rtx, int);
 
 /* Generate code to evaluate EXP and jump to IF_FALSE_LABEL if
    the result is zero, or IF_TRUE_LABEL if the result is one.  */
-extern void do_jump (tree, rtx, rtx);
+extern void do_jump (tree, rtx, rtx, int);
 
 /* Generate rtl to compare two rtx's, will call emit_cmp_insn.  */
 extern rtx compare_from_rtx (rtx, rtx, enum rtx_code, int, enum machine_mode,
 			     rtx);
 extern void do_compare_rtx_and_jump (rtx, rtx, enum rtx_code, int,
-				     enum machine_mode, rtx, rtx, rtx);
+				     enum machine_mode, rtx, rtx, rtx, int);
 
 /* Two different ways of generating switch statements.  */
 extern int try_casesi (tree, tree, tree, tree, rtx, rtx, rtx);
Index: gcc/ada/ChangeLog
===================================================================
--- gcc/ada/ChangeLog	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/ada/ChangeLog	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,3 +1,10 @@
+2010-02-27  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR ada/42253
+	* gcc-interface/utils2.c (build_binary_op) <EQ_EXPR>: Assert that fat
+	pointer base types are variant of each other.  Apply special treatment
+	for null to fat pointer types in all cases.
+
 2010-01-21  Release Manager
 
 	* GCC 4.4.3 released.
Index: gcc/ada/gcc-interface/utils2.c
===================================================================
--- gcc/ada/gcc-interface/utils2.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/ada/gcc-interface/utils2.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -879,26 +879,28 @@
 	  return result;
 	}
 
-      /* Otherwise, the base types must be the same unless the objects are
-	 fat pointers or records.  If we have records, use the best type and
-	 convert both operands to that type.  */
+      /* Otherwise, the base types must be the same, unless they are both fat
+	 pointer types or record types.  In the latter case, use the best type
+	 and convert both operands to that type.  */
       if (left_base_type != right_base_type)
 	{
 	  if (TYPE_FAT_POINTER_P (left_base_type)
-	      && TYPE_FAT_POINTER_P (right_base_type)
-	      && TYPE_MAIN_VARIANT (left_base_type)
-		 == TYPE_MAIN_VARIANT (right_base_type))
-	    best_type = left_base_type;
+	      && TYPE_FAT_POINTER_P (right_base_type))
+	    {
+	      gcc_assert (TYPE_MAIN_VARIANT (left_base_type)
+			  == TYPE_MAIN_VARIANT (right_base_type));
+	      best_type = left_base_type;
+	    }
+
 	  else if (TREE_CODE (left_base_type) == RECORD_TYPE
 		   && TREE_CODE (right_base_type) == RECORD_TYPE)
 	    {
-	      /* The only way these are permitted to be the same is if both
-		 types have the same name.  In that case, one of them must
-		 not be self-referential.  Use that one as the best type.
-		 Even better is if one is of fixed size.  */
+	      /* The only way this is permitted is if both types have the same
+		 name.  In that case, one of them must not be self-referential.
+		 Use it as the best type.  Even better with a fixed size.  */
 	      gcc_assert (TYPE_NAME (left_base_type)
-			  && (TYPE_NAME (left_base_type)
-			      == TYPE_NAME (right_base_type)));
+			  && TYPE_NAME (left_base_type)
+			     == TYPE_NAME (right_base_type));
 
 	      if (TREE_CONSTANT (TYPE_SIZE (left_base_type)))
 		best_type = left_base_type;
@@ -911,34 +913,34 @@
 	      else
 		gcc_unreachable ();
 	    }
+
 	  else
 	    gcc_unreachable ();
 
 	  left_operand = convert (best_type, left_operand);
 	  right_operand = convert (best_type, right_operand);
 	}
-
-      /* If we are comparing a fat pointer against zero, we need to
-	 just compare the data pointer.  */
-      else if (TYPE_FAT_POINTER_P (left_base_type)
-	       && TREE_CODE (right_operand) == CONSTRUCTOR
-	       && integer_zerop (VEC_index (constructor_elt,
-					    CONSTRUCTOR_ELTS (right_operand),
-					    0)
-				 ->value))
-	{
-	  right_operand = build_component_ref (left_operand, NULL_TREE,
-					       TYPE_FIELDS (left_base_type),
-					       false);
-	  left_operand = convert (TREE_TYPE (right_operand),
-				  integer_zero_node);
-	}
       else
 	{
 	  left_operand = convert (left_base_type, left_operand);
 	  right_operand = convert (right_base_type, right_operand);
 	}
 
+      /* If we are comparing a fat pointer against zero, we just need to
+	 compare the data pointer.  */
+      if (TYPE_FAT_POINTER_P (left_base_type)
+	  && TREE_CODE (right_operand) == CONSTRUCTOR
+	  && integer_zerop (VEC_index (constructor_elt,
+				       CONSTRUCTOR_ELTS (right_operand),
+				       0)->value))
+	{
+	  left_operand
+	    = build_component_ref (left_operand, NULL_TREE,
+				   TYPE_FIELDS (left_base_type), false);
+	  right_operand
+	    = convert (TREE_TYPE (left_operand), integer_zero_node);
+	}
+
       modulus = NULL_TREE;
       break;
 
Index: gcc/dse.c
===================================================================
--- gcc/dse.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/dse.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1015,9 +1015,6 @@
 {
   switch (GET_CODE (x))
     {
-    case MEM:
-      return MEM_READONLY_P (x);
-
     case CONST:
     case CONST_INT:
     case CONST_DOUBLE:
Index: gcc/c-decl.c
===================================================================
--- gcc/c-decl.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/c-decl.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,6 +1,6 @@
 /* Process declarations and variables for C compiler.
    Copyright (C) 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
-   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
+   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
    Free Software Foundation, Inc.
 
 This file is part of GCC.
@@ -3735,7 +3735,8 @@
   tree complit;
   tree stmt;
 
-  if (type == error_mark_node)
+  if (type == error_mark_node
+      || init == error_mark_node)
     return error_mark_node;
 
   decl = build_decl (VAR_DECL, NULL_TREE, type);
@@ -5255,6 +5256,11 @@
 	     type itself.  FUNCTION_DECLs appear when there is an implicit
 	     function declaration in the parameter list.  */
 
+	  /* When we reinsert this decl in the function body, we need
+	     to reconstruct whether it was marked as nested.  */
+	  gcc_assert (TREE_CODE (decl) == FUNCTION_DECL
+		      ? b->nested
+		      : !b->nested);
 	  TREE_CHAIN (decl) = others;
 	  others = decl;
 	  /* fall through */
@@ -6372,7 +6378,8 @@
       DECL_CONTEXT (decl) = current_function_decl;
       if (DECL_NAME (decl))
 	bind (DECL_NAME (decl), decl, current_scope,
-	      /*invisible=*/false, /*nested=*/false);
+	      /*invisible=*/false,
+	      /*nested=*/(TREE_CODE (decl) == FUNCTION_DECL));
     }
 
   /* And all the tag declarations.  */
Index: gcc/fortran/trans-expr.c
===================================================================
--- gcc/fortran/trans-expr.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/fortran/trans-expr.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -2118,8 +2118,8 @@
    an actual argument derived type array is copied and then returned
    after the function call.  */
 void
-gfc_conv_subref_array_arg (gfc_se * parmse, gfc_expr * expr,
-			   int g77, sym_intent intent)
+gfc_conv_subref_array_arg (gfc_se * parmse, gfc_expr * expr, int g77,
+			   sym_intent intent, bool formal_ptr)
 {
   gfc_se lse;
   gfc_se rse;
@@ -2132,8 +2132,10 @@
   tree tmp_index;
   tree tmp;
   tree base_type;
+  tree size;
   stmtblock_t body;
   int n;
+  int dimen;
 
   gcc_assert (expr->expr_type == EXPR_VARIABLE);
 
@@ -2262,9 +2264,10 @@
      outside the innermost loop, so the overall transfer could be
      optimized further.  */
   info = &rse.ss->data.info;
+  dimen = info->dimen;
 
   tmp_index = gfc_index_zero_node;
-  for (n = info->dimen - 1; n > 0; n--)
+  for (n = dimen - 1; n > 0; n--)
     {
       tree tmp_str;
       tmp = rse.loop->loopvar[n];
@@ -2324,6 +2327,38 @@
   if (expr->ts.type == BT_CHARACTER)
     parmse->string_length = expr->ts.cl->backend_decl;
 
+  /* Determine the offset for pointer formal arguments and set the
+     lbounds to one.  */
+  if (formal_ptr)
+    {
+      size = gfc_index_one_node;
+      offset = gfc_index_zero_node;  
+      for (n = 0; n < dimen; n++)
+	{
+	  tmp = gfc_conv_descriptor_ubound (parmse->expr,
+					    gfc_rank_cst[n]);
+	  gfc_add_modify (&parmse->pre, tmp,
+			  fold_build2 (PLUS_EXPR, gfc_array_index_type,
+				       tmp, gfc_index_one_node));
+	  tmp = gfc_conv_descriptor_lbound (parmse->expr,
+					    gfc_rank_cst[n]);
+	  gfc_add_modify (&parmse->pre, tmp, gfc_index_one_node);
+	  size = gfc_evaluate_now (size, &parmse->pre);
+	  offset = fold_build2 (MINUS_EXPR, gfc_array_index_type,
+				offset, size);
+	  offset = gfc_evaluate_now (offset, &parmse->pre);
+	  tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,
+			     rse.loop->to[n], rse.loop->from[n]);
+	  tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,
+			     tmp, gfc_index_one_node);
+	  size = fold_build2 (MULT_EXPR, gfc_array_index_type,
+			      size, tmp);
+	}
+
+      tmp = gfc_conv_descriptor_offset (parmse->expr);
+      gfc_add_modify (&parmse->pre, tmp, offset);
+    }
+
   /* We want either the address for the data or the address of the descriptor,
      depending on the mode of passing array arguments.  */
   if (g77)
@@ -2666,7 +2701,8 @@
 		   is converted to a temporary, which is passed and then
 		   written back after the procedure call.  */
 		gfc_conv_subref_array_arg (&parmse, e, f,
-			fsym ? fsym->attr.intent : INTENT_INOUT);
+				fsym ? fsym->attr.intent : INTENT_INOUT,
+				fsym && fsym->attr.pointer);
 	      else
 	        gfc_conv_array_parameter (&parmse, e, argss, f, fsym,
 					  sym->name);
@@ -3518,6 +3554,150 @@
 }
 
 
+static tree
+gfc_trans_alloc_subarray_assign (tree dest, gfc_component * cm,
+				 gfc_expr * expr)
+{
+  gfc_se se;
+  gfc_ss *rss;
+  stmtblock_t block;
+  tree offset;
+  int n;
+  tree tmp;
+  tree tmp2;
+  gfc_array_spec *as;
+  gfc_expr *arg = NULL;
+
+  gfc_start_block (&block);
+  gfc_init_se (&se, NULL);
+
+  /* Get the descriptor for the expressions.  */ 
+  rss = gfc_walk_expr (expr);
+  se.want_pointer = 0;
+  gfc_conv_expr_descriptor (&se, expr, rss);
+  gfc_add_block_to_block (&block, &se.pre);
+  gfc_add_modify (&block, dest, se.expr);
+
+  /* Deal with arrays of derived types with allocatable components.  */
+  if (cm->ts.type == BT_DERIVED
+	&& cm->ts.derived->attr.alloc_comp)
+    tmp = gfc_copy_alloc_comp (cm->ts.derived,
+			       se.expr, dest,
+			       cm->as->rank);
+  else
+    tmp = gfc_duplicate_allocatable (dest, se.expr,
+				     TREE_TYPE(cm->backend_decl),
+				     cm->as->rank);
+
+  gfc_add_expr_to_block (&block, tmp);
+  gfc_add_block_to_block (&block, &se.post);
+
+  if (expr->expr_type != EXPR_VARIABLE)
+    gfc_conv_descriptor_data_set (&block, se.expr,
+				  null_pointer_node);
+
+  /* We need to know if the argument of a conversion function is a
+     variable, so that the correct lower bound can be used.  */
+  if (expr->expr_type == EXPR_FUNCTION
+	&& expr->value.function.isym
+	&& expr->value.function.isym->conversion
+	&& expr->value.function.actual->expr
+	&& expr->value.function.actual->expr->expr_type == EXPR_VARIABLE)
+    arg = expr->value.function.actual->expr;
+
+  /* Obtain the array spec of full array references.  */
+  if (arg)
+    as = gfc_get_full_arrayspec_from_expr (arg);
+  else
+    as = gfc_get_full_arrayspec_from_expr (expr);
+
+  /* Shift the lbound and ubound of temporaries to being unity,
+     rather than zero, based. Always calculate the offset.  */
+  offset = gfc_conv_descriptor_offset (dest);
+  gfc_add_modify (&block, offset, gfc_index_zero_node);
+  tmp2 =gfc_create_var (gfc_array_index_type, NULL);
+
+  for (n = 0; n < expr->rank; n++)
+    {
+      tree span;
+      tree lbound;
+      tree ubound;
+
+      /* Obtain the correct lbound - ISO/IEC TR 15581:2001 page 9.
+	 TODO It looks as if gfc_conv_expr_descriptor should return
+	 the correct bounds and that the following should not be
+	 necessary.  This would simplify gfc_conv_intrinsic_bound
+	 as well.  */
+      if (as && as->lower[n])
+	{
+	  gfc_se lbse;
+	  gfc_init_se (&lbse, NULL);
+	  gfc_conv_expr (&lbse, as->lower[n]);
+	  gfc_add_block_to_block (&block, &lbse.pre);
+	  lbound = gfc_evaluate_now (lbse.expr, &block);
+	}
+      else if (as && arg)
+	{
+	  tmp = gfc_get_symbol_decl (arg->symtree->n.sym);
+	  lbound = gfc_conv_descriptor_lbound (tmp, gfc_rank_cst[n]);
+	}
+      else if (as)
+	lbound = gfc_conv_descriptor_lbound (dest, gfc_rank_cst[n]);
+      else
+	lbound = gfc_index_one_node;
+
+      lbound = fold_convert (gfc_array_index_type, lbound);
+
+      /* Shift the bounds and set the offset accordingly.  */
+      tmp = gfc_conv_descriptor_ubound (dest, gfc_rank_cst[n]);
+      span = fold_build2 (MINUS_EXPR, gfc_array_index_type, tmp,
+		gfc_conv_descriptor_lbound (dest, gfc_rank_cst[n]));
+
+      ubound = fold_build2 (PLUS_EXPR, gfc_array_index_type,
+			    span, lbound);
+      gfc_add_modify (&block, tmp, ubound);
+
+      tmp = gfc_conv_descriptor_lbound (dest, gfc_rank_cst[n]);
+      gfc_add_modify (&block, tmp, lbound);
+
+      tmp = fold_build2 (MULT_EXPR, gfc_array_index_type,
+		gfc_conv_descriptor_lbound (dest, gfc_rank_cst[n]),
+		gfc_conv_descriptor_stride (dest, gfc_rank_cst[n]));
+
+      gfc_add_modify (&block, tmp2, tmp);
+      tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,
+			 offset, tmp2);
+      gfc_add_modify (&block, offset, tmp);
+    }
+
+  if (arg)
+    {
+      /* If a conversion expression has a null data pointer
+	 argument, nullify the allocatable component.  */
+      tree non_null_expr;
+      tree null_expr;
+
+      if (arg->symtree->n.sym->attr.allocatable
+	    || arg->symtree->n.sym->attr.pointer)
+	{
+	  non_null_expr = gfc_finish_block (&block);
+	  gfc_start_block (&block);
+	  gfc_conv_descriptor_data_set (&block, dest,
+					null_pointer_node);
+	  null_expr = gfc_finish_block (&block);
+	  tmp = gfc_conv_descriptor_data_get (arg->symtree->n.sym->backend_decl);
+	  tmp = build2 (EQ_EXPR, boolean_type_node, tmp,
+			fold_convert (TREE_TYPE (tmp),
+				      null_pointer_node));
+	  return build3_v (COND_EXPR, tmp,
+			   null_expr, non_null_expr);
+	}
+    }
+
+  return gfc_finish_block (&block);
+}
+
+
 /* Assign a single component of a derived type constructor.  */
 
 static tree
@@ -3528,8 +3708,6 @@
   gfc_ss *rss;
   stmtblock_t block;
   tree tmp;
-  tree offset;
-  int n;
 
   gfc_start_block (&block);
 
@@ -3569,91 +3747,8 @@
  	gfc_conv_descriptor_data_set (&block, dest, null_pointer_node);
       else if (cm->attr.allocatable)
 	{
-	  tree tmp2;
-
-          gfc_init_se (&se, NULL);
- 
-	  rss = gfc_walk_expr (expr);
-	  se.want_pointer = 0;
-	  gfc_conv_expr_descriptor (&se, expr, rss);
-	  gfc_add_block_to_block (&block, &se.pre);
-
-	  tmp = fold_convert (TREE_TYPE (dest), se.expr);
-	  gfc_add_modify (&block, dest, tmp);
-
-	  if (cm->ts.type == BT_DERIVED && cm->ts.derived->attr.alloc_comp)
-	    tmp = gfc_copy_alloc_comp (cm->ts.derived, se.expr, dest,
-				       cm->as->rank);
-	  else
-	    tmp = gfc_duplicate_allocatable (dest, se.expr,
-					     TREE_TYPE(cm->backend_decl),
-					     cm->as->rank);
-
+	  tmp = gfc_trans_alloc_subarray_assign (dest, cm, expr);
 	  gfc_add_expr_to_block (&block, tmp);
-	  gfc_add_block_to_block (&block, &se.post);
-
-	  if (expr->expr_type != EXPR_VARIABLE)
-	    gfc_conv_descriptor_data_set (&block, se.expr, null_pointer_node);
-
-	  /* Shift the lbound and ubound of temporaries to being unity, rather
-	     than zero, based.  Calculate the offset for all cases.  */
-	  offset = gfc_conv_descriptor_offset (dest);
-	  gfc_add_modify (&block, offset, gfc_index_zero_node);
-	  tmp2 =gfc_create_var (gfc_array_index_type, NULL);
-	  for (n = 0; n < expr->rank; n++)
-	    {
-	      if (expr->expr_type != EXPR_VARIABLE
-		    && expr->expr_type != EXPR_CONSTANT)
-		{
-		  tree span;
-		  tmp = gfc_conv_descriptor_ubound (dest, gfc_rank_cst[n]);
-		  span = fold_build2 (MINUS_EXPR, gfc_array_index_type, tmp,
-			    gfc_conv_descriptor_lbound (dest, gfc_rank_cst[n]));
-		  gfc_add_modify (&block, tmp,
-				       fold_build2 (PLUS_EXPR,
-						    gfc_array_index_type,
-						    span, gfc_index_one_node));
-		  tmp = gfc_conv_descriptor_lbound (dest, gfc_rank_cst[n]);
-		  gfc_add_modify (&block, tmp, gfc_index_one_node);
-		}
-	      tmp = fold_build2 (MULT_EXPR, gfc_array_index_type,
-				 gfc_conv_descriptor_lbound (dest,
-							     gfc_rank_cst[n]),
-				 gfc_conv_descriptor_stride (dest,
-							     gfc_rank_cst[n]));
-	      gfc_add_modify (&block, tmp2, tmp);
-	      tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type, offset, tmp2);
-	      gfc_add_modify (&block, offset, tmp);
-	    }
-
-	  if (expr->expr_type == EXPR_FUNCTION
-		&& expr->value.function.isym
-		&& expr->value.function.isym->conversion
-		&& expr->value.function.actual->expr
-		&& expr->value.function.actual->expr->expr_type
-						== EXPR_VARIABLE)
-	    {
-	      /* If a conversion expression has a null data pointer
-		 argument, nullify the allocatable component.  */
-	      gfc_symbol *s;
-	      tree non_null_expr;
-	      tree null_expr;
-	      s = expr->value.function.actual->expr->symtree->n.sym;
-	      if (s->attr.allocatable || s->attr.pointer)
-		{
-		  non_null_expr = gfc_finish_block (&block);
-		  gfc_start_block (&block);
-		  gfc_conv_descriptor_data_set (&block, dest,
-						null_pointer_node);
-		  null_expr = gfc_finish_block (&block);
-		  tmp = gfc_conv_descriptor_data_get (s->backend_decl);
-		  tmp = build2 (EQ_EXPR, boolean_type_node, tmp,
-			        fold_convert (TREE_TYPE (tmp),
-					      null_pointer_node));
-		  return build3_v (COND_EXPR, tmp, null_expr,
-				   non_null_expr);
-		}
-	    }
 	}
       else
 	{
Index: gcc/fortran/symbol.c
===================================================================
--- gcc/fortran/symbol.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/fortran/symbol.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -4237,6 +4237,8 @@
   new_symtree->n.sym->module = gfc_get_string (old_sym->module);
   new_symtree->n.sym->from_intmod = old_sym->from_intmod;
   new_symtree->n.sym->intmod_sym_id = old_sym->intmod_sym_id;
+  if (old_sym->attr.function)
+    new_symtree->n.sym->result = new_symtree->n.sym;
   /* Build the formal arg list.  */
   build_formal_args (new_symtree->n.sym, old_sym, add_optional_arg);
 
Index: gcc/fortran/decl.c
===================================================================
--- gcc/fortran/decl.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/fortran/decl.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,5 +1,5 @@
 /* Declaration statement matcher
-   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008
+   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008, 2009, 2010
    Free Software Foundation, Inc.
    Contributed by Andy Vaught
 
@@ -6597,10 +6597,9 @@
 
   if (initializer == NULL || initializer->ts.type != BT_INTEGER)
     {
-      gfc_error("ENUMERATOR %L not initialized with integer expression",
-		&var_locus);
+      gfc_error ("ENUMERATOR %L not initialized with integer expression",
+		 &var_locus);
       m = MATCH_ERROR;
-      gfc_free_enum_history ();
       goto cleanup;
     }
 
@@ -6666,7 +6665,10 @@
     {
       m = enumerator_decl ();
       if (m == MATCH_ERROR)
-	goto cleanup;
+	{
+	  gfc_free_enum_history ();
+	  goto cleanup;
+	}
       if (m == MATCH_NO)
 	break;
 
Index: gcc/fortran/gfortran.h
===================================================================
--- gcc/fortran/gfortran.h	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/fortran/gfortran.h	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -2450,6 +2450,8 @@
 gfc_expr *gfc_default_initializer (gfc_typespec *);
 gfc_expr *gfc_get_variable_expr (gfc_symtree *);
 
+gfc_array_spec *gfc_get_full_arrayspec_from_expr (gfc_expr *expr);
+
 bool gfc_traverse_expr (gfc_expr *, gfc_symbol *,
 			bool (*)(gfc_expr *, gfc_symbol *, int*),
 			int);
Index: gcc/fortran/ChangeLog
===================================================================
--- gcc/fortran/ChangeLog	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/fortran/ChangeLog	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,3 +1,79 @@
+2010-03-11  Tobias Burnus  <burnus@net-b.de
+
+	PR fortran/43303
+	* symbol.c (get_iso_c_sym): Set sym->result.
+
+2010-02-16  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/41869
+	* module.c (fix_mio_expr): Fix for private generic procedures.
+
+2010-02-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/43030
+	* resolve.c (gfc_resolve_dim_arg): Call gfc_clear_ts.
+
+	PR fortran/43029
+	* decl.c (enumerator_decl): Don't call gfc_free_enum_history
+	here.
+	(gfc_match_enumerator_def): But here whenever enumerator_decl returns
+	MATCH_ERROR.
+
+2010-02-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/42309
+	* trans-expr.c (gfc_conv_subref_array_arg): Avoid accessing
+	info->dimen after info has been freed.
+
+2010-02-06  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/42309
+	* trans-expr.c (gfc_conv_subref_array_arg): Add new argument
+	'formal_ptr'. If this is true, give returned descriptor unity
+	lbounds, in all dimensions, and the appropriate offset.
+	(gfc_conv_procedure_call); If formal is a pointer, set the last
+	argument of gfc_conv_subref_array_arg to true.
+	* trans.h : Add last argument for gfc_conv_subref_array_arg.
+	* trans-io.c (set_internal_unit, gfc_trans_transfer): Set the
+	new arg of gfc_conv_subref_array_arg to false.
+	* trans-stmt.c (forall_make_variable_temp): The same.
+
+2010-02-02  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/42650
+	* parse.c (decode_specification_statement): Use sym->result not sym.
+
+2010-01-31  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/38324
+	* expr.c (gfc_get_full_arrayspec_from_expr): New function.
+	* gfortran.h : Add prototype for above.
+	* trans-expr.c (gfc_trans_alloc_subarray_assign): New function.
+	(gfc_trans_subcomponent_assign): Call new function to replace
+	the code to deal with allocatable components.
+	* trans-intrinsic.c (gfc_conv_intrinsic_bound): Call
+	gfc_get_full_arrayspec_from_expr to replace existing code.
+
+2010-01-30  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/41044
+	PR fortran/41167
+	* expr.c (remove_subobject_ref): If the constructor is NULL use
+	the expression as the source.
+	(simplify_const_ref): Change the type of expression if
+	there are component references.  Allow for substring to be at
+	the end of an arbitrarily long chain of references.  If an
+	element is found that is not in an EXPR_ARRAY, assume that this
+	is scalar initialization of array. Call remove_subobject_ref in
+	this case with NULL second argument.
+
+2010-01-27  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/42736
+	* trans-stmt.c (gfc_conv_elemental_dependencies): If temporary
+	is required, turn any trailing array elements after a range
+	into ranges so that offsets can be calculated.
+
 2010-01-21  Release Manager
 
 	* GCC 4.4.3 released.
Index: gcc/fortran/trans-stmt.c
===================================================================
--- gcc/fortran/trans-stmt.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/fortran/trans-stmt.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -212,6 +212,7 @@
   gfc_ss *ss;
   gfc_ss_info *info;
   gfc_symbol *fsym;
+  gfc_ref *ref;
   int n;
   tree data;
   tree offset;
@@ -267,6 +268,34 @@
 	  /* Obtain the argument descriptor for unpacking.  */
 	  gfc_init_se (&parmse, NULL);
 	  parmse.want_pointer = 1;
+
+	  /* The scalarizer introduces some specific peculiarities when
+	     handling elemental subroutines; the stride can be needed up to
+	     the dim_array - 1, rather than dim_loop - 1 to calculate
+	     offsets outside the loop.  For this reason, we make sure that
+	     the descriptor has the dimensionality of the array by converting
+	     trailing elements into ranges with end = start.  */
+	  for (ref = e->ref; ref; ref = ref->next)
+	    if (ref->type == REF_ARRAY && ref->u.ar.type == AR_SECTION)
+	      break;
+
+	  if (ref)
+	    {
+	      bool seen_range = false;
+	      for (n = 0; n < ref->u.ar.dimen; n++)
+		{
+		  if (ref->u.ar.dimen_type[n] == DIMEN_RANGE)
+		    seen_range = true;
+
+		  if (!seen_range
+			|| ref->u.ar.dimen_type[n] != DIMEN_ELEMENT)
+		    continue;
+
+		  ref->u.ar.end[n] = gfc_copy_expr (ref->u.ar.start[n]);
+		  ref->u.ar.dimen_type[n] = DIMEN_RANGE;
+		}
+	    }
+
 	  gfc_conv_expr_descriptor (&parmse, e, gfc_walk_expr (e));
 	  gfc_add_block_to_block (&se->pre, &parmse.pre);
 
@@ -1691,7 +1720,7 @@
   if (old_sym->attr.dimension)
     {
       gfc_init_se (&tse, NULL);
-      gfc_conv_subref_array_arg (&tse, e, 0, INTENT_IN);
+      gfc_conv_subref_array_arg (&tse, e, 0, INTENT_IN, false);
       gfc_add_block_to_block (pre, &tse.pre);
       gfc_add_block_to_block (post, &tse.post);
       tse.expr = build_fold_indirect_ref (tse.expr);
Index: gcc/fortran/expr.c
===================================================================
--- gcc/fortran/expr.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/fortran/expr.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1123,8 +1123,13 @@
 {
   gfc_expr *e;
 
-  e = cons->expr;
-  cons->expr = NULL;
+  if (cons)
+    {
+      e = cons->expr;
+      cons->expr = NULL;
+    }
+  else
+    e = gfc_copy_expr (p);
   e->ref = p->ref->next;
   p->ref->next =  NULL;
   gfc_replace_expr (p, e);
@@ -1428,6 +1433,7 @@
 {
   gfc_constructor *cons;
   gfc_expr *newp;
+  gfc_ref *last_ref;
 
   while (p->ref)
     {
@@ -1437,6 +1443,13 @@
 	  switch (p->ref->u.ar.type)
 	    {
 	    case AR_ELEMENT:
+	      /* <type/kind spec>, parameter :: x(<int>) = scalar_expr
+		 will generate this.  */
+	      if (p->expr_type != EXPR_ARRAY)
+		{
+		  remove_subobject_ref (p, NULL);
+		  break;
+		}
 	      if (find_array_element (p->value.constructor, &p->ref->u.ar,
 				      &cons) == FAILURE)
 		return FAILURE;
@@ -1466,18 +1479,25 @@
 			return FAILURE;
 		    }
 
-		  /* If this is a CHARACTER array and we possibly took a
-		     substring out of it, update the type-spec's character
-		     length according to the first element (as all should have
-		     the same length).  */
-		  if (p->ts.type == BT_CHARACTER)
+		  if (p->ts.type == BT_DERIVED
+			&& p->ref->next
+			&& p->value.constructor)
 		    {
-		      int string_len;
+		      /* There may have been component references.  */
+		      p->ts = p->value.constructor->expr->ts;
+		    }
 
-		      gcc_assert (p->ref->next);
-		      gcc_assert (!p->ref->next->next);
-		      gcc_assert (p->ref->next->type == REF_SUBSTRING);
+		  last_ref = p->ref;
+		  for (; last_ref->next; last_ref = last_ref->next) {};
 
+		  if (p->ts.type == BT_CHARACTER
+			&& last_ref->type == REF_SUBSTRING)
+		    {
+		      /* If this is a CHARACTER array and we possibly took
+			 a substring out of it, update the type-spec's
+			 character length according to the first element
+			 (as all should have the same length).  */
+		      int string_len;
 		      if (p->value.constructor)
 			{
 			  const gfc_expr* first = p->value.constructor->expr;
@@ -3327,6 +3347,58 @@
 }
 
 
+/* Returns the array_spec of a full array expression.  A NULL is
+   returned otherwise.  */
+gfc_array_spec *
+gfc_get_full_arrayspec_from_expr (gfc_expr *expr)
+{
+  gfc_array_spec *as;
+  gfc_ref *ref;
+
+  if (expr->rank == 0)
+    return NULL;
+
+  /* Follow any component references.  */
+  if (expr->expr_type == EXPR_VARIABLE
+      || expr->expr_type == EXPR_CONSTANT)
+    {
+      as = expr->symtree->n.sym->as;
+      for (ref = expr->ref; ref; ref = ref->next)
+	{
+	  switch (ref->type)
+	    {
+	    case REF_COMPONENT:
+	      as = ref->u.c.component->as;
+	      continue;
+
+	    case REF_SUBSTRING:
+	      continue;
+
+	    case REF_ARRAY:
+	      {
+		switch (ref->u.ar.type)
+		  {
+		  case AR_ELEMENT:
+		  case AR_SECTION:
+		  case AR_UNKNOWN:
+		    as = NULL;
+		    continue;
+
+		  case AR_FULL:
+		    break;
+		  }
+		break;
+	      }
+	    }
+	}
+    }
+  else
+    as = NULL;
+
+  return as;
+}
+
+
 /* General expression traversal function.  */
 
 bool
Index: gcc/fortran/module.c
===================================================================
--- gcc/fortran/module.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/fortran/module.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -2846,13 +2846,29 @@
     }
   else if (e->expr_type == EXPR_FUNCTION && e->value.function.name)
     {
+      gfc_symbol *sym;
+
       /* In some circumstances, a function used in an initialization
 	 expression, in one use associated module, can fail to be
 	 coupled to its symtree when used in a specification
 	 expression in another module.  */
+
       fname = e->value.function.esym ? e->value.function.esym->name
 				     : e->value.function.isym->name;
       e->symtree = gfc_find_symtree (gfc_current_ns->sym_root, fname);
+
+      if (e->symtree)
+	return;
+
+      /* This is probably a reference to a private procedure from another
+	 module.  To prevent a segfault, make a generic with no specific
+	 instances.  If this module is used, without the required
+	 specific coming from somewhere, the appropriate error message
+	 is issued.  */
+      gfc_get_symbol (fname, gfc_current_ns, &sym);
+      sym->attr.flavor = FL_PROCEDURE;
+      sym->attr.generic = 1;
+      e->symtree = gfc_find_symtree (gfc_current_ns->sym_root, fname);
     }
 }
 
Index: gcc/fortran/trans.h
===================================================================
--- gcc/fortran/trans.h	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/fortran/trans.h	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -314,7 +314,7 @@
 int gfc_conv_function_call (gfc_se *, gfc_symbol *, gfc_actual_arglist *,
 			    tree);
 
-void gfc_conv_subref_array_arg (gfc_se *, gfc_expr *, int, sym_intent);
+void gfc_conv_subref_array_arg (gfc_se *, gfc_expr *, int, sym_intent, bool);
 
 /* gfc_trans_* shouldn't call push/poplevel, use gfc_push/pop_scope */
 
Index: gcc/fortran/resolve.c
===================================================================
--- gcc/fortran/resolve.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/fortran/resolve.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,5 +1,5 @@
 /* Perform type resolution on the various structures.
-   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
+   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
    Free Software Foundation, Inc.
    Contributed by Andy Vaught
 
@@ -3722,6 +3722,7 @@
     {
       gfc_typespec ts;
 
+      gfc_clear_ts (&ts);
       ts.type = BT_INTEGER;
       ts.kind = gfc_index_integer_kind;
 
Index: gcc/fortran/trans-io.c
===================================================================
--- gcc/fortran/trans-io.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/fortran/trans-io.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -746,7 +746,7 @@
 	  /* Use a temporary for components of arrays of derived types
 	     or substring array references.  */
 	  gfc_conv_subref_array_arg (&se, e, 0,
-		last_dt == READ ? INTENT_IN : INTENT_OUT);
+		last_dt == READ ? INTENT_IN : INTENT_OUT, false);
 	  tmp = build_fold_indirect_ref (se.expr);
 	  se.expr = gfc_build_addr_expr (pchar_type_node, tmp);
 	  tmp = gfc_conv_descriptor_data_get (tmp);
@@ -2191,7 +2191,7 @@
 	  if (seen_vector && last_dt == READ)
 	    {
 	      /* Create a temp, read to that and copy it back.  */
-	      gfc_conv_subref_array_arg (&se, expr, 0, INTENT_OUT);
+	      gfc_conv_subref_array_arg (&se, expr, 0, INTENT_OUT, false);
 	      tmp =  se.expr;
 	    }
 	  else
Index: gcc/fortran/parse.c
===================================================================
--- gcc/fortran/parse.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/fortran/parse.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -110,7 +110,7 @@
   match ("import", gfc_match_import, ST_IMPORT);
   match ("use", gfc_match_use, ST_USE);
 
-  if (gfc_current_block ()->ts.type != BT_DERIVED)
+  if (gfc_current_block ()->result->ts.type != BT_DERIVED)
     goto end_of_block;
 
   match (NULL, gfc_match_st_function, ST_STATEMENT_FUNCTION);
Index: gcc/fortran/trans-intrinsic.c
===================================================================
--- gcc/fortran/trans-intrinsic.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/fortran/trans-intrinsic.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -832,7 +832,6 @@
   gfc_se argse;
   gfc_ss *ss;
   gfc_array_spec * as;
-  gfc_ref *ref;
 
   arg = expr->value.function.actual;
   arg2 = arg->next;
@@ -901,43 +900,8 @@
   ubound = gfc_conv_descriptor_ubound (desc, bound);
   lbound = gfc_conv_descriptor_lbound (desc, bound);
   
-  /* Follow any component references.  */
-  if (arg->expr->expr_type == EXPR_VARIABLE
-      || arg->expr->expr_type == EXPR_CONSTANT)
-    {
-      as = arg->expr->symtree->n.sym->as;
-      for (ref = arg->expr->ref; ref; ref = ref->next)
-	{
-	  switch (ref->type)
-	    {
-	    case REF_COMPONENT:
-	      as = ref->u.c.component->as;
-	      continue;
+  as = gfc_get_full_arrayspec_from_expr (arg->expr);
 
-	    case REF_SUBSTRING:
-	      continue;
-
-	    case REF_ARRAY:
-	      {
-		switch (ref->u.ar.type)
-		  {
-		  case AR_ELEMENT:
-		  case AR_SECTION:
-		  case AR_UNKNOWN:
-		    as = NULL;
-		    continue;
-
-		  case AR_FULL:
-		    break;
-		  }
-		break;
-	      }
-	    }
-	}
-    }
-  else
-    as = NULL;
-
   /* 13.14.53: Result value for LBOUND
 
      Case (i): For an array section or for an array expression other than a
Index: gcc/BASE-VER
===================================================================
--- gcc/BASE-VER	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/BASE-VER	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1 +1 @@
-4.4.3
+4.4.4
Index: gcc/tree-vect-analyze.c
===================================================================
--- gcc/tree-vect-analyze.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/tree-vect-analyze.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -3508,7 +3508,9 @@
       FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, gimple_op (stmt, 0))
 	if (vinfo_for_stmt (use_stmt)
 	    && !STMT_SLP_TYPE (vinfo_for_stmt (use_stmt))
-            && STMT_VINFO_RELEVANT (vinfo_for_stmt (use_stmt)))
+            && (STMT_VINFO_RELEVANT (vinfo_for_stmt (use_stmt))
+                || STMT_VINFO_DEF_TYPE (vinfo_for_stmt (use_stmt)) 
+                    == vect_reduction_def))
 	  vect_mark_slp_stmts (node, hybrid, i);
 
   vect_detect_hybrid_slp_stmts (SLP_TREE_LEFT (node));
Index: gcc/gimplify.c
===================================================================
--- gcc/gimplify.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/gimplify.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,6 +1,6 @@
 /* Tree lowering pass.  This pass converts the GENERIC functions-as-trees
    tree representation into the GIMPLE form.
-   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
    Free Software Foundation, Inc.
    Major work done by Sebastian Pop <s.pop@laposte.net>,
    Diego Novillo <dnovillo@redhat.com> and Jason Merrill <jason@redhat.com>.
@@ -2762,6 +2762,36 @@
 {
   tree type = TREE_TYPE (expr);
 
+  if (TREE_CODE (expr) == NE_EXPR
+      && TREE_CODE (TREE_OPERAND (expr, 0)) == CALL_EXPR
+      && integer_zerop (TREE_OPERAND (expr, 1)))
+    {
+      tree call = TREE_OPERAND (expr, 0);
+      tree fn = get_callee_fndecl (call);
+
+      /* For __builtin_expect ((long) (x), y) recurse into x as well
+	 if x is truth_value_p.  */
+      if (fn
+	  && DECL_BUILT_IN_CLASS (fn) == BUILT_IN_NORMAL
+	  && DECL_FUNCTION_CODE (fn) == BUILT_IN_EXPECT
+	  && call_expr_nargs (call) == 2)
+	{
+	  tree arg = CALL_EXPR_ARG (call, 0);
+	  if (arg)
+	    {
+	      if (TREE_CODE (arg) == NOP_EXPR
+		  && TREE_TYPE (arg) == TREE_TYPE (call))
+		arg = TREE_OPERAND (arg, 0);
+	      if (truth_value_p (TREE_CODE (arg)))
+		{
+		  arg = gimple_boolify (arg);
+		  CALL_EXPR_ARG (call, 0)
+		    = fold_convert (TREE_TYPE (call), arg);
+		}
+	    }
+	}
+    }
+
   if (TREE_CODE (type) == BOOLEAN_TYPE)
     return expr;
 
@@ -3684,6 +3714,21 @@
 	      }
 	  }
 
+	/* If the target is volatile and we have non-zero elements
+	   initialize the target from a temporary.  */
+	if (TREE_THIS_VOLATILE (object)
+	    && !TREE_ADDRESSABLE (type)
+	    && num_nonzero_elements > 0)
+	  {
+	    tree temp = create_tmp_var (TYPE_MAIN_VARIANT (type), NULL);
+	    TREE_OPERAND (*expr_p, 0) = temp;
+	    *expr_p = build2 (COMPOUND_EXPR, TREE_TYPE (*expr_p),
+			      *expr_p,
+			      build2 (MODIFY_EXPR, void_type_node,
+				      object, temp));
+	    return GS_OK;
+	  }
+
 	if (notify_temp_creation)
 	  return GS_OK;
 
@@ -3931,11 +3976,14 @@
     switch (TREE_CODE (*from_p))
       {
       case VAR_DECL:
-	/* If we're assigning from a constant constructor, move the
-	   constructor expression to the RHS of the MODIFY_EXPR.  */
+	/* If we're assigning from a read-only variable initialized with
+	   a constructor, do the direct assignment from the constructor,
+	   but only if neither source nor target are volatile since this
+	   latter assignment might end up being done on a per-field basis.  */
 	if (DECL_INITIAL (*from_p)
 	    && TREE_READONLY (*from_p)
 	    && !TREE_THIS_VOLATILE (*from_p)
+	    && !TREE_THIS_VOLATILE (*to_p)
 	    && TREE_CODE (DECL_INITIAL (*from_p)) == CONSTRUCTOR)
 	  {
 	    tree old_from = *from_p;
Index: gcc/loop-doloop.c
===================================================================
--- gcc/loop-doloop.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/loop-doloop.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,5 +1,5 @@
 /* Perform doloop optimizations
-   Copyright (C) 2004, 2005, 2006, 2007, 2008 Free Software Foundation,
+   Copyright (C) 2004, 2005, 2006, 2007, 2008, 2010 Free Software Foundation,
    Inc.
    Based on code by Michael P. Hayes (m.hayes@elec.canterbury.ac.nz)
 
@@ -291,7 +291,8 @@
   op0 = force_operand (op0, NULL_RTX);
   op1 = force_operand (op1, NULL_RTX);
   label = block_label (dest);
-  do_compare_rtx_and_jump (op0, op1, code, 0, mode, NULL_RTX, NULL_RTX, label);
+  do_compare_rtx_and_jump (op0, op1, code, 0, mode, NULL_RTX,
+			   NULL_RTX, label, -1);
 
   jump = get_last_insn ();
   if (!jump || !JUMP_P (jump))
Index: gcc/expmed.c
===================================================================
--- gcc/expmed.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/expmed.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,7 +1,7 @@
 /* Medium-level subroutines: convert bit-field store and extract
    and shifts, multiplies and divides to rtl instructions.
    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
    Free Software Foundation, Inc.
 
 This file is part of GCC.
@@ -5608,7 +5608,7 @@
   emit_move_insn (target, const1_rtx);
   label = gen_label_rtx ();
   do_compare_rtx_and_jump (op0, op1, code, unsignedp, mode, NULL_RTX,
-			   NULL_RTX, label);
+			   NULL_RTX, label, -1);
 
   emit_move_insn (target, const0_rtx);
   emit_label (label);
@@ -5626,5 +5626,5 @@
 {
   int unsignedp = (op == LTU || op == LEU || op == GTU || op == GEU);
   do_compare_rtx_and_jump (arg1, arg2, op, unsignedp, mode,
-			   NULL_RTX, NULL_RTX, label);
+			   NULL_RTX, NULL_RTX, label, -1);
 }
Index: gcc/except.c
===================================================================
--- gcc/except.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/except.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,6 +1,6 @@
 /* Implements exception handling.
    Copyright (C) 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
    Free Software Foundation, Inc.
    Contributed by Mike Stump <mrs@cygnus.com>.
 
@@ -1834,7 +1834,7 @@
 
 #ifdef DONT_USE_BUILTIN_SETJMP
   {
-    rtx x;
+    rtx x, last;
     x = emit_library_call_value (setjmp_libfunc, NULL_RTX, LCT_RETURNS_TWICE,
 				 TYPE_MODE (integer_type_node), 1,
 				 plus_constant (XEXP (fc, 0),
@@ -1842,7 +1842,12 @@
 
     emit_cmp_and_jump_insns (x, const0_rtx, NE, 0,
 			     TYPE_MODE (integer_type_node), 0, dispatch_label);
-    add_reg_br_prob_note (get_insns (), REG_BR_PROB_BASE/100);
+    last = get_last_insn ();
+    if (JUMP_P (last) && any_condjump_p (last))
+      {
+        gcc_assert (!find_reg_note (last, REG_BR_PROB, 0));
+        add_reg_note (last, REG_BR_PROB, GEN_INT (REG_BR_PROB_BASE / 100));
+      }
   }
 #else
   expand_builtin_setjmp_setup (plus_constant (XEXP (fc, 0), sjlj_fc_jbuf_ofs),
Index: gcc/cfgexpand.c
===================================================================
--- gcc/cfgexpand.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/cfgexpand.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -379,46 +379,6 @@
 }
 
 
-/* Verify that there is exactly single jump instruction since last and attach
-   REG_BR_PROB note specifying probability.
-   ??? We really ought to pass the probability down to RTL expanders and let it
-   re-distribute it when the conditional expands into multiple conditionals.
-   This is however difficult to do.  */
-void
-add_reg_br_prob_note (rtx last, int probability)
-{
-  if (profile_status == PROFILE_ABSENT)
-    return;
-  for (last = NEXT_INSN (last); last && NEXT_INSN (last); last = NEXT_INSN (last))
-    if (JUMP_P (last))
-      {
-	/* It is common to emit condjump-around-jump sequence when we don't know
-	   how to reverse the conditional.  Special case this.  */
-	if (!any_condjump_p (last)
-	    || !JUMP_P (NEXT_INSN (last))
-	    || !simplejump_p (NEXT_INSN (last))
-	    || !NEXT_INSN (NEXT_INSN (last))
-	    || !BARRIER_P (NEXT_INSN (NEXT_INSN (last)))
-	    || !NEXT_INSN (NEXT_INSN (NEXT_INSN (last)))
-	    || !LABEL_P (NEXT_INSN (NEXT_INSN (NEXT_INSN (last))))
-	    || NEXT_INSN (NEXT_INSN (NEXT_INSN (NEXT_INSN (last)))))
-	  goto failed;
-	gcc_assert (!find_reg_note (last, REG_BR_PROB, 0));
-	add_reg_note (last, REG_BR_PROB,
-		      GEN_INT (REG_BR_PROB_BASE - probability));
-	return;
-      }
-  if (!last || !JUMP_P (last) || !any_condjump_p (last))
-    goto failed;
-  gcc_assert (!find_reg_note (last, REG_BR_PROB, 0));
-  add_reg_note (last, REG_BR_PROB, GEN_INT (probability));
-  return;
-failed:
-  if (dump_file)
-    fprintf (dump_file, "Failed to add probability note\n");
-}
-
-
 #ifndef STACK_ALIGNMENT_NEEDED
 #define STACK_ALIGNMENT_NEEDED 1
 #endif
@@ -1669,8 +1629,8 @@
      two-way jump that needs to be decomposed into two basic blocks.  */
   if (false_edge->dest == bb->next_bb)
     {
-      jumpif (pred, label_rtx_for_bb (true_edge->dest));
-      add_reg_br_prob_note (last, true_edge->probability);
+      jumpif (pred, label_rtx_for_bb (true_edge->dest),
+	      true_edge->probability);
       maybe_dump_rtl_for_gimple_stmt (stmt, last);
       if (true_edge->goto_locus)
 	{
@@ -1685,8 +1645,8 @@
     }
   if (true_edge->dest == bb->next_bb)
     {
-      jumpifnot (pred, label_rtx_for_bb (false_edge->dest));
-      add_reg_br_prob_note (last, false_edge->probability);
+      jumpifnot (pred, label_rtx_for_bb (false_edge->dest),
+		 false_edge->probability);
       maybe_dump_rtl_for_gimple_stmt (stmt, last);
       if (false_edge->goto_locus)
 	{
@@ -1700,8 +1660,7 @@
       return NULL;
     }
 
-  jumpif (pred, label_rtx_for_bb (true_edge->dest));
-  add_reg_br_prob_note (last, true_edge->probability);
+  jumpif (pred, label_rtx_for_bb (true_edge->dest), true_edge->probability);
   last = get_last_insn ();
   if (false_edge->goto_locus)
     {
Index: gcc/tree-ssa-pre.c
===================================================================
--- gcc/tree-ssa-pre.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/tree-ssa-pre.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1395,34 +1395,20 @@
 
 
 
+static pre_expr
+phi_translate (pre_expr expr, bitmap_set_t set1, bitmap_set_t set2,
+	       basic_block pred, basic_block phiblock);
 
 /* Translate EXPR using phis in PHIBLOCK, so that it has the values of
    the phis in PRED.  Return NULL if we can't find a leader for each part
    of the translated expression.  */
 
 static pre_expr
-phi_translate (pre_expr expr, bitmap_set_t set1, bitmap_set_t set2,
-	       basic_block pred, basic_block phiblock)
+phi_translate_1 (pre_expr expr, bitmap_set_t set1, bitmap_set_t set2,
+		 basic_block pred, basic_block phiblock)
 {
-  pre_expr oldexpr = expr;
-  pre_expr phitrans;
-
-  if (!expr)
-    return NULL;
-
-  if (value_id_constant_p (get_expr_value_id (expr)))
-    return expr;
-
-  phitrans = phi_trans_lookup (expr, pred);
-  if (phitrans)
-    return phitrans;
-
   switch (expr->kind)
     {
-      /* Constants contain no values that need translation.  */
-    case CONSTANT:
-      return expr;
-
     case NARY:
       {
 	unsigned int i;
@@ -1510,7 +1496,6 @@
 	      }
 	    add_to_value (new_val_id, expr);
 	  }
-	phi_trans_add (oldexpr, expr, pred);
 	return expr;
       }
       break;
@@ -1660,7 +1645,6 @@
 	    add_to_value (new_val_id, expr);
 	  }
 	VEC_free (vn_reference_op_s, heap, newoperands);
-	phi_trans_add (oldexpr, expr, pred);
 	return expr;
       }
       break;
@@ -1706,6 +1690,44 @@
     }
 }
 
+/* Wrapper around phi_translate_1 providing caching functionality.  */
+
+static pre_expr
+phi_translate (pre_expr expr, bitmap_set_t set1, bitmap_set_t set2,
+	       basic_block pred, basic_block phiblock)
+{
+  pre_expr phitrans;
+
+  if (!expr)
+    return NULL;
+
+  /* Constants contain no values that need translation.  */
+  if (expr->kind == CONSTANT)
+    return expr;
+
+  if (value_id_constant_p (get_expr_value_id (expr)))
+    return expr;
+
+  if (expr->kind != NAME)
+    {
+      phitrans = phi_trans_lookup (expr, pred);
+      if (phitrans)
+	return phitrans;
+    }
+
+  /* Translate.  */
+  phitrans = phi_translate_1 (expr, set1, set2, pred, phiblock);
+
+  /* Don't add empty translations to the cache.  Neither add
+     translations of NAMEs as those are cheap to translate.  */
+  if (phitrans
+      && expr->kind != NAME)
+    phi_trans_add (expr, phitrans, pred);
+
+  return phitrans;
+}
+
+
 /* For each expression in SET, translate the values through phi nodes
    in PHIBLOCK using edge PHIBLOCK->PRED, and store the resulting
    expressions in DEST.  */
@@ -1729,12 +1751,16 @@
     {
       pre_expr translated;
       translated = phi_translate (expr, set, NULL, pred, phiblock);
+      if (!translated)
+	continue;
 
-      /* Don't add empty translations to the cache  */
-      if (translated)
-	phi_trans_add (expr, translated, pred);
-
-      if (translated != NULL)
+      /* We might end up with multiple expressions from SET being
+	 translated to the same value.  In this case we do not want
+	 to retain the NARY or REFERENCE expression but prefer a NAME
+	 which would be the leader.  */
+      if (translated->kind == NAME)
+	bitmap_value_replace_in_set (dest, translated);
+      else
 	bitmap_value_insert_into_set (dest, translated);
     }
   VEC_free (pre_expr, heap, exprs);
Index: gcc/loop-invariant.c
===================================================================
--- gcc/loop-invariant.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/loop-invariant.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1207,14 +1207,16 @@
       emit_insn_after (gen_move_insn (dest, reg), inv->insn);
       reorder_insns (inv->insn, inv->insn, BB_END (preheader));
 
-      /* If there is a REG_EQUAL note on the insn we just moved, and
-	 insn is in a basic block that is not always executed, the note
-	 may no longer be valid after we move the insn.
-	 Note that uses in REG_EQUAL notes are taken into account in
-	 the computation of invariants.  Hence it is safe to retain the
-	 note even if the note contains register references.  */
-      if (! inv->always_executed
-	  && (note = find_reg_note (inv->insn, REG_EQUAL, NULL_RTX)))
+      /* If there is a REG_EQUAL note on the insn we just moved, and the
+	 insn is in a basic block that is not always executed or the note
+	 contains something for which we don't know the invariant status,
+	 the note may no longer be valid after we move the insn.  Note that
+	 uses in REG_EQUAL notes are taken into account in the computation
+	 of invariants, so it is safe to retain the note even if it contains
+	 register references for which we know the invariant status.  */
+      if ((note = find_reg_note (inv->insn, REG_EQUAL, NULL_RTX))
+	  && (!inv->always_executed
+	      || !check_maybe_invariant (XEXP (note, 0))))
 	remove_note (inv->insn, note);
     }
   else
Index: gcc/rtl.h
===================================================================
--- gcc/rtl.h	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/rtl.h	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,6 +1,6 @@
 /* Register Transfer Language (RTL) definitions for GCC
    Copyright (C) 1987, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
-   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
+   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
    Free Software Foundation, Inc.
 
 This file is part of GCC.
@@ -2305,8 +2305,6 @@
 /* In predict.c */
 extern void invert_br_probabilities (rtx);
 extern bool expensive_function_p (int);
-/* In cfgexpand.c */
-extern void add_reg_br_prob_note (rtx last, int probability);
 
 /* In var-tracking.c */
 extern unsigned int variable_tracking_main (void);
Index: gcc/tree-inline.c
===================================================================
--- gcc/tree-inline.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/tree-inline.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -2729,6 +2729,8 @@
 {
   HOST_WIDE_INT size;
 
+  gcc_assert (!VOID_TYPE_P (type));
+
   size = int_size_in_bytes (type);
 
   if (size < 0 || size > MOVE_MAX_PIECES * MOVE_RATIO (!optimize_size))
@@ -2980,7 +2982,8 @@
 	  {
 	    tree t;
 	    for (t = TYPE_ARG_TYPES (funtype); t; t = TREE_CHAIN (t))
-	      cost += estimate_move_cost (TREE_VALUE (t));
+	      if (!VOID_TYPE_P (TREE_VALUE (t)))
+		cost += estimate_move_cost (TREE_VALUE (t));
 	  }
 	else
 	  {
@@ -4268,6 +4271,46 @@
   return true;
 }
 
+/* Delete all unreachable basic blocks and update callgraph.
+   Doing so is somewhat nontrivial because we need to update all clones and
+   remove inline function that become unreachable.  */
+
+static bool
+delete_unreachable_blocks_update_callgraph (copy_body_data *id)
+{
+  bool changed = false;
+  basic_block b, next_bb;
+
+  find_unreachable_blocks ();
+
+  /* Delete all unreachable basic blocks.  */
+
+  for (b = ENTRY_BLOCK_PTR->next_bb; b != EXIT_BLOCK_PTR; b = next_bb)
+    {
+      next_bb = b->next_bb;
+
+      if (!(b->flags & BB_REACHABLE))
+	{
+          gimple_stmt_iterator bsi;
+
+          for (bsi = gsi_start_bb (b); !gsi_end_p (bsi); gsi_next (&bsi))
+	    if (gimple_code (gsi_stmt (bsi)) == GIMPLE_CALL)
+	      {
+	        struct cgraph_edge *e;
+
+	        if ((e = cgraph_edge (id->dst_node, gsi_stmt (bsi))) != NULL)
+		  cgraph_remove_edge (e);
+	      }
+	  delete_basic_block (b);
+	  changed = true;
+	}
+    }
+
+  if (changed)
+    tidy_fallthru_edges ();
+  return changed;
+}
+
 /* Create a copy of a function's tree.
    OLD_DECL and NEW_DECL are FUNCTION_DECL tree nodes
    of the original function and the new copied function
@@ -4442,7 +4485,7 @@
       free_dominance_info (CDI_DOMINATORS);
       free_dominance_info (CDI_POST_DOMINATORS);
       if (!update_clones)
-        delete_unreachable_blocks ();
+        delete_unreachable_blocks_update_callgraph (&id);
       update_ssa (TODO_update_ssa);
       if (!update_clones)
 	{
Index: gcc/combine.c
===================================================================
--- gcc/combine.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/combine.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,6 +1,6 @@
 /* Optimize by combining instructions for GNU compiler.
    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
    Free Software Foundation, Inc.
 
 This file is part of GCC.
@@ -6531,8 +6531,10 @@
       if (mode == tmode)
 	return new_rtx;
 
-      if (GET_CODE (new_rtx) == CONST_INT)
-	return gen_int_mode (INTVAL (new_rtx), mode);
+      if (CONST_INT_P (new_rtx)
+	  || GET_CODE (new_rtx) == CONST_DOUBLE)
+	return simplify_unary_operation (unsignedp ? ZERO_EXTEND : SIGN_EXTEND,
+					 mode, new_rtx, tmode);
 
       /* If we know that no extraneous bits are set, and that the high
 	 bit is not set, convert the extraction to the cheaper of
Index: gcc/config.gcc
===================================================================
--- gcc/config.gcc	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/config.gcc	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1088,7 +1088,7 @@
 			tmake_file="${tmake_file} i386/t-linux64"
 			need_64bit_hwint=yes
 			case X"${with_cpu}" in
-			Xgeneric|Xcore2|Xnocona|Xx86-64|Xamdfam10|Xbarcelona|Xk8|Xopteron|Xathlon64|Xathlon-fx)
+			Xgeneric|Xcore2|Xnocona|Xx86-64|Xamdfam10|Xbarcelona|Xk8|Xopteron|Xathlon64|Xathlon-fx|Xathlon64-sse3|Xk8-sse3|Xopteron-sse3)
 				;;
 			X)
 				if test x$with_cpu_64 = x; then
@@ -1097,7 +1097,7 @@
 				;;
 			*)
 				echo "Unsupported CPU used in --with-cpu=$with_cpu, supported values:" 1>&2
-				echo "generic core2 nocona x86-64 amdfam10 barcelona k8 opteron athlon64 athlon-fx" 1>&2
+				echo "generic core2 nocona x86-64 amdfam10 barcelona k8 opteron athlon64 athlon-fx athlon64-sse3 k8-sse3 opteron-sse3" 1>&2
 				exit 1
 				;;
 			esac
@@ -1202,7 +1202,7 @@
 		# libgcc/configure.ac instead.
 		need_64bit_hwint=yes
 		case X"${with_cpu}" in
-		Xgeneric|Xcore2|Xnocona|Xx86-64|Xamdfam10|Xbarcelona|Xk8|Xopteron|Xathlon64|Xathlon-fx)
+		Xgeneric|Xcore2|Xnocona|Xx86-64|Xamdfam10|Xbarcelona|Xk8|Xopteron|Xathlon64|Xathlon-fx|Xathlon64-sse3|Xk8-sse3|Xopteron-sse3)
 			;;
 		X)
 			if test x$with_cpu_64 = x; then
@@ -1211,7 +1211,7 @@
 			;;
 		*)
 			echo "Unsupported CPU used in --with-cpu=$with_cpu, supported values:" 1>&2
-			echo "generic core2 nocona x86-64 amdfam10 barcelona k8 opteron athlon64 athlon-fx" 1>&2
+			echo "generic core2 nocona x86-64 amdfam10 barcelona k8 opteron athlon64 athlon-fx athlon64-sse3 k8-sse3 opteron-sse3" 1>&2
 			exit 1
 			;;
 		esac
@@ -2191,7 +2191,7 @@
 	extra_parts="crti.o crtn.o crtbegin.o crtend.o"
 	;;
 sparc-*-linux*)		# SPARC's running GNU/Linux, libc6
-	tm_file="${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h linux.h"
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h sparc/gas.h linux.h"
 	extra_options="${extra_options} sparc/long-double-switch.opt"
 	tmake_file="${tmake_file} sparc/t-linux"
 	if test x$enable_targets = xall; then
@@ -2303,7 +2303,7 @@
 	esac
 	;;
 sparc64-*-linux*)		# 64-bit SPARC's running GNU/Linux
-	tm_file="sparc/biarch64.h ${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h linux.h sparc/linux64.h"
+	tm_file="sparc/biarch64.h ${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h sparc/gas.h linux.h sparc/linux64.h"
 	extra_options="${extra_options} sparc/long-double-switch.opt"
 	tmake_file="${tmake_file} sparc/t-linux sparc/t-linux64 sparc/t-crtfm"
 	;;
@@ -2472,7 +2472,10 @@
         amdfam10-*|barcelona-*)
           with_cpu=amdfam10
           ;;
-        k8-*|opteron-*|athlon_64-*)
+        k8_sse3-*|opteron_sse3-*|athlon64_sse3-*)
+          with_cpu=k8-sse3
+          ;;
+        k8-*|opteron-*|athlon64-*|athlon_fx-*)
           with_cpu=k8
           ;;
         athlon_xp-*|athlon_mp-*|athlon_4-*)
@@ -2518,7 +2521,10 @@
         amdfam10-*|barcelona-*)
           with_cpu=amdfam10
           ;;
-        k8-*|opteron-*|athlon_64-*)
+        k8_sse3-*|opteron_sse3-*|athlon64_sse3-*)
+          with_cpu=k8-sse3
+          ;;
+        k8-*|opteron-*|athlon64-*|athlon_fx-*)
           with_cpu=k8
           ;;
         nocona-*)
@@ -2812,7 +2818,7 @@
 				esac
 				# OK
 				;;
-			"" | amdfam10 | barcelona | k8 | opteron | athlon64 | athlon-fx | nocona | core2 | generic)
+			"" | amdfam10 | barcelona | k8-sse3 | opteron-sse3 | athlon64-sse3 | k8 | opteron | athlon64 | athlon-fx | nocona | core2 | generic)
 				# OK
 				;;
 			*)
Index: gcc/Makefile.in
===================================================================
--- gcc/Makefile.in	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/Makefile.in	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -3,7 +3,7 @@
 
 # Copyright (C) 1987, 1988, 1990, 1991, 1992, 1993, 1994, 1995, 1996,
 # 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
-# 2008, 2009 Free Software Foundation, Inc.
+# 2008, 2009, 2010 Free Software Foundation, Inc.
 
 #This file is part of GCC.
 
@@ -2514,7 +2514,7 @@
    tree-pass.h $(DF_H) $(DIAGNOSTIC_H) vecprim.h
 dojump.o : dojump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \
    $(FLAGS_H) $(FUNCTION_H) $(EXPR_H) $(OPTABS_H) $(INSN_ATTR_H) insn-config.h \
-   langhooks.h $(GGC_H) gt-dojump.h vecprim.h $(BASIC_BLOCK_H)
+   langhooks.h $(GGC_H) gt-dojump.h vecprim.h $(BASIC_BLOCK_H) output.h
 builtins.o : builtins.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
    $(TREE_H) $(GIMPLE_H) $(FLAGS_H) $(TARGET_H) $(FUNCTION_H) $(REGS_H) \
    $(EXPR_H) $(OPTABS_H) insn-config.h $(RECOG_H) output.h typeclass.h \
Index: gcc/tree-ssa-reassoc.c
===================================================================
--- gcc/tree-ssa-reassoc.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/tree-ssa-reassoc.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,5 +1,5 @@
 /* Reassociation for trees.
-   Copyright (C) 2005, 2007, 2008, 2009 Free Software Foundation, Inc.
+   Copyright (C) 2005, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
    Contributed by Daniel Berlin <dan@dberlin.org>
 
 This file is part of GCC.
@@ -844,7 +844,7 @@
   if ((!op1def || gimple_nop_p (op1def))
       && (!op2def || gimple_nop_p (op2def)))
     {
-      gsi = gsi_start_bb (single_succ (ENTRY_BLOCK_PTR));
+      gsi = gsi_after_labels (single_succ (ENTRY_BLOCK_PTR));
       gsi_insert_before (&gsi, sum, GSI_NEW_STMT);
     }
   else if ((!op1def || gimple_nop_p (op1def))
@@ -853,7 +853,7 @@
     {
       if (gimple_code (op2def) == GIMPLE_PHI)
 	{
-	  gsi = gsi_start_bb (gimple_bb (op2def));
+	  gsi = gsi_after_labels (gimple_bb (op2def));
 	  gsi_insert_before (&gsi, sum, GSI_NEW_STMT);
 	}
       else
@@ -878,7 +878,7 @@
     {
       if (gimple_code (op1def) == GIMPLE_PHI)
 	{
-	  gsi = gsi_start_bb (gimple_bb (op1def));
+	  gsi = gsi_after_labels (gimple_bb (op1def));
 	  gsi_insert_before (&gsi, sum, GSI_NEW_STMT);
 	}
       else
Index: gcc/config/alpha/alpha.c
===================================================================
--- gcc/config/alpha/alpha.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/config/alpha/alpha.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -391,7 +391,7 @@
 	    break;
 	  }
       if (! cpu_table [i].name)
-	error ("bad value %qs for -mcpu switch", alpha_tune_string);
+	error ("bad value %qs for -mtune switch", alpha_tune_string);
     }
 
   /* Do some sanity checks on the above options.  */
Index: gcc/config/alpha/alpha.md
===================================================================
--- gcc/config/alpha/alpha.md	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/config/alpha/alpha.md	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -4339,20 +4339,22 @@
 		   (match_operand:SI 3 "const48_operand" "I")
 		   (const_int 0))
 	         (match_operand:SI 4 "sext_add_operand" "rIO")))
-   (clobber (match_scratch:SI 5 "=r"))]
+   (clobber (match_scratch:DI 5 "=r"))]
   ""
   "#"
   ""
   [(set (match_dup 5)
-	(match_op_dup:SI 1 [(match_dup 2) (const_int 0)]))
+	(match_op_dup:DI 1 [(match_dup 2) (const_int 0)]))
    (set (match_dup 0)
-	(plus:SI (mult:SI (match_dup 5) (match_dup 3))
+	(plus:SI (mult:SI (match_dup 6) (match_dup 3))
 		 (match_dup 4)))]
 {
   if (can_create_pseudo_p ())
-    operands[5] = gen_reg_rtx (SImode);
+    operands[5] = gen_reg_rtx (DImode);
   else if (reg_overlap_mentioned_p (operands[5], operands[4]))
-    operands[5] = operands[0];
+    operands[5] = gen_lowpart (DImode, operands[0]);
+
+  operands[6] = gen_lowpart (SImode, operands[5]);
 })
 
 (define_insn_and_split "*cmp_sadd_sidi"
@@ -4365,20 +4367,22 @@
 		     (match_operand:SI 3 "const48_operand" "I")
 		     (const_int 0))
 	           (match_operand:SI 4 "sext_add_operand" "rIO"))))
-   (clobber (match_scratch:SI 5 "=r"))]
+   (clobber (match_scratch:DI 5 "=r"))]
   ""
   "#"
   ""
   [(set (match_dup 5)
-	(match_op_dup:SI 1 [(match_dup 2) (const_int 0)]))
+	(match_op_dup:DI 1 [(match_dup 2) (const_int 0)]))
    (set (match_dup 0)
-	(sign_extend:DI (plus:SI (mult:SI (match_dup 5) (match_dup 3))
+	(sign_extend:DI (plus:SI (mult:SI (match_dup 6) (match_dup 3))
 				 (match_dup 4))))]
 {
   if (can_create_pseudo_p ())
-    operands[5] = gen_reg_rtx (SImode);
+    operands[5] = gen_reg_rtx (DImode);
   else if (reg_overlap_mentioned_p (operands[5], operands[4]))
-    operands[5] = gen_lowpart (SImode, operands[0]);
+    operands[5] = operands[0];
+
+  operands[6] = gen_lowpart (SImode, operands[5]);
 })
 
 (define_insn_and_split "*cmp_ssub_di"
@@ -4415,20 +4419,22 @@
 		    (match_operand:SI 3 "const48_operand" "I")
 		    (const_int 0))
 	          (match_operand:SI 4 "reg_or_8bit_operand" "rI")))
-   (clobber (match_scratch:SI 5 "=r"))]
+   (clobber (match_scratch:DI 5 "=r"))]
   ""
   "#"
   ""
   [(set (match_dup 5)
-	(match_op_dup:SI 1 [(match_dup 2) (const_int 0)]))
+	(match_op_dup:DI 1 [(match_dup 2) (const_int 0)]))
    (set (match_dup 0)
-	(minus:SI (mult:SI (match_dup 5) (match_dup 3))
+	(minus:SI (mult:SI (match_dup 6) (match_dup 3))
 		 (match_dup 4)))]
 {
   if (can_create_pseudo_p ())
-    operands[5] = gen_reg_rtx (SImode);
+    operands[5] = gen_reg_rtx (DImode);
   else if (reg_overlap_mentioned_p (operands[5], operands[4]))
-    operands[5] = operands[0];
+    operands[5] = gen_lowpart (DImode, operands[0]);
+
+  operands[6] = gen_lowpart (SImode, operands[5]);
 })
 
 (define_insn_and_split "*cmp_ssub_sidi"
@@ -4441,20 +4447,22 @@
 		      (match_operand:SI 3 "const48_operand" "I")
 		      (const_int 0))
 	            (match_operand:SI 4 "reg_or_8bit_operand" "rI"))))
-   (clobber (match_scratch:SI 5 "=r"))]
+   (clobber (match_scratch:DI 5 "=r"))]
   ""
   "#"
   ""
   [(set (match_dup 5)
-	(match_op_dup:SI 1 [(match_dup 2) (const_int 0)]))
+	(match_op_dup:DI 1 [(match_dup 2) (const_int 0)]))
    (set (match_dup 0)
-	(sign_extend:DI (minus:SI (mult:SI (match_dup 5) (match_dup 3))
+	(sign_extend:DI (minus:SI (mult:SI (match_dup 6) (match_dup 3))
 				  (match_dup 4))))]
 {
   if (can_create_pseudo_p ())
-    operands[5] = gen_reg_rtx (SImode);
+    operands[5] = gen_reg_rtx (DImode);
   else if (reg_overlap_mentioned_p (operands[5], operands[4]))
-    operands[5] = gen_lowpart (SImode, operands[0]);
+    operands[5] = operands[0];
+
+  operands[6] = gen_lowpart (SImode, operands[5]);
 })
 
 ;; Here are the CALL and unconditional branch insns.  Calls on NT and OSF
Index: gcc/config/s390/s390.c
===================================================================
--- gcc/config/s390/s390.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/config/s390/s390.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -10090,6 +10090,14 @@
     return more;
 }
 
+static void
+s390_sched_init (FILE *file ATTRIBUTE_UNUSED,
+		 int verbose ATTRIBUTE_UNUSED,
+		 int max_ready ATTRIBUTE_UNUSED)
+{
+  last_scheduled_insn = NULL_RTX;
+}
+
 /* Initialize GCC target structure.  */
 
 #undef  TARGET_ASM_ALIGNED_HI_OP
@@ -10147,6 +10155,8 @@
 #define TARGET_SCHED_VARIABLE_ISSUE s390_sched_variable_issue
 #undef TARGET_SCHED_REORDER
 #define TARGET_SCHED_REORDER s390_sched_reorder
+#undef TARGET_SCHED_INIT
+#define TARGET_SCHED_INIT s390_sched_init
 
 #undef TARGET_CANNOT_COPY_INSN_P
 #define TARGET_CANNOT_COPY_INSN_P s390_cannot_copy_insn_p
Index: gcc/config/s390/s390.md
===================================================================
--- gcc/config/s390/s390.md	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/config/s390/s390.md	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1864,8 +1864,8 @@
 })
 
 (define_insn "*movqi"
-  [(set (match_operand:QI 0 "nonimmediate_operand" "=d,d,d,d,R,T,Q,S")
-        (match_operand:QI 1 "general_operand" "d,n,R,T,d,d,n,n"))]
+  [(set (match_operand:QI 0 "nonimmediate_operand" "=d,d,d,d,R,T,Q,S,?Q")
+        (match_operand:QI 1 "general_operand"      " d,n,R,T,d,d,n,n,?Q"))]
   ""
   "@
    lr\t%0,%1
@@ -1875,9 +1875,10 @@
    stc\t%1,%0
    stcy\t%1,%0
    mvi\t%S0,%b1
-   mviy\t%S0,%b1"
-  [(set_attr "op_type" "RR,RI,RX,RXY,RX,RXY,SI,SIY")
-   (set_attr "type" "lr,*,*,*,store,store,store,store")
+   mviy\t%S0,%b1
+   *"
+  [(set_attr "op_type" "RR,RI,RX,RXY,RX,RXY,SI,SIY,SS")
+   (set_attr "type" "lr,*,*,*,store,store,store,store,*")
    (set_attr "z10prop" "z10_fr_E1,
                         z10_fwd_A1,
                         z10_super_E1,
@@ -1885,7 +1886,8 @@
                         z10_rec,
                         z10_rec,
                         z10_super,
-                        z10_super")])
+                        z10_super,
+                        *")])
 
 (define_peephole2
   [(set (match_operand:QI 0 "nonimmediate_operand" "")
@@ -2262,6 +2264,22 @@
   "mvc\t%O0(%2,%R0),%S1"
   [(set_attr "op_type" "SS")])
 
+; This splitter converts a QI to QI mode copy into a BLK mode copy in
+; order to have it implemented with mvc.
+
+(define_split
+  [(set (match_operand:QI 0 "memory_operand" "")
+        (match_operand:QI 1 "memory_operand" ""))]
+  "reload_completed"
+  [(parallel
+    [(set (match_dup 0) (match_dup 1))
+     (use (const_int 1))])]
+{
+  operands[0] = adjust_address (operands[0], BLKmode, 0);
+  operands[1] = adjust_address (operands[1], BLKmode, 0);
+})
+
+
 (define_peephole2
   [(parallel
     [(set (match_operand:BLK 0 "memory_operand" "")
Index: gcc/config/spu/spu-c.c
===================================================================
--- gcc/config/spu/spu-c.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/config/spu/spu-c.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -161,8 +161,7 @@
 	  if ((!SCALAR_TYPE_P (param_type)
 	       || !SCALAR_TYPE_P (arg_type)
 	       || (all_scalar && p == 0))
-	      && !comptypes (TYPE_MAIN_VARIANT (param_type),
-			     TYPE_MAIN_VARIANT (arg_type)))
+	      && !lang_hooks.types_compatible_p (param_type, arg_type))
 	    break;
 	}
       if (param == void_list_node)
Index: gcc/config/sparc/sparc.c
===================================================================
--- gcc/config/sparc/sparc.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/config/sparc/sparc.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,6 +1,6 @@
 /* Subroutines for insn-output.c for SPARC.
    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010
    Free Software Foundation, Inc.
    Contributed by Michael Tiemann (tiemann@cygnus.com)
    64-bit SPARC-V9 support by Michael Tiemann, Jim Wilson, and Doug Evans,
@@ -371,8 +371,9 @@
 static void emit_save_or_restore_regs (int);
 static void sparc_asm_function_prologue (FILE *, HOST_WIDE_INT);
 static void sparc_asm_function_epilogue (FILE *, HOST_WIDE_INT);
-#ifdef OBJECT_FORMAT_ELF
-static void sparc_elf_asm_named_section (const char *, unsigned int, tree);
+#if defined (OBJECT_FORMAT_ELF)
+static void sparc_elf_asm_named_section (const char *, unsigned int, tree)
+    ATTRIBUTE_UNUSED;
 #endif
 
 static int sparc_adjust_cost (rtx, rtx, rtx, int);
@@ -7847,19 +7848,11 @@
     }
 }
 
-#ifdef OBJECT_FORMAT_ELF
+#if defined (OBJECT_FORMAT_ELF)
 static void
 sparc_elf_asm_named_section (const char *name, unsigned int flags,
 			     tree decl)
 {
-  if (flags & SECTION_MERGE)
-    {
-      /* entsize cannot be expressed in this section attributes
-	 encoding style.  */
-      default_elf_asm_named_section (name, flags, decl);
-      return;
-    }
-
   fprintf (asm_out_file, "\t.section\t\"%s\"", name);
 
   if (!(flags & SECTION_DEBUG))
Index: gcc/config/sparc/gas.h
===================================================================
--- gcc/config/sparc/gas.h	(.../tags/gcc_4_4_3_release)	(wersja 0)
+++ gcc/config/sparc/gas.h	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -0,0 +1,6 @@
+/* Definitions of target machine for GCC, for SPARC
+   using the GNU assembler.  */
+
+/* Switch into a generic section.  */
+#undef TARGET_ASM_NAMED_SECTION
+#define TARGET_ASM_NAMED_SECTION  default_elf_asm_named_section
Index: gcc/config/sparc/sysv4.h
===================================================================
--- gcc/config/sparc/sysv4.h	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/config/sparc/sysv4.h	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,5 +1,6 @@
 /* Target definitions for GNU compiler for SPARC running System V.4
-   Copyright (C) 1991, 1992, 1995, 1996, 1997, 1998, 2000, 2002, 2007, 2009
+   Copyright (C) 1991, 1992, 1995, 1996, 1997, 1998, 2000, 2002, 2007, 2009,
+   2010
    Free Software Foundation, Inc.
    Contributed by Ron Guilmette (rfg@monkeys.com).
 
Index: gcc/config/sh/sh.c
===================================================================
--- gcc/config/sh/sh.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/config/sh/sh.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,6 +1,6 @@
 /* Output routines for GCC for Renesas / SuperH SH.
    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-   2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
+   2003, 2004, 2005, 2006, 2007, 2008, 2010 Free Software Foundation, Inc.
    Contributed by Steve Chamberlain (sac@cygnus.com).
    Improved by Jim Wilson (wilson@cygnus.com).
 
@@ -4061,6 +4061,13 @@
 	       && ! TARGET_SMALLCODE)
 	new_align = 4;
 
+      /* There is a possibility that a bf is transformed into a bf/s by the
+	 delay slot scheduler.  */
+      if (JUMP_P (from) && !JUMP_TABLE_DATA_P (from) 
+	  && get_attr_type (from) == TYPE_CBRANCH
+	  && GET_CODE (PATTERN (NEXT_INSN (PREV_INSN (from)))) != SEQUENCE)
+	inc += 2;
+
       if (found_si)
 	{
 	  count_si += inc;
@@ -6764,13 +6771,13 @@
 	  pop (PR_REG);
 	}
 
-      /* Banked registers are poped first to avoid being scheduled in the
+      /* Banked registers are popped first to avoid being scheduled in the
 	 delay slot. RTE switches banks before the ds instruction.  */
       if (current_function_interrupt)
 	{
-	  for (i = FIRST_BANKED_REG; i <= LAST_BANKED_REG; i++)
-	    if (TEST_HARD_REG_BIT (live_regs_mask, i)) 
-	      pop (LAST_BANKED_REG - i);
+	  for (i = LAST_BANKED_REG; i >= FIRST_BANKED_REG; i--)
+	    if (TEST_HARD_REG_BIT (live_regs_mask, i))
+	      pop (i);
 
 	  last_reg = FIRST_PSEUDO_REGISTER - LAST_BANKED_REG - 1;
 	}
@@ -8721,9 +8728,7 @@
 	&& GET_CODE (PATTERN (insn)) != USE
 	&& GET_CODE (PATTERN (insn)) != CLOBBER)
        || GET_CODE (insn) == CALL_INSN
-       || (GET_CODE (insn) == JUMP_INSN
-	   && GET_CODE (PATTERN (insn)) != ADDR_DIFF_VEC
-	   && GET_CODE (PATTERN (insn)) != ADDR_VEC))
+       || (JUMP_P (insn) && !JUMP_TABLE_DATA_P (insn)))
       && GET_CODE (PATTERN (NEXT_INSN (PREV_INSN (insn)))) != SEQUENCE
       && get_attr_needs_delay_slot (insn) == NEEDS_DELAY_SLOT_YES)
     return 2;
@@ -8731,9 +8736,7 @@
   /* SH2e has a bug that prevents the use of annulled branches, so if
      the delay slot is not filled, we'll have to put a NOP in it.  */
   if (sh_cpu == CPU_SH2E
-      && GET_CODE (insn) == JUMP_INSN
-      && GET_CODE (PATTERN (insn)) != ADDR_DIFF_VEC
-      && GET_CODE (PATTERN (insn)) != ADDR_VEC
+      && JUMP_P (insn) && !JUMP_TABLE_DATA_P (insn)
       && get_attr_type (insn) == TYPE_CBRANCH
       && GET_CODE (PATTERN (NEXT_INSN (PREV_INSN (insn)))) != SEQUENCE)
     return 2;
Index: gcc/config/sh/sh.md
===================================================================
--- gcc/config/sh/sh.md	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/config/sh/sh.md	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,6 +1,6 @@
 ;;- Machine description for Renesas / SuperH SH.
 ;;  Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-;;  2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
+;;  2003, 2004, 2005, 2006, 2007, 2008, 2010 Free Software Foundation, Inc.
 ;;  Contributed by Steve Chamberlain (sac@cygnus.com).
 ;;  Improved by Jim Wilson (wilson@cygnus.com).
 
@@ -734,7 +734,7 @@
   [(set (pc)
 	(if_then_else (match_operator 0 "comparison_operator"
 			[(match_operand:DI 1 "arith_operand" "r,r")
-			 (match_operand:DI 2 "arith_operand" "rN,i")])
+			 (match_operand:DI 2 "arith_operand" "rN,I08")])
 		      (label_ref (match_operand 3 "" ""))
 		      (pc)))
    (clobber (match_scratch:SI 4 "=X,&r"))
Index: gcc/config/ia64/ia64.md
===================================================================
--- gcc/config/ia64/ia64.md	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/config/ia64/ia64.md	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -5818,7 +5818,7 @@
 })
 
 (define_insn "call_nogp"
-  [(call (mem:DI (match_operand:DI 0 "call_operand" "?b,i"))
+  [(call (mem:DI (match_operand:DI 0 "call_operand" "?b,s"))
 	 (const_int 0))
    (clobber (match_operand:DI 1 "register_operand" "=b,b"))]
   ""
@@ -5827,7 +5827,7 @@
 
 (define_insn "call_value_nogp"
   [(set (match_operand 0 "" "=X,X")
-	(call (mem:DI (match_operand:DI 1 "call_operand" "?b,i"))
+	(call (mem:DI (match_operand:DI 1 "call_operand" "?b,s"))
 	      (const_int 0)))
    (clobber (match_operand:DI 2 "register_operand" "=b,b"))]
   ""
@@ -5835,14 +5835,14 @@
   [(set_attr "itanium_class" "br,scall")])
 
 (define_insn "sibcall_nogp"
-  [(call (mem:DI (match_operand:DI 0 "call_operand" "?b,i"))
+  [(call (mem:DI (match_operand:DI 0 "call_operand" "?b,s"))
 	 (const_int 0))]
   ""
   "br%+.many %0"
   [(set_attr "itanium_class" "br,scall")])
 
 (define_insn "call_gp"
-  [(call (mem:DI (match_operand:DI 0 "call_operand" "?r,i"))
+  [(call (mem:DI (match_operand:DI 0 "call_operand" "?r,s"))
 	 (const_int 1))
    (clobber (match_operand:DI 1 "register_operand" "=b,b"))
    (clobber (match_scratch:DI 2 "=&r,X"))
@@ -5883,7 +5883,7 @@
 
 (define_insn "call_value_gp"
   [(set (match_operand 0 "" "=X,X")
-	(call (mem:DI (match_operand:DI 1 "call_operand" "?r,i"))
+	(call (mem:DI (match_operand:DI 1 "call_operand" "?r,s"))
 	      (const_int 1)))
    (clobber (match_operand:DI 2 "register_operand" "=b,b"))
    (clobber (match_scratch:DI 3 "=&r,X"))
@@ -5923,7 +5923,7 @@
 })
 
 (define_insn_and_split "sibcall_gp"
-  [(call (mem:DI (match_operand:DI 0 "call_operand" "?r,i"))
+  [(call (mem:DI (match_operand:DI 0 "call_operand" "?r,s"))
 	 (const_int 1))
    (clobber (match_scratch:DI 1 "=&r,X"))
    (clobber (match_scratch:DI 2 "=b,X"))]
Index: gcc/config/rs6000/rs6000.c
===================================================================
--- gcc/config/rs6000/rs6000.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/config/rs6000/rs6000.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,6 +1,6 @@
 /* Subroutines used for code generation on IBM RS/6000.
    Copyright (C) 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
-   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
+   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
    Free Software Foundation, Inc.
    Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)
 
@@ -5232,14 +5232,6 @@
 	       && ! legitimate_constant_pool_address_p (operands[1])
 	       && ! toc_relative_expr_p (operands[1]))
 	{
-	  /* Emit a USE operation so that the constant isn't deleted if
-	     expensive optimizations are turned on because nobody
-	     references it.  This should only be done for operands that
-	     contain SYMBOL_REFs with CONSTANT_POOL_ADDRESS_P set.
-	     This should not be done for operands that contain LABEL_REFs.
-	     For now, we just handle the obvious case.  */
-	  if (GET_CODE (operands[1]) != LABEL_REF)
-	    emit_use (operands[1]);
 
 #if TARGET_MACHO
 	  /* Darwin uses a special PIC legitimizer.  */
@@ -15534,7 +15526,7 @@
 
   do_compare_rtx_and_jump (opcode, tocompare, EQ, 1,
 			   SImode, NULL_RTX, NULL_RTX,
-			   no_toc_save_needed);
+			   no_toc_save_needed, -1);
 
   mem = gen_frame_mem (Pmode,
 		       gen_rtx_PLUS (Pmode, stack_top,
Index: gcc/config/arm/arm.c
===================================================================
--- gcc/config/arm/arm.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/config/arm/arm.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -10273,11 +10273,14 @@
   return "";
 }
 
-/* Output a 'call' insn that is a reference in memory.  */
+/* Output a 'call' insn that is a reference in memory. This is
+   disabled for ARMv5 and we prefer a blx instead because otherwise
+   there's a significant performance overhead.  */
 const char *
 output_call_mem (rtx *operands)
 {
-  if (TARGET_INTERWORK && !arm_arch5)
+  gcc_assert (!arm_arch5);
+  if (TARGET_INTERWORK)
     {
       output_asm_insn ("ldr%?\t%|ip, %0", operands);
       output_asm_insn ("mov%?\t%|lr, %|pc", operands);
@@ -10289,16 +10292,11 @@
 	 first instruction.  It's safe to use IP as the target of the
 	 load since the call will kill it anyway.  */
       output_asm_insn ("ldr%?\t%|ip, %0", operands);
-      if (arm_arch5)
-	output_asm_insn ("blx%?\t%|ip", operands);
+      output_asm_insn ("mov%?\t%|lr, %|pc", operands);
+      if (arm_arch4t)
+	output_asm_insn ("bx%?\t%|ip", operands);
       else
-	{
-	  output_asm_insn ("mov%?\t%|lr, %|pc", operands);
-	  if (arm_arch4t)
-	    output_asm_insn ("bx%?\t%|ip", operands);
-	  else
-	    output_asm_insn ("mov%?\t%|pc, %|ip", operands);
-	}
+	output_asm_insn ("mov%?\t%|pc, %|ip", operands);
     }
   else
     {
Index: gcc/config/arm/thumb2.md
===================================================================
--- gcc/config/arm/thumb2.md	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/config/arm/thumb2.md	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1108,9 +1108,9 @@
 )
 
 (define_insn "*thumb2_addsi_short"
-  [(set (match_operand:SI 0 "low_register_operand" "=l")
-	(plus:SI (match_operand:SI 1 "low_register_operand" "l")
-		 (match_operand:SI 2 "low_reg_or_int_operand" "lIL")))
+  [(set (match_operand:SI 0 "low_register_operand" "=l,l")
+	(plus:SI (match_operand:SI 1 "low_register_operand" "l,0")
+		 (match_operand:SI 2 "low_reg_or_int_operand" "lPt,Ps")))
    (clobber (reg:CC CC_REGNUM))]
   "TARGET_THUMB2 && reload_completed"
   "*
@@ -1171,7 +1171,7 @@
    (clobber (reg:CC CC_REGNUM))]
   "TARGET_THUMB2"
   "*
-  if (get_attr_length (insn) == 2 && which_alternative == 0)
+  if (get_attr_length (insn) == 2)
     return \"cbz\\t%0, %l1\";
   else
     return \"cmp\\t%0, #0\;beq\\t%l1\";
@@ -1179,7 +1179,8 @@
   [(set (attr "length") 
         (if_then_else
 	    (and (ge (minus (match_dup 1) (pc)) (const_int 2))
-	         (le (minus (match_dup 1) (pc)) (const_int 128)))
+	         (le (minus (match_dup 1) (pc)) (const_int 128))
+	         (eq (symbol_ref ("which_alternative")) (const_int 0)))
 	    (const_int 2)
 	    (const_int 8)))]
 )
@@ -1193,7 +1194,7 @@
    (clobber (reg:CC CC_REGNUM))]
   "TARGET_THUMB2"
   "*
-  if (get_attr_length (insn) == 2 && which_alternative == 0)
+  if (get_attr_length (insn) == 2)
     return \"cbnz\\t%0, %l1\";
   else
     return \"cmp\\t%0, #0\;bne\\t%l1\";
@@ -1201,7 +1202,8 @@
   [(set (attr "length") 
         (if_then_else
 	    (and (ge (minus (match_dup 1) (pc)) (const_int 2))
-	         (le (minus (match_dup 1) (pc)) (const_int 128)))
+	         (le (minus (match_dup 1) (pc)) (const_int 128))
+	         (eq (symbol_ref ("which_alternative")) (const_int 0)))
 	    (const_int 2)
 	    (const_int 8)))]
 )
Index: gcc/config/arm/lib1funcs.asm
===================================================================
--- gcc/config/arm/lib1funcs.asm	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/config/arm/lib1funcs.asm	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -95,7 +95,8 @@
 #endif
 
 #if defined(__ARM_ARCH_7__) || defined(__ARM_ARCH_7A__) \
-	|| defined(__ARM_ARCH_7R__) || defined(__ARM_ARCH_7M__)
+	|| defined(__ARM_ARCH_7R__) || defined(__ARM_ARCH_7M__) \
+	|| defined(__ARM_ARCH_7EM__)
 # define __ARM_ARCH__ 7
 #endif
 
Index: gcc/config/arm/constraints.md
===================================================================
--- gcc/config/arm/constraints.md	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/config/arm/constraints.md	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -30,6 +30,7 @@
 
 ;; The following multi-letter normal constraints have been used:
 ;; in ARM/Thumb-2 state: Da, Db, Dc, Dn, Dl, DL, Dv
+;; in Thumb-2 state: Ps, Pt
 
 ;; The following memory constraints have been used:
 ;; in ARM/Thumb-2 state: Q, Ut, Uv, Uy, Un, Us
@@ -129,6 +130,16 @@
       (match_test "TARGET_THUMB1 && ival >= -508 && ival <= 508
 		   && ((ival & 3) == 0)")))
 
+(define_constraint "Ps"
+  "@internal In Thumb-2 state a constant in the range -255 to +255"
+  (and (match_code "const_int")
+       (match_test "TARGET_THUMB2 && ival >= -255 && ival <= 255")))
+
+(define_constraint "Pt"
+  "@internal In Thumb-2 state a constant in the range -7 to +7"
+  (and (match_code "const_int")
+       (match_test "TARGET_THUMB2 && ival >= -7 && ival <= 7")))
+
 (define_constraint "G"
  "In ARM/Thumb-2 state a valid FPA immediate constant."
  (and (match_code "const_double")
Index: gcc/config/arm/neon.ml
===================================================================
--- gcc/config/arm/neon.ml	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/config/arm/neon.ml	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,7 +1,7 @@
 (* Common code for ARM NEON header file, documentation and test case
    generators.
 
-   Copyright (C) 2006, 2007 Free Software Foundation, Inc.
+   Copyright (C) 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
    Contributed by CodeSourcery.
 
    This file is part of GCC.
@@ -233,6 +233,7 @@
        cases.  The function supplied must return the integer to be written
        into the testcase for the argument number (0-based) supplied to it.  *)
   | Const_valuator of (int -> int)
+  | Fixed_return_reg
 
 exception MixedMode of elts * elts
 
@@ -1076,9 +1077,13 @@
       Use_operands [| Dreg; Qreg |], "vget_high",
       notype_1, pf_su_8_64;
     Vget_low, [Instruction_name ["vmov"];
-               Disassembles_as [Use_operands [| Dreg; Dreg |]]],
+               Disassembles_as [Use_operands [| Dreg; Dreg |]];
+	       Fixed_return_reg],
       Use_operands [| Dreg; Qreg |], "vget_low",
-      notype_1, pf_su_8_64;
+      notype_1, pf_su_8_32;
+     Vget_low, [No_op],
+      Use_operands [| Dreg; Qreg |], "vget_low",
+      notype_1, [S64; U64];
 
     (* Conversions.  *)
     Vcvt, [InfoWord], All (2, Dreg), "vcvt", conv_1,
Index: gcc/config/arm/neon-testgen.ml
===================================================================
--- gcc/config/arm/neon-testgen.ml	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/config/arm/neon-testgen.ml	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,5 +1,5 @@
 (* Auto-generate ARM Neon intrinsics tests.
-   Copyright (C) 2006, 2007 Free Software Foundation, Inc.
+   Copyright (C) 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
    Contributed by CodeSourcery.
 
    This file is part of GCC.
@@ -58,7 +58,7 @@
 
 (* Emit declarations of local variables that are going to be passed
    to an intrinsic, together with one to take a returned value if needed.  *)
-let emit_automatics chan c_types =
+let emit_automatics chan c_types features =
   let emit () =
     ignore (
       List.fold_left (fun arg_number -> fun (flags, ty) ->
@@ -75,11 +75,17 @@
   in
     match c_types with
       (_, return_ty) :: tys ->
-        if return_ty <> "void" then
-          (* The intrinsic returns a value.  *)
-          (Printf.fprintf chan "  %s out_%s;\n" return_ty return_ty;
-           emit ())
-        else
+        if return_ty <> "void" then begin
+          (* The intrinsic returns a value.  We need to do explict register
+             allocation for vget_low tests or they fail because of copy
+             elimination.  *)
+          ((if List.mem Fixed_return_reg features then
+              Printf.fprintf chan "  register %s out_%s asm (\"d18\");\n"
+                             return_ty return_ty
+            else
+              Printf.fprintf chan "  %s out_%s;\n" return_ty return_ty);
+	   emit ())
+        end else
           (* The intrinsic does not return a value.  *)
           emit ()
     | _ -> assert false
@@ -256,7 +262,7 @@
     (* Emit file and function prologues.  *)
     emit_prologue chan test_name;
     (* Emit local variable declarations.  *)
-    emit_automatics chan c_types;
+    emit_automatics chan c_types features;
     Printf.fprintf chan "\n";
     (* Emit the call to the intrinsic.  *)
     emit_call chan const_valuator c_types name elt_ty;
Index: gcc/config/arm/arm.md
===================================================================
--- gcc/config/arm/arm.md	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/config/arm/arm.md	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -8441,12 +8441,17 @@
    (set_attr "type" "call")]
 )
 
+
+;; Note: not used for armv5+ because the sequence used (ldr pc, ...) is not
+;; considered a function call by the branch predictor of some cores (PR40887).
+;; Falls back to blx rN (*call_reg_armv5).
+
 (define_insn "*call_mem"
   [(call (mem:SI (match_operand:SI 0 "call_memory_operand" "m"))
 	 (match_operand 1 "" ""))
    (use (match_operand 2 "" ""))
    (clobber (reg:SI LR_REGNUM))]
-  "TARGET_ARM"
+  "TARGET_ARM && !arm_arch5"
   "*
   return output_call_mem (operands);
   "
@@ -8548,13 +8553,15 @@
    (set_attr "type" "call")]
 )
 
+;; Note: see *call_mem
+
 (define_insn "*call_value_mem"
   [(set (match_operand 0 "" "")
 	(call (mem:SI (match_operand:SI 1 "call_memory_operand" "m"))
 	      (match_operand 2 "" "")))
    (use (match_operand 3 "" ""))
    (clobber (reg:SI LR_REGNUM))]
-  "TARGET_ARM && (!CONSTANT_ADDRESS_P (XEXP (operands[1], 0)))"
+  "TARGET_ARM && !arm_arch5 && (!CONSTANT_ADDRESS_P (XEXP (operands[1], 0)))"
   "*
   return output_call_mem (&operands[1]);
   "
Index: gcc/config/pa/pa.md
===================================================================
--- gcc/config/pa/pa.md	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/config/pa/pa.md	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -3548,7 +3548,7 @@
 
   size = INTVAL (operands[2]);
   align = INTVAL (operands[3]);
-  align = align > 4 ? 4 : align;
+  align = align > 4 ? 4 : (align ? align : 1);
 
   /* If size/alignment is large, then use the library routines.  */
   if (size / align > 16)
@@ -3736,7 +3736,7 @@
 
   size = INTVAL (operands[2]);
   align = INTVAL (operands[3]);
-  align = align > 8 ? 8 : align;
+  align = align > 8 ? 8 : (align ? align : 1);
 
   /* If size/alignment is large, then use the library routines.  */
   if (size / align > 16)
Index: gcc/cfgrtl.c
===================================================================
--- gcc/cfgrtl.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/cfgrtl.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,6 +1,6 @@
 /* Control flow graph manipulation code for GNU compiler.
    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010
    Free Software Foundation, Inc.
 
 This file is part of GCC.
@@ -2951,7 +2951,7 @@
   op0 = force_operand (op0, NULL_RTX);
   op1 = force_operand (op1, NULL_RTX);
   do_compare_rtx_and_jump (op0, op1, comp, 0,
-			   mode, NULL_RTX, NULL_RTX, label);
+			   mode, NULL_RTX, NULL_RTX, label, -1);
   jump = get_last_insn ();
   JUMP_LABEL (jump) = label;
   LABEL_NUSES (label)++;
Index: gcc/stmt.c
===================================================================
--- gcc/stmt.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ gcc/stmt.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,6 +1,6 @@
 /* Expands front end tree to back end RTL for GCC
-   Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997,
-   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
+   Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
    Free Software Foundation, Inc.
 
 This file is part of GCC.
@@ -2472,7 +2472,7 @@
 		  int unsignedp)
 {
   do_compare_rtx_and_jump (op0, op1, EQ, unsignedp, mode,
-			   NULL_RTX, NULL_RTX, label);
+			   NULL_RTX, NULL_RTX, label, -1);
 }
 
 /* Not all case values are encountered equally.  This function
Index: libstdc++-v3/include/parallel/numeric
===================================================================
--- libstdc++-v3/include/parallel/numeric	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ libstdc++-v3/include/parallel/numeric	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -280,7 +280,7 @@
       typedef typename
 	__gnu_parallel::multiplies<value_type1, value_type2>::result
         multiplies_result_type;
-      return inner_product(first1, last1, first2, init,
+      return _GLIBCXX_STD_P::inner_product(first1, last1, first2, init,
                            __gnu_parallel::plus<T, multiplies_result_type>(),
                            __gnu_parallel::
 			   multiplies<value_type1, value_type2>(),
@@ -300,7 +300,7 @@
       typedef typename
 	__gnu_parallel::multiplies<value_type1, value_type2>::result
         multiplies_result_type;
-      return inner_product(first1, last1, first2, init,
+      return _GLIBCXX_STD_P::inner_product(first1, last1, first2, init,
                            __gnu_parallel::plus<T, multiplies_result_type>(),
                            __gnu_parallel::
 			   multiplies<value_type1, value_type2>());
@@ -355,7 +355,8 @@
     partial_sum(InputIterator begin, InputIterator end, OutputIterator result)
     {
       typedef typename iterator_traits<InputIterator>::value_type value_type;
-      return partial_sum(begin, end, result, std::plus<value_type>());
+      return _GLIBCXX_STD_P::partial_sum(begin, end, result,
+                                         std::plus<value_type>());
     }
 
   // Public interface
Index: libstdc++-v3/include/parallel/algobase.h
===================================================================
--- libstdc++-v3/include/parallel/algobase.h	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ libstdc++-v3/include/parallel/algobase.h	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -146,7 +146,7 @@
   template<typename InputIterator1, typename InputIterator2>
     inline bool
     equal(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2)
-    { return mismatch(begin1, end1, begin2).first == end1; }
+    { return _GLIBCXX_STD_P::mismatch(begin1, end1, begin2).first == end1; }
 
   // Public interface
   template<typename InputIterator1, typename InputIterator2,
@@ -154,7 +154,10 @@
     inline bool
     equal(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, 
 	  Predicate pred)
-    { return mismatch(begin1, end1, begin2, pred).first == end1; }
+    {
+      return _GLIBCXX_STD_P::mismatch(begin1, end1, begin2, pred).first
+                  == end1;
+    }
 
   // Sequential fallback
   template<typename InputIterator1, typename InputIterator2>
Index: libstdc++-v3/include/parallel/partial_sum.h
===================================================================
--- libstdc++-v3/include/parallel/partial_sum.h	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ libstdc++-v3/include/parallel/partial_sum.h	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -155,7 +155,7 @@
         else
           {
             ::new(&(sums[iam]))
-	      value_type(std::accumulate(begin + borders[iam] + 1,
+	      value_type(__gnu_parallel::accumulate(begin + borders[iam] + 1,
 					 begin + borders[iam + 1],
 					 *(begin + borders[iam]),
 					 bin_op,
Index: libstdc++-v3/include/parallel/algo.h
===================================================================
--- libstdc++-v3/include/parallel/algo.h	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ libstdc++-v3/include/parallel/algo.h	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -289,8 +289,8 @@
       typedef typename iteratori_traits::value_type valuei_type;
       typedef typename iteratorf_traits::value_type valuef_type;
 
-      return find_first_of(begin1, end1, begin2, end2, __gnu_parallel::
-                           equal_to<valuei_type, valuef_type>());
+      return _GLIBCXX_STD_P::find_first_of(begin1, end1, begin2, end2,
+                __gnu_parallel::equal_to<valuei_type, valuef_type>());
     }
 
   // Sequential fallback
@@ -1152,7 +1152,7 @@
              const T& val)
     {
       typedef typename iterator_traits<ForwardIterator>::value_type value_type;
-      return search_n(begin, end, count, val,
+      return _GLIBCXX_STD_P::search_n(begin, end, count, val,
                       __gnu_parallel::equal_to<value_type, T>());
     }
 
@@ -2093,7 +2093,7 @@
       typedef typename iterator1_traits::value_type value1_type;
       typedef typename iterator2_traits::value_type value2_type;
 
-      return merge(begin1, end1, begin2, end2, result, 
+      return _GLIBCXX_STD_P::merge(begin1, end1, begin2, end2, result, 
                    __gnu_parallel::less<value1_type, value2_type>());
     }
 
@@ -2134,7 +2134,7 @@
     {
       typedef iterator_traits<RandomAccessIterator> traits_type;
       typedef typename traits_type::value_type value_type;
-      nth_element(begin, nth, end, std::less<value_type>());
+      _GLIBCXX_STD_P::nth_element(begin, nth, end, std::less<value_type>());
     }
 
   // Sequential fallback
@@ -2175,7 +2175,8 @@
     {
       typedef iterator_traits<RandomAccessIterator> traits_type;
       typedef typename traits_type::value_type value_type;
-      partial_sort(begin, middle, end, std::less<value_type>());
+      _GLIBCXX_STD_P::partial_sort(begin, middle, end,
+                                   std::less<value_type>());
     }
 
   // Sequential fallback
@@ -2244,7 +2245,7 @@
     max_element(ForwardIterator begin, ForwardIterator end)
     {
       typedef typename iterator_traits<ForwardIterator>::value_type value_type;
-      return max_element(begin, end, std::less<value_type>());
+      return _GLIBCXX_STD_P::max_element(begin, end, std::less<value_type>());
     }
 
   // Public interface
@@ -2335,7 +2336,7 @@
     min_element(ForwardIterator begin, ForwardIterator end)
     {
       typedef typename iterator_traits<ForwardIterator>::value_type value_type;
-      return min_element(begin, end, std::less<value_type>());
+      return _GLIBCXX_STD_P::min_element(begin, end, std::less<value_type>());
     }
 
   // Public interface
Index: libstdc++-v3/include/backward/hash_map
===================================================================
--- libstdc++-v3/include/backward/hash_map	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ libstdc++-v3/include/backward/hash_map	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,6 +1,7 @@
 // Hashing map implementation -*- C++ -*-
 
-// Copyright (C) 2001, 2002, 2004, 2005, 2006, 2009 Free Software Foundation, Inc.
+// Copyright (C) 2001, 2002, 2004, 2005, 2006, 2009, 2010
+// Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -53,8 +54,8 @@
  *  containing extensions from the HP/SGI STL subset).
  */
 
-#ifndef _HASH_MAP
-#define _HASH_MAP 1
+#ifndef _BACKWARD_HASH_MAP
+#define _BACKWARD_HASH_MAP 1
 
 #include "backward_warning.h"
 #include <bits/c++config.h>
Index: libstdc++-v3/include/backward/hash_fun.h
===================================================================
--- libstdc++-v3/include/backward/hash_fun.h	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ libstdc++-v3/include/backward/hash_fun.h	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,6 +1,7 @@
 // 'struct hash' from SGI -*- C++ -*-
 
-// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2009 Free Software Foundation, Inc.
+// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2009, 2010
+// Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -53,8 +54,8 @@
  *  containing extensions from the HP/SGI STL subset).
  */
 
-#ifndef _HASH_FUN_H
-#define _HASH_FUN_H 1
+#ifndef _BACKWARD_HASH_FUN_H
+#define _BACKWARD_HASH_FUN_H 1
 
 #include <cstddef>
 
Index: libstdc++-v3/include/backward/hashtable.h
===================================================================
--- libstdc++-v3/include/backward/hashtable.h	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ libstdc++-v3/include/backward/hashtable.h	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,6 +1,6 @@
 // Hashtable implementation used by containers -*- C++ -*-
 
-// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
+// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
 // Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
@@ -54,8 +54,8 @@
  *  containing extensions from the HP/SGI STL subset).
  */
 
-#ifndef _HASHTABLE_H
-#define _HASHTABLE_H 1
+#ifndef _BACKWARD_HASHTABLE_H
+#define _BACKWARD_HASHTABLE_H 1
 
 // Hashtable class, used to implement the hashed associative containers
 // hash_set, hash_map, hash_multiset, and hash_multimap.
Index: libstdc++-v3/include/backward/auto_ptr.h
===================================================================
--- libstdc++-v3/include/backward/auto_ptr.h	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ libstdc++-v3/include/backward/auto_ptr.h	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -27,8 +27,8 @@
  *  You should not attempt to use it directly.
  */
 
-#ifndef _STL_AUTO_PTR_H
-#define _STL_AUTO_PTR_H 1
+#ifndef _BACKWARD_AUTO_PTR_H
+#define _BACKWARD_AUTO_PTR_H 1
 
 #include <bits/c++config.h>
 #include <debug/debug.h>
@@ -289,4 +289,4 @@
 
 _GLIBCXX_END_NAMESPACE
 
-#endif /* _STL_AUTO_PTR_H */
+#endif /* _BACKWARD_AUTO_PTR_H */
Index: libstdc++-v3/include/backward/strstream
===================================================================
--- libstdc++-v3/include/backward/strstream	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ libstdc++-v3/include/backward/strstream	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,6 +1,7 @@
 // Backward-compat support -*- C++ -*-
 
-// Copyright (C) 2001, 2002, 2004, 2005, 2009 Free Software Foundation, Inc.
+// Copyright (C) 2001, 2002, 2004, 2005, 2009, 2010
+// Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -40,8 +41,8 @@
 // MAY BE REMOVED in a future standard revision.  One should use the
 // header <sstream> instead.
 
-#ifndef _GLIBCXX_STRSTREAM
-#define _GLIBCXX_STRSTREAM
+#ifndef _BACKWARD_STRSTREAM
+#define _BACKWARD_STRSTREAM
 
 #include "backward_warning.h"
 #include <iosfwd>
Index: libstdc++-v3/include/backward/binders.h
===================================================================
--- libstdc++-v3/include/backward/binders.h	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ libstdc++-v3/include/backward/binders.h	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -54,8 +54,8 @@
  *  You should not attempt to use it directly.
  */
 
-#ifndef _GLIBCXX_BINDERS_H
-#define _GLIBCXX_BINDERS_H 1
+#ifndef _BACKWARD_BINDERS_H
+#define _BACKWARD_BINDERS_H 1
 
 _GLIBCXX_BEGIN_NAMESPACE(std)
 
@@ -165,4 +165,4 @@
 
 _GLIBCXX_END_NAMESPACE
 
-#endif /* _GLIBCXX_BINDERS_H */
+#endif /* _BACKWARD_BINDERS_H */
Index: libstdc++-v3/include/backward/hash_set
===================================================================
--- libstdc++-v3/include/backward/hash_set	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ libstdc++-v3/include/backward/hash_set	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,6 +1,7 @@
 // Hashing set implementation -*- C++ -*-
 
-// Copyright (C) 2001, 2002, 2004, 2005, 2006, 2009 Free Software Foundation, Inc.
+// Copyright (C) 2001, 2002, 2004, 2005, 2006, 2009, 2010
+// Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -53,8 +54,8 @@
  *  containing extensions from the HP/SGI STL subset).
  */
 
-#ifndef _HASH_SET
-#define _HASH_SET 1
+#ifndef _BACKWARD_HASH_SET
+#define _BACKWARD_HASH_SET 1
 
 #include "backward_warning.h"
 #include <bits/c++config.h>
Index: libstdc++-v3/ChangeLog
===================================================================
--- libstdc++-v3/ChangeLog	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ libstdc++-v3/ChangeLog	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,3 +1,36 @@
+2010-03-22  Johannes Singler  <singler@kit.edu>
+
+        * include/parallel/numeric (inner_product, partial_sum):
+        Precede subsequent call with _GLIBCXX_STD_P:: to avoid ambiguity 
+        between __gnu_parallel:: and std::
+        * include/parallel/algobase.h (equal): Likewise.
+        * include/parallel/algo.h (find_first_of, search_n, merge, nth_element,
+        partial_sort, max_element, min_element): Likewise.
+        * include/parallel/partial_sum.h (parallel_partial_sum_linear):
+        Qualify accumulate call with __gnu_parallel::.
+
+2010-03-18  Paolo Carlini  <paolo.carlini@oracle.com>
+
+	* include/backward/hash_map: Use consistently the _BACKWARD_*
+	prefix for the include guard.
+	* include/backward/hash_fun.h: Likewise.
+	* include/backward/hashtable.h: Likewise.
+	* include/backward/auto_ptr.h: Likewise.
+	* include/backward/strstream: Likewise.
+	* include/backward/binders.h: Likewise.
+	* include/backward/hash_set: Likewise.
+
+2010-02-23  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
+
+	Backport:
+	2010-01-20  Janis Johnson  <janis187@us.ibm.com>
+		    Paolo Carlini  <paolo.carlini@oracle.com>
+
+	PR libstdc++/21769
+	* testsuite/lib/dg-options.exp (add_options_for_no_pch): Add.
+	* testsuite/26_numerics/headers/cmath/c99_classification_macros_c.cc:
+	Use it.
+
 2010-01-21  Release Manager
 
 	* GCC 4.4.3 released.
Index: libstdc++-v3/testsuite/26_numerics/headers/cmath/c99_classification_macros_c.cc
===================================================================
--- libstdc++-v3/testsuite/26_numerics/headers/cmath/c99_classification_macros_c.cc	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ libstdc++-v3/testsuite/26_numerics/headers/cmath/c99_classification_macros_c.cc	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,6 +1,6 @@
 // 2001-04-06 gdr
 
-// Copyright (C) 2001, 2005, 2009 Free Software Foundation, Inc.
+// Copyright (C) 2001, 2005, 2009, 2010 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -17,8 +17,9 @@
 // with this library; see the file COPYING3.  If not see
 // <http://www.gnu.org/licenses/>.
 
+// { dg-do compile }
+// { dg-add-options no_pch }
 
-// { dg-do compile }
 // { dg-xfail-if "" { { *-*-linux* *-*-darwin[3-7]* } || { uclibc || newlib } } { "*" } { "" } }
 // { dg-excess-errors "" { target { { *-*-linux* *-*-darwin[3-7]* } || { uclibc || newlib } } } }
 
Index: libstdc++-v3/testsuite/lib/dg-options.exp
===================================================================
--- libstdc++-v3/testsuite/lib/dg-options.exp	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ libstdc++-v3/testsuite/lib/dg-options.exp	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,6 +1,6 @@
 # Handlers for additional dg-xxx keywords in tests.
 
-# Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009
+# Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010
 # Free Software Foundation, Inc.
 #
 # This program is free software; you can redistribute it and/or modify
@@ -142,3 +142,8 @@
     }
     return
 }
+
+proc add_options_for_no_pch { flags } {
+    # This forces any generated and possibly included PCH to be invalid.
+    return "-D__GLIBCXX__=99999999"
+}
Index: libgfortran/ChangeLog
===================================================================
--- libgfortran/ChangeLog	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ libgfortran/ChangeLog	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,3 +1,50 @@
+2010-03-25  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR libfortran/43517
+	* io/read.c (read_x): Return if seen EOR condition.
+
+2010-03-17  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR libfortran/43265
+	* io/io.h: Delete prototype for read_sf, making it static.
+	* io/read.c (read_x): Modify to call hit_eof if PAD="no".
+	* io/transfer.c (read_sf_internal): New static function extracted from
+	read_sf for use on internal units only. Handle empty string case.
+	(read_sf): New factoring of this function, make it static.  Add special
+	conditions for EOF based on ADVANCE="no", PAD="no", and whether any
+	bytes have been previously read from the record.
+	(read_block_form): Modify to call read_sf or read_sf_internal.
+	(next_record_r): Add a done flag similar to next_record_w. Call hit_eof
+	if internal array unit next record returns finished, meaning an EOF was
+	found and not done, ie not the last record expected.  For external
+	units call hit_eof if item_count is 1 or there are no pending spaces.
+	(next_record): Update call to next_record_r.
+
+2010-03-12  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR libfortran/43265
+	Backport from trunk.
+	* io/read.c (read_x): Replace the use of read_sf with equivalent lower
+	level I/O, eliminating unneeded code and handling EOF and EOR
+	conditions.
+	* io/io.h: Revise prototype for read_sf.
+	* io/transfer.c (read_sf): Delete no_error parameter and all uses of it.
+	Set eof and eor condition flags. (read_block_form): Likewise.
+	(next_record_r): Add condition to call to hit_eof.
+	
+2010-03-11  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/43228
+	* io/list_read.c (nml_parse_qualifier): Disable expanded_read
+	for array sections.
+
+2010-02-04  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR libfortran/42901
+	* io/list_read.c (nml_get_obj_data): Add new qualifier flag, clean up
+	code, and adjust logic to set namelist info pointer correctly for array
+	qualifiers of derived type components.
+
 2010-01-21  Release Manager
 
 	* GCC 4.4.3 released.
Index: libgfortran/io/list_read.c
===================================================================
--- libgfortran/io/list_read.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ libgfortran/io/list_read.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -287,10 +287,10 @@
 eat_line (st_parameter_dt *dtp)
 {
   char c;
-  if (!is_internal_unit (dtp))
-    do
-      c = next_char (dtp);
-    while (c != '\n');
+
+  do
+    c = next_char (dtp);
+  while (c != '\n');
 }
 
 
@@ -2092,6 +2092,14 @@
 	    }
 	}
 
+      if (is_array_section == 1 && dtp->u.p.expanded_read == 1)
+     	{
+	  int i;
+	  dtp->u.p.expanded_read = 0;
+	  for (i = 0; i < dim; i++)
+	    ls[i].end = ls[i].start;
+      	}
+
       /* Check the values of the triplet indices.  */
       if ((ls[dim].start > (ssize_t)ad[dim].ubound)
 	  || (ls[dim].start < (ssize_t)ad[dim].lbound)
@@ -2563,7 +2571,7 @@
   namelist_info * first_nl = NULL;
   namelist_info * root_nl = NULL;
   int dim, parsed_rank;
-  int component_flag;
+  int component_flag, qualifier_flag;
   index_type clow, chigh;
   int non_zero_rank_count;
 
@@ -2612,11 +2620,12 @@
       break;
     }
 
-  /* Untouch all nodes of the namelist and reset the flag that is set for
+  /* Untouch all nodes of the namelist and reset the flags that are set for
      derived type components.  */
 
   nml_untouch_nodes (dtp);
   component_flag = 0;
+  qualifier_flag = 0;
   non_zero_rank_count = 0;
 
   /* Get the object name - should '!' and '\n' be permitted separators?  */
@@ -2698,10 +2707,11 @@
 		    " for namelist variable %s", nl->var_name);
 	  goto nml_err_ret;
 	}
-
       if (parsed_rank > 0)
 	non_zero_rank_count++;
 
+      qualifier_flag = 1;
+
       c = next_char (dtp);
       unget_char (dtp, c);
     }
@@ -2726,6 +2736,7 @@
 
       root_nl = nl;
       component_flag = 1;
+
       c = next_char (dtp);
       goto get_name;
     }
@@ -2766,15 +2777,6 @@
       unget_char (dtp, c);
     }
 
-  /* If a derived type touch its components and restore the root
-     namelist_info if we have parsed a qualified derived type
-     component.  */
-
-  if (nl->type == GFC_DTYPE_DERIVED)
-    nml_touch_nodes (nl);
-  if (component_flag && nl->var_rank > 0 && nl->next)
-    nl = first_nl;
-
   /* Make sure no extraneous qualifiers are there.  */
 
   if (c == '(')
@@ -2819,10 +2821,24 @@
 		nl->var_name);
       goto nml_err_ret;
     }
+  /* If a derived type, touch its components and restore the root
+     namelist_info if we have parsed a qualified derived type
+     component.  */
 
-  if (first_nl != NULL && first_nl->var_rank > 0)
-    nl = first_nl;
-  
+  if (nl->type == GFC_DTYPE_DERIVED)
+    nml_touch_nodes (nl);
+
+  if (first_nl)
+    {
+      if (first_nl->var_rank == 0)
+	{
+	  if (component_flag && qualifier_flag)
+	    nl = first_nl;
+	}
+      else
+	nl = first_nl;
+    }
+
   if (nml_read_obj (dtp, nl, 0, pprev_nl, nml_err_msg, nml_err_msg_size,
 		    clow, chigh) == FAILURE)
     goto nml_err_ret;
Index: libgfortran/io/read.c
===================================================================
--- libgfortran/io/read.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ libgfortran/io/read.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1019,16 +1019,84 @@
  * and never look at it. */
 
 void
-read_x (st_parameter_dt * dtp, int n)
+read_x (st_parameter_dt *dtp, int n)
 {
+  int length;
+  char *p, q;
+
   if ((dtp->u.p.current_unit->pad_status == PAD_NO || is_internal_unit (dtp))
        && dtp->u.p.current_unit->bytes_left < n)
     n = dtp->u.p.current_unit->bytes_left;
+    
+  if (n == 0)
+    return;
 
-  dtp->u.p.sf_read_comma = 0;
-  if (n > 0)
-    read_sf (dtp, &n, 1);
-  dtp->u.p.sf_read_comma = 1;
+  length = n;
+
+  if (is_internal_unit (dtp))
+    {
+      p = mem_alloc_r (dtp->u.p.current_unit->s, &length);
+      if (unlikely (length < n))
+	n = length;
+      goto done;
+    }
+
+  if (dtp->u.p.sf_seen_eor)
+    return;
+
+  p = fbuf_read (dtp->u.p.current_unit, &length);
+  if (p == NULL)
+    {
+      hit_eof (dtp);
+      return;
+    }
+  
+  if (length == 0 && dtp->u.p.item_count == 1)
+    {
+      if (dtp->u.p.current_unit->pad_status == PAD_NO)
+	{
+	  hit_eof (dtp);
+	  return;
+	}
+      else
+	return;
+    }
+
+  n = 0;
+  while (n < length)
+    {
+      q = *p;
+      if (q == '\n' || q == '\r')
+	{
+	  /* Unexpected end of line. Set the position.  */
+	  fbuf_seek (dtp->u.p.current_unit, n + 1 ,SEEK_CUR);
+	  dtp->u.p.sf_seen_eor = 1;
+
+	  /* If we encounter a CR, it might be a CRLF.  */
+	  if (q == '\r') /* Probably a CRLF */
+	    {
+	      /* See if there is an LF. Use fbuf_read rather then fbuf_getc so
+		 the position is not advanced unless it really is an LF.  */
+	      int readlen = 1;
+	      p = fbuf_read (dtp->u.p.current_unit, &readlen);
+	      if (*p == '\n' && readlen == 1)
+	        {
+		  dtp->u.p.sf_seen_eor = 2;
+		  fbuf_seek (dtp->u.p.current_unit, 1 ,SEEK_CUR);
+		}
+	    }
+	  goto done;
+	}
+      n++;
+      p++;
+    } 
+
+  fbuf_seek (dtp->u.p.current_unit, n, SEEK_CUR);
+  
+ done:
+  if ((dtp->common.flags & IOPARM_DT_HAS_SIZE) != 0)
+    dtp->u.p.size_used += (GFC_IO_INT) n;
+  dtp->u.p.current_unit->bytes_left -= n;
   dtp->u.p.current_unit->strm_pos += (gfc_offset) n;
 }
 
Index: libgfortran/io/io.h
===================================================================
--- libgfortran/io/io.h	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ libgfortran/io/io.h	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -848,9 +848,6 @@
 extern void * read_block_form (st_parameter_dt *, int *);
 internal_proto(read_block_form);
 
-extern char *read_sf (st_parameter_dt *, int *, int);
-internal_proto(read_sf);
-
 extern void *write_block (st_parameter_dt *, int);
 internal_proto(write_block);
 
Index: libgfortran/io/transfer.c
===================================================================
--- libgfortran/io/transfer.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ libgfortran/io/transfer.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -162,9 +162,7 @@
 }
 
 
-/* Mid level data transfer statements.  These subroutines do reading
-   and writing in the style of salloc_r()/salloc_w() within the
-   current record.  */
+/* Mid level data transfer statements.  */
 
 /* When reading sequential formatted records we have a problem.  We
    don't know how long the line is until we read the trailing newline,
@@ -177,24 +175,56 @@
    we hit the newline.  For small allocations, we use a static buffer.
    For larger allocations, we are forced to allocate memory on the
    heap.  Hopefully this won't happen very often.  */
+   
+/* Read sequential file - internal unit  */
 
-char *
-read_sf (st_parameter_dt *dtp, int * length, int no_error)
+static char *
+read_sf_internal (st_parameter_dt *dtp, int * length)
 {
   static char *empty_string[0];
-  char *base, *p, q;
-  int n, lorig, memread, seen_comma;
+  char *base;
+  int lorig;
 
-  /* If we hit EOF previously with the no_error flag set (i.e. X, T,
-     TR edit descriptors), and we now try to read again, this time
-     without setting no_error.  */
-  if (!no_error && dtp->u.p.at_eof)
+  if (dtp->internal_unit_len == 0
+      && dtp->u.p.current_unit->pad_status == PAD_NO)
+    hit_eof (dtp);
+
+  /* If we have seen an eor previously, return a length of 0.  The
+     caller is responsible for correctly padding the input field.  */
+  if (dtp->u.p.sf_seen_eor)
     {
       *length = 0;
+      /* Just return something that isn't a NULL pointer, otherwise the
+         caller thinks an error occured.  */
+      return (char*) empty_string;
+    }
+
+  lorig = *length;
+  base = mem_alloc_r (dtp->u.p.current_unit->s, length);
+  if (unlikely (lorig > *length))
+    {
       hit_eof (dtp);
       return NULL;
     }
 
+  dtp->u.p.current_unit->bytes_left -= *length;
+
+  if ((dtp->common.flags & IOPARM_DT_HAS_SIZE) != 0)
+    dtp->u.p.size_used += (GFC_IO_INT) *length;
+
+  return base;
+
+}
+
+/* Read sequential file - external unit */
+
+static char *
+read_sf (st_parameter_dt *dtp, int * length)
+{
+  static char *empty_string[0];
+  char *base, *p, q;
+  int n, lorig, seen_comma;
+
   /* If we have seen an eor previously, return a length of 0.  The
      caller is responsible for correctly padding the input field.  */
   if (dtp->u.p.sf_seen_eor)
@@ -205,19 +235,6 @@
       return (char*) empty_string;
     }
 
-  if (is_internal_unit (dtp))
-    {
-      memread = *length;
-      base = mem_alloc_r (dtp->u.p.current_unit->s, length);
-      if (unlikely (memread > *length))
-	{
-          hit_eof (dtp);
-	  return NULL;
-	}
-      n = *length;
-      goto done;
-    }
-
   n = seen_comma = 0;
 
   /* Read data into format buffer and scan through it.  */
@@ -260,8 +277,6 @@
 	     so we can just continue with a short read.  */
 	  if (dtp->u.p.current_unit->pad_status == PAD_NO)
 	    {
-	      if (likely (no_error))
-		break;
 	      generate_error (&dtp->common, LIBERROR_EOR, NULL);
 	      return NULL;
 	    }
@@ -291,13 +306,29 @@
      some other stuff. Set the relevant flags.  */
   if (lorig > *length && !dtp->u.p.sf_seen_eor && !seen_comma)
     {
-      if (n > 0 || no_error)
-        dtp->u.p.at_eof = 1;
-      else
+      if (n > 0)
         {
-          hit_eof (dtp);
-          return NULL;
-        }
+	  if (dtp->u.p.advance_status == ADVANCE_NO)
+	    {
+	      if (dtp->u.p.current_unit->pad_status == PAD_NO)
+	        {
+		  hit_eof (dtp);
+		  return NULL;
+		}
+	      else
+		dtp->u.p.eor_condition = 1;
+	    }
+	  else
+	    dtp->u.p.at_eof = 1;
+	}
+      else if (dtp->u.p.advance_status == ADVANCE_NO
+	       || dtp->u.p.current_unit->pad_status == PAD_NO
+	       || dtp->u.p.current_unit->bytes_left
+		    == dtp->u.p.current_unit->recl)
+	{
+	  hit_eof (dtp);
+	  return NULL;
+	}
     }
 
  done:
@@ -338,7 +369,8 @@
             dtp->u.p.current_unit->bytes_left = dtp->u.p.current_unit->recl;
 	  else
 	    {
-	      if (unlikely (dtp->u.p.current_unit->pad_status == PAD_NO))
+	      if (unlikely (dtp->u.p.current_unit->pad_status == PAD_NO)
+		  && !is_internal_unit (dtp))
 		{
 		  /* Not enough data left.  */
 		  generate_error (&dtp->common, LIBERROR_EOR, NULL);
@@ -346,9 +378,10 @@
 		}
 	    }
 
-	  if (unlikely (dtp->u.p.current_unit->bytes_left == 0))
+	  if (unlikely (dtp->u.p.current_unit->bytes_left == 0
+	      && !is_internal_unit(dtp)))
 	    {
-              hit_eof (dtp);
+	      hit_eof (dtp);
 	      return NULL;
 	    }
 
@@ -360,7 +393,11 @@
       (dtp->u.p.current_unit->flags.access == ACCESS_SEQUENTIAL ||
        dtp->u.p.current_unit->flags.access == ACCESS_STREAM))
     {
-      source = read_sf (dtp, nbytes, 0);
+      if (is_internal_unit (dtp))
+	source = read_sf_internal (dtp, nbytes);
+      else
+	source = read_sf (dtp, nbytes);
+
       dtp->u.p.current_unit->strm_pos +=
 	(gfc_offset) (*nbytes + dtp->u.p.sf_seen_eor);
       return source;
@@ -2641,7 +2678,7 @@
 /* Space to the next record for read mode.  */
 
 static void
-next_record_r (st_parameter_dt *dtp)
+next_record_r (st_parameter_dt *dtp, int done)
 {
   gfc_offset record;
   int bytes_left;
@@ -2668,10 +2705,9 @@
     case FORMATTED_SEQUENTIAL:
       /* read_sf has already terminated input because of an '\n', or
          we have hit EOF.  */
-      if (dtp->u.p.sf_seen_eor || dtp->u.p.at_eof)
+      if (dtp->u.p.sf_seen_eor)
 	{
 	  dtp->u.p.sf_seen_eor = 0;
-          dtp->u.p.at_eof = 0;
 	  break;
 	}
 
@@ -2683,6 +2719,8 @@
 
 	      record = next_array_record (dtp, dtp->u.p.current_unit->ls,
 					  &finished);
+	      if (!done && finished)
+		hit_eof (dtp);
 
 	      /* Now seek to this record.  */
 	      record = record * dtp->u.p.current_unit->recl;
@@ -2720,8 +2758,9 @@
 		{
                   if (errno != 0)
                     generate_error (&dtp->common, LIBERROR_OS, NULL);
-                  else
-                    hit_eof (dtp);
+		  else if (dtp->u.p.item_count == 1
+			   || dtp->u.p.pending_spaces == 0)
+		    hit_eof (dtp);
 		  break;
                 }
 	      
@@ -3061,7 +3100,7 @@
   dtp->u.p.current_unit->read_bad = 0;
 
   if (dtp->u.p.mode == READING)
-    next_record_r (dtp);
+    next_record_r (dtp, done);
   else
     next_record_w (dtp, done);
 
Index: libmudflap/ChangeLog
===================================================================
--- libmudflap/ChangeLog	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ libmudflap/ChangeLog	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,3 +1,8 @@
+2010-03-15  David S. Miller  <davem@davemloft.net>
+
+	* testsuite/libmudflap.c/pass54-frag.c: Add explicit return from
+	main.
+
 2010-01-21  Release Manager
 
 	* GCC 4.4.3 released.
Index: libmudflap/testsuite/libmudflap.c/pass54-frag.c
===================================================================
--- libmudflap/testsuite/libmudflap.c/pass54-frag.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ libmudflap/testsuite/libmudflap.c/pass54-frag.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -30,4 +30,5 @@
   foo ();
   bar ();
   __mf_set_options ("-mode-check");
+  return 0;
 }
Index: libiberty/ChangeLog
===================================================================
--- libiberty/ChangeLog	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ libiberty/ChangeLog	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,3 +1,9 @@
+2010-01-25  Ian Lance Taylor  <iant@google.com>
+
+	* cp-demangle.c (cplus_demangle_type): Check for invalid type
+	after "DF".
+	* testsuite/demangle-expected: Add test.
+
 2010-01-21  Release Manager
 
 	* GCC 4.4.3 released.
Index: libiberty/testsuite/demangle-expected
===================================================================
--- libiberty/testsuite/demangle-expected	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ libiberty/testsuite/demangle-expected	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -3910,3 +3910,8 @@
 --format=gnu-v3
 _Z1gIIidEEDTclL_Z1fEspplfp_Li1EEEDpT_
 decltype (f((parm#1+(1))...)) g<int, double>(int, double)
+#
+# Used to crash the demangler.
+--format=gnu-v3
+DFA
+DFA
Index: libiberty/cp-demangle.c
===================================================================
--- libiberty/cp-demangle.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ libiberty/cp-demangle.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,5 +1,5 @@
 /* Demangler for g++ V3 ABI.
-   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008
+   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
    Free Software Foundation, Inc.
    Written by Ian Lance Taylor <ian@wasabisystems.com>.
 
@@ -2149,6 +2149,8 @@
 	    /* For demangling we don't care about the bits.  */
 	    d_number (di);
 	  ret->u.s_fixed.length = cplus_demangle_type (di);
+	  if (ret->u.s_fixed.length == NULL)
+	    return NULL;
 	  d_number (di);
 	  peek = d_next_char (di);
 	  ret->u.s_fixed.sat = (peek == 's');
Index: libffi/ChangeLog
===================================================================
--- libffi/ChangeLog	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ libffi/ChangeLog	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,3 +1,8 @@
+2010-02-15  Matthias Klose  <doko@ubuntu.com>
+
+	* src/arm/sysv.S (__ARM_ARCH__): Define for processor
+	__ARM_ARCH_7EM__.
+
 2010-01-21  Release Manager
 
 	* GCC 4.4.3 released.
Index: libffi/src/arm/sysv.S
===================================================================
--- libffi/src/arm/sysv.S	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ libffi/src/arm/sysv.S	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -73,7 +73,8 @@
 #endif
 
 #if defined(__ARM_ARCH_7__) || defined(__ARM_ARCH_7A__) \
-        || defined(__ARM_ARCH_7R__) || defined(__ARM_ARCH_7M__)
+        || defined(__ARM_ARCH_7R__) || defined(__ARM_ARCH_7M__) \
+	|| defined(__ARM_ARCH_7EM__)
 # undef __ARM_ARCH__
 # define __ARM_ARCH__ 7
 #endif
Index: libcpp/init.c
===================================================================
--- libcpp/init.c	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ libcpp/init.c	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,6 +1,6 @@
 /* CPP Library.
    Copyright (C) 1986, 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2009
+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2009, 2010
    Free Software Foundation, Inc.
    Contributed by Per Bothner, 1994-95.
    Based on CCCP program by Paul Rubin, June 1986
@@ -570,9 +570,9 @@
       pfile->state.in_directive = 0;
 
       /* If it's a #line directive, handle it.  */
-      if (token1->type == CPP_NUMBER)
+      if (token1->type == CPP_NUMBER
+	  && _cpp_handle_directive (pfile, token->flags & PREV_WHITE))
 	{
-	  _cpp_handle_directive (pfile, token->flags & PREV_WHITE);
 	  read_original_directory (pfile);
 	  return;
 	}
Index: libcpp/ChangeLog
===================================================================
--- libcpp/ChangeLog	(.../tags/gcc_4_4_3_release)	(wersja 157785)
+++ libcpp/ChangeLog	(.../branches/gcc-4_4-branch)	(wersja 157785)
@@ -1,3 +1,8 @@
+2010-02-11  Jakub Jelinek  <jakub@redhat.com>
+
+	* init.c (read_original_filename): Don't call read_original_directory
+	if _cpp_handle_directive returns 0.
+
 2010-01-21  Release Manager
 
 	* GCC 4.4.3 released.

Zmiany atrybutów dla: .
___________________________________________________________________
Dodane: svn:mergeinfo
   Połączono zmiany /trunk:r155835,156042

