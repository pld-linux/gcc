Index: libquadmath/ChangeLog
===================================================================
--- libquadmath/ChangeLog	(.../tags/gcc_4_6_0_release)	(wersja 171573)
+++ libquadmath/ChangeLog	(.../branches/gcc-4_6-branch)	(wersja 171573)
@@ -1,3 +1,11 @@
+2011-03-26  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline
+	2011-03-25  Jakub Jelinek  <jakub@redhat.com>
+
+	* printf/printf_fp.c (__quadmath_printf_fp): Use memcpy instead of
+	mempcpy.
+
 2011-03-25  Release Manager
 
 	* GCC 4.6.0 released.
Index: libquadmath/printf/printf_fp.c
===================================================================
--- libquadmath/printf/printf_fp.c	(.../tags/gcc_4_6_0_release)	(wersja 171573)
+++ libquadmath/printf/printf_fp.c	(.../branches/gcc-4_6-branch)	(wersja 171573)
@@ -1197,7 +1197,7 @@
 	    if (*copywc == decimalwc)
 	      memcpy (cp, decimal, decimal_len), cp += decimal_len;
 	    else if (*copywc == thousands_sepwc)
-	      mempcpy (cp, thousands_sep, thousands_sep_len), cp += thousands_sep_len;
+	      memcpy (cp, thousands_sep, thousands_sep_len), cp += thousands_sep_len;
 	    else
 	      *cp++ = (char) *copywc;
 	}
Index: gcc/c-family/c-common.c
===================================================================
--- gcc/c-family/c-common.c	(.../tags/gcc_4_6_0_release)	(wersja 171573)
+++ gcc/c-family/c-common.c	(.../branches/gcc-4_6-branch)	(wersja 171573)
@@ -3300,6 +3300,20 @@
   primop0 = get_narrower (op0, &unsignedp0);
   primop1 = get_narrower (op1, &unsignedp1);
 
+  /* If primopN is first sign-extended from primopN's precision to opN's
+     precision, then zero-extended from opN's precision to
+     *restype_ptr precision, shortenings might be invalid.  */
+  if (TYPE_PRECISION (TREE_TYPE (primop0)) < TYPE_PRECISION (TREE_TYPE (op0))
+      && TYPE_PRECISION (TREE_TYPE (op0)) < TYPE_PRECISION (*restype_ptr)
+      && !unsignedp0
+      && TYPE_UNSIGNED (TREE_TYPE (op0)))
+    primop0 = op0;
+  if (TYPE_PRECISION (TREE_TYPE (primop1)) < TYPE_PRECISION (TREE_TYPE (op1))
+      && TYPE_PRECISION (TREE_TYPE (op1)) < TYPE_PRECISION (*restype_ptr)
+      && !unsignedp1
+      && TYPE_UNSIGNED (TREE_TYPE (op1)))
+    primop1 = op1;
+
   /* Handle the case that OP0 does not *contain* a conversion
      but it *requires* conversion to FINAL_TYPE.  */
 
Index: gcc/DATESTAMP
===================================================================
--- gcc/DATESTAMP	(.../tags/gcc_4_6_0_release)	(wersja 171573)
+++ gcc/DATESTAMP	(.../branches/gcc-4_6-branch)	(wersja 171573)
@@ -1 +1 @@
-20110325
+20110327
Index: gcc/DEV-PHASE
===================================================================
--- gcc/DEV-PHASE	(.../tags/gcc_4_6_0_release)	(wersja 171573)
+++ gcc/DEV-PHASE	(.../branches/gcc-4_6-branch)	(wersja 171573)
@@ -0,0 +1 @@
+prerelease
Index: gcc/ChangeLog
===================================================================
--- gcc/ChangeLog	(.../tags/gcc_4_6_0_release)	(wersja 171573)
+++ gcc/ChangeLog	(.../branches/gcc-4_6-branch)	(wersja 171573)
@@ -1,3 +1,59 @@
+2011-03-26  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline:
+	2011-03-24  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/48237
+	* config/i386/i386.md (*movdf_internal_rex64): Do not split
+	alternatives that can be handled with movq or movabsq insn.
+	(*movdf_internal): Disable for !TARGET_64BIT.
+	(*movdf_internal_nointeger): Ditto.
+	* config/i386/i386.c (ix86_print_operand): Handle DFmode immediates.
+
+2011-03-26  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline
+	2011-03-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/48204
+	* simplify-rtx.c (simplify_const_unary_operation): Call
+	real_convert when changing mode class with FLOAT_EXTEND.
+
+	2011-03-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/42544
+	PR c/48197
+	* c-common.c (shorten_compare): If primopN is first sign-extended
+	to opN and then zero-extended to result type, set primopN to opN.
+
+	PR rtl-optimization/48156
+	* df-core.c (df_get_bb_dirty): Use df_lr if df_live is NULL,
+	assume df and df_lr are not NULL.
+
+	2011-03-17  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/48141
+	* params.def (PARAM_MAX_DSE_ACTIVE_LOCAL_STORES): New.
+	* dse.c: Include params.h.
+	(active_local_stores_len): New variable.
+	(add_wild_read, dse_step1): Clear it when setting active_local_stores
+	to NULL.
+	(record_store, check_mem_read_rtx): Decrease it when removing
+	from the chain.
+	(scan_insn): Likewise.  Increase it when adding to chain, if it
+	reaches PARAM_MAX_DSE_ACTIVE_LOCAL_STORES limit, set to 1 and
+	set active_local_stores to NULL before the addition.
+	* Makefile.in (dse.o): Depend on $(PARAMS_H).
+
+	PR rtl-optimization/48141
+	* dse.c (record_store): If no positions are needed in an insn
+	that cannot be deleted, at least unchain it from active_local_stores.
+
+2011-03-25  Jakub Jelinek  <jakub@redhat.com>
+
+	* BASE-VER: Set to 4.6.1.
+	* DEV-PHASE: Set to prerelease.
+
 2011-03-25  Release Manager
 
 	* GCC 4.6.0 released.
Index: gcc/testsuite/gcc.target/i386/pr48237.c
===================================================================
--- gcc/testsuite/gcc.target/i386/pr48237.c	(.../tags/gcc_4_6_0_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/i386/pr48237.c	(.../branches/gcc-4_6-branch)	(wersja 171573)
@@ -0,0 +1,22 @@
+/* { dg-do compile } */
+/* { dg-options "-O -fcaller-saves -fschedule-insns2 -fselective-scheduling2 -mtune=core2" } */
+
+union double_union
+{
+  double d;
+  int i[2];
+};
+
+void bar (int, ...);
+
+void
+foo (double d)
+{
+  union double_union du = { d };
+  while (1)
+    {
+      du.i[1] -= 0x100000L;
+      bar (0, du.d);
+      du.d += d;
+    }
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr48197.c
===================================================================
--- gcc/testsuite/gcc.c-torture/execute/pr48197.c	(.../tags/gcc_4_6_0_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/execute/pr48197.c	(.../branches/gcc-4_6-branch)	(wersja 171573)
@@ -0,0 +1,25 @@
+/* PR c/48197 */
+
+extern void abort (void);
+static int y = 0x8000;
+
+int
+main ()
+{
+  unsigned int x = (short)y;
+  if (sizeof (0LL) == sizeof (0U))
+    return 0;
+  if (0LL > (0U ^ (short)-0x8000))
+    abort ();
+  if (0LL > (0U ^ x))
+    abort ();
+  if (0LL > (0U ^ (short)y))
+    abort ();
+  if ((0U ^ (short)-0x8000) < 0LL)
+    abort ();
+  if ((0U ^ x) < 0LL)
+    abort ();
+  if ((0U ^ (short)y) < 0LL)
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr42544.c
===================================================================
--- gcc/testsuite/gcc.c-torture/execute/pr42544.c	(.../tags/gcc_4_6_0_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/execute/pr42544.c	(.../branches/gcc-4_6-branch)	(wersja 171573)
@@ -0,0 +1,14 @@
+/* PR c/42544 */
+
+extern void abort (void);
+
+int
+main ()
+{
+  signed short s = -1;
+  if (sizeof (long long) == sizeof (unsigned int))
+    return 0;
+  if ((unsigned int) s >= 0x100000000ULL)
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/pr48141.c
===================================================================
--- gcc/testsuite/gcc.dg/pr48141.c	(.../tags/gcc_4_6_0_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/pr48141.c	(.../branches/gcc-4_6-branch)	(wersja 171573)
@@ -0,0 +1,17 @@
+/* PR rtl-optimization/48141 */
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+#define A i = 0;
+#define B A A A A A A A A A A
+#define C B B B B B B B B B B
+#define D C C C C C C C C C C
+#define E D D D D D D D D D D
+
+int
+foo (void)
+{
+  volatile int i = 0;
+  E E E E E E E E E E E
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/pr48156.c
===================================================================
--- gcc/testsuite/gcc.dg/pr48156.c	(.../tags/gcc_4_6_0_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/pr48156.c	(.../branches/gcc-4_6-branch)	(wersja 171573)
@@ -0,0 +1,45 @@
+/* PR rtl-optimization/48156 */
+/* { dg-do run } */
+/* { dg-options "-O -fcrossjumping --param min-crossjump-insns=1" } */
+
+extern void abort (void);
+
+static int __attribute__ ((noinline, noclone))
+equals (int s1, int s2)
+{
+  return s1 == s2;
+}
+
+static int __attribute__ ((noinline, noclone))
+bar (void)
+{
+  return 1;
+}
+
+static void __attribute__ ((noinline, noclone))
+baz (int f, int j)
+{
+  if (f != 4 || j != 2)
+    abort ();
+}
+
+void
+foo (int x)
+{
+  int i = 0, j = bar ();
+
+  if (x == 1)
+    i = 2;
+
+  if (j && equals (i, j))
+    baz (8, i);
+  else
+    baz (4, i);
+}
+
+int
+main ()
+{
+  foo (1);
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/dfp/pr48204.c
===================================================================
--- gcc/testsuite/gcc.dg/dfp/pr48204.c	(.../tags/gcc_4_6_0_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/dfp/pr48204.c	(.../branches/gcc-4_6-branch)	(wersja 171573)
@@ -0,0 +1,10 @@
+/* PR debug/48204 */
+/* { dg-do compile } */
+/* { dg-options "-O -fno-tree-ccp -fno-tree-dominator-opts -fno-tree-fre -g" } */
+
+void
+foo (void)
+{
+  float cf = 3.0f;
+  _Decimal64 d64 = cf;
+}
Index: gcc/testsuite/ChangeLog
===================================================================
--- gcc/testsuite/ChangeLog	(.../tags/gcc_4_6_0_release)	(wersja 171573)
+++ gcc/testsuite/ChangeLog	(.../branches/gcc-4_6-branch)	(wersja 171573)
@@ -1,3 +1,34 @@
+2011-03-26  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline:
+	2011-03-24  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/48237
+	* gcc.target/i386/pr48237.c: New test.
+
+2011-03-26  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline
+	2011-03-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/48204
+	* gcc.dg/dfp/pr48204.c: New test.
+
+	2011-03-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/42544
+	PR c/48197
+	* gcc.c-torture/execute/pr42544.c: New test.
+	* gcc.c-torture/execute/pr48197.c: New test.
+
+	PR rtl-optimization/48156
+	* gcc.dg/pr48156.c: New test.
+
+	2011-03-17  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/48141
+	* gcc.dg/pr48141.c: New test.
+
 2011-03-25  Release Manager
 
 	* GCC 4.6.0 released.
Index: gcc/df-core.c
===================================================================
--- gcc/df-core.c	(.../tags/gcc_4_6_0_release)	(wersja 171573)
+++ gcc/df-core.c	(.../branches/gcc-4_6-branch)	(wersja 171573)
@@ -1,6 +1,6 @@
 /* Allocation for dataflow support routines.
    Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
-   2008, 2009, 2010 Free Software Foundation, Inc.
+   2008, 2009, 2010, 2011 Free Software Foundation, Inc.
    Originally contributed by Michael P. Hayes
              (m.hayes@elec.canterbury.ac.nz, mhayes@redhat.com)
    Major rewrite contributed by Danny Berlin (dberlin@dberlin.org)
@@ -1400,10 +1400,9 @@
 bool
 df_get_bb_dirty (basic_block bb)
 {
-  if (df && df_live)
-    return bitmap_bit_p (df_live->out_of_date_transfer_functions, bb->index);
-  else
-    return false;
+  return bitmap_bit_p ((df_live
+			? df_live : df_lr)->out_of_date_transfer_functions,
+		       bb->index);
 }
 
 
Index: gcc/dse.c
===================================================================
--- gcc/dse.c	(.../tags/gcc_4_6_0_release)	(wersja 171573)
+++ gcc/dse.c	(.../branches/gcc-4_6-branch)	(wersja 171573)
@@ -1,5 +1,5 @@
 /* RTL dead store elimination.
-   Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010
+   Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011
    Free Software Foundation, Inc.
 
    Contributed by Richard Sandiford <rsandifor@codesourcery.com>
@@ -47,6 +47,7 @@
 #include "optabs.h"
 #include "dbgcnt.h"
 #include "target.h"
+#include "params.h"
 
 /* This file contains three techniques for performing Dead Store
    Elimination (dse).
@@ -387,6 +388,7 @@
 /* The linked list of stores that are under consideration in this
    basic block.  */
 static insn_info_t active_local_stores;
+static int active_local_stores_len;
 
 struct bb_info
 {
@@ -947,6 +949,7 @@
     }
   insn_info->wild_read = true;
   active_local_stores = NULL;
+  active_local_stores_len = 0;
 }
 
 
@@ -1530,20 +1533,21 @@
 
       /* An insn can be deleted if every position of every one of
 	 its s_infos is zero.  */
-      if (any_positions_needed_p (s_info)
-	  || ptr->cannot_delete)
+      if (any_positions_needed_p (s_info))
 	del = false;
 
       if (del)
 	{
 	  insn_info_t insn_to_delete = ptr;
 
+	  active_local_stores_len--;
 	  if (last)
 	    last->next_local_store = ptr->next_local_store;
 	  else
 	    active_local_stores = ptr->next_local_store;
 
-	  delete_dead_store_insn (insn_to_delete);
+	  if (!insn_to_delete->cannot_delete)
+	    delete_dead_store_insn (insn_to_delete);
 	}
       else
 	last = ptr;
@@ -2074,6 +2078,7 @@
 	      if (dump_file)
 		dump_insn_info ("removing from active", i_ptr);
 
+	      active_local_stores_len--;
 	      if (last)
 		last->next_local_store = i_ptr->next_local_store;
 	      else
@@ -2163,6 +2168,7 @@
 	      if (dump_file)
 		dump_insn_info ("removing from active", i_ptr);
 
+	      active_local_stores_len--;
 	      if (last)
 		last->next_local_store = i_ptr->next_local_store;
 	      else
@@ -2222,6 +2228,7 @@
 	      if (dump_file)
 		dump_insn_info ("removing from active", i_ptr);
 
+	      active_local_stores_len--;
 	      if (last)
 		last->next_local_store = i_ptr->next_local_store;
 	      else
@@ -2426,6 +2433,7 @@
 		  if (dump_file)
 		    dump_insn_info ("removing from active", i_ptr);
 
+		  active_local_stores_len--;
 		  if (last)
 		    last->next_local_store = i_ptr->next_local_store;
 		  else
@@ -2453,6 +2461,12 @@
 		    fprintf (dump_file, "handling memset as BLKmode store\n");
 		  if (mems_found == 1)
 		    {
+		      if (active_local_stores_len++
+			  >= PARAM_VALUE (PARAM_MAX_DSE_ACTIVE_LOCAL_STORES))
+			{
+			  active_local_stores_len = 1;
+			  active_local_stores = NULL;
+			}
 		      insn_info->next_local_store = active_local_stores;
 		      active_local_stores = insn_info;
 		    }
@@ -2496,6 +2510,12 @@
      it as cannot delete.  This simplifies the processing later.  */
   if (mems_found == 1)
     {
+      if (active_local_stores_len++
+	  >= PARAM_VALUE (PARAM_MAX_DSE_ACTIVE_LOCAL_STORES))
+	{
+	  active_local_stores_len = 1;
+	  active_local_stores = NULL;
+	}
       insn_info->next_local_store = active_local_stores;
       active_local_stores = insn_info;
     }
@@ -2534,6 +2554,7 @@
 
       if (del)
 	{
+	  active_local_stores_len--;
 	  if (last)
 	    last->next_local_store = insn_info->next_local_store;
 	  else
@@ -2584,6 +2605,7 @@
 	    = create_alloc_pool ("cse_store_info_pool",
 				 sizeof (struct store_info), 100);
 	  active_local_stores = NULL;
+	  active_local_stores_len = 0;
 	  cselib_clear_table ();
 
 	  /* Scan the insns.  */
Index: gcc/BASE-VER
===================================================================
--- gcc/BASE-VER	(.../tags/gcc_4_6_0_release)	(wersja 171573)
+++ gcc/BASE-VER	(.../branches/gcc-4_6-branch)	(wersja 171573)
@@ -1 +1 @@
-4.6.0
+4.6.1
Index: gcc/simplify-rtx.c
===================================================================
--- gcc/simplify-rtx.c	(.../tags/gcc_4_6_0_release)	(wersja 171573)
+++ gcc/simplify-rtx.c	(.../branches/gcc-4_6-branch)	(wersja 171573)
@@ -1526,7 +1526,8 @@
     }
 
   else if (GET_CODE (op) == CONST_DOUBLE
-	   && SCALAR_FLOAT_MODE_P (mode))
+	   && SCALAR_FLOAT_MODE_P (mode)
+	   && SCALAR_FLOAT_MODE_P (GET_MODE (op)))
     {
       REAL_VALUE_TYPE d, t;
       REAL_VALUE_FROM_CONST_DOUBLE (d, op);
@@ -1549,7 +1550,10 @@
 	  d = real_value_truncate (mode, d);
 	  break;
 	case FLOAT_EXTEND:
-	  /* All this does is change the mode.  */
+	  /* All this does is change the mode, unless changing
+	     mode class.  */
+	  if (GET_MODE_CLASS (mode) != GET_MODE_CLASS (GET_MODE (op)))
+	    real_convert (&d, mode, &d);
 	  break;
 	case FIX:
 	  real_arithmetic (&d, FIX_TRUNC_EXPR, &d, NULL);
Index: gcc/Makefile.in
===================================================================
--- gcc/Makefile.in	(.../tags/gcc_4_6_0_release)	(wersja 171573)
+++ gcc/Makefile.in	(.../branches/gcc-4_6-branch)	(wersja 171573)
@@ -3070,7 +3070,7 @@
    $(TREE_H) $(TM_P_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h \
    $(RECOG_H) $(EXPR_H) $(DF_H) cselib.h $(DBGCNT_H) $(TIMEVAR_H) \
    $(TREE_PASS_H) alloc-pool.h $(ALIAS_H) dse.h $(OPTABS_H) $(TARGET_H) \
-   $(BITMAP_H)
+   $(BITMAP_H) $(PARAMS_H)
 fwprop.o : fwprop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
    $(DIAGNOSTIC_CORE_H) insn-config.h $(RECOG_H) $(FLAGS_H) $(OBSTACK_H) $(BASIC_BLOCK_H) \
    output.h $(DF_H) alloc-pool.h $(TIMEVAR_H) $(TREE_PASS_H) $(TARGET_H) \
Index: gcc/config/i386/i386.md
===================================================================
--- gcc/config/i386/i386.md	(.../tags/gcc_4_6_0_release)	(wersja 171573)
+++ gcc/config/i386/i386.md	(.../branches/gcc-4_6-branch)	(wersja 171573)
@@ -2906,9 +2906,9 @@
 
 (define_insn "*movdf_internal_rex64"
   [(set (match_operand:DF 0 "nonimmediate_operand"
-		"=f,m,f,r  ,m ,Y2*x,Y2*x,Y2*x,m   ,Yi,r ")
+		"=f,m,f,r ,m,!r,!m,Y2*x,Y2*x,Y2*x,m   ,Yi,r ")
 	(match_operand:DF 1 "general_operand"
-		"fm,f,G,rmF,Fr,C   ,Y2*x,m   ,Y2*x,r ,Yi"))]
+		"fm,f,G,rm,r,F ,F ,C   ,Y2*x,m   ,Y2*x,r ,Yi"))]
   "TARGET_64BIT && !(MEM_P (operands[0]) && MEM_P (operands[1]))
    && (reload_in_progress || reload_completed
        || (ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_LARGE)
@@ -2929,9 +2929,15 @@
 
     case 3:
     case 4:
+      return "mov{q}\t{%1, %0|%0, %1}";
+
+    case 5:
+      return "movabs{q}\t{%1, %0|%0, %1}";
+
+    case 6:
       return "#";
 
-    case 5:
+    case 7:
       switch (get_attr_mode (insn))
 	{
 	case MODE_V4SF:
@@ -2949,9 +2955,9 @@
 	default:
 	  gcc_unreachable ();
 	}
-    case 6:
-    case 7:
     case 8:
+    case 9:
+    case 10:
       switch (get_attr_mode (insn))
 	{
 	case MODE_V4SF:
@@ -2986,17 +2992,27 @@
 	  gcc_unreachable ();
 	}
 
-    case 9:
-    case 10:
+    case 11:
+    case 12:
     return "%vmovd\t{%1, %0|%0, %1}";
 
     default:
       gcc_unreachable();
     }
 }
-  [(set_attr "type" "fmov,fmov,fmov,multi,multi,sselog1,ssemov,ssemov,ssemov,ssemov,ssemov")
+  [(set_attr "type" "fmov,fmov,fmov,imov,imov,imov,multi,sselog1,ssemov,ssemov,ssemov,ssemov,ssemov")
+   (set (attr "modrm")
+     (if_then_else
+       (and (eq_attr "alternative" "5") (eq_attr "type" "imov"))
+	 (const_string "0")
+	 (const_string "*")))
+   (set (attr "length_immediate")
+     (if_then_else
+       (and (eq_attr "alternative" "5") (eq_attr "type" "imov"))
+	 (const_string "8")
+	 (const_string "*")))
    (set (attr "prefix")
-     (if_then_else (eq_attr "alternative" "0,1,2,3,4")
+     (if_then_else (eq_attr "alternative" "0,1,2,3,4,5,6")
        (const_string "orig")
        (const_string "maybe_vex")))
    (set (attr "prefix_data16")
@@ -3006,18 +3022,18 @@
    (set (attr "mode")
         (cond [(eq_attr "alternative" "0,1,2")
 		 (const_string "DF")
-	       (eq_attr "alternative" "3,4,9,10")
+	       (eq_attr "alternative" "3,4,5,6,11,12")
 		 (const_string "DI")
 
 	       /* For SSE1, we have many fewer alternatives.  */
 	       (eq (symbol_ref "TARGET_SSE2") (const_int 0))
-		 (cond [(eq_attr "alternative" "5,6")
+		 (cond [(eq_attr "alternative" "7,8")
 			  (const_string "V4SF")
 		       ]
 		   (const_string "V2SF"))
 
 	       /* xorps is one byte shorter.  */
-	       (eq_attr "alternative" "5")
+	       (eq_attr "alternative" "7")
 		 (cond [(ne (symbol_ref "optimize_function_for_size_p (cfun)")
 			    (const_int 0))
 			  (const_string "V4SF")
@@ -3032,7 +3048,7 @@
 		  chains, otherwise use short move to avoid extra work.
 
 		  movaps encodes one byte shorter.  */
-	       (eq_attr "alternative" "6")
+	       (eq_attr "alternative" "8")
 		 (cond
 		   [(ne (symbol_ref "optimize_function_for_size_p (cfun)")
 		        (const_int 0))
@@ -3045,7 +3061,7 @@
 	       /* For architectures resolving dependencies on register
 		  parts we may avoid extra work to zero out upper part
 		  of register.  */
-	       (eq_attr "alternative" "7")
+	       (eq_attr "alternative" "9")
 		 (if_then_else
 		   (ne (symbol_ref "TARGET_SSE_SPLIT_REGS")
 		       (const_int 0))
@@ -3059,7 +3075,7 @@
 		"=f,m,f,r  ,o ,Y2*x,Y2*x,Y2*x,m   ")
 	(match_operand:DF 1 "general_operand"
 		"fm,f,G,roF,Fr,C   ,Y2*x,m   ,Y2*x"))]
-  "!(MEM_P (operands[0]) && MEM_P (operands[1]))
+  "!TARGET_64BIT && !(MEM_P (operands[0]) && MEM_P (operands[1]))
    && optimize_function_for_speed_p (cfun)
    && TARGET_INTEGER_DFMODE_MOVES
    && (reload_in_progress || reload_completed
@@ -3199,9 +3215,9 @@
 			"=f,m,f,*r  ,o  ,Y2*x,Y2*x,Y2*x ,m  ")
 	(match_operand:DF 1 "general_operand"
 			"fm,f,G,*roF,*Fr,C   ,Y2*x,mY2*x,Y2*x"))]
-  "!(MEM_P (operands[0]) && MEM_P (operands[1]))
-   && ((optimize_function_for_size_p (cfun)
-       || !TARGET_INTEGER_DFMODE_MOVES) && !TARGET_64BIT)
+  "!TARGET_64BIT && !(MEM_P (operands[0]) && MEM_P (operands[1]))
+   && (optimize_function_for_size_p (cfun)
+       || !TARGET_INTEGER_DFMODE_MOVES)
    && (reload_in_progress || reload_completed
        || (ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_LARGE)
        || (!(TARGET_SSE2 && TARGET_SSE_MATH)
Index: gcc/config/i386/i386.c
===================================================================
--- gcc/config/i386/i386.c	(.../tags/gcc_4_6_0_release)	(wersja 171573)
+++ gcc/config/i386/i386.c	(.../branches/gcc-4_6-branch)	(wersja 171573)
@@ -14389,17 +14389,21 @@
 	fprintf (file, "0x%08x", (unsigned int) l);
     }
 
-  /* These float cases don't actually occur as immediate operands.  */
   else if (GET_CODE (x) == CONST_DOUBLE && GET_MODE (x) == DFmode)
     {
-      char dstr[30];
+      REAL_VALUE_TYPE r;
+      long l[2];
 
-      real_to_decimal (dstr, CONST_DOUBLE_REAL_VALUE (x), sizeof (dstr), 0, 1);
-      fputs (dstr, file);
+      REAL_VALUE_FROM_CONST_DOUBLE (r, x);
+      REAL_VALUE_TO_TARGET_DOUBLE (r, l);
+
+      if (ASSEMBLER_DIALECT == ASM_ATT)
+	putc ('$', file);
+      fprintf (file, "0x%lx%08lx", l[1] & 0xffffffff, l[0] & 0xffffffff);
     }
 
-  else if (GET_CODE (x) == CONST_DOUBLE
-	   && GET_MODE (x) == XFmode)
+  /* These float cases don't actually occur as immediate operands.  */
+  else if (GET_CODE (x) == CONST_DOUBLE && GET_MODE (x) == XFmode)
     {
       char dstr[30];
 
Index: gcc/params.def
===================================================================
--- gcc/params.def	(.../tags/gcc_4_6_0_release)	(wersja 171573)
+++ gcc/params.def	(.../branches/gcc-4_6-branch)	(wersja 171573)
@@ -698,6 +698,12 @@
 	 "The maximum number of instructions ready to be issued to be considered by the scheduler during the first scheduling pass",
 	 100, 0, 0)
 
+/* This is the maximum number of active local stores RTL DSE will consider.  */
+DEFPARAM (PARAM_MAX_DSE_ACTIVE_LOCAL_STORES,
+	  "max-dse-active-local-stores",
+	  "Maximum number of active local stores in RTL dead store elimination",
+	  5000, 0, 0)
+
 /* Prefetching and cache-optimizations related parameters.  Default values are
    usually set by machine description.  */
 
Index: libstdc++-v3/include/bits/random.tcc
===================================================================
--- libstdc++-v3/include/bits/random.tcc	(.../tags/gcc_4_6_0_release)	(wersja 171573)
+++ libstdc++-v3/include/bits/random.tcc	(.../branches/gcc-4_6-branch)	(wersja 171573)
@@ -1100,7 +1100,7 @@
 	  param_type;
 	
 	const double __y =
-	  _M_gd(__urng, param_type(__p.k(), __p.p() / (1.0 - __p.p())));
+	  _M_gd(__urng, param_type(__p.k(), (1.0 - __p.p()) / __p.p()));
 
 	std::poisson_distribution<result_type> __poisson(__y);
 	return __poisson(__urng);
Index: libstdc++-v3/include/bits/random.h
===================================================================
--- libstdc++-v3/include/bits/random.h	(.../tags/gcc_4_6_0_release)	(wersja 171573)
+++ libstdc++-v3/include/bits/random.h	(.../branches/gcc-4_6-branch)	(wersja 171573)
@@ -3782,7 +3782,9 @@
 	explicit
 	param_type(_IntType __k = 1, double __p = 0.5)
 	: _M_k(__k), _M_p(__p)
-	{ }
+	{
+	  _GLIBCXX_DEBUG_ASSERT((_M_k > 0) && (_M_p > 0.0) && (_M_p <= 1.0));
+	}
 
 	_IntType
 	k() const
@@ -3803,12 +3805,12 @@
 
       explicit
       negative_binomial_distribution(_IntType __k = 1, double __p = 0.5)
-      : _M_param(__k, __p), _M_gd(__k, __p / (1.0 - __p))
+      : _M_param(__k, __p), _M_gd(__k, (1.0 - __p) / __p)
       { }
 
       explicit
       negative_binomial_distribution(const param_type& __p)
-      : _M_param(__p), _M_gd(__p.k(), __p.p() / (1.0 - __p.p()))
+      : _M_param(__p), _M_gd(__p.k(), (1.0 - __p.p()) / __p.p())
       { }
 
       /**
Index: libstdc++-v3/ChangeLog
===================================================================
--- libstdc++-v3/ChangeLog	(.../tags/gcc_4_6_0_release)	(wersja 171573)
+++ libstdc++-v3/ChangeLog	(.../branches/gcc-4_6-branch)	(wersja 171573)
@@ -1,3 +1,13 @@
+2011-03-26  Paolo Carlini  <paolo.carlini@oracle.com>
+
+	* include/bits/random.h (negative_binomial_distribution<>::
+	negative_binomial_distribution(_IntType, double),
+	negative_binomial_distribution<>::
+	negative_binomial_distribution(const param_type&)): Fix thinko
+	p / (1 - p) for (1 - p) / p.
+	* include/bits/random.tcc (negative_binomial_distribution<>::
+	operator()): Fix.
+
 2011-03-25  Release Manager
 
 	* GCC 4.6.0 released.
