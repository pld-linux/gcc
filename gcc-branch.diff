Index: configure
===================================================================
--- configure	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ configure	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -5780,8 +5780,6 @@
 
 
 # Check for PPL
-ppl_major_version=0
-ppl_minor_version=10
 ppllibs=" -lppl_c -lppl -lgmpxx"
 pplinc=
 
@@ -5838,8 +5836,8 @@
 if test "x$with_ppl" != "xno" -a "${ENABLE_PPL_CHECK}" = "yes"; then
   saved_CFLAGS="$CFLAGS"
   CFLAGS="$CFLAGS $pplinc $gmpinc"
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for version $ppl_major_version.$ppl_minor_version of PPL" >&5
-$as_echo_n "checking for version $ppl_major_version.$ppl_minor_version of PPL... " >&6; }
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for version 0.10 (or later revision) of PPL" >&5
+$as_echo_n "checking for version 0.10 (or later revision) of PPL... " >&6; }
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include "ppl_c.h"
@@ -5847,7 +5845,7 @@
 main ()
 {
 
-  #if PPL_VERSION_MAJOR != $ppl_major_version || PPL_VERSION_MINOR != $ppl_minor_version
+  #if PPL_VERSION_MAJOR != 0 || PPL_VERSION_MINOR < 10
   choke me
   #endif
 
Index: libgomp/configure.tgt
===================================================================
--- libgomp/configure.tgt	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ libgomp/configure.tgt	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -125,6 +125,10 @@
 	config_path="bsd posix"
 	;;
 
+  mips-sgi-irix6*)
+	# Need to link with -lpthread so libgomp.so is self-contained.
+	XLDFLAGS="${XLDFLAGS} -lpthread"
+	;;
   *)
 	;;
 
Index: libgomp/ChangeLog
===================================================================
--- libgomp/ChangeLog	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ libgomp/ChangeLog	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1,3 +1,18 @@
+2011-01-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline
+	2010-12-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/46874
+	* libgomp.fortran/allocatable6.f90: New test.
+
+2010-12-17  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	Backport from mainline:
+	2010-12-01  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* configure.tgt (mips-sgi-irix6*): Add -lpthread to XLDFLAGS.
+
 2010-12-16  Release Manager
 
 	* GCC 4.5.2 released.
Index: libgomp/testsuite/libgomp.fortran/allocatable6.f90
===================================================================
--- libgomp/testsuite/libgomp.fortran/allocatable6.f90	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ libgomp/testsuite/libgomp.fortran/allocatable6.f90	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -0,0 +1,45 @@
+! PR fortran/46874
+! { dg-do run }
+
+  interface
+    subroutine sub (a, b, c, d, n)
+      integer :: n
+      integer, allocatable :: a(:), b(:), c(:), d(:)
+    end subroutine
+  end interface
+
+  integer, allocatable :: a(:), b(:), c(:), d(:)
+  integer :: i, j
+  allocate (a(50), b(50), c(50), d(50))
+  do i = 1, 50
+    a(i) = 2 + modulo (i, 7)
+    b(i) = 179 - modulo (i, 11)
+  end do
+  c = 0
+  d = 2147483647
+  call sub (a, b, c, d, 50)
+  do i = 1, 50
+    j = 0
+    if (i .eq. 3) then
+      j = 8
+    else if (i .gt. 1 .and. i .lt. 9) then
+      j = 7
+    end if
+    if (c(i) .ne. j) call abort
+    j = 179 - modulo (i, 11)
+    if (i .gt. 1 .and. i .lt. 9) j = i
+    if (d(i) .ne. j) call abort
+  end do
+  deallocate (a, b, c, d)
+end
+
+subroutine sub (a, b, c, d, n)
+  integer :: n
+  integer, allocatable :: a(:), b(:), c(:), d(:)
+!$omp parallel do shared(a, b) reduction(+:c) reduction(min:d)
+  do i = 1, n
+    c(a(i)) = c(a(i)) + 1
+    d(i) = min(d(i), b(i))
+    d(a(i)) = min(d(a(i)), a(i))
+  end do
+end
Index: gcc/tree-vrp.c
===================================================================
--- gcc/tree-vrp.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/tree-vrp.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -7290,6 +7290,7 @@
   size_t i;
   prop_value_t *single_val_range;
   bool do_value_subst_p;
+  unsigned num = num_ssa_names;
 
   if (dump_file)
     {
@@ -7301,10 +7302,10 @@
   /* We may have ended with ranges that have exactly one value.  Those
      values can be substituted as any other const propagated
      value using substitute_and_fold.  */
-  single_val_range = XCNEWVEC (prop_value_t, num_ssa_names);
+  single_val_range = XCNEWVEC (prop_value_t, num);
 
   do_value_subst_p = false;
-  for (i = 0; i < num_ssa_names; i++)
+  for (i = 0; i < num; i++)
     if (vr_value[i]
 	&& vr_value[i]->type == VR_RANGE
 	&& vr_value[i]->min == vr_value[i]->max
@@ -7332,7 +7333,7 @@
   identify_jump_threads ();
 
   /* Free allocated memory.  */
-  for (i = 0; i < num_ssa_names; i++)
+  for (i = 0; i < num; i++)
     if (vr_value[i])
       {
 	BITMAP_FREE (vr_value[i]->equiv);
Index: gcc/doc/extend.texi
===================================================================
--- gcc/doc/extend.texi	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/doc/extend.texi	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -11873,6 +11873,12 @@
 vector float vec_div (vector float, vector float);
 vector double vec_div (vector double, vector double);
 vector double vec_floor (vector double);
+vector double vec_ld (int, const vector double *);
+vector double vec_ld (int, const double *);
+vector double vec_ldl (int, const vector double *);
+vector double vec_ldl (int, const double *);
+vector unsigned char vec_lvsl (int, const volatile double *);
+vector unsigned char vec_lvsr (int, const volatile double *);
 vector double vec_madd (vector double, vector double, vector double);
 vector double vec_max (vector double, vector double);
 vector double vec_min (vector double, vector double);
@@ -11899,6 +11905,8 @@
 vector double vec_sub (vector double, vector double);
 vector float vec_sqrt (vector float);
 vector double vec_sqrt (vector double);
+void vec_st (vector double, int, vector double *);
+void vec_st (vector double, int, double *);
 vector double vec_trunc (vector double);
 vector double vec_xor (vector double, vector double);
 vector double vec_xor (vector double, vector bool long);
@@ -11927,8 +11935,66 @@
 int vec_any_nle (vector double, vector double);
 int vec_any_nlt (vector double, vector double);
 int vec_any_numeric (vector double);
+
+vector double vec_vsx_ld (int, const vector double *);
+vector double vec_vsx_ld (int, const double *);
+vector float vec_vsx_ld (int, const vector float *);
+vector float vec_vsx_ld (int, const float *);
+vector bool int vec_vsx_ld (int, const vector bool int *);
+vector signed int vec_vsx_ld (int, const vector signed int *);
+vector signed int vec_vsx_ld (int, const int *);
+vector signed int vec_vsx_ld (int, const long *);
+vector unsigned int vec_vsx_ld (int, const vector unsigned int *);
+vector unsigned int vec_vsx_ld (int, const unsigned int *);
+vector unsigned int vec_vsx_ld (int, const unsigned long *);
+vector bool short vec_vsx_ld (int, const vector bool short *);
+vector pixel vec_vsx_ld (int, const vector pixel *);
+vector signed short vec_vsx_ld (int, const vector signed short *);
+vector signed short vec_vsx_ld (int, const short *);
+vector unsigned short vec_vsx_ld (int, const vector unsigned short *);
+vector unsigned short vec_vsx_ld (int, const unsigned short *);
+vector bool char vec_vsx_ld (int, const vector bool char *);
+vector signed char vec_vsx_ld (int, const vector signed char *);
+vector signed char vec_vsx_ld (int, const signed char *);
+vector unsigned char vec_vsx_ld (int, const vector unsigned char *);
+vector unsigned char vec_vsx_ld (int, const unsigned char *);
+
+void vec_vsx_st (vector double, int, vector double *);
+void vec_vsx_st (vector double, int, double *);
+void vec_vsx_st (vector float, int, vector float *);
+void vec_vsx_st (vector float, int, float *);
+void vec_vsx_st (vector signed int, int, vector signed int *);
+void vec_vsx_st (vector signed int, int, int *);
+void vec_vsx_st (vector unsigned int, int, vector unsigned int *);
+void vec_vsx_st (vector unsigned int, int, unsigned int *);
+void vec_vsx_st (vector bool int, int, vector bool int *);
+void vec_vsx_st (vector bool int, int, unsigned int *);
+void vec_vsx_st (vector bool int, int, int *);
+void vec_vsx_st (vector signed short, int, vector signed short *);
+void vec_vsx_st (vector signed short, int, short *);
+void vec_vsx_st (vector unsigned short, int, vector unsigned short *);
+void vec_vsx_st (vector unsigned short, int, unsigned short *);
+void vec_vsx_st (vector bool short, int, vector bool short *);
+void vec_vsx_st (vector bool short, int, unsigned short *);
+void vec_vsx_st (vector pixel, int, vector pixel *);
+void vec_vsx_st (vector pixel, int, unsigned short *);
+void vec_vsx_st (vector pixel, int, short *);
+void vec_vsx_st (vector bool short, int, short *);
+void vec_vsx_st (vector signed char, int, vector signed char *);
+void vec_vsx_st (vector signed char, int, signed char *);
+void vec_vsx_st (vector unsigned char, int, vector unsigned char *);
+void vec_vsx_st (vector unsigned char, int, unsigned char *);
+void vec_vsx_st (vector bool char, int, vector bool char *);
+void vec_vsx_st (vector bool char, int, unsigned char *);
+void vec_vsx_st (vector bool char, int, signed char *);
 @end smallexample
 
+Note that the @samp{vec_ld} and @samp{vec_st} builtins will always
+generate the Altivec @samp{LVX} and @samp{STVX} instructions even
+if the VSX instruction set is available.  The @samp{vec_vsx_ld} and
+@samp{vec_vsx_st} builtins will always generate the VSX @samp{LXVD2X},
+@samp{LXVW4X}, @samp{STXVD2X}, and @samp{STXVW4X} instructions.
+
 GCC provides a few other builtins on Powerpc to access certain instructions:
 @smallexample
 float __builtin_recipdivf (float, float);
@@ -12799,7 +12865,7 @@
 be a @var{constant-expression}, as defined in 5.19.2 of the ANSI/ISO C++
 standard.
 
-See @uref{http://people.redhat.com/drepper/tls.pdf,
+See @uref{http://www.akkadia.org/drepper/tls.pdf,
 ELF Handling For Thread-Local Storage} for a detailed explanation of
 the four thread-local storage addressing models, and how the run-time
 is expected to function.
Index: gcc/doc/install.texi
===================================================================
--- gcc/doc/install.texi	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/doc/install.texi	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -44,9 +44,9 @@
 @settitle Installing GCC: GNU Free Documentation License
 @end ifset
 
-@c Copyright (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
-@c 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 
-@c 2010 Free Software Foundation, Inc.
+@c Copyright (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997,
+@c 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
+@c 2009, 2010, 2011 Free Software Foundation, Inc.
 @c *** Converted to texinfo by Dean Wakerley, dean@wakerley.com
 
 @c IMPORTANT: whenever you modify this file, run `install.texi2html' to
@@ -72,8 +72,8 @@
 @c Part 2 Summary Description and Copyright
 @copying
 Copyright @copyright{} 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997,
-1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
-2008 Free Software Foundation, Inc.
+1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
+2009, 2010, 2011 Free Software Foundation, Inc.
 @sp 1
 Permission is granted to copy, distribute and/or modify this document
 under the terms of the GNU Free Documentation License, Version 1.2 or
@@ -2784,10 +2784,6 @@
 @end itemize
 
 @item
-Motorola 68HC11/68HC12---@uref{http://www.gnu-m68hc11.org,,GNU
-Development Tools for the Motorola 68HC11/68HC12}.
-
-@item
 @uref{http://www.sco.com/skunkware/devtools/index.html#gcc,,SCO
 OpenServer/Unixware}.
 
@@ -3311,23 +3307,8 @@
 @heading @anchor{hppa-hp-hpux10}hppa*-hp-hpux10
 
 For hpux10.20, we @emph{highly} recommend you pick up the latest sed patch
-@code{PHCO_19798} from HP@.  HP has two sites which provide patches free of
-charge:
+@code{PHCO_19798} from HP@.
 
-@itemize @bullet
-@item
-@html
-<a href="http://us.itrc.hp.com/service/home/home.do">US, Canada, Asia-Pacific, and
-Latin-America</a>
-@end html
-@ifnothtml
-@uref{http://us.itrc.hp.com/service/home/home.do,,} US, Canada, Asia-Pacific,
-and Latin-America.
-@end ifnothtml
-@item
-@uref{http://europe.itrc.hp.com/service/home/home.do,,} Europe.
-@end itemize
-
 The C++ ABI has changed incompatibly in GCC 4.0.  COMDAT subspaces are
 used for one-only code and data.  This resolves many of the previous
 problems in using C++ on this target.  However, the ABI is not compatible
Index: gcc/tree-ssa-loop-im.c
===================================================================
--- gcc/tree-ssa-loop-im.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/tree-ssa-loop-im.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -2139,7 +2139,7 @@
   edge ex;
 
   for (i = 0; VEC_iterate (edge, exits, i, ex); i++)
-    if (ex->flags & EDGE_ABNORMAL)
+    if (ex->flags & (EDGE_ABNORMAL | EDGE_EH))
       return false;
 
   return true;
Index: gcc/tree-loop-distribution.c
===================================================================
--- gcc/tree-loop-distribution.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/tree-loop-distribution.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -251,7 +251,7 @@
 
 /* Generate a call to memset.  Return true when the operation succeeded.  */
 
-static bool
+static void
 generate_memset_zero (gimple stmt, tree op0, tree nb_iter,
 		      gimple_stmt_iterator bsi)
 {
@@ -265,45 +265,27 @@
 
   DR_STMT (dr) = stmt;
   DR_REF (dr) = op0;
-  if (!dr_analyze_innermost (dr))
-    goto end;
+  res = dr_analyze_innermost (dr);
+  gcc_assert (res && stride_of_unit_type_p (DR_STEP (dr), TREE_TYPE (op0)));
 
-  /* Test for a positive stride, iterating over every element.  */
-  if (integer_zerop (size_binop (MINUS_EXPR,
-				 fold_convert (sizetype, DR_STEP (dr)),
-				 TYPE_SIZE_UNIT (TREE_TYPE (op0)))))
-    {
-      addr_base = fold_convert_loc (loc, sizetype,
-				    size_binop_loc (loc, PLUS_EXPR,
-						    DR_OFFSET (dr),
-						    DR_INIT (dr)));
-      addr_base = fold_build2_loc (loc, POINTER_PLUS_EXPR,
-				   TREE_TYPE (DR_BASE_ADDRESS (dr)),
-				   DR_BASE_ADDRESS (dr), addr_base);
+  nb_bytes = build_size_arg_loc (loc, nb_iter, op0, &stmt_list);
+  addr_base = size_binop_loc (loc, PLUS_EXPR, DR_OFFSET (dr), DR_INIT (dr));
+  addr_base = fold_convert_loc (loc, sizetype, addr_base);
 
-      nb_bytes = build_size_arg_loc (loc, nb_iter, op0, &stmt_list);
-    }
-
   /* Test for a negative stride, iterating over every element.  */
-  else if (integer_zerop (size_binop (PLUS_EXPR,
-				      TYPE_SIZE_UNIT (TREE_TYPE (op0)),
-				      fold_convert (sizetype, DR_STEP (dr)))))
+  if (integer_zerop (size_binop (PLUS_EXPR,
+				 TYPE_SIZE_UNIT (TREE_TYPE (op0)),
+				 fold_convert (sizetype, DR_STEP (dr)))))
     {
-      nb_bytes = build_size_arg_loc (loc, nb_iter, op0, &stmt_list);
-
-      addr_base = size_binop_loc (loc, PLUS_EXPR, DR_OFFSET (dr), DR_INIT (dr));
-      addr_base = fold_convert_loc (loc, sizetype, addr_base);
       addr_base = size_binop_loc (loc, MINUS_EXPR, addr_base,
 				  fold_convert_loc (loc, sizetype, nb_bytes));
       addr_base = size_binop_loc (loc, PLUS_EXPR, addr_base,
 				  TYPE_SIZE_UNIT (TREE_TYPE (op0)));
-      addr_base = fold_build2_loc (loc, POINTER_PLUS_EXPR,
-				   TREE_TYPE (DR_BASE_ADDRESS (dr)),
-				   DR_BASE_ADDRESS (dr), addr_base);
     }
-  else
-    goto end;
 
+  addr_base = fold_build2_loc (loc, POINTER_PLUS_EXPR,
+			       TREE_TYPE (DR_BASE_ADDRESS (dr)),
+			       DR_BASE_ADDRESS (dr), addr_base);
   mem = force_gimple_operand (addr_base, &stmts, true, NULL);
   gimple_seq_add_seq (&stmt_list, stmts);
 
@@ -311,14 +293,11 @@
   fn_call = gimple_build_call (fn, 3, mem, integer_zero_node, nb_bytes);
   gimple_seq_add_stmt (&stmt_list, fn_call);
   gsi_insert_seq_after (&bsi, stmt_list, GSI_CONTINUE_LINKING);
-  res = true;
 
   if (dump_file && (dump_flags & TDF_DETAILS))
     fprintf (dump_file, "generated memset zero\n");
 
- end:
   free_data_ref (dr);
-  return res;
 }
 
 /* Tries to generate a builtin function for the instructions of LOOP
@@ -332,7 +311,6 @@
   unsigned i, x = 0;
   basic_block *bbs;
   gimple write = NULL;
-  tree op0, op1;
   gimple_stmt_iterator bsi;
   tree nb_iter = number_of_exit_cond_executions (loop);
 
@@ -368,26 +346,17 @@
 	}
     }
 
-  if (!write)
+  if (!stmt_with_adjacent_zero_store_dr_p (write))
     goto end;
 
-  op0 = gimple_assign_lhs (write);
-  op1 = gimple_assign_rhs1 (write);
-
-  if (!(TREE_CODE (op0) == ARRAY_REF
-	|| TREE_CODE (op0) == INDIRECT_REF))
-    goto end;
-
   /* The new statements will be placed before LOOP.  */
   bsi = gsi_last_bb (loop_preheader_edge (loop)->src);
+  generate_memset_zero (write, gimple_assign_lhs (write), nb_iter, bsi);
+  res = true;
 
-  if (gimple_assign_rhs_code (write) == INTEGER_CST
-      && (integer_zerop (op1) || real_zerop (op1)))
-    res = generate_memset_zero (write, op0, nb_iter, bsi);
-
   /* If this is the last partition for which we generate code, we have
      to destroy the loop.  */
-  if (res && !copy_p)
+  if (!copy_p)
     {
       unsigned nbbs = loop->num_nodes;
       edge exit = single_exit (loop);
@@ -531,24 +500,6 @@
 static void rdg_flag_vertex_and_dependent (struct graph *, int, bitmap, bitmap,
 					   bitmap, bool *);
 
-/* Flag all the uses of U.  */
-
-static void
-rdg_flag_all_uses (struct graph *rdg, int u, bitmap partition, bitmap loops,
-		   bitmap processed, bool *part_has_writes)
-{
-  struct graph_edge *e;
-
-  for (e = rdg->vertices[u].succ; e; e = e->succ_next)
-    if (!bitmap_bit_p (processed, e->dest))
-      {
-	rdg_flag_vertex_and_dependent (rdg, e->dest, partition, loops,
-				       processed, part_has_writes);
-	rdg_flag_all_uses (rdg, e->dest, partition, loops, processed,
-			   part_has_writes);
-      }
-}
-
 /* Flag the uses of U stopping following the information from
    upstream_mem_writes.  */
 
@@ -720,68 +671,13 @@
     }
 }
 
-/* Flag all the nodes of RDG containing memory accesses that could
-   potentially belong to arrays already accessed in the current
-   PARTITION.  */
-
-static void
-rdg_flag_similar_memory_accesses (struct graph *rdg, bitmap partition,
-				  bitmap loops, bitmap processed,
-				  VEC (int, heap) **other_stores)
-{
-  bool foo;
-  unsigned i, n;
-  int j, k, kk;
-  bitmap_iterator ii;
-  struct graph_edge *e;
-
-  EXECUTE_IF_SET_IN_BITMAP (partition, 0, i, ii)
-    if (RDG_MEM_WRITE_STMT (rdg, i)
-	|| RDG_MEM_READS_STMT (rdg, i))
-      {
-	for (j = 0; j < rdg->n_vertices; j++)
-	  if (!bitmap_bit_p (processed, j)
-	      && (RDG_MEM_WRITE_STMT (rdg, j)
-		  || RDG_MEM_READS_STMT (rdg, j))
-	      && rdg_has_similar_memory_accesses (rdg, i, j))
-	    {
-	      /* Flag first the node J itself, and all the nodes that
-		 are needed to compute J.  */
-	      rdg_flag_vertex_and_dependent (rdg, j, partition, loops,
-					     processed, &foo);
-
-	      /* When J is a read, we want to coalesce in the same
-		 PARTITION all the nodes that are using J: this is
-		 needed for better cache locality.  */
-	      rdg_flag_all_uses (rdg, j, partition, loops, processed, &foo);
-
-	      /* Remove from OTHER_STORES the vertex that we flagged.  */
-	      if (RDG_MEM_WRITE_STMT (rdg, j))
-		for (k = 0; VEC_iterate (int, *other_stores, k, kk); k++)
-		  if (kk == j)
-		    {
-		      VEC_unordered_remove (int, *other_stores, k);
-		      break;
-		    }
-	    }
-
-	/* If the node I has two uses, then keep these together in the
-	   same PARTITION.  */
-	for (n = 0, e = rdg->vertices[i].succ; e; e = e->succ_next, n++);
-
-	if (n > 1)
-	  rdg_flag_all_uses (rdg, i, partition, loops, processed, &foo);
-      }
-}
-
 /* Returns a bitmap in which all the statements needed for computing
    the strongly connected component C of the RDG are flagged, also
    including the loop exit conditions.  */
 
 static bitmap
 build_rdg_partition_for_component (struct graph *rdg, rdgc c,
-				   bool *part_has_writes,
-				   VEC (int, heap) **other_stores)
+				   bool *part_has_writes)
 {
   int i, v;
   bitmap partition = BITMAP_ALLOC (NULL);
@@ -793,13 +689,6 @@
       rdg_flag_vertex_and_dependent (rdg, v, partition, loops, processed,
 				     part_has_writes);
 
-  /* Also iterate on the array of stores not in the starting vertices,
-     and determine those vertices that have some memory affinity with
-     the current nodes in the component: these are stores to the same
-     arrays, i.e. we're taking care of cache locality.  */
-  rdg_flag_similar_memory_accesses (rdg, partition, loops, processed,
-				    other_stores);
-
   rdg_flag_loop_exits (rdg, loops, partition, processed, part_has_writes);
 
   BITMAP_FREE (processed);
@@ -863,6 +752,79 @@
   BITMAP_FREE (saved_components);
 }
 
+/* Returns true when it is possible to generate a builtin pattern for
+   the PARTITION of RDG.  For the moment we detect only the memset
+   zero pattern.  */
+
+static bool
+can_generate_builtin (struct graph *rdg, bitmap partition)
+{
+  unsigned i;
+  bitmap_iterator bi;
+  int nb_reads = 0;
+  int nb_writes = 0;
+  int stores_zero = 0;
+
+  EXECUTE_IF_SET_IN_BITMAP (partition, 0, i, bi)
+    if (RDG_MEM_READS_STMT (rdg, i))
+      nb_reads++;
+    else if (RDG_MEM_WRITE_STMT (rdg, i))
+      {
+	nb_writes++;
+	if (stmt_with_adjacent_zero_store_dr_p (RDG_STMT (rdg, i)))
+	  stores_zero++;
+      }
+
+  return stores_zero == 1 && nb_writes == 1 && nb_reads == 0;
+}
+
+/* Returns true when PARTITION1 and PARTITION2 have similar memory
+   accesses in RDG.  */
+
+static bool
+similar_memory_accesses (struct graph *rdg, bitmap partition1,
+			 bitmap partition2)
+{
+  unsigned i, j;
+  bitmap_iterator bi, bj;
+
+  EXECUTE_IF_SET_IN_BITMAP (partition1, 0, i, bi)
+    if (RDG_MEM_WRITE_STMT (rdg, i)
+	|| RDG_MEM_READS_STMT (rdg, i))
+      EXECUTE_IF_SET_IN_BITMAP (partition2, 0, j, bj)
+	if (RDG_MEM_WRITE_STMT (rdg, j)
+	    || RDG_MEM_READS_STMT (rdg, j))
+	  if (rdg_has_similar_memory_accesses (rdg, i, j))
+	    return true;
+
+  return false;
+}
+
+/* Fuse all the partitions from PARTITIONS that contain similar memory
+   references, i.e., we're taking care of cache locality.  This
+   function does not fuse those partitions that contain patterns that
+   can be code generated with builtins.  */
+
+static void
+fuse_partitions_with_similar_memory_accesses (struct graph *rdg,
+					      VEC (bitmap, heap) **partitions)
+{
+  int p1, p2;
+  bitmap partition1, partition2;
+
+  for (p1 = 0; VEC_iterate (bitmap, *partitions, p1, partition1); p1++)
+    if (!can_generate_builtin (rdg, partition1))
+      for (p2 = 0; VEC_iterate (bitmap, *partitions, p2, partition2); p2++)
+	if (p1 != p2
+	    && !can_generate_builtin (rdg, partition2)
+	    && similar_memory_accesses (rdg, partition1, partition2))
+	  {
+	    bitmap_ior_into (partition1, partition2);
+	    VEC_ordered_remove (bitmap, *partitions, p2);
+	    p2--;
+	  }
+}
+
 /* Aggregate several components into a useful partition that is
    registered in the PARTITIONS vector.  Partitions will be
    distributed in different loops.  */
@@ -885,8 +847,7 @@
       if (bitmap_bit_p (processed, v))
 	continue;
 
-      np = build_rdg_partition_for_component (rdg, x, &part_has_writes,
-					      other_stores);
+      np = build_rdg_partition_for_component (rdg, x, &part_has_writes);
       bitmap_ior_into (partition, np);
       bitmap_ior_into (processed, np);
       BITMAP_FREE (np);
@@ -932,6 +893,8 @@
     VEC_safe_push (bitmap, heap, *partitions, partition);
   else
     BITMAP_FREE (partition);
+
+  fuse_partitions_with_similar_memory_accesses (rdg, partitions);
 }
 
 /* Dump to FILE the PARTITIONS.  */
Index: gcc/DATESTAMP
===================================================================
--- gcc/DATESTAMP	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/DATESTAMP	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1 +1 @@
-20101216
+20110212
Index: gcc/DEV-PHASE
===================================================================
--- gcc/DEV-PHASE	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/DEV-PHASE	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -0,0 +1 @@
+prerelease
Index: gcc/tree-ssa-sccvn.c
===================================================================
--- gcc/tree-ssa-sccvn.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/tree-ssa-sccvn.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -988,6 +988,7 @@
 }
 
 static tree *last_vuse_ptr;
+static vn_lookup_kind vn_walk_kind;
 
 /* Callback for walk_non_aliased_vuses.  Adjusts the vn_reference_t VR_
    with the current VUSE and performs the expression lookup.  */
@@ -1063,6 +1064,7 @@
       size2 = TREE_INT_CST_LOW (gimple_call_arg (def_stmt, 2)) * 8;
       if ((unsigned HOST_WIDE_INT)size2 / 8
 	  == TREE_INT_CST_LOW (gimple_call_arg (def_stmt, 2))
+	  && maxsize2 != -1
 	  && operand_equal_p (base, base2, 0)
 	  && offset2 <= offset
 	  && offset2 + size2 >= offset + maxsize)
@@ -1086,7 +1088,8 @@
       HOST_WIDE_INT offset2, size2, maxsize2;
       base2 = get_ref_base_and_extent (gimple_assign_lhs (def_stmt),
 				       &offset2, &size2, &maxsize2);
-      if (operand_equal_p (base, base2, 0)
+      if (maxsize2 != -1
+	  && operand_equal_p (base, base2, 0)
 	  && offset2 <= offset
 	  && offset2 + size2 >= offset + maxsize)
 	{
@@ -1101,7 +1104,8 @@
 
   /* For aggregate copies translate the reference through them if
      the copy kills ref.  */
-  else if (gimple_assign_single_p (def_stmt)
+  else if (vn_walk_kind == VN_WALKREWRITE
+	   && gimple_assign_single_p (def_stmt)
 	   && (DECL_P (gimple_assign_rhs1 (def_stmt))
 	       || INDIRECT_REF_P (gimple_assign_rhs1 (def_stmt))
 	       || handled_component_p (gimple_assign_rhs1 (def_stmt))))
@@ -1116,7 +1120,8 @@
       /* See if the assignment kills REF.  */
       base2 = get_ref_base_and_extent (gimple_assign_lhs (def_stmt),
 				       &offset2, &size2, &maxsize2);
-      if (!operand_equal_p (base, base2, 0)
+      if (maxsize2 == -1
+	  || !operand_equal_p (base, base2, 0)
 	  || offset2 > offset
 	  || offset2 + size2 < offset + maxsize)
 	return (void *)-1;
@@ -1190,7 +1195,7 @@
 tree
 vn_reference_lookup_pieces (tree vuse, alias_set_type set, tree type,
 			    VEC (vn_reference_op_s, heap) *operands,
-			    vn_reference_t *vnresult, bool maywalk)
+			    vn_reference_t *vnresult, vn_lookup_kind kind)
 {
   struct vn_reference_s vr1;
   vn_reference_t tmp;
@@ -1215,10 +1220,11 @@
   vn_reference_lookup_1 (&vr1, vnresult);
 
   if (!*vnresult
-      && maywalk
+      && kind != VN_NOWALK
       && vr1.vuse)
     {
       ao_ref r;
+      vn_walk_kind = kind;
       if (ao_ref_init_from_vn_reference (&r, set, type, vr1.operands))
 	*vnresult =
 	  (vn_reference_t)walk_non_aliased_vuses (&r, vr1.vuse,
@@ -1241,7 +1247,7 @@
    stored in the hashtable if one exists.  */
 
 tree
-vn_reference_lookup (tree op, tree vuse, bool maywalk,
+vn_reference_lookup (tree op, tree vuse, vn_lookup_kind kind,
 		     vn_reference_t *vnresult)
 {
   VEC (vn_reference_op_s, heap) *operands;
@@ -1256,12 +1262,13 @@
   vr1.set = get_alias_set (op);
   vr1.hashcode = vn_reference_compute_hash (&vr1);
 
-  if (maywalk
+  if (kind != VN_NOWALK
       && vr1.vuse)
     {
       vn_reference_t wvnresult;
       ao_ref r;
       ao_ref_init (&r, op);
+      vn_walk_kind = kind;
       wvnresult =
 	(vn_reference_t)walk_non_aliased_vuses (&r, vr1.vuse,
 						vn_reference_lookup_2,
@@ -1980,14 +1987,14 @@
 
   last_vuse = gimple_vuse (stmt);
   last_vuse_ptr = &last_vuse;
-  result = vn_reference_lookup (op, gimple_vuse (stmt), true, NULL);
+  result = vn_reference_lookup (op, gimple_vuse (stmt), VN_WALKREWRITE, NULL);
   last_vuse_ptr = NULL;
 
   /* If we have a VCE, try looking up its operand as it might be stored in
      a different type.  */
   if (!result && TREE_CODE (op) == VIEW_CONVERT_EXPR)
     result = vn_reference_lookup (TREE_OPERAND (op, 0), gimple_vuse (stmt),
-    				  true, NULL);
+    				  VN_WALKREWRITE, NULL);
 
   /* We handle type-punning through unions by value-numbering based
      on offset and size of the access.  Be prepared to handle a
@@ -2098,7 +2105,7 @@
      Otherwise, the vdefs for the store are used when inserting into
      the table, since the store generates a new memory state.  */
 
-  result = vn_reference_lookup (lhs, gimple_vuse (stmt), false, NULL);
+  result = vn_reference_lookup (lhs, gimple_vuse (stmt), VN_NOWALK, NULL);
 
   if (result)
     {
Index: gcc/tree-ssa-sccvn.h
===================================================================
--- gcc/tree-ssa-sccvn.h	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/tree-ssa-sccvn.h	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -185,10 +185,11 @@
 void copy_reference_ops_from_call (gimple, VEC(vn_reference_op_s, heap) **);
 bool ao_ref_init_from_vn_reference (ao_ref *, alias_set_type, tree,
 				    VEC (vn_reference_op_s, heap) *);
+typedef enum { VN_NOWALK, VN_WALK, VN_WALKREWRITE } vn_lookup_kind;
 tree vn_reference_lookup_pieces (tree, alias_set_type, tree,
 				 VEC (vn_reference_op_s, heap) *,
-				 vn_reference_t *, bool);
-tree vn_reference_lookup (tree, tree, bool, vn_reference_t *);
+				 vn_reference_t *, vn_lookup_kind);
+tree vn_reference_lookup (tree, tree, vn_lookup_kind, vn_reference_t *);
 vn_reference_t vn_reference_insert (tree, tree, tree);
 vn_reference_t vn_reference_insert_pieces (tree, alias_set_type, tree,
 					   VEC (vn_reference_op_s, heap) *,
Index: gcc/ChangeLog
===================================================================
--- gcc/ChangeLog	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/ChangeLog	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1,3 +1,655 @@
+2011-02-11  Bernd Schmidt  <bernds@codesourcery.com>
+
+	PR rtl-optimization/47166
+	* reload1.c (emit_reload_insns): Disable the spill_reg_store
+	mechanism for PRE_MODIFY and POST_MODIFY.
+	(inc_for_reload): For PRE_MODIFY, return the insn that sets the
+	reloadreg.
+
+2011-02-10  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	Backport from mainline:
+	2011-02-07  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	* config.gcc (hppa[12]*-*-hpux11*): Don't set extra_parts.
+	* config/pa/stublib.c (pthread_default_stacksize_np, pthread_mutex_lock,
+	pthread_mutex_unlock): Remove.
+	* config/pa/t-pa-hpux11: Remove rules to build pthread stubs.
+	* config/pa/t-pa64: Likewise.
+	* config/pa/pa64-hpux.h (LIB_SPEC): In static links, link against
+	shared libc if not linking against libpthread.
+	* config/pa/pa-hpux11.h (LIB_SPEC): Likewise.
+
+2011-02-03  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Backport from mainline:
+	2011-02-02  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	PR target/47272
+	* doc/extend.texi (PowerPC AltiVec/VSX Built-in Functions):
+	Document using vector double with the load/store builtins, and
+	that the load/store builtins always use Altivec instructions.
+
+	* config/rs6000/vector.md (vector_altivec_load_<mode>): New insns
+	to use altivec memory instructions, even on VSX.
+	(vector_altivec_store_<mode>): Ditto.
+
+	* config/rs6000/rs6000-protos.h (rs6000_address_for_altivec): New
+	function.
+
+	* config/rs6000/rs6000-c.c (altivec_overloaded_builtins): Add
+	V2DF, V2DI support to load/store overloaded builtins.
+
+	* config/rs6000/rs6000-builtin.def (ALTIVEC_BUILTIN_*): Add
+	altivec load/store builtins for V2DF/V2DI types.
+
+	* config/rs6000/rs6000.c (rs6000_option_override_internal): Don't
+	set avoid indexed addresses on power6 if -maltivec.
+	(altivec_expand_ld_builtin): Add V2DF, V2DI support, use
+	vector_altivec_load/vector_altivec_store builtins.
+	(altivec_expand_st_builtin): Ditto.
+	(altivec_expand_builtin): Add VSX memory builtins.
+	(rs6000_init_builtins): Add V2DI types to internal types.
+	(altivec_init_builtins): Add support for V2DF/V2DI altivec
+	load/store builtins.
+	(rs6000_address_for_altivec): Insure memory address is appropriate
+	for Altivec.
+
+	* config/rs6000/vsx.md (vsx_load_<mode>): New expanders for
+	vec_vsx_ld and vec_vsx_st.
+	(vsx_store_<mode>): Ditto.
+
+	* config/rs6000/rs6000.h (RS6000_BTI_long_long): New type
+	variables to hold long long types for VSX vector memory builtins.
+	(RS6000_BTI_unsigned_long_long): Ditto.
+	(long_long_integer_type_internal_node): Ditti.
+	(long_long_unsigned_type_internal_node): Ditti.
+
+	* config/rs6000/altivec.md (UNSPEC_LVX): New UNSPEC.
+	(altivec_lvx_<mode>): Make altivec_lvx use a mode iterator.
+	(altivec_stvx_<mode>): Make altivec_stvx use a mode iterator.
+
+	* config/rs6000/altivec.h (vec_vsx_ld): Define VSX memory builtin
+	short cuts.
+	(vec_vsx_st): Ditto.
+
+	Backport from mainline:
+	2011-02-01  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	PR target/47580
+	* config/rs6000/vsx.md (vsx_float<VSi><mode>2): Use
+	gpc_reg_operand instead of vsx_register_operand to match rs6000.md
+	generator functions.
+	(vsx_floatuns<VSi><mode>2): Ditto.
+	(vsx_fix_trunc<mode><VSi>2): Ditto.
+	(vsx_fixuns_trunc<mode><VSi>2): Ditto.
+
+2011-02-02  Nick Clifton  <nickc@redhat.com>
+
+	Import these patches from the mainline:
+	2011-01-31  Nick Clifton  <nickc@redhat.com>
+
+	* config/rx/rx.c (rx_get_stack_layout): Only save call clobbered
+	registers inside interrupt handlers if the handler is not a leaf
+	function.
+
+	2011-01-25  Nick Clifton  <nickc@redhat.com>
+
+	* config/rx/rx.h (LIBCALL_VALUE): Do not promote complex types.
+	* config/rx/rx.c (rx_function_value): Likewise.
+	(rx_promote_function_mode): Likewise.
+	(gen_safe_add): Place an outsized immediate value inside an UNSPEC
+	in order to make it legitimate.
+	* config/rx/rx.md (adddi3_internal): If the second operand is a
+	MEM make sure that the first operand is the same as the result
+	register.
+	(addsi3_unspec): Delete.
+	(subdi3): Do not accept immediate operands.
+	(subdi3_internal): Likewise.
+
+	2011-01-24  Richard Henderson  <rth@redhat.com>
+
+	* config/rx/predicates.md (rx_fp_comparison_operator): Don't accept
+	compound unordered comparisons.
+	* config/rx/rx.c (rx_split_fp_compare): Remove.
+	* config/rx/rx-protos.h: Update.
+	* config/rx/rx.md (gcc_conds, rx_conds): Remove.
+	(cbranchsf4): Don't call rx_split_fp_compare.
+	(*cbranchsf4): Use rx_split_cbranch.
+	(*cmpsf): Don't accept "i" constraint.
+	(*conditional_branch): Only valid after reload.
+	(cstoresf4): Merge expander with insn.  Don't call
+	rx_split_fp_compare.
+
+	2011-01-22  Nick Clifton  <nickc@redhat.com>
+
+	* config/rx/rx.md (cstoresf4): Pass comparison operator to
+	rx_split_fp_compare.
+
+	2011-01-22  Nick Clifton  <nickc@redhat.com>
+
+	* config/rx/rx.md (UNSPEC_CONST): New.
+	(deallocate_and_return): Wrap the amount popped off the stack in
+	an UNSPEC_CONST in order to stop it being rejected by
+	-mmax-constant-size.
+	(pop_and_return): Add a "(return)" rtx.
+	(call): Drop the immediate operand.
+	(call_internal): Likewise.
+	(call_value): Likewise.
+	(call_value_internal): Likewise.
+	(sibcall_internal): Likewise.
+	(sibcall_value_internal): Likewise.
+	(sibcall): Likewise.  Generate an explicit call using
+	sibcall_internal.
+	(sibcall_value): Likewise.
+	(mov<>): FAIL if a constant operand is not legitimate.
+	(addsi3_unpsec): New pattern.
+
+	* config/rx/rx.c (rx_print_operand_address): Handle UNPSEC
+	CONSTs.
+	(ok_for_max_constant): New function.
+	(gen_safe_add): New function.
+	(rx_expand_prologue): Use gen_safe_add.
+	(rx_expand_epilogue): Likewise.
+	(rx_is_legitimate_constant): Use ok_for_max_constant.  Handle
+	UNSPEC CONSTs.
+
+	2011-01-17  Richard Henderson  <rth@redhat.com>
+
+	* config/rx/predicates.md (rx_constshift_operand): Use match_test.
+	(rx_restricted_mem_operand): New.
+	(rx_shift_operand): Use register_operand.
+	(rx_source_operand, rx_compare_operand): Likewise.
+	* config/rx/rx.md (addsi3_flags): New expander.
+	(adddi3): Rewrite as expander.
+	(adc_internal, *adc_flags, adddi3_internal): New patterns.
+	(subsi3_flags): New expander.
+	(subdi3): Rewrite as expander.
+	(sbb_internal, *sbb_flags, subdi3_internal): New patterns.
+
+	* config/rx/rx.c (RX_BUILTIN_SAT): Remove.
+	(rx_init_builtins): Remove sat builtin.
+	(rx_expand_builtin): Likewise.
+	* config/rx/rx.md (ssaddsi3): New.
+	(*sat): Rename from sat.  Represent the CC_REG input.
+
+	* config/rx/predicates.md (rshift_operator): New.
+	* config/rx/rx.c (rx_expand_insv): Remove.
+	* config/rx/rx-protos.h: Update.
+	* config/rx/rx.md (*bitset): Rename from bitset.  Swap the ashift
+	operand to the canonical position.
+	(*bitset_in_memory, *bitinvert, *bitinvert_in_memory): Similarly.
+	(*bitclr, *bitclr_in_memory): Similarly.
+	(*insv_imm, rx_insv_reg, *insv_cond, *bmcc, *insv_cond_lt): New.
+	(insv): Retain the zero_extract in the expansion.
+
+	* config/rx/rx.md (bswapsi2): Use = not + for output reload.
+	(bswaphi2, bitinvert, revw): Likewise.
+
+	* config/rx/rx.c (gen_rx_store_vector): Use VOIDmode for gen_rtx_SET.
+	(gen_rx_rtsd_vector, gen_rx_popm_vector): Likewise.
+	* config/rx/rx.md (pop_and_return): Use VOIDmode for SET.
+	(stack_push, stack_pushm, stack_pop, stack_popm): Likewise.
+	(bitset, bitset_in_memory): Likewise.
+	(bitinvert, bitinvert_in_memory): Likewise.
+	(bitclr, bitclr_in_memory): Likewise.
+	(insv, sync_lock_test_and_setsi, movstr, rx_movstr): Likewise.
+	(rx_strend, rx_cmpstrn): Likewise.
+	(rx_setmem): Likewise.  Make the source BLKmode to match the dest.
+	(bitop peep2 patterns): Remove.
+
+	* config/rx/rx.c (rx_match_ccmode): New.
+	* config/rx/rx-protos.h: Update.
+	* config/rx/rx.md (abssi2): Clobber, don't set flags.
+	(addsi3, adddi3, andsi3, negsi2, one_cmplsi2, iorsi3): Likewise.
+	(rotlsi3, rotrsi3, ashrsi3, lshrsi3, ashlsi3): Likewise.
+	(subsi3, subdi3, xorsi3, addsf3, divsf3, mulsf3, subsf3): Likewise.
+	(fix_truncsfsi2, floatsisf2): Likewise.
+	(*abssi2_flags, *addsi3_flags, *andsi3_flags, *negsi2_flags): New.
+	(*one_cmplsi2_flags, *iorsi3_flags, *rotlsi3_flags): New.
+	(*rotrsi3_flags, *ashrsi3_flags, *lshrsi3_flags, *ashlsi3_flags): New.
+	(*subsi3_flags, *xorsi3_flags): New.
+
+	* config/rx/rx.md (cstoresf4, *cstoresf4): New patterns.
+
+	* config/rx/rx.c (rx_print_operand): Remove workaround for
+	unsplit comparison operations.
+
+	* config/rx/rx.md (movsicc): Split after reload.
+	(*movsicc): Merge *movsieq and *movsine via match_operator.
+	(*stcc): New pattern.
+
+	* config/rx/rx.c (rx_float_compare_mode): Remove.
+	* config/rx/rx.h (rx_float_compare_mode): Remove.
+	* config/rx/rx.md (cstoresi4): Split after reload.
+	(*sccc): New pattern.
+
+	* config/rx/predicates.md (label_ref_operand): New.
+	(rx_z_comparison_operator): New.
+	(rx_zs_comparison_operator): New.
+	(rx_fp_comparison_operator): New.
+	* config/rx/rx.c (rx_print_operand) [B]: Examine comparison modes.
+	Validate that the flags are set properly for the comparison.
+	(rx_gen_cond_branch_template): Remove.
+	(rx_cc_modes_compatible): Remove.
+	(mode_from_flags): New.
+	(flags_from_code): Rename from flags_needed_for_conditional.
+	(rx_cc_modes_compatible): Re-write in terms of flags_from_mode.
+	(rx_select_cc_mode): Likewise.
+	(rx_split_fp_compare): New.
+	(rx_split_cbranch): New.
+	* config/rx/rx.md (most_cond, zs_cond): Remove iterators.
+	(*cbranchsi4): Use match_operator and rx_split_cbranch.
+	(*cbranchsf4): Similarly.
+	(*cbranchsi4_tst): Rename from *tstbranchsi4_<code>.  Use
+	match_operator and rx_split_cbranch.
+	(*cbranchsi4_tst_ext): Combine *tstbranchsi4m_eq and
+	tstbranchsi4m_ne.  Use match_operator and rx_split_cbranch.
+	(*cmpsi): Rename from cmpsi.
+	(*tstsi): Rename from tstsi.
+	(*cmpsf): Rename from cmpsf; use CC_Fmode.
+	(*conditional_branch): Rename from conditional_branch.
+	(*reveresed_conditional_branch): Remove.
+	(b<code>): Remove expander.
+	* config/rx/rx-protos.h: Update.
+
+	* config/rx/rx.c (rx_compare_redundant): Remove.
+	* config/rx/rx.md (cmpsi): Don't use it.
+	* config/rx/rx-protos.h: Update.
+
+	* config/rx/rx-modes.def (CC_F): New mode.
+	* config/rx/rx.c (rx_select_cc_mode): New.
+	* config/rx/rx.h (SELECT_CC_MODE): Use it.
+	* config/rx/rx-protos.h: Update.
+
+2011-02-01  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/47541
+	* tree-ssa-structalias.c (push_fields_onto_fieldstack): Make
+	sure to have a field at offset zero.
+
+2011-01-31  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Backport from mainline:
+	2010-12-30  Nathan Froyd  <froydnj@codesourcery.com>
+
+        PR target/44606
+        * reload1.c (choose_reload_regs): Don't look for equivalences for
+        output reloads of constant loads.
+
+2011-01-30  Gerald Pfeifer  <gerald@pfeifer.com>
+
+	* doc/install.texi (hppa-hp-hpux10): Remove references to HP
+	support sites.
+
+2011-01-30  Gerald Pfeifer  <gerald@pfeifer.com>
+
+	* doc/install.texi: Update copyright years.
+
+2011-01-30  Gerald Pfeifer  <gerald@pfeifer.com>
+
+	* doc/install.texi (Binaries): Remove outdated reference for
+	Motorola 68HC11/68HC12 downloads.
+
+2011-01-30  Gerald Pfeifer  <gerald@pfeifer.com>
+
+	* doc/extend.texi (Thread-Local): Adjust reference to Ulrich
+	Drepper's paper.
+
+2011-01-29  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	Backport from mainline:
+	2010-08-22  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+        PR boehm-gc/34544
+	* gthr-posix.h (__gthread_active_init): Delete.
+	(__gthread_active_p): Do activity check here.
+	Don't include errno.h on hppa-hpux.  Update comment.
+	* gthr-posix95.h (__gthread_active_init): Delete.
+	(__gthread_active_p): Do activity check here.
+	Don't include errno.h on hppa-hpux.  Update comment.
+	* config.gcc (hppa[12]*-*-hpux11*): Define extra_parts.
+	* config/pa/pa64-hpux.h (LIB_SPEC): When -static is specified, only
+	add -lpthread when -mt or -pthread is specified.
+	* config/pa/pa-hpux11.h (LIB_SPEC): likewise.
+	(LINK_GCC_C_SEQUENCE_SPEC): Define.
+	* config/pa/t-pa-hpux11 (LIBGCCSTUB_OBJS): Define.
+	(stublib.c, pthread_default_stacksize_np-stub.o,
+	pthread_mutex_lock-stub.o, pthread_mutex_unlock-stub.o,
+	$(T)libgcc_stub.a): Add methods.
+	* config/pa/t-pa64 (LIBGCCSTUB_OBJS): Add pthread stubs.
+	(stublib.c, pthread_default_stacksize_np-stub.o,
+	pthread_mutex_lock-stub.o, pthread_mutex_unlock-stub.o): Add methods.
+	* config/pa/stublib.c (pthread_default_stacksize_np, pthread_mutex_lock,
+	pthread_mutex_unlock): New stubs.
+
+2011-01-26  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR rtl-optimization/44469
+	* cfgcleanup.c (try_optimize_cfg): Iterate in CFG layout mode too
+	after removing trivially dead basic blocks.
+
+2011-01-25  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/47411
+	Backport from mainline
+	2010-06-30  Michael Matz  <matz@suse.de>
+
+	PR bootstrap/44699
+	* tree-vrp.c (vrp_finalize): Deal with changing num_ssa_names.
+
+2011-01-21  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	Backport from mainline.
+	2010-09-08  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	PR target/44392
+	* config/arm/arm.md (bswapsi2): Handle condition correctly
+	for armv6 and optimize_size.
+
+2011-01-21  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/47365
+	* tree-ssa-sccvn.h (vn_lookup_kind): Declare.
+	(vn_reference_lookup_pieces): Adjust.
+	(vn_reference_lookup): Likewise.
+	* tree-ssa-sccvn.c (vn_walk_kind): New static global.
+	(vn_reference_lookup_3): Only look through kills if in
+	VN_WALKREWRITE mode.
+	(vn_reference_lookup_pieces): Adjust.
+	(vn_reference_lookup): Likewise.
+	(visit_reference_op_load): Likewise.
+	(visit_reference_op_store): Likewise.
+	* tree-ssa-pre.c (phi_translate_1): Use VN_WALK mode.
+	(compute_avail): Likewise.
+	(eliminate): Likewise.
+
+2011-01-20  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/47167
+	* tree-ssa-copyrename.c (copy_rename_partition_coalesce):
+	Revert previous change, only avoid enumeral type changes.
+
+2011-01-17  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2011-01-17  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/47318
+	* config/i386/avxintrin.h (_mm_maskload_pd): Change mask to
+	__m128i.
+	(_mm_maskstore_pd): Likewise.
+	(_mm_maskload_ps): Likewise.
+	(_mm_maskstore_ps): Likewise.
+	(_mm256_maskload_pd): Change mask to __m256i.
+	(_mm256_maskstore_pd): Likewise.
+	(_mm256_maskload_ps): Likewise.
+	(_mm256_maskstore_ps): Likewise.
+
+	* config/i386/i386-builtin-types.def: Updated.
+	(ix86_expand_special_args_builtin): Likewise.
+
+	* config/i386/i386.c (bdesc_special_args): Update
+	__builtin_ia32_maskloadpd, __builtin_ia32_maskloadps,
+	__builtin_ia32_maskloadpd256, __builtin_ia32_maskloadps256,
+	__builtin_ia32_maskstorepd, __builtin_ia32_maskstoreps,
+	__builtin_ia32_maskstorepd256 and __builtin_ia32_maskstoreps256.
+
+	* config/i386/sse.md (avx_maskload<ssemodesuffix><avxmodesuffix>):
+	Use <avxpermvecmode> on mask register.
+	(avx_maskstore<ssemodesuffix><avxmodesuffix>): Likewise.
+
+2011-01-17  Olivier Hainque  <hainque@adacore.com>
+            Michael Haubenwallner  <michael.haubenwallner@salomon.at>
+            Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/46655
+	* xcoffout.c (ASM_OUTPUT_LINE): Output line only if positive, and only
+	if <= USHRT_MAX in 32-bit mode.
+
+2011-01-17  Richard Guenther  <rguenther@suse.de>
+
+	Backport from mainline
+	PR tree-optimization/47286
+	* tree-ssa-structalias.c (new_var_info): Register variables
+	are global.
+
+	PR tree-optimization/44592
+	* tree-ssa-ccp.c (gimplify_and_update_call_from_tree): Copy
+	from trunk.
+
+2011-01-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline
+	2011-01-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/47201
+	* config/i386/i386.c (ix86_delegitimize_address): If
+	simplify_gen_subreg fails, return orig_x.
+
+	2011-01-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/47150
+	* c-convert.c (convert): When converting a complex expression
+	other than COMPLEX_EXPR to a different complex type, ensure
+	c_save_expr is called instead of save_expr, unless in_late_binary_op.
+	* c-typeck.c (convert_for_assignment): Set in_late_binary_op also
+	when converting COMPLEX_TYPE.
+
+	2010-12-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/46880
+	* config/i386/sse.md (sse2_loadlpd, sse2_movsd): Fix shufpd source
+	operand.
+
+	PR middle-end/45852
+	* expr.c (store_expr): Ignore alt_rtl if equal to target,
+	but has side-effects.
+
+	2010-12-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/43655
+	* tree-ssa-ter.c (is_replaceable_p): Don't use
+	gimple_references_memory_p for -O0, instead check for load
+	by looking at rhs.
+
+	PR debug/46893
+	* cfgexpand.c (expand_debug_expr): If GET_MODE (op0) is VOIDmode,
+	use TYPE_MODE (TREE_TYPE (tem)) instead of mode1.
+
+	2010-12-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/46804
+	* regmove.c (optimize_reg_copy_3): Look for REG_EQUAL note
+	on the setter of src_reg rather than on insn.  If it is
+	equal to the setter's original SET_SRC, replace it with its
+	zero or sign extension instead of dropping it.
+
+	PR rtl-optimization/46865
+	* rtl.c (rtx_equal_p_cb, rtx_equal_p): For last operand of
+	ASM_OPERANDS and ASM_INPUT if integers are different,
+	call locator_eq.
+	* jump.c (rtx_renumbered_equal_p): Likewise.
+
+	PR tree-optimization/46864
+	* tree-ssa-loop-im.c (loop_suitable_for_sm): Return false even
+	when there are EDGE_EH exit edges.
+
+	2010-12-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/41082
+	* config/rs6000/rs6000.c (rs6000_expand_vector_extract): Use stvx
+	instead of stve*x.
+	(altivec_expand_stv_builtin): For op0 use mode of operand 1 instead
+	of operand 0.
+	* config/rs6000/altivec.md (VI_scalar): New mode attr.
+	(altivec_stve<VI_char>x, *altivec_stvesfx): Use scalar instead of
+	vector mode for operand 0, put operand 1 into UNSPEC.
+
+2011-01-13  Nick Clifton  <nickc@redhat.com>
+
+	Import this fix from the mainline:
+	2010-10-19  Nick Clifton  <nickc@redhat.com>
+
+	* config/rx/rx.c (rx_function_value): Small integer types are
+	promoted to SImode.
+	(rx_promote_function_mode): New function.
+	(TARGET_PROMOTE_FUNCTION_MODE): Define.
+
+2011-01-07  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	Backport from mainline:
+	2011-01-06  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	PR target/43309
+	* config/i386/i386.c (legitimize_tls_address)
+	<TLS_MODEL_INITIAL_EXEC>: Handle TARGET_64BIT && TARGET_SUN_TLS.
+	* config/i386/i386.md (UNSPEC_TLS_IE_SUN): Declare.
+	(tls_initial_exec_64_sun): New pattern.
+
+2011-01-03  Eric Botcazou  <ebotcazou@adacore.com>
+
+	Backport from mainline
+	2010-12-30  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/47038
+	* config/sparc/sparc.c (sparc_file_end): Call resolve_unique_section
+	on the GOT helper if USE_HIDDEN_LINKONCE.
+
+	2010-12-02  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/46685
+	* config/sparc/sparc.c (can_use_mov_pic_label_ref): New predicate.
+	(sparc_expand_move): Call it to decide whether to emit the special
+	mov{si,di}_pic_label_ref patterns.
+	(sparc_legitimize_pic_address): Call it to decide whether to emit
+	the regular PIC sequence for labels.  Fix long line.
+	(sparc_file_end): Set is_thunk for the PIC helper.
+
+2010-12-30  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	* config/pa/pa.md: Add ",*" condition to 64-bit add/subtract boolean
+	patterns.
+
+2010-12-27  Yao Qi  <yao@codesourcery.com>
+
+	Backport from mainline:
+	2010-10-14  Yao Qi  <yao@codesourcery.com>
+
+	PR target/45447
+	* config/arm/arm.c (arm_build_builtin_va_list): Assign
+	va_list_name to TYPE_STUB_DECL (va_list_type).
+
+2010-12-23  Sebastian Pop  <sebastian.pop@amd.com>
+	    Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/46758
+	* graphite-sese-to-poly.c (scan_tree_for_params_right_scev): Use
+	tree_int_to_gmp instead of int_cst_value.
+	(scan_tree_for_params_int): Same.
+	(scan_tree_for_params): Same.
+	(pdr_add_data_dimensions): Use ppl_set_inhomogeneous_tree.
+
+2010-12-23  Sebastian Pop  <sebastian.pop@amd.com>
+
+	Backport from mainline
+	Fix PR45758: reset scevs before Graphite.
+        2010-09-24  Sebastian Pop  <sebastian.pop@amd.com>
+
+	PR tree-optimization/45552
+	* graphite.c (graphite_initialize): Call scev_reset.
+
+2010-12-23  Sebastian Pop  <sebastian.pop@amd.com>
+
+	PR tree-optimization/43023
+	* tree-data-ref.c (mem_write_stride_of_same_size_as_unit_type_p):
+	Removed.
+	(stores_zero_from_loop): Call stmt_stores_zero.
+	(stmt_with_adjacent_zero_store_dr_p): New.
+	* tree-data-ref.h (stmt_with_adjacent_zero_store_dr_p): Declared.
+	(stride_of_unit_type_p): New.
+	* tree-loop-distribution.c (generate_memset_zero): Do not return a
+	boolean.  Call gcc_assert on stride_of_unit_type_p.
+	(generate_builtin): Call stmt_stores_zero.
+	(rdg_flag_all_uses): Removed.
+	(rdg_flag_similar_memory_accesses): Removed.
+	(build_rdg_partition_for_component): Removed parameter
+	other_stores.  Removed call to rdg_flag_similar_memory_accesses.
+	(can_generate_builtin): New.
+	(similar_memory_accesses): New.
+	(fuse_partitions_with_similar_memory_accesses): New.
+	(rdg_build_partitions): Call
+	fuse_partitions_with_similar_memory_accesses.
+
+2010-12-21  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline:
+	2010-12-09  Martin Jambor  <mjambor@suse.cz>
+
+	PR middle-end/46734
+	* tree-sra.c (splice_param_accesses): Check that there are not
+	multiple ADDRESSABLE types.
+
+2010-12-19  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	Backport from mainline:
+	2010-12-18  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	PR target/46915
+	* config/pa/pa.c (branch_to_delay_slot_p): Use next_active_insn instead
+	of next_real_insn.  Search forward checking for both ASM_INPUT and
+	ASM_OPERANDS asms until exit condition is found.
+	(branch_needs_nop_p): Likewise.
+	(use_skip_p): New function.
+	(output_cbranch): Use use_skip_p.
+	(output_bb, output_bvb): Likewise.
+
+2010-12-19  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/46729
+	* config/sparc/sparc.h (GLOBAL_OFFSET_TABLE_REGNUM): New macro.
+	(PIC_OFFSET_TABLE_REGNUM): Rewrite in terms of above macro.
+	* config/sparc/sparc.c (pic_helper_needed): Delete.
+	(global_offset_table): Likewise.
+	(pic_helper_symbol): Rename to...
+	(got_helper_rtx): ...this.
+	(global_offset_table_rtx): New global variable.
+	(sparc_got_symbol): Likewise.
+	(sparc_got): New static function.
+	(check_pic): Use local variable and call sparc_got.
+	(sparc_tls_symbol): Initialize to NULL_RTX.
+	(sparc_tls_got): In non-PIC mode, reload the GOT register for Sun TLS
+	and 32-bit ABI and copy the GOT symbol to a new register otherwise.
+	(get_pc_thunk_name): Rename local variable.
+	(gen_load_pcrel_sym): New wrapper around load_pcrel_sym{si,di}.
+	(load_pic_register): Rename to...
+	(load_got_register): ...this.  Adjust and call gen_load_pcrel_sym.
+	(sparc_expand_prologue): Do not test flag_pic.
+	(sparc_output_mi_thunk): Use pic_offset_table_rtx directly.
+	(sparc_file_end): Test got_helper_rtx instead of pic_helper_needed.
+	Rename local variable and do not call get_pc_thunk_name again.
+	* config/sparc/sparc.md (load_pcrel_sym): Add operand #3.
+
+2010-12-18  Alexandre Oliva  <aoliva@redhat.com>
+
+	PR debug/46756
+	* jump.c (mark_all_labels): Skip debug insns.
+
+2010-12-18  Alexandre Oliva  <aoliva@redhat.com>
+
+	PR debug/46782
+	* cfgcleanup.c (try_forward_edges): Skip debug insns.
+
+2010-12-16  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* tree-ssa-sccvn.c (vn_reference_lookup_3): Always punt if the call to
+	get_ref_base_and_extent returns -1 as the max size.
+
+2010-12-16  Richard Guenther  <rguenther@suse.de>
+
+	* DEV-PHASE: Set back to prerelease.
+	* BASE-VER: Bump to 4.5.3.
+
 2010-12-16  Release Manager
 
 	* GCC 4.5.2 released.
Index: gcc/testsuite/gcc.c-torture/compile/pr47150.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr47150.c	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr47150.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -0,0 +1,11 @@
+/* PR c/47150 */
+
+float _Complex foo (float, float);
+
+void
+bar ()
+{
+  float w = 2;
+  float _Complex b;
+  b = 0.5 * (foo (0, w) + foo (1, w) / w);
+}
Index: gcc/testsuite/gcc.c-torture/compile/20110126-1.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/20110126-1.c	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/20110126-1.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -0,0 +1,18 @@
+/* PR rtl-optimization/44469 */
+/* Testcase by Siarhei Siamashka <siarhei.siamashka@gmail.com> */
+
+int a (int *t, const char *p)
+{
+  if (*t == 0)
+    {
+    }
+  else if (*t == 1)
+    {
+      p = (const char *)t;
+    }
+  else
+    __builtin_unreachable();
+  if (p[0])
+    return 0;
+  return 1;
+}
Index: gcc/testsuite/gcc.target/arm/pr45447.c
===================================================================
--- gcc/testsuite/gcc.target/arm/pr45447.c	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/arm/pr45447.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -0,0 +1,3 @@
+/* { dg-do compile } */
+/* { dg-options "-g -femit-struct-debug-baseonly" } */
+typedef __builtin_va_list x;
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-8.c
===================================================================
--- gcc/testsuite/gcc.target/powerpc/vsx-builtin-8.c	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/powerpc/vsx-builtin-8.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -0,0 +1,97 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-require-effective-target powerpc_vsx_ok } */
+/* { dg-options "-O3 -mcpu=power7" } */
+
+/* Test the various load/store varients.  */
+
+#include <altivec.h>
+
+#define TEST_COPY(NAME, TYPE)						\
+void NAME ## _copy_native (vector TYPE *a, vector TYPE *b)		\
+{									\
+  *a = *b;								\
+}									\
+									\
+void NAME ## _copy_vec (vector TYPE *a, vector TYPE *b)			\
+{									\
+  vector TYPE x = vec_ld (0, b);					\
+  vec_st (x, 0, a);							\
+}									\
+
+#define TEST_COPYL(NAME, TYPE)						\
+void NAME ## _lvxl (vector TYPE *a, vector TYPE *b)			\
+{									\
+  vector TYPE x = vec_ldl (0, b);					\
+  vec_stl (x, 0, a);							\
+}									\
+
+#define TEST_VSX_COPY(NAME, TYPE)					\
+void NAME ## _copy_vsx (vector TYPE *a, vector TYPE *b)			\
+{									\
+  vector TYPE x = vec_vsx_ld (0, b);					\
+  vec_vsx_st (x, 0, a);							\
+}									\
+
+#define TEST_ALIGN(NAME, TYPE)						\
+void NAME ## _align (vector unsigned char *a, TYPE *b)			\
+{									\
+  vector unsigned char x = vec_lvsl (0, b);				\
+  vector unsigned char y = vec_lvsr (0, b);				\
+  vec_st (x, 0, a);							\
+  vec_st (y, 8, a);							\
+}
+
+#ifndef NO_COPY
+TEST_COPY(uchar,  unsigned char)
+TEST_COPY(schar,  signed   char)
+TEST_COPY(bchar,  bool     char)
+TEST_COPY(ushort, unsigned short)
+TEST_COPY(sshort, signed   short)
+TEST_COPY(bshort, bool     short)
+TEST_COPY(uint,   unsigned int)
+TEST_COPY(sint,   signed   int)
+TEST_COPY(bint,   bool     int)
+TEST_COPY(float,  float)
+TEST_COPY(double, double)
+#endif	/* NO_COPY */
+
+#ifndef NO_COPYL
+TEST_COPYL(uchar,  unsigned char)
+TEST_COPYL(schar,  signed   char)
+TEST_COPYL(bchar,  bool     char)
+TEST_COPYL(ushort, unsigned short)
+TEST_COPYL(sshort, signed   short)
+TEST_COPYL(bshort, bool     short)
+TEST_COPYL(uint,   unsigned int)
+TEST_COPYL(sint,   signed   int)
+TEST_COPYL(bint,   bool     int)
+TEST_COPYL(float,  float)
+TEST_COPYL(double, double)
+#endif	/* NO_COPYL */
+
+#ifndef NO_ALIGN
+TEST_ALIGN(uchar,  unsigned char)
+TEST_ALIGN(schar,  signed   char)
+TEST_ALIGN(ushort, unsigned short)
+TEST_ALIGN(sshort, signed   short)
+TEST_ALIGN(uint,   unsigned int)
+TEST_ALIGN(sint,   signed   int)
+TEST_ALIGN(float,  float)
+TEST_ALIGN(double, double)
+#endif	/* NO_ALIGN */
+
+
+#ifndef NO_VSX_COPY
+TEST_VSX_COPY(uchar,  unsigned char)
+TEST_VSX_COPY(schar,  signed   char)
+TEST_VSX_COPY(bchar,  bool     char)
+TEST_VSX_COPY(ushort, unsigned short)
+TEST_VSX_COPY(sshort, signed   short)
+TEST_VSX_COPY(bshort, bool     short)
+TEST_VSX_COPY(uint,   unsigned int)
+TEST_VSX_COPY(sint,   signed   int)
+TEST_VSX_COPY(bint,   bool     int)
+TEST_VSX_COPY(float,  float)
+TEST_VSX_COPY(double, double)
+#endif	/* NO_VSX_COPY */
Index: gcc/testsuite/gcc.target/powerpc/ppc64-abi-dfp-1.c
===================================================================
--- gcc/testsuite/gcc.target/powerpc/ppc64-abi-dfp-1.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/testsuite/gcc.target/powerpc/ppc64-abi-dfp-1.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1,4 +1,5 @@
 /* { dg-do run { target { powerpc64-*-* && { lp64 && dfprt } } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
 /* { dg-options "-std=gnu99 -O2 -fno-strict-aliasing" } */
 
 /* Testcase to check for ABI compliance of parameter passing
@@ -31,61 +32,43 @@
 reg_parms_t gparms;
 
 
-/* Testcase could break on future gcc's, if parameter regs
-   are changed before this asm.  */
+/* Wrapper to save the GPRs and FPRs and then jump to the real function.  */
+#define WRAPPER(NAME)							\
+__asm__ ("\t.globl\t" #NAME "_asm\n\t"					\
+	 ".section \".opd\",\"aw\"\n\t"					\
+	 ".align 3\n"							\
+	 #NAME "_asm:\n\t"						\
+	 ".quad .L." #NAME "_asm,.TOC.@tocbase,0\n\t"			\
+	 ".text\n\t"							\
+	 ".type " #NAME "_asm, @function\n"				\
+	 ".L." #NAME "_asm:\n\t"					\
+	 "ld 11,gparms@got(2)\n\t"					\
+	 "std 3,0(11)\n\t"						\
+	 "std 4,8(11)\n\t"						\
+	 "std 5,16(11)\n\t"						\
+	 "std 6,24(11)\n\t"						\
+	 "std 7,32(11)\n\t"						\
+	 "std 8,40(11)\n\t"						\
+	 "std 9,48(11)\n\t"						\
+	 "std 10,56(11)\n\t"						\
+	 "stfd 1,64(11)\n\t"						\
+	 "stfd 2,72(11)\n\t"						\
+	 "stfd 3,80(11)\n\t"						\
+	 "stfd 4,88(11)\n\t"						\
+	 "stfd 5,96(11)\n\t"						\
+	 "stfd 6,104(11)\n\t"						\
+	 "stfd 7,112(11)\n\t"						\
+	 "stfd 8,120(11)\n\t"						\
+	 "stfd 9,128(11)\n\t"						\
+	 "stfd 10,136(11)\n\t"						\
+	 "stfd 11,144(11)\n\t"						\
+	 "stfd 12,152(11)\n\t"						\
+	 "stfd 13,160(11)\n\t"						\
+	 "b " #NAME "\n\t"						\
+	 ".long 0\n\t"							\
+	 ".byte 0,0,0,0,0,0,0,0\n\t"					\
+	 ".size " #NAME ",.-" #NAME "\n")
 
-#ifndef __MACH__
-#define save_parms(lparms)				\
-    asm volatile ("ld 11,gparms@got(2)\n\t"                \
-                  "std 3,0(11)\n\t"		        \
-	          "std 4,8(11)\n\t"			\
-	          "std 5,16(11)\n\t"			\
-	          "std 6,24(11)\n\t"			\
-	          "std 7,32(11)\n\t"			\
-	          "std 8,40(11)\n\t"			\
-	          "std 9,48(11)\n\t"			\
-	          "std 10,56(11)\n\t"			\
-                  "stfd 1,64(11)\n\t"			\
-	          "stfd 2,72(11)\n\t"			\
-	          "stfd 3,80(11)\n\t"			\
-	          "stfd 4,88(11)\n\t"			\
-	          "stfd 5,96(11)\n\t"			\
-	          "stfd 6,104(11)\n\t"			\
-	          "stfd 7,112(11)\n\t"			\
-	          "stfd 8,120(11)\n\t"			\
-	          "stfd 9,128(11)\n\t"			\
-	          "stfd 10,136(11)\n\t"			\
-	          "stfd 11,144(11)\n\t"			\
-	          "stfd 12,152(11)\n\t"                 \
-	          "stfd 13,160(11)\n\t":::"11", "memory");  \
-                  lparms = gparms;
-#else
-#define save_parms(lparms)				\
-    asm volatile ("ld r11,gparms@got(r2)\n\t"           \
-                  "std r3,0(r11)\n\t"		        \
-	          "std r4,8(r11)\n\t"			\
-	          "std r5,16(r11)\n\t"			\
-	          "std r6,24(r11)\n\t"			\
-	          "std r7,32(r11)\n\t"			\
-	          "std r8,40(r11)\n\t"			\
-	          "std r9,48(r11)\n\t"			\
-	          "std r10,56(r11)\n\t"                 \
-                  "stfd f1,64(r11)\n\t"		        \
-	          "stfd f2,72(r11)\n\t"			\
-	          "stfd f3,80(r11)\n\t"			\
-	          "stfd f4,88(r11)\n\t"			\
-	          "stfd f5,96(r11)\n\t"			\
-	          "stfd f6,104(r11)\n\t"		\
-	          "stfd f7,112(r11)\n\t"		\
-	          "stfd f8,120(r11)\n\t"		\
-	          "stfd f9,128(r11)\n\t"		\
-	          "stfd f10,136(r11)\n\t"		\
-	          "stfd f11,144(r11)\n\t"		\
-	          "stfd f12,152(r11)\n\t"               \
-	          "stfd f13,160(r11)\n\t":::"r11", "memory");  \
-                  lparms = gparms;
-#endif
-
 typedef struct sf
 {
   struct sf *backchain;
@@ -97,6 +80,13 @@
   unsigned long slot[100];
 } stack_frame_t;
 
+extern void func0_asm (double, double, double, double, double, double,
+		       double, double, double, double, double, double,
+		       double, double, 
+		       _Decimal64, _Decimal128, _Decimal64);
+
+WRAPPER(func0);
+
 /* Fill up floating point registers with double arguments, forcing
    decimal float arguments into the parameter save area.  */
 void __attribute__ ((noinline))
@@ -105,186 +95,209 @@
        double a13, double a14, 
        _Decimal64 a15, _Decimal128 a16, _Decimal64 a17)
 {
-  reg_parms_t lparms;
   stack_frame_t *sp;
 
-  save_parms (lparms);
   sp = __builtin_frame_address (0);
   sp = sp->backchain;
 
-  if (a1 != lparms.fprs[0]) FAILURE
-  if (a2 != lparms.fprs[1]) FAILURE
-  if (a3 != lparms.fprs[2]) FAILURE
-  if (a4 != lparms.fprs[3]) FAILURE
-  if (a5 != lparms.fprs[4]) FAILURE
-  if (a6 != lparms.fprs[5]) FAILURE
-  if (a7 != lparms.fprs[6]) FAILURE
-  if (a8 != lparms.fprs[7]) FAILURE
-  if (a9 != lparms.fprs[8]) FAILURE
-  if (a10 != lparms.fprs[9]) FAILURE
-  if (a11 != lparms.fprs[10]) FAILURE
-  if (a12 != lparms.fprs[11]) FAILURE
-  if (a13 != lparms.fprs[12]) FAILURE
+  if (a1 != gparms.fprs[0]) FAILURE
+  if (a2 != gparms.fprs[1]) FAILURE
+  if (a3 != gparms.fprs[2]) FAILURE
+  if (a4 != gparms.fprs[3]) FAILURE
+  if (a5 != gparms.fprs[4]) FAILURE
+  if (a6 != gparms.fprs[5]) FAILURE
+  if (a7 != gparms.fprs[6]) FAILURE
+  if (a8 != gparms.fprs[7]) FAILURE
+  if (a9 != gparms.fprs[8]) FAILURE
+  if (a10 != gparms.fprs[9]) FAILURE
+  if (a11 != gparms.fprs[10]) FAILURE
+  if (a12 != gparms.fprs[11]) FAILURE
+  if (a13 != gparms.fprs[12]) FAILURE
   if (a14 != *(double *)&sp->slot[13]) FAILURE
   if (a15 != *(_Decimal64 *)&sp->slot[14]) FAILURE
   if (a16 != *(_Decimal128 *)&sp->slot[15]) FAILURE
   if (a17 != *(_Decimal64 *)&sp->slot[17]) FAILURE
 }
 
+extern void func1_asm (double, double, double, double, double, double,
+		       double, double, double, double, double, double,
+		       double, _Decimal128 );
+
+WRAPPER(func1);
+
 void __attribute__ ((noinline))
 func1 (double a1, double a2, double a3, double a4, double a5, double a6,
        double a7, double a8, double a9, double a10, double a11, double a12,
        double a13, _Decimal128 a14)
 {
-  reg_parms_t lparms;
   stack_frame_t *sp;
 
-  save_parms (lparms);
   sp = __builtin_frame_address (0);
   sp = sp->backchain;
 
-  if (a1 != lparms.fprs[0]) FAILURE
-  if (a2 != lparms.fprs[1]) FAILURE
-  if (a3 != lparms.fprs[2]) FAILURE
-  if (a4 != lparms.fprs[3]) FAILURE
-  if (a5 != lparms.fprs[4]) FAILURE
-  if (a6 != lparms.fprs[5]) FAILURE
-  if (a7 != lparms.fprs[6]) FAILURE
-  if (a8 != lparms.fprs[7]) FAILURE
-  if (a9 != lparms.fprs[8]) FAILURE
-  if (a10 != lparms.fprs[9]) FAILURE
-  if (a11 != lparms.fprs[10]) FAILURE
-  if (a12 != lparms.fprs[11]) FAILURE
-  if (a13 != lparms.fprs[12]) FAILURE
+  if (a1 != gparms.fprs[0]) FAILURE
+  if (a2 != gparms.fprs[1]) FAILURE
+  if (a3 != gparms.fprs[2]) FAILURE
+  if (a4 != gparms.fprs[3]) FAILURE
+  if (a5 != gparms.fprs[4]) FAILURE
+  if (a6 != gparms.fprs[5]) FAILURE
+  if (a7 != gparms.fprs[6]) FAILURE
+  if (a8 != gparms.fprs[7]) FAILURE
+  if (a9 != gparms.fprs[8]) FAILURE
+  if (a10 != gparms.fprs[9]) FAILURE
+  if (a11 != gparms.fprs[10]) FAILURE
+  if (a12 != gparms.fprs[11]) FAILURE
+  if (a13 != gparms.fprs[12]) FAILURE
   if (a14 != *(_Decimal128 *)&sp->slot[13]) FAILURE
 }
 
+extern void func2_asm (double, double, double, double, double, double,
+		       double, double, double, double, double, double,
+		       _Decimal128);
+
+WRAPPER(func2);
+
 void __attribute__ ((noinline))
 func2 (double a1, double a2, double a3, double a4, double a5, double a6,
        double a7, double a8, double a9, double a10, double a11, double a12,
        _Decimal128 a13)
 {
-  reg_parms_t lparms;
   stack_frame_t *sp;
 
-  save_parms (lparms);
   sp = __builtin_frame_address (0);
   sp = sp->backchain;
 
-  if (a1 != lparms.fprs[0]) FAILURE
-  if (a2 != lparms.fprs[1]) FAILURE
-  if (a3 != lparms.fprs[2]) FAILURE
-  if (a4 != lparms.fprs[3]) FAILURE
-  if (a5 != lparms.fprs[4]) FAILURE
-  if (a6 != lparms.fprs[5]) FAILURE
-  if (a7 != lparms.fprs[6]) FAILURE
-  if (a8 != lparms.fprs[7]) FAILURE
-  if (a9 != lparms.fprs[8]) FAILURE
-  if (a10 != lparms.fprs[9]) FAILURE
-  if (a11 != lparms.fprs[10]) FAILURE
-  if (a12 != lparms.fprs[11]) FAILURE
+  if (a1 != gparms.fprs[0]) FAILURE
+  if (a2 != gparms.fprs[1]) FAILURE
+  if (a3 != gparms.fprs[2]) FAILURE
+  if (a4 != gparms.fprs[3]) FAILURE
+  if (a5 != gparms.fprs[4]) FAILURE
+  if (a6 != gparms.fprs[5]) FAILURE
+  if (a7 != gparms.fprs[6]) FAILURE
+  if (a8 != gparms.fprs[7]) FAILURE
+  if (a9 != gparms.fprs[8]) FAILURE
+  if (a10 != gparms.fprs[9]) FAILURE
+  if (a11 != gparms.fprs[10]) FAILURE
+  if (a12 != gparms.fprs[11]) FAILURE
   if (a13 != *(_Decimal128 *)&sp->slot[12]) FAILURE
 }
 
+extern void func3_asm (_Decimal64, _Decimal128, _Decimal64, _Decimal128,
+		       _Decimal64, _Decimal128, _Decimal64, _Decimal128,
+		       _Decimal64, _Decimal128);
+
+WRAPPER(func3);
+
 void __attribute__ ((noinline))
 func3 (_Decimal64 a1, _Decimal128 a2, _Decimal64 a3, _Decimal128 a4,
        _Decimal64 a5, _Decimal128 a6, _Decimal64 a7, _Decimal128 a8,
        _Decimal64 a9, _Decimal128 a10)
 {
-  reg_parms_t lparms;
   stack_frame_t *sp;
 
-  save_parms (lparms);
   sp = __builtin_frame_address (0);
   sp = sp->backchain;
 
-  if (a1 != *(_Decimal64 *)&lparms.fprs[0]) FAILURE	/* f1        */
-  if (a2 != *(_Decimal128 *)&lparms.fprs[1]) FAILURE	/* f2 & f3   */
-  if (a3 != *(_Decimal64 *)&lparms.fprs[3]) FAILURE	/* f4        */
-  if (a4 != *(_Decimal128 *)&lparms.fprs[5]) FAILURE	/* f6 & f7   */
-  if (a5 != *(_Decimal64 *)&lparms.fprs[7]) FAILURE	/* f8        */
-  if (a6 != *(_Decimal128 *)&lparms.fprs[9]) FAILURE	/* f10 & f11 */
-  if (a7 != *(_Decimal64 *)&lparms.fprs[11]) FAILURE	/* f12       */
+  if (a1 != *(_Decimal64 *)&gparms.fprs[0]) FAILURE	/* f1        */
+  if (a2 != *(_Decimal128 *)&gparms.fprs[1]) FAILURE	/* f2 & f3   */
+  if (a3 != *(_Decimal64 *)&gparms.fprs[3]) FAILURE	/* f4        */
+  if (a4 != *(_Decimal128 *)&gparms.fprs[5]) FAILURE	/* f6 & f7   */
+  if (a5 != *(_Decimal64 *)&gparms.fprs[7]) FAILURE	/* f8        */
+  if (a6 != *(_Decimal128 *)&gparms.fprs[9]) FAILURE	/* f10 & f11 */
+  if (a7 != *(_Decimal64 *)&gparms.fprs[11]) FAILURE	/* f12       */
   if (a8 != *(_Decimal128 *)&sp->slot[10]) FAILURE
   if (a9 != *(_Decimal64 *)&sp->slot[12]) FAILURE
   if (a10 != *(_Decimal128 *)&sp->slot[13]) FAILURE
 }
 
+extern void func4_asm (_Decimal128, _Decimal64, _Decimal128, _Decimal64,
+		       _Decimal128, _Decimal64, _Decimal128, _Decimal64);
+
+WRAPPER(func4);
+
 void __attribute__ ((noinline))
 func4 (_Decimal128 a1, _Decimal64 a2, _Decimal128 a3, _Decimal64 a4,
        _Decimal128 a5, _Decimal64 a6, _Decimal128 a7, _Decimal64 a8)
 {
-  reg_parms_t lparms;
   stack_frame_t *sp;
 
-  save_parms (lparms);
   sp = __builtin_frame_address (0);
   sp = sp->backchain;
 
-  if (a1 != *(_Decimal128 *)&lparms.fprs[1]) FAILURE	/* f2 & f3   */
-  if (a2 != *(_Decimal64 *)&lparms.fprs[3]) FAILURE	/* f4        */
-  if (a3 != *(_Decimal128 *)&lparms.fprs[5]) FAILURE	/* f6 & f7   */
-  if (a4 != *(_Decimal64 *)&lparms.fprs[7]) FAILURE	/* f8        */
-  if (a5 != *(_Decimal128 *)&lparms.fprs[9]) FAILURE	/* f10 & f11 */
-  if (a6 != *(_Decimal64 *)&lparms.fprs[11]) FAILURE	/* f12       */
+  if (a1 != *(_Decimal128 *)&gparms.fprs[1]) FAILURE	/* f2 & f3   */
+  if (a2 != *(_Decimal64 *)&gparms.fprs[3]) FAILURE	/* f4        */
+  if (a3 != *(_Decimal128 *)&gparms.fprs[5]) FAILURE	/* f6 & f7   */
+  if (a4 != *(_Decimal64 *)&gparms.fprs[7]) FAILURE	/* f8        */
+  if (a5 != *(_Decimal128 *)&gparms.fprs[9]) FAILURE	/* f10 & f11 */
+  if (a6 != *(_Decimal64 *)&gparms.fprs[11]) FAILURE	/* f12       */
   if (a7 != *(_Decimal128 *)&sp->slot[9]) FAILURE
   if (a8 != *(_Decimal64 *)&sp->slot[11]) FAILURE
 }
 
+extern void func5_asm (_Decimal32, _Decimal32, _Decimal32, _Decimal32,
+		       _Decimal32, _Decimal32, _Decimal32, _Decimal32,
+		       _Decimal32, _Decimal32, _Decimal32, _Decimal32,
+		       _Decimal32, _Decimal32, _Decimal32, _Decimal32);
+
+WRAPPER(func5);
+
 void __attribute__ ((noinline))
 func5 (_Decimal32 a1, _Decimal32 a2, _Decimal32 a3, _Decimal32 a4,
        _Decimal32 a5, _Decimal32 a6, _Decimal32 a7, _Decimal32 a8,
        _Decimal32 a9, _Decimal32 a10, _Decimal32 a11, _Decimal32 a12,
        _Decimal32 a13, _Decimal32 a14, _Decimal32 a15, _Decimal32 a16)
 {
-  reg_parms_t lparms;
   stack_frame_t *sp;
 
-  save_parms (lparms);
   sp = __builtin_frame_address (0);
   sp = sp->backchain;
 
   /* _Decimal32 is passed in the lower half of an FPR or parameter slot.  */
-  if (a1 != ((d32parm_t *)&lparms.fprs[0])->d) FAILURE		/* f1  */
-  if (a2 != ((d32parm_t *)&lparms.fprs[1])->d) FAILURE		/* f2  */
-  if (a3 != ((d32parm_t *)&lparms.fprs[2])->d) FAILURE		/* f3  */
-  if (a4 != ((d32parm_t *)&lparms.fprs[3])->d) FAILURE		/* f4  */
-  if (a5 != ((d32parm_t *)&lparms.fprs[4])->d) FAILURE		/* f5  */
-  if (a6 != ((d32parm_t *)&lparms.fprs[5])->d) FAILURE		/* f6  */
-  if (a7 != ((d32parm_t *)&lparms.fprs[6])->d) FAILURE		/* f7  */
-  if (a8 != ((d32parm_t *)&lparms.fprs[7])->d) FAILURE		/* f8  */
-  if (a9 != ((d32parm_t *)&lparms.fprs[8])->d) FAILURE		/* f9  */
-  if (a10 != ((d32parm_t *)&lparms.fprs[9])->d) FAILURE		/* f10 */
-  if (a11 != ((d32parm_t *)&lparms.fprs[10])->d) FAILURE	/* f11 */
-  if (a12 != ((d32parm_t *)&lparms.fprs[11])->d) FAILURE	/* f12 */
-  if (a13 != ((d32parm_t *)&lparms.fprs[12])->d) FAILURE	/* f13 */
+  if (a1 != ((d32parm_t *)&gparms.fprs[0])->d) FAILURE		/* f1  */
+  if (a2 != ((d32parm_t *)&gparms.fprs[1])->d) FAILURE		/* f2  */
+  if (a3 != ((d32parm_t *)&gparms.fprs[2])->d) FAILURE		/* f3  */
+  if (a4 != ((d32parm_t *)&gparms.fprs[3])->d) FAILURE		/* f4  */
+  if (a5 != ((d32parm_t *)&gparms.fprs[4])->d) FAILURE		/* f5  */
+  if (a6 != ((d32parm_t *)&gparms.fprs[5])->d) FAILURE		/* f6  */
+  if (a7 != ((d32parm_t *)&gparms.fprs[6])->d) FAILURE		/* f7  */
+  if (a8 != ((d32parm_t *)&gparms.fprs[7])->d) FAILURE		/* f8  */
+  if (a9 != ((d32parm_t *)&gparms.fprs[8])->d) FAILURE		/* f9  */
+  if (a10 != ((d32parm_t *)&gparms.fprs[9])->d) FAILURE		/* f10 */
+  if (a11 != ((d32parm_t *)&gparms.fprs[10])->d) FAILURE	/* f11 */
+  if (a12 != ((d32parm_t *)&gparms.fprs[11])->d) FAILURE	/* f12 */
+  if (a13 != ((d32parm_t *)&gparms.fprs[12])->d) FAILURE	/* f13 */
   if (a14 != ((d32parm_t *)&sp->slot[13])->d) FAILURE
   if (a15 != ((d32parm_t *)&sp->slot[14])->d) FAILURE
   if (a16 != ((d32parm_t *)&sp->slot[15])->d) FAILURE
 }
 
+extern void func6_asm (_Decimal32, _Decimal64, _Decimal128,
+		       _Decimal32, _Decimal64, _Decimal128,
+		       _Decimal32, _Decimal64, _Decimal128,
+		       _Decimal32, _Decimal64, _Decimal128);
+
+WRAPPER(func6);
+
 void __attribute__ ((noinline))
 func6 (_Decimal32 a1, _Decimal64 a2, _Decimal128 a3,
        _Decimal32 a4, _Decimal64 a5, _Decimal128 a6,
        _Decimal32 a7, _Decimal64 a8, _Decimal128 a9,
        _Decimal32 a10, _Decimal64 a11, _Decimal128 a12)
 {
-  reg_parms_t lparms;
   stack_frame_t *sp;
 
-  save_parms (lparms);
   sp = __builtin_frame_address (0);
   sp = sp->backchain;
 
-  if (a1 != ((d32parm_t *)&lparms.fprs[0])->d) FAILURE		/* f1        */
-  if (a2 != *(_Decimal64 *)&lparms.fprs[1]) FAILURE		/* f2        */
-  if (a3 != *(_Decimal128 *)&lparms.fprs[3]) FAILURE		/* f4 & f5   */
-  if (a4 != ((d32parm_t *)&lparms.fprs[5])->d) FAILURE		/* f6        */
-  if (a5 != *(_Decimal64 *)&lparms.fprs[6]) FAILURE		/* f7        */
-  if (a6 != *(_Decimal128 *)&lparms.fprs[7]) FAILURE		/* f8 & f9   */
-  if (a7 != ((d32parm_t *)&lparms.fprs[9])->d) FAILURE		/* f10       */
-  if (a8 != *(_Decimal64 *)&lparms.fprs[10]) FAILURE		/* f11       */
-  if (a9 != *(_Decimal128 *)&lparms.fprs[11]) FAILURE		/* f12 & f13 */
+  if (a1 != ((d32parm_t *)&gparms.fprs[0])->d) FAILURE		/* f1        */
+  if (a2 != *(_Decimal64 *)&gparms.fprs[1]) FAILURE		/* f2        */
+  if (a3 != *(_Decimal128 *)&gparms.fprs[3]) FAILURE		/* f4 & f5   */
+  if (a4 != ((d32parm_t *)&gparms.fprs[5])->d) FAILURE		/* f6        */
+  if (a5 != *(_Decimal64 *)&gparms.fprs[6]) FAILURE		/* f7        */
+  if (a6 != *(_Decimal128 *)&gparms.fprs[7]) FAILURE		/* f8 & f9   */
+  if (a7 != ((d32parm_t *)&gparms.fprs[9])->d) FAILURE		/* f10       */
+  if (a8 != *(_Decimal64 *)&gparms.fprs[10]) FAILURE		/* f11       */
+  if (a9 != *(_Decimal128 *)&gparms.fprs[11]) FAILURE		/* f12 & f13 */
   if (a10 != ((d32parm_t *)&sp->slot[12])->d) FAILURE
   if (a11 != *(_Decimal64 *)&sp->slot[13]) FAILURE
 }
@@ -292,23 +305,23 @@
 int
 main (void)
 {
-  func0 (1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5, 10.5, 11.5, 12.5, 13.5,
-	 14.5, 15.2dd, 16.2dl, 17.2dd);
-  func1 (101.5, 102.5, 103.5, 104.5, 105.5, 106.5, 107.5, 108.5, 109.5,
-	 110.5, 111.5, 112.5, 113.5, 114.2dd);
-  func2 (201.5, 202.5, 203.5, 204.5, 205.5, 206.5, 207.5, 208.5, 209.5,
-	 210.5, 211.5, 212.5, 213.2dd);
-  func3 (301.2dd, 302.2dl, 303.2dd, 304.2dl, 305.2dd, 306.2dl, 307.2dd,
-	 308.2dl, 309.2dd, 310.2dl);
-  func4 (401.2dl, 402.2dd, 403.2dl, 404.2dd, 405.2dl, 406.2dd, 407.2dl,
-	 408.2dd);
+  func0_asm (1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5, 10.5, 11.5, 12.5, 13.5,
+	     14.5, 15.2dd, 16.2dl, 17.2dd);
+  func1_asm (101.5, 102.5, 103.5, 104.5, 105.5, 106.5, 107.5, 108.5, 109.5,
+	     110.5, 111.5, 112.5, 113.5, 114.2dd);
+  func2_asm (201.5, 202.5, 203.5, 204.5, 205.5, 206.5, 207.5, 208.5, 209.5,
+	     210.5, 211.5, 212.5, 213.2dd);
+  func3_asm (301.2dd, 302.2dl, 303.2dd, 304.2dl, 305.2dd, 306.2dl, 307.2dd,
+	     308.2dl, 309.2dd, 310.2dl);
+  func4_asm (401.2dl, 402.2dd, 403.2dl, 404.2dd, 405.2dl, 406.2dd, 407.2dl,
+	     408.2dd);
 #if 0
   /* _Decimal32 doesn't yet follow the ABI; enable this when it does.  */
-  func5 (501.2df, 502.2df, 503.2df, 504.2df, 505.2df, 506.2df, 507.2df,
-	 508.2df, 509.2df, 510.2df, 511.2df, 512.2df, 513.2df, 514.2df,
-	 515.2df, 516.2df);
-  func6 (601.2df, 602.2dd, 603.2dl, 604.2df, 605.2dd, 606.2dl,
-	 607.2df, 608.2dd, 609.2dl, 610.2df, 611.2dd, 612.2dl);
+  func5_asm (501.2df, 502.2df, 503.2df, 504.2df, 505.2df, 506.2df, 507.2df,
+	     508.2df, 509.2df, 510.2df, 511.2df, 512.2df, 513.2df, 514.2df,
+	     515.2df, 516.2df);
+  func6_asm (601.2df, 602.2dd, 603.2dl, 604.2df, 605.2dd, 606.2dl,
+	     607.2df, 608.2dd, 609.2dl, 610.2df, 611.2dd, 612.2dl);
 #endif
 
   if (failcnt != 0)
Index: gcc/testsuite/gcc.target/powerpc/ppc32-abi-dfp-1.c
===================================================================
--- gcc/testsuite/gcc.target/powerpc/ppc32-abi-dfp-1.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/testsuite/gcc.target/powerpc/ppc32-abi-dfp-1.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -30,31 +30,6 @@
 
 reg_parms_t gparms;
 
-
-/* Testcase could break on future gcc's, if parameter regs
-   are changed before this asm.  */
-
-#define save_parms(lparms)				\
-    asm volatile ("lis 11,gparms@ha\n\t"		\
-                  "la 11,gparms@l(11)\n\t"		\
-                  "st 3,0(11)\n\t"		        \
-	          "st 4,4(11)\n\t"			\
-	          "st 5,8(11)\n\t"			\
-	          "st 6,12(11)\n\t"			\
-	          "st 7,16(11)\n\t"			\
-	          "st 8,20(11)\n\t"			\
-	          "st 9,24(11)\n\t"			\
-	          "st 10,28(11)\n\t"			\
-                  "stfd 1,32(11)\n\t"			\
-	          "stfd 2,40(11)\n\t"			\
-	          "stfd 3,48(11)\n\t"			\
-	          "stfd 4,56(11)\n\t"			\
-	          "stfd 5,64(11)\n\t"			\
-	          "stfd 6,72(11)\n\t"			\
-	          "stfd 7,80(11)\n\t"			\
-	          "stfd 8,88(11)\n\t":::"11", "memory");  \
-                  lparms = gparms;
-
 typedef struct sf
 {
   struct sf *backchain;
@@ -62,115 +37,159 @@
   unsigned int slot[200];
 } stack_frame_t;
 
+/* Wrapper to save the GPRs and FPRs and then jump to the real function.  */
+#define WRAPPER(NAME)							\
+__asm__ ("\t.globl\t" #NAME "_asm\n\t"					\
+	 ".text\n\t"							\
+	 ".type " #NAME "_asm, @function\n"				\
+	 #NAME "_asm:\n\t"						\
+	 "lis 11,gparms@ha\n\t"						\
+	 "la 11,gparms@l(11)\n\t"					\
+	 "st 3,0(11)\n\t"						\
+	 "st 4,4(11)\n\t"						\
+	 "st 5,8(11)\n\t"						\
+	 "st 6,12(11)\n\t"						\
+	 "st 7,16(11)\n\t"						\
+	 "st 8,20(11)\n\t"						\
+	 "st 9,24(11)\n\t"						\
+	 "st 10,28(11)\n\t"						\
+	 "stfd 1,32(11)\n\t"						\
+	 "stfd 2,40(11)\n\t"						\
+	 "stfd 3,48(11)\n\t"						\
+	 "stfd 4,56(11)\n\t"						\
+	 "stfd 5,64(11)\n\t"						\
+	 "stfd 6,72(11)\n\t"						\
+	 "stfd 7,80(11)\n\t"						\
+	 "stfd 8,88(11)\n\t"						\
+	 "b " #NAME "\n\t"						\
+	 ".size " #NAME ",.-" #NAME "\n")
+
 /* Fill up floating point registers with double arguments, forcing
    decimal float arguments into the parameter save area.  */
+extern void func0_asm (double, double, double, double, double,
+		       double, double, double, _Decimal64, _Decimal128);
+
+WRAPPER(func0);
+
 void __attribute__ ((noinline))
 func0 (double a1, double a2, double a3, double a4, double a5,
        double a6, double a7, double a8, _Decimal64 a9, _Decimal128 a10)
 {
-  reg_parms_t lparms;
   stack_frame_t *sp;
 
-  save_parms (lparms);
   sp = __builtin_frame_address (0);
   sp = sp->backchain;
 
-  if (a1 != lparms.fprs[0]) FAILURE
-  if (a2 != lparms.fprs[1]) FAILURE
-  if (a3 != lparms.fprs[2]) FAILURE
-  if (a4 != lparms.fprs[3]) FAILURE
-  if (a5 != lparms.fprs[4]) FAILURE
-  if (a6 != lparms.fprs[5]) FAILURE
-  if (a7 != lparms.fprs[6]) FAILURE
-  if (a8 != lparms.fprs[7]) FAILURE
+  if (a1 != gparms.fprs[0]) FAILURE
+  if (a2 != gparms.fprs[1]) FAILURE
+  if (a3 != gparms.fprs[2]) FAILURE
+  if (a4 != gparms.fprs[3]) FAILURE
+  if (a5 != gparms.fprs[4]) FAILURE
+  if (a6 != gparms.fprs[5]) FAILURE
+  if (a7 != gparms.fprs[6]) FAILURE
+  if (a8 != gparms.fprs[7]) FAILURE
   if (a9 != *(_Decimal64 *)&sp->slot[0]) FAILURE
   if (a10 != *(_Decimal128 *)&sp->slot[2]) FAILURE
 }
 
 /* Alternate 64-bit and 128-bit decimal float arguments, checking that
    _Decimal128 is always passed in even/odd register pairs.  */
+extern void func1_asm (_Decimal64, _Decimal128, _Decimal64, _Decimal128,
+		       _Decimal64, _Decimal128, _Decimal64, _Decimal128);
+
+WRAPPER(func1);
+
 void __attribute__ ((noinline))
 func1 (_Decimal64 a1, _Decimal128 a2, _Decimal64 a3, _Decimal128 a4,
        _Decimal64 a5, _Decimal128 a6, _Decimal64 a7, _Decimal128 a8)
 {
-  reg_parms_t lparms;
   stack_frame_t *sp;
 
-  save_parms (lparms);
   sp = __builtin_frame_address (0);
   sp = sp->backchain;
 
-  if (a1 != *(_Decimal64 *)&lparms.fprs[0]) FAILURE	/* f1 */
-  if (a2 != *(_Decimal128 *)&lparms.fprs[1]) FAILURE	/* f2 & f3 */
-  if (a3 != *(_Decimal64 *)&lparms.fprs[3]) FAILURE	/* f4 */
-  if (a4 != *(_Decimal128 *)&lparms.fprs[5]) FAILURE	/* f6 & f7 */
-  if (a5 != *(_Decimal64 *)&lparms.fprs[7]) FAILURE	/* f8 */
+  if (a1 != *(_Decimal64 *)&gparms.fprs[0]) FAILURE	/* f1 */
+  if (a2 != *(_Decimal128 *)&gparms.fprs[1]) FAILURE	/* f2 & f3 */
+  if (a3 != *(_Decimal64 *)&gparms.fprs[3]) FAILURE	/* f4 */
+  if (a4 != *(_Decimal128 *)&gparms.fprs[5]) FAILURE	/* f6 & f7 */
+  if (a5 != *(_Decimal64 *)&gparms.fprs[7]) FAILURE	/* f8 */
   if (a6 != *(_Decimal128 *)&sp->slot[0]) FAILURE
   if (a7 != *(_Decimal64 *)&sp->slot[4]) FAILURE
   if (a8 != *(_Decimal128 *)&sp->slot[6]) FAILURE
 }
 
+extern void func2_asm (_Decimal128, _Decimal64, _Decimal128, _Decimal64,
+		       _Decimal128, _Decimal64, _Decimal128, _Decimal64);
+
+WRAPPER(func2);
+
 void __attribute__ ((noinline))
 func2 (_Decimal128 a1, _Decimal64 a2, _Decimal128 a3, _Decimal64 a4,
        _Decimal128 a5, _Decimal64 a6, _Decimal128 a7, _Decimal64 a8)
 {
-  reg_parms_t lparms;
   stack_frame_t *sp;
 
-  save_parms (lparms);
   sp = __builtin_frame_address (0);
   sp = sp->backchain;
 
-  if (a1 != *(_Decimal128 *)&lparms.fprs[1]) FAILURE	/* f2 & f3 */
-  if (a2 != *(_Decimal64 *)&lparms.fprs[3]) FAILURE	/* f4 */
-  if (a3 != *(_Decimal128 *)&lparms.fprs[5]) FAILURE	/* f6 & f7 */
-  if (a4 != *(_Decimal64 *)&lparms.fprs[7]) FAILURE	/* f8 */
+  if (a1 != *(_Decimal128 *)&gparms.fprs[1]) FAILURE	/* f2 & f3 */
+  if (a2 != *(_Decimal64 *)&gparms.fprs[3]) FAILURE	/* f4 */
+  if (a3 != *(_Decimal128 *)&gparms.fprs[5]) FAILURE	/* f6 & f7 */
+  if (a4 != *(_Decimal64 *)&gparms.fprs[7]) FAILURE	/* f8 */
   if (a5 != *(_Decimal128 *)&sp->slot[0]) FAILURE
   if (a6 != *(_Decimal64 *)&sp->slot[4]) FAILURE
   if (a7 != *(_Decimal128 *)&sp->slot[6]) FAILURE
   if (a8 != *(_Decimal64 *)&sp->slot[10]) FAILURE
 }
 
+extern void func3_asm (_Decimal64, _Decimal128, _Decimal64, _Decimal128,
+		       _Decimal64);
+
+WRAPPER(func3);
+
 void __attribute__ ((noinline))
 func3 (_Decimal64 a1, _Decimal128 a2, _Decimal64 a3, _Decimal128 a4,
        _Decimal64 a5)
 {
-  reg_parms_t lparms;
   stack_frame_t *sp;
 
-  save_parms (lparms);
   sp = __builtin_frame_address (0);
   sp = sp->backchain;
 
-  if (a1 != *(_Decimal64 *)&lparms.fprs[0]) FAILURE	/* f1 */
-  if (a2 != *(_Decimal128 *)&lparms.fprs[1]) FAILURE	/* f2 & f3 */
-  if (a3 != *(_Decimal64 *)&lparms.fprs[3]) FAILURE	/* f4 */
-  if (a4 != *(_Decimal128 *)&lparms.fprs[5]) FAILURE	/* f6 & f7 */
+  if (a1 != *(_Decimal64 *)&gparms.fprs[0]) FAILURE	/* f1 */
+  if (a2 != *(_Decimal128 *)&gparms.fprs[1]) FAILURE	/* f2 & f3 */
+  if (a3 != *(_Decimal64 *)&gparms.fprs[3]) FAILURE	/* f4 */
+  if (a4 != *(_Decimal128 *)&gparms.fprs[5]) FAILURE	/* f6 & f7 */
   if (a5 != *(_Decimal128 *)&sp->slot[0]) FAILURE
 }
 
+extern void func4_asm (_Decimal32, _Decimal32, _Decimal32, _Decimal32,
+		       _Decimal32, _Decimal32, _Decimal32, _Decimal32,
+		       _Decimal32, _Decimal32, _Decimal32, _Decimal32,
+		       _Decimal32, _Decimal32, _Decimal32, _Decimal32);
+
+WRAPPER(func4);
+
 void __attribute__ ((noinline))
 func4 (_Decimal32 a1, _Decimal32 a2, _Decimal32 a3, _Decimal32 a4,
        _Decimal32 a5, _Decimal32 a6, _Decimal32 a7, _Decimal32 a8,
        _Decimal32 a9, _Decimal32 a10, _Decimal32 a11, _Decimal32 a12,
        _Decimal32 a13, _Decimal32 a14, _Decimal32 a15, _Decimal32 a16)
 {
-  reg_parms_t lparms;
   stack_frame_t *sp;
 
-  save_parms (lparms);
   sp = __builtin_frame_address (0);
   sp = sp->backchain;
 
   /* _Decimal32 is passed in the lower half of an FPR, or in parameter slot.  */
-  if (a1 != ((d32parm_t *)&lparms.fprs[0])->d) FAILURE		/* f1  */
-  if (a2 != ((d32parm_t *)&lparms.fprs[1])->d) FAILURE		/* f2  */
-  if (a3 != ((d32parm_t *)&lparms.fprs[2])->d) FAILURE		/* f3  */
-  if (a4 != ((d32parm_t *)&lparms.fprs[3])->d) FAILURE		/* f4  */
-  if (a5 != ((d32parm_t *)&lparms.fprs[4])->d) FAILURE		/* f5  */
-  if (a6 != ((d32parm_t *)&lparms.fprs[5])->d) FAILURE		/* f6  */
-  if (a7 != ((d32parm_t *)&lparms.fprs[6])->d) FAILURE		/* f7  */
-  if (a8 != ((d32parm_t *)&lparms.fprs[7])->d) FAILURE		/* f8  */
+  if (a1 != ((d32parm_t *)&gparms.fprs[0])->d) FAILURE		/* f1  */
+  if (a2 != ((d32parm_t *)&gparms.fprs[1])->d) FAILURE		/* f2  */
+  if (a3 != ((d32parm_t *)&gparms.fprs[2])->d) FAILURE		/* f3  */
+  if (a4 != ((d32parm_t *)&gparms.fprs[3])->d) FAILURE		/* f4  */
+  if (a5 != ((d32parm_t *)&gparms.fprs[4])->d) FAILURE		/* f5  */
+  if (a6 != ((d32parm_t *)&gparms.fprs[5])->d) FAILURE		/* f6  */
+  if (a7 != ((d32parm_t *)&gparms.fprs[6])->d) FAILURE		/* f7  */
+  if (a8 != ((d32parm_t *)&gparms.fprs[7])->d) FAILURE		/* f8  */
   if (a9 != *(_Decimal32 *)&sp->slot[0]) FAILURE
   if (a10 != *(_Decimal32 *)&sp->slot[1]) FAILURE
   if (a11 != *(_Decimal32 *)&sp->slot[2]) FAILURE
@@ -181,24 +200,29 @@
   if (a16 != *(_Decimal32 *)&sp->slot[7]) FAILURE
 }
 
+extern void func5_asm (_Decimal32, _Decimal64, _Decimal128,
+		       _Decimal32, _Decimal64, _Decimal128,
+		       _Decimal32, _Decimal64, _Decimal128,
+		       _Decimal32, _Decimal64, _Decimal128);
+
+WRAPPER(func5);
+
 void __attribute__ ((noinline))
 func5 (_Decimal32 a1, _Decimal64 a2, _Decimal128 a3,
        _Decimal32 a4, _Decimal64 a5, _Decimal128 a6,
        _Decimal32 a7, _Decimal64 a8, _Decimal128 a9,
        _Decimal32 a10, _Decimal64 a11, _Decimal128 a12)
 {
-  reg_parms_t lparms;
   stack_frame_t *sp;
 
-  save_parms (lparms);
   sp = __builtin_frame_address (0);
   sp = sp->backchain;
 
-  if (a1 != ((d32parm_t *)&lparms.fprs[0])->d) FAILURE		/* f1      */
-  if (a2 != *(_Decimal64 *)&lparms.fprs[1]) FAILURE		/* f2      */
-  if (a3 != *(_Decimal128 *)&lparms.fprs[3]) FAILURE		/* f4 & f5 */
-  if (a4 != ((d32parm_t *)&lparms.fprs[5])->d) FAILURE		/* f6      */
-  if (a5 != *(_Decimal64 *)&lparms.fprs[6]) FAILURE		/* f7      */
+  if (a1 != ((d32parm_t *)&gparms.fprs[0])->d) FAILURE		/* f1      */
+  if (a2 != *(_Decimal64 *)&gparms.fprs[1]) FAILURE		/* f2      */
+  if (a3 != *(_Decimal128 *)&gparms.fprs[3]) FAILURE		/* f4 & f5 */
+  if (a4 != ((d32parm_t *)&gparms.fprs[5])->d) FAILURE		/* f6      */
+  if (a5 != *(_Decimal64 *)&gparms.fprs[6]) FAILURE		/* f7      */
 
   if (a6 != *(_Decimal128 *)&sp->slot[0]) FAILURE
   if (a7 != *(_Decimal32 *)&sp->slot[4]) FAILURE
@@ -212,15 +236,15 @@
 int
 main ()
 {
-  func0 (1., 2., 3., 4., 5., 6., 7., 8., 9.dd, 10.dl);
-  func1 (1.dd, 2.dl, 3.dd, 4.dl, 5.dd, 6.dl, 7.dd, 8.dl);
-  func2 (1.dl, 2.dd, 3.dl, 4.dd, 5.dl, 6.dd, 7.dl, 8.dd);
-  func3 (1.dd, 2.dl, 3.dd, 4.dl, 5.dl);
-  func4 (501.2df, 502.2df, 503.2df, 504.2df, 505.2df, 506.2df, 507.2df,
-	 508.2df, 509.2df, 510.2df, 511.2df, 512.2df, 513.2df, 514.2df,
-	 515.2df, 516.2df);
-  func5 (601.2df, 602.2dd, 603.2dl, 604.2df, 605.2dd, 606.2dl,
-	 607.2df, 608.2dd, 609.2dl, 610.2df, 611.2dd, 612.2dl);
+  func0_asm (1., 2., 3., 4., 5., 6., 7., 8., 9.dd, 10.dl);
+  func1_asm (1.dd, 2.dl, 3.dd, 4.dl, 5.dd, 6.dl, 7.dd, 8.dl);
+  func2_asm (1.dl, 2.dd, 3.dl, 4.dd, 5.dl, 6.dd, 7.dl, 8.dd);
+  func3_asm (1.dd, 2.dl, 3.dd, 4.dl, 5.dl);
+  func4_asm (501.2df, 502.2df, 503.2df, 504.2df, 505.2df, 506.2df, 507.2df,
+	     508.2df, 509.2df, 510.2df, 511.2df, 512.2df, 513.2df, 514.2df,
+	     515.2df, 516.2df);
+  func5_asm (601.2df, 602.2dd, 603.2dl, 604.2df, 605.2dd, 606.2dl,
+	     607.2df, 608.2dd, 609.2dl, 610.2df, 611.2dd, 612.2dl);
 
   if (failcnt != 0)
     abort ();
Index: gcc/testsuite/gcc.target/powerpc/avoid-indexed-addresses.c
===================================================================
--- gcc/testsuite/gcc.target/powerpc/avoid-indexed-addresses.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/testsuite/gcc.target/powerpc/avoid-indexed-addresses.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1,5 +1,5 @@
 /* { dg-do compile { target { powerpc*-*-* } } } */
-/* { dg-options "-O2 -mavoid-indexed-addresses" } */
+/* { dg-options "-O2 -mavoid-indexed-addresses -mno-altivec -mno-vsx" } */
 
 /* { dg-final { scan-assembler-not "lbzx" } }
 
Index: gcc/testsuite/gcc.target/i386/avx-check.h
===================================================================
--- gcc/testsuite/gcc.target/i386/avx-check.h	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/testsuite/gcc.target/i386/avx-check.h	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -20,7 +20,7 @@
     return 0;
 
   /* Run AVX test only if host has AVX support.  */
-  if (ecx & bit_AVX)
+  if ((ecx & (bit_AVX | bit_OSXSAVE)) == (bit_AVX | bit_OSXSAVE))
     {
       do_test ();
 #ifdef DEBUG
Index: gcc/testsuite/gcc.target/i386/avx-vmaskmovps-256-1.c
===================================================================
--- gcc/testsuite/gcc.target/i386/avx-vmaskmovps-256-1.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/testsuite/gcc.target/i386/avx-vmaskmovps-256-1.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -16,10 +16,11 @@
   int i;
   int m[8] = {mask_v(0), mask_v(1), mask_v(2), mask_v(3), mask_v(4), mask_v(5), mask_v(6), mask_v(7)};
   float s[8] = {1,2,3,4,5,6,7,8};
-  union256 u, mask;
+  union256 u;
+  union256i_d mask;
   float e [8] = {0.0};
 
-  mask.x = _mm256_loadu_ps ((float*)m);
+  mask.x = _mm256_loadu_si256 ((__m256i *)m);
   u.x = _mm256_maskload_ps (s, mask.x);
 
   for (i = 0 ; i < 8; i++) 
Index: gcc/testsuite/gcc.target/i386/pr46880.c
===================================================================
--- gcc/testsuite/gcc.target/i386/pr46880.c	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/i386/pr46880.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -0,0 +1,28 @@
+/* PR target/46880 */
+/* { dg-do run } */
+/* { dg-options "-O2 -fno-strict-aliasing -msse2" } */
+/* { dg-require-effective-target sse2_runtime } */
+
+typedef double __m128d __attribute__ ((__vector_size__ (16), __may_alias__));
+typedef double (*T)[2];
+
+static __attribute__ ((noinline, noclone)) __m128d
+foo (__m128d c, __m128d d)
+{
+  T cp = (T) &c;
+  T dp = (T) &d;
+  __m128d e = { (*cp)[1], (*dp)[1] };
+  return e;
+}
+
+int
+main ()
+{
+  __m128d c = { 1.0, 2.0 };
+  __m128d d = { 3.0, 4.0 };
+  union { __m128d x; double d[2]; } u;
+  u.x = foo (c, d);
+  if (u.d[0] != 2.0 || u.d[1] != 4.0)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.target/i386/avx-vmaskmovps-1.c
===================================================================
--- gcc/testsuite/gcc.target/i386/avx-vmaskmovps-1.c	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/i386/avx-vmaskmovps-1.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -0,0 +1,31 @@
+/* { dg-do run } */
+/* { dg-require-effective-target avx } */
+/* { dg-options "-O2 -mavx" } */
+
+#include "avx-check.h"
+
+#ifndef MASK
+#define MASK 134
+#endif
+
+#define mask_v(pos) (((MASK & (0x1 << (pos))) >> (pos)) << 31)
+
+void static
+avx_test (void)
+{
+  int i;
+  int m[4] = {mask_v(0), mask_v(1), mask_v(2), mask_v(3)};
+  float s[4] = {1,2,3,4};
+  union128 u;
+  union128i_d mask;
+  float e[4] = {0.0};
+
+  mask.x = _mm_loadu_si128 ((__m128i *)m);
+  u.x = _mm_maskload_ps (s, mask.x);
+
+  for (i = 0 ; i < 4; i++) 
+    e[i] = m[i] ? s[i] : 0;
+   
+  if (check_union128 (u, e))
+    abort ();
+}
Index: gcc/testsuite/gcc.target/i386/avx-vmaskmovpd-256-1.c
===================================================================
--- gcc/testsuite/gcc.target/i386/avx-vmaskmovpd-256-1.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/testsuite/gcc.target/i386/avx-vmaskmovpd-256-1.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -14,12 +14,13 @@
 avx_test (void)
 {
   int i;
-  long long m[8] = {mask_v(0), mask_v(1), mask_v(2), mask_v(3)};
+  long long m[4] = {mask_v(0), mask_v(1), mask_v(2), mask_v(3)};
   double s[4] = {1.1, 2.2, 3.3, 4.4};
-  union256d u, mask;
+  union256d u;
+  union256i_q mask;
   double e [4] = {0.0};
 
-  mask.x = _mm256_loadu_pd ((double*)m);
+  mask.x = _mm256_loadu_si256 ((__m256i *)m);
   u.x = _mm256_maskload_pd (s, mask.x);
 
   for (i = 0 ; i < 4; i++) 
Index: gcc/testsuite/gcc.target/i386/avx-vmaskmovpd-1.c
===================================================================
--- gcc/testsuite/gcc.target/i386/avx-vmaskmovpd-1.c	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/i386/avx-vmaskmovpd-1.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -0,0 +1,31 @@
+/* { dg-do run } */
+/* { dg-require-effective-target avx } */
+/* { dg-options "-O2 -mavx" } */
+
+#include "avx-check.h"
+
+#ifndef MASK
+#define MASK 7
+#endif
+
+#define mask_v(pos) (((MASK & (0x1ULL << (pos))) >> (pos)) << 63)
+
+void static
+avx_test (void)
+{
+  int i;
+  long long m[2] = {mask_v(0), mask_v(1)};
+  double s[2] = {1.1, 2.2};
+  union128d u;
+  union128i_q mask;
+  double e[2] = {0.0};
+
+  mask.x = _mm_loadu_si128 ((__m128i *)m);
+  u.x = _mm_maskload_pd (s, mask.x);
+
+  for (i = 0 ; i < 2; i++) 
+    e[i] = m[i] ? s[i] : 0;
+   
+  if (check_union128d (u, e))
+    abort ();
+}
Index: gcc/testsuite/gcc.target/i386/pr46865-1.c
===================================================================
--- gcc/testsuite/gcc.target/i386/pr46865-1.c	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/i386/pr46865-1.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -0,0 +1,31 @@
+/* PR rtl-optimization/46865 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+extern unsigned long f;
+
+#define m1(f)							\
+  if (f & 1)							\
+    asm volatile ("nop /* asmnop */\n");			\
+  else								\
+    asm volatile ("nop /* asmnop */\n");
+
+#define m2(f)							\
+  if (f & 1)							\
+    asm volatile ("nop /* asmnop */\n" : : "i" (6) : "cx");	\
+  else								\
+    asm volatile ("nop /* asmnop */\n" : : "i" (6) : "cx");
+
+void
+foo (void)
+{
+  m1 (f);
+}
+
+void
+bar (void)
+{
+  m2 (f);
+}
+
+/* { dg-final { scan-assembler-times "asmnop" 2 } } */
Index: gcc/testsuite/gcc.target/i386/pr45852.c
===================================================================
--- gcc/testsuite/gcc.target/i386/pr45852.c	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/i386/pr45852.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -0,0 +1,16 @@
+/* PR middle-end/45852 */
+/* { dg-options "-O2 -mcmodel=small" } */
+/* { dg-do compile { target { { i?86-*-linux* x86_64-*-linux* } && lp64 } } } */
+/* { dg-require-visibility "" } */
+
+struct S { int s; };
+
+volatile struct S globvar __attribute__((visibility ("hidden"))) = { -6 };
+
+void
+foo (void)
+{
+  globvar = globvar;
+}
+
+/* { dg-final { scan-assembler-times "globvar.%?rip" 2 } } */
Index: gcc/testsuite/gcc.target/i386/avx-vmaskmovps-256-2.c
===================================================================
--- gcc/testsuite/gcc.target/i386/avx-vmaskmovps-256-2.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/testsuite/gcc.target/i386/avx-vmaskmovps-256-2.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -16,12 +16,13 @@
   int i;
   int m[8] = {mask_v(0), mask_v(1), mask_v(2), mask_v(3), mask_v(4), mask_v(5), mask_v(6), mask_v(7)};
   float s[8] = {1,2,3,4,5,6,7,8};
-  union256 src, mask;
+  union256 src;
+  union256i_d mask;
   float e [8] = {0.0};
   float d [8] = {0.0};
 
   src.x = _mm256_loadu_ps (s);
-  mask.x = _mm256_loadu_ps ((float *)m);
+  mask.x = _mm256_loadu_si256 ((__m256i *)m);
   _mm256_maskstore_ps (d, mask.x, src.x);
 
   for (i = 0 ; i < 8; i++) 
Index: gcc/testsuite/gcc.target/i386/avx-vmaskmovps-2.c
===================================================================
--- gcc/testsuite/gcc.target/i386/avx-vmaskmovps-2.c	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/i386/avx-vmaskmovps-2.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -0,0 +1,33 @@
+/* { dg-do run } */
+/* { dg-require-effective-target avx } */
+/* { dg-options "-O2 -mavx" } */
+
+#include "avx-check.h"
+
+#ifndef MASK
+#define MASK 214
+#endif
+
+#define mask_v(pos) (((MASK & (0x1 << (pos))) >> (pos)) << 31)
+
+void static
+avx_test (void)
+{
+  int i;
+  int m[4] = {mask_v(0), mask_v(1), mask_v(2), mask_v(3)};
+  float s[4] = {1,2,3,4};
+  union128 src;
+  union128i_d mask;
+  float e[4] = {0.0};
+  float d[4] = {0.0};
+
+  src.x = _mm_loadu_ps (s);
+  mask.x = _mm_loadu_si128 ((__m128i *)m);
+  _mm_maskstore_ps (d, mask.x, src.x);
+
+  for (i = 0 ; i < 4; i++) 
+    e[i] = m[i] ? s[i] : 0;
+   
+  if (checkVf (d, e, 4))
+    abort ();
+}
Index: gcc/testsuite/gcc.target/i386/avx-vmaskmovpd-256-2.c
===================================================================
--- gcc/testsuite/gcc.target/i386/avx-vmaskmovpd-256-2.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/testsuite/gcc.target/i386/avx-vmaskmovpd-256-2.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -18,10 +18,11 @@
   double s[4] = {1.1, 2.2, 3.3, 4.4};
   double e [4] = {0.0};
   double d [4] = {0.0};
-  union256d src, mask;
+  union256d src;
+  union256i_q mask;
   
   src.x = _mm256_loadu_pd (s);
-  mask.x = _mm256_loadu_pd ((double*)m);
+  mask.x = _mm256_loadu_si256 ((__m256i *)m);
   _mm256_maskstore_pd (d, mask.x, src.x);
 
   for (i = 0 ; i < 4; i++) 
Index: gcc/testsuite/gcc.target/i386/avx-vmaskmovpd-2.c
===================================================================
--- gcc/testsuite/gcc.target/i386/avx-vmaskmovpd-2.c	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/i386/avx-vmaskmovpd-2.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -0,0 +1,33 @@
+/* { dg-do run } */
+/* { dg-require-effective-target avx } */
+/* { dg-options "-O2 -mavx" } */
+
+#include "avx-check.h"
+
+#ifndef MASK
+#define MASK 6
+#endif
+
+#define mask_v(pos) (((MASK & (0x1ULL << (pos))) >> (pos)) << 63)
+
+void static
+avx_test (void)
+{
+  int i;
+  long long m[2] = {mask_v(0), mask_v(1)};
+  double s[2] = {1.1, 2.2};
+  double e[2] = {0.0};
+  double d[2] = {0.0};
+  union128d src;
+  union128i_q mask;
+  
+  src.x = _mm_loadu_pd (s);
+  mask.x = _mm_loadu_si128 ((__m128i *)m);
+  _mm_maskstore_pd (d, mask.x, src.x);
+
+  for (i = 0 ; i < 2; i++) 
+    e[i] = m[i] ? s[i] : 0;
+   
+  if (checkVd (d, e, 2))
+    abort ();
+}
Index: gcc/testsuite/gcc.target/i386/pr46865-2.c
===================================================================
--- gcc/testsuite/gcc.target/i386/pr46865-2.c	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/i386/pr46865-2.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -0,0 +1,32 @@
+/* PR rtl-optimization/46865 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -save-temps" } */
+
+extern unsigned long f;
+
+#define m1(f)							\
+  if (f & 1)							\
+    asm volatile ("nop /* asmnop */\n");			\
+  else								\
+    asm volatile ("nop /* asmnop */\n");
+
+#define m2(f)							\
+  if (f & 1)							\
+    asm volatile ("nop /* asmnop */\n" : : "i" (6) : "cx");	\
+  else								\
+    asm volatile ("nop /* asmnop */\n" : : "i" (6) : "cx");
+
+void
+foo (void)
+{
+  m1 (f);
+}
+
+void
+bar (void)
+{
+  m2 (f);
+}
+
+/* { dg-final { scan-assembler-times "asmnop" 2 } } */
+/* { dg-final { cleanup-saved-temps } } */
Index: gcc/testsuite/gcc.target/mips/save-restore-1.c
===================================================================
--- gcc/testsuite/gcc.target/mips/save-restore-1.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/testsuite/gcc.target/mips/save-restore-1.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1,5 +1,6 @@
 /* Check that we can use the save instruction to save varargs.  */
 /* { dg-options "(-mips16) isa_rev>=1 -mabi=32 -O2" } */
+/* { dg-skip-if "PR target/46610" { mips-sgi-irix6* } } */
 
 #include <stdarg.h>
 
Index: gcc/testsuite/gcc.target/mips/save-restore-3.c
===================================================================
--- gcc/testsuite/gcc.target/mips/save-restore-3.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/testsuite/gcc.target/mips/save-restore-3.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1,6 +1,7 @@
 /* Check that we can use the save instruction to save spilled arguments
    when the argument save area is out of range of a direct load or store.  */
 /* { dg-options "(-mips16) isa_rev>=1 -mabi=32 -O2" } */
+/* { dg-skip-if "PR target/46610" { mips-sgi-irix6* } } */
 
 void bar (int *);
 
Index: gcc/testsuite/gcc.target/mips/save-restore-4.c
===================================================================
--- gcc/testsuite/gcc.target/mips/save-restore-4.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/testsuite/gcc.target/mips/save-restore-4.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1,5 +1,6 @@
 /* Check that we can use the save instruction to save $16, $17 and $31.  */
 /* { dg-options "(-mips16) isa_rev>=1 -mabi=32 -O2" } */
+/* { dg-skip-if "PR target/46610" { mips-sgi-irix6* } } */
 
 void bar (void);
 
Index: gcc/testsuite/gcc.target/mips/save-restore-5.c
===================================================================
--- gcc/testsuite/gcc.target/mips/save-restore-5.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/testsuite/gcc.target/mips/save-restore-5.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1,5 +1,6 @@
 /* Check that we don't try to save the same register twice.  */
 /* { dg-options "(-mips16) isa_rev>=1 -mgp32 -O2" } */
+/* { dg-skip-if "PR target/46610" { mips-sgi-irix6* } } */
 
 int bar (int, int, int, int);
 void frob (void);
Index: gcc/testsuite/gnat.dg/opt13.adb
===================================================================
--- gcc/testsuite/gnat.dg/opt13.adb	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gnat.dg/opt13.adb	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -0,0 +1,13 @@
+-- { dg-do run }
+-- { dg-options "-O" }
+
+with Opt13_Pkg; use Opt13_Pkg;
+
+procedure Opt13 is
+  T : My_Type;
+begin
+  Allocate (T);
+  if N /= 1 then
+    raise Program_Error;
+  end if;
+end;
Index: gcc/testsuite/gnat.dg/opt13_pkg.adb
===================================================================
--- gcc/testsuite/gnat.dg/opt13_pkg.adb	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gnat.dg/opt13_pkg.adb	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -0,0 +1,31 @@
+package body Opt13_Pkg is
+
+  subtype Index_Type is Natural range 0 .. 16;
+
+  type Arr is array (Index_Type range <>) of Integer;
+
+  type Rec is record
+    F1, F2, F3 : Float;
+    N : Natural;
+    B1, B2 : Boolean;
+    F4 : Float;
+  end record;
+
+  type Data (D : Index_Type) is record
+    A : Arr (1 .. D);
+    R : Rec;
+  end record;
+
+  Zero : constant Rec := (0.0, 0.0, 0.0, 0, False, False, 0.0);
+
+  procedure Allocate (T : out My_Type) is
+  begin
+    T := new Data (Index_Type'last);
+    T.R := Zero;
+
+    for I in 1 .. T.A'last loop
+      N := 1;
+    end loop;
+  end;
+
+end Opt13_Pkg;
Index: gcc/testsuite/gnat.dg/opt13_pkg.ads
===================================================================
--- gcc/testsuite/gnat.dg/opt13_pkg.ads	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gnat.dg/opt13_pkg.ads	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -0,0 +1,15 @@
+package Opt13_Pkg is
+
+    N : Natural := 0;
+
+    type My_Type is private;
+
+    procedure Allocate (T : out My_Type);
+
+private
+
+    type Data;
+
+    type My_Type is access Data;
+
+end Opt13_Pkg;
Index: gcc/testsuite/gcc.dg/pr47201.c
===================================================================
--- gcc/testsuite/gcc.dg/pr47201.c	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/pr47201.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -0,0 +1,18 @@
+/* PR target/47201 */
+/* { dg-do compile } */
+/* { dg-options "-O -fpic -g" { target fpic } } */
+
+union U
+{
+  __UINTPTR_TYPE__ m;
+  float d;
+} u;
+
+int
+foo (void)
+{
+  union U v = {
+    (__UINTPTR_TYPE__)&u
+  };
+  return u.d == v.d;
+}
Index: gcc/testsuite/gcc.dg/pr46893.c
===================================================================
--- gcc/testsuite/gcc.dg/pr46893.c	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/pr46893.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -0,0 +1,13 @@
+/* PR debug/46893 */
+/* { dg-do compile } */
+/* { dg-options "-O -g" } */
+
+void
+foo (void)
+{
+  union { unsigned long long l; double d; } u = { 0x7ff0000000000000ULL };
+  double v = 0, w = -u.d;
+
+  if (w)
+    w = v;
+}
Index: gcc/testsuite/gcc.dg/20061124-1.c
===================================================================
--- gcc/testsuite/gcc.dg/20061124-1.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/testsuite/gcc.dg/20061124-1.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1,5 +1,6 @@
 /* { dg-do run } */
 /* { dg-require-effective-target sync_char_short } */
+/* { dg-options "-mcpu=v9" { target sparc*-*-* } } */
 
 /* This testcase failed on s390 because no compare instruction for
    the check of FLAG was emitted.  */
Index: gcc/testsuite/gcc.dg/compat/vector-1b_main.c
===================================================================
--- gcc/testsuite/gcc.dg/compat/vector-1b_main.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/testsuite/gcc.dg/compat/vector-1b_main.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1,12 +1,10 @@
 /* { dg-skip-if "test AVX vector" { ! { i?86-*-* x86_64-*-* } } } */
-/* { dg-require-effective-target avx } */
+/* { dg-require-effective-target avx_runtime } */
 
 /* Test compatibility of vector types: layout between separately-compiled
    modules, parameter passing, and function return.  This test uses
    vectors of integer values.  */
 
-#include "cpuid.h"
-
 extern void vector_1_x (void);
 extern void exit (int);
 int fails;
@@ -14,14 +12,6 @@
 int
 main ()
 {
-  unsigned int eax, ebx, ecx, edx;
-
-  if (!__get_cpuid (1, &eax, &ebx, &ecx, &edx))
-    return 0;
-
-  /* Run AVX vector test only if host has AVX support.  */
-  if (ecx & bit_AVX)
-    vector_1_x ();
-
+  vector_1_x ();
   exit (0);
 }
Index: gcc/testsuite/gcc.dg/compat/vector-2b_main.c
===================================================================
--- gcc/testsuite/gcc.dg/compat/vector-2b_main.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/testsuite/gcc.dg/compat/vector-2b_main.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1,12 +1,10 @@
 /* { dg-skip-if "test AVX support" { ! { i?86-*-* x86_64-*-* } } } */
-/* { dg-require-effective-target avx } */
+/* { dg-require-effective-target avx_runtime } */
 
 /* Test compatibility of vector types: layout between separately-compiled
    modules, parameter passing, and function return.  This test uses
    vectors of floating points values.  */
 
-#include "cpuid.h"
-
 extern void vector_2_x (void);
 extern void exit (int);
 int fails;
@@ -14,14 +12,6 @@
 int
 main ()
 {
-  unsigned int eax, ebx, ecx, edx;
-
-  if (!__get_cpuid (1, &eax, &ebx, &ecx, &edx))
-    return 0;
-
-  /* Run AVX vector test only if host has AVX support.  */
-  if (ecx & bit_AVX)
-    vector_2_x ();
-
+  vector_2_x ();
   exit (0);
 }
Index: gcc/testsuite/gcc.dg/debug/pr46782.c
===================================================================
--- gcc/testsuite/gcc.dg/debug/pr46782.c	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/debug/pr46782.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -0,0 +1,11 @@
+/* PR debug/46782 */
+/* { dg-do compile } */
+/* { dg-options "-w -O0 -fvar-tracking -fcompare-debug" } */
+
+void foo (int i)
+{
+  if (i)
+    i++;
+  while (i)
+    ;
+}
Index: gcc/testsuite/gcc.dg/graphite/run-id-pr46758.c
===================================================================
--- gcc/testsuite/gcc.dg/graphite/run-id-pr46758.c	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/graphite/run-id-pr46758.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -0,0 +1,18 @@
+int
+movegt (int y, long long a)
+{
+  int i;
+  int ret = 0;
+  for (i = 0; i < y; i++)
+    if (a == -1LL << 33)
+      ret = -1;
+  return ret;
+}
+
+int
+main ()
+{
+  if (movegt (1, -1LL << 33) != -1)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/graphite/pr45552.c
===================================================================
--- gcc/testsuite/gcc.dg/graphite/pr45552.c	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/graphite/pr45552.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -0,0 +1,46 @@
+typedef struct
+{
+  double z;
+} Vector;
+typedef struct
+{
+  float *vertex;
+  float *normal;
+} VertexArray;
+typedef struct
+{
+  Vector *vertex;
+  int num_vertex;
+} ObjectSmooth;
+typedef struct
+{
+  int num_cells;
+} State;
+static void *array_from_ObjectSmooth( ObjectSmooth *obj )
+{
+  int i, j;
+  VertexArray *array = (VertexArray *) __builtin_malloc( sizeof( VertexArray ) );
+  array->vertex = (float *) __builtin_malloc( 3*sizeof(float)*obj->num_vertex );
+  array->normal = (float *) __builtin_malloc( 3*sizeof(float)*obj->num_vertex );
+  for (i=0, j=0; i<obj->num_vertex; ++i) {
+    array->normal[j++] = 9;
+    array->vertex[j] = obj->vertex[i].z;
+    array->normal[j++] = 1;
+  }
+}
+static void draw_cell( void )
+{
+  glCallList( array_from_ObjectSmooth( (ObjectSmooth *) __builtin_malloc(10) ));
+}
+static int render( State *st)
+{
+  int b;
+  for (b=0; b<st->num_cells; ++b) {
+    draw_cell();
+    draw_cell();
+  }
+}
+reshape_glcells( int width, int height )
+{
+  render( 0 );
+}
Index: gcc/testsuite/gcc.dg/torture/pr47365.c
===================================================================
--- gcc/testsuite/gcc.dg/torture/pr47365.c	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/torture/pr47365.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -0,0 +1,39 @@
+/* { dg-do run } */
+
+struct A
+{
+  int i;
+};
+
+struct B
+{
+  struct A a[2];
+};
+
+int i = 1;
+struct B b = { 0, 3 };
+
+static void
+test ()
+{
+  if (b.a[0].i != i)
+    {
+      int t = b.a[0].i;
+      b.a[0] = b.a[1];
+      b.a[1].i = t;
+    }
+
+  if (b.a[1].i == i)
+    __builtin_abort ();
+
+  if (b.a[0].i == 0)
+    __builtin_abort ();
+}
+
+int
+main ()
+{
+  test ();
+  return 0;
+}
+
Index: gcc/testsuite/gcc.dg/torture/pr47411.c
===================================================================
--- gcc/testsuite/gcc.dg/torture/pr47411.c	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/torture/pr47411.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -0,0 +1,42 @@
+/* { dg-do compile } */
+
+typedef long unsigned int size_t;
+
+static __inline void *
+__inline_memcpy_chk (void *__dest, const void *__src, size_t __len)
+{
+  return __builtin___memcpy_chk (__dest, __src, __len, __builtin_object_size (__dest, 0));
+}
+
+extern void *xmalloc (size_t) __attribute__ ((__malloc__));
+
+struct htab { void ** entries; };
+
+typedef struct htab *htab_t;
+
+extern void ** htab_find_slot (htab_t, const void *);
+
+enum mode_class { MODE_RANDOM, MODE_CC, MODE_INT, MAX_MODE_CLASS };
+
+struct mode_data
+{
+  struct mode_data *next;
+  enum mode_class cl;
+};
+
+static const struct mode_data blank_mode = { 0, MAX_MODE_CLASS };
+
+static htab_t modes_by_name;
+
+struct mode_data *
+new_mode (void)
+{
+  struct mode_data *m
+    = ((struct mode_data *) xmalloc (sizeof (struct mode_data)));
+
+  ((__builtin_object_size (m, 0) != (size_t) -1) ? __builtin___memcpy_chk (m, &blank_mode, sizeof (struct mode_data), __builtin_object_size (m, 0)) : __inline_memcpy_chk (m, &blank_mode, sizeof (struct mode_data)));
+
+  *htab_find_slot (modes_by_name, m) = m;
+
+  return m;
+}
Index: gcc/testsuite/gcc.dg/tree-ssa/pr47392.c
===================================================================
--- gcc/testsuite/gcc.dg/tree-ssa/pr47392.c	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/tree-ssa/pr47392.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -0,0 +1,42 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -fdump-tree-pre-stats" } */
+
+struct A
+{
+  int i;
+};
+
+struct B
+{
+  struct A a[2];
+};
+
+int i = 1;
+struct B b = { 0, 3 };
+
+static void
+test ()
+{
+  if (b.a[0].i != i)
+    {
+      int t = b.a[0].i;
+      b.a[0] = b.a[1];
+      b.a[1].i = t;
+    }
+
+  if (b.a[1].i == i)
+    __builtin_abort ();
+
+  if (b.a[0].i == 0)
+    __builtin_abort ();
+}
+
+int
+main ()
+{
+  test ();
+  return 0;
+}
+
+/* { dg-final { scan-tree-dump "Eliminated: 1" "pre" } } */
+/* { dg-final { cleanup-tree-dump "pre" } } */
Index: gcc/testsuite/gcc.dg/tree-ssa/pr47286.c
===================================================================
--- gcc/testsuite/gcc.dg/tree-ssa/pr47286.c	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/tree-ssa/pr47286.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -0,0 +1,20 @@
+/* { dg-do compile } */
+/* { dg-skip-if "" { ! { i?86-*-* x86_64-*-* } } { "*" } { "" } } */
+/* { dg-options "-O2 -fdump-tree-optimized" } */
+
+struct thread_info { int preempt_count; };
+static inline struct thread_info *current_thread_info(void)
+{
+  register struct thread_info *sp asm("esp");
+  return sp;
+}
+void testcase(void)
+{
+  current_thread_info()->preempt_count += 1;
+}
+
+/* We have to make sure that alias analysis treats sp as pointing
+   to globals and thus the store not optimized away.  */
+
+/* { dg-final { scan-tree-dump "->preempt_count =" "optimized" } } */
+/* { dg-final { cleanup-tree-dump "optimized" } } */
Index: gcc/testsuite/gcc.dg/tree-ssa/pr42585.c
===================================================================
--- gcc/testsuite/gcc.dg/tree-ssa/pr42585.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/testsuite/gcc.dg/tree-ssa/pr42585.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -32,6 +32,9 @@
 }
 
 /* The local aggregates . */
-/* { dg-final { scan-tree-dump-times "struct _fat_ptr _ans" 0 "optimized"} } */
-/* { dg-final { scan-tree-dump-times "struct _fat_ptr _T2" 0 "optimized"} } */
+/* Whether the structs are totally scalarized or not depends on the
+   MOVE_RATIO macro defintion in the back end.  The scalarization will
+   not take place when using small values for MOVE_RATIO.  */
+/* { dg-final { scan-tree-dump-times "struct _fat_ptr _ans" 0 "optimized" { target { ! "powerpc*-*-* arm-*-* sh*-*-* s390*-*-*" } } } } */
+/* { dg-final { scan-tree-dump-times "struct _fat_ptr _T2" 0 "optimized" { target { ! "powerpc*-*-* arm-*-* sh*-*-* s390*-*-*" } } } } */
 /* { dg-final { cleanup-tree-dump "optimized" } } */
Index: gcc/testsuite/gcc.dg/pr28796-2.c
===================================================================
--- gcc/testsuite/gcc.dg/pr28796-2.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/testsuite/gcc.dg/pr28796-2.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -2,6 +2,7 @@
 /* { dg-options "-O2 -funsafe-math-optimizations -fno-finite-math-only -DUNSAFE" } */
 /* { dg-add-options ieee } */
 /* { dg-skip-if "No Inf/NaN support" { spu-*-* } } */
+/* { dg-skip-if "Bug in _Q_dtoq" { sparc*-sun-solaris2.8 } } */
 
 #include "tg-tests.h"
 
Index: gcc/testsuite/gcc.dg/pr44606.c
===================================================================
--- gcc/testsuite/gcc.dg/pr44606.c	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/pr44606.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -0,0 +1,52 @@
+/* PR target/44606 */
+/* { dg-do run } */
+/* { dg-options "-O2" } */
+
+#include <stdio.h>
+
+extern void abort (void);
+
+ typedef struct _PixelPacket { 	unsigned char r, g, b; }
+ PixelPacket;
+#define ARRAYLEN(X) (sizeof(X)/sizeof(X[0]))
+PixelPacket q[6];
+#define COLS (ARRAYLEN(q) - 1)
+PixelPacket p[2*COLS + 22];
+#define Minify(POS, WEIGHT) do {	\
+	total_r += (WEIGHT)*(p[POS].r);	\
+	total_g += (WEIGHT)*(p[POS].g);	\
+	total_b += (WEIGHT)*(p[POS].b);	\
+} while (0)
+unsigned long columns = COLS;
+int main(void)
+{
+	static const unsigned char answers[COLS] = { 31, 32, 34, 35, 36 };
+	unsigned long x;
+	for (x = 0; x < sizeof(p)/sizeof(p[0]); x++) {
+		p[x].b = (x + 34) | 1;
+	}
+	for (x = 0; x < columns; x++) {
+		double total_r = 0, total_g = 0, total_b = 0;
+		double saved_r = 0, saved_g = 0, saved_b = 0;
+		Minify(2*x +  0,  3.0);
+		Minify(2*x +  1,  7.0);
+		Minify(2*x +  2,  7.0);
+		saved_r = total_r;
+		saved_g = total_g;
+		Minify(2*x + 11, 15.0);
+		Minify(2*x + 12,  7.0);
+		Minify(2*x + 18,  7.0);
+		Minify(2*x + 19, 15.0);
+		Minify(2*x + 20, 15.0);
+		Minify(2*x + 21,  7.0);
+		q[x].r = (unsigned char)(total_r/128.0 + 0.5);
+		q[x].g = (unsigned char)(total_g/128.0 + 0.5);
+		q[x].b = (unsigned char)(total_b/128.0 + 0.5);
+		fprintf(stderr, "r:%f g:%f b:%f\n", saved_r, saved_g, saved_b);
+	}
+	for (x = 0; x < COLS; x++) {
+		if (answers[x] != q[x].b)
+			abort();
+	}
+	return 0;
+}
Index: gcc/testsuite/gcc.dg/vect/pr43430-1.c
===================================================================
--- gcc/testsuite/gcc.dg/vect/pr43430-1.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/testsuite/gcc.dg/vect/pr43430-1.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -35,5 +35,5 @@
   return foo (data_ch1, data_ch2, 1);
 }
 
-/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_condition } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
Index: gcc/testsuite/gcc.dg/vect/slp-multitypes-2.c
===================================================================
--- gcc/testsuite/gcc.dg/vect/slp-multitypes-2.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/testsuite/gcc.dg/vect/slp-multitypes-2.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1,4 +1,5 @@
 /* { dg-require-effective-target vect_int } */
+/* { dg-do run { xfail { sparc*-*-* && ilp32 } } } PR rtl-opt/46603 */
 
 #include <stdarg.h>
 #include <stdio.h>
Index: gcc/testsuite/ChangeLog
===================================================================
--- gcc/testsuite/ChangeLog	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/testsuite/ChangeLog	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1,3 +1,265 @@
+2011-02-10  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	PR target/46610
+	* gcc.target/mips/save-restore-1.c: Skip on mips-sgi-irix6*.
+	* gcc.target/mips/save-restore-3.c: Likewise.
+	* gcc.target/mips/save-restore-4.c: Likewise.
+	* gcc.target/mips/save-restore-5.c: Likewise.
+
+	PR target/47683
+	* g++.dg/tree-prof/partition1.C: Skip on mips-sgi-irix*.
+	* g++.dg/tree-prof/partition2.C: Likewise.
+
+2011-02-07  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	Backport from mainline:
+	2010-07-23  Uros Bizjak  <ubizjak@gmail.com>
+
+	* lib/target-supports.exp (check_avx_hw_available): New procedure.
+	(check_effective_target_avx_runtime): New procedure.
+
+	* gcc.dg/compat/vector-1b_main.c: Use avx_runtime effective target.
+	Remove cpuid.h include and __get_cpuid test.
+	* gcc.dg/compat/vector-2b_main.c: Ditto.
+
+	* gcc.target/i386/avx-check.h (main): Also check bit_OSXSAVE.
+
+2011-02-03  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Backport from mainline:
+	2011-02-02  Michael Meissner  <meissner@linux.vnet.ibm.com>
+	PR target/47272
+	* gcc.target/powerpc/vsx-builtin-8.c: New file, test vec_vsx_ld
+	and vec_vsx_st.
+
+	* gcc.target/powerpc/avoid-indexed-addresses.c: Disable altivec
+	and vsx so a default --with-cpu=power7 doesn't give an error
+	when -mavoid-indexed-addresses is used.
+
+	* gcc.target/powerpc/ppc32-abi-dfp-1.c: Rewrite to use an asm
+	wrapper function to save the arguments and then jump to the real
+	function, rather than depending on the compiler not to move stuff
+	before an asm.
+	* gcc.target/powerpc/ppc64-abi-dfp-2.c: Ditto.
+
+2011-02-03  Jonathan Wakely  <jwakely.gcc@gmail.com>
+
+	PR c++/47589
+	* g++.dg/pr47589.C: New test.
+
+2011-02-01  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/47541
+	* g++.dg/torture/pr47541.C: New testcase.
+
+2011-01-31  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Backport from mainline:
+	2010-12-30  Nathan Froyd  <froydnj@codesourcery.com>
+
+        PR target/44606
+        * gcc.dg/pr44606.c: New test.
+
+2011-01-27  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>
+
+	* gcc.dg/tree-ssa/pr42585.c: Disable on power, arm, sh, s390 and
+	s390x.
+
+2011-01-26  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.c-torture/compile/20110126-1.c: New test.
+
+2011-01-25  Tobias Burnus  <burnus@net-b.de>
+
+	Backport from mainline
+	2011-01-17  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/47331
+	* gfortran.dg/gomp/pr47331.f90: New test.
+
+2011-01-25  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/47448
+	* gfortran.dg/redefined_intrinsic_assignment_2.f90: New.
+
+2011-01-25  Richard Guenther  <rguenther@suse.de>
+
+	PR middle-end/47411
+	* gcc.dg/torture/pr47411.c: New testcase.
+
+2011-01-24  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* gfortran.dg/cray_pointers_2.f90: Avoid cycling through
+	optimization options.
+
+2011-01-24  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* gfortran.dg/array_constructor_33.f90: Use dg-timeout-factor 4.
+
+2011-01-21  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/47365
+	* gcc.dg/torture/pr47365.c: New testcase.
+	* gcc.dg/tree-ssa/pr47392.c: Likewise.
+
+2011-01-21  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* g++.dg/other/anon5.C: Skip on mips-sgi-irix*.
+
+2011-01-17  Eric Botcazou  <ebotcazou@adacore.com>
+
+	Backport from mainline
+	2010-11-22  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.dg/pr28796-2.c: SKIP on SPARC/Solaris 8.
+
+	PR rtl-optimization/46603
+	* gcc.dg/vect/slp-multitypes-2.c: XFAIL execution on SPARC 32-bit.
+
+	2010-08-31  Bingfeng Mei  <bmei@broadcom.com>
+
+	* gcc.dg/vect/pr43430-1.c: Requires vect_condition target.
+
+2011-01-17  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* g++.old-deja/g++.other/init19.C: Don't XFAIL on mips-sgi-irix*.
+
+2011-01-17  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2011-01-17  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/47318
+	* gcc.target/i386/avx-vmaskmovpd-1.c: New.
+	* gcc.target/i386/avx-vmaskmovpd-2.c: Likewise.
+	* gcc.target/i386/avx-vmaskmovps-1.c: Likewise.
+	* gcc.target/i386/avx-vmaskmovps-1.c: Likewise.
+
+	* gcc.target/i386/avx-vmaskmovpd-256-1.c (avx_test): Load mask
+	as __m256i.
+	* gcc.target/i386/avx-vmaskmovpd-256-2.c (avx_test): Likewise.
+	* gcc.target/i386/avx-vmaskmovps-256-1.c (avx_test): Likewise.
+	* gcc.target/i386/avx-vmaskmovps-256-2.c (avx_test): Likewise.
+
+2011-01-17  Richard Guenther  <rguenther@suse.de>
+
+	Backport from mainline
+	PR tree-optimization/47286
+	* gcc.dg/tree-ssa/pr47286.c: New testcase.
+
+	PR tree-optimization/44592
+	* gfortran.dg/pr44592.f90: New testcase.
+
+2011-01-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline
+	2011-01-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/47201
+	* gcc.dg/pr47201.c: New test.
+
+	2011-01-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/47150
+	* gcc.c-torture/compile/pr47150.c: New test.
+
+	2010-12-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/46880
+	* gcc.target/i386/pr46880.c: New test.
+
+	PR middle-end/45852
+	* gcc.target/i386/pr45852.c: New test.
+
+	2010-12-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/43655
+	* g++.dg/opt/pr43655.C: New test.
+
+	PR debug/46893
+	* gcc.dg/pr46893.c: New test.
+
+	2010-12-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/46804
+	* gfortran.dg/pr46804.f90: New test.
+
+	PR rtl-optimization/46865
+	* gcc.target/i386/pr46865-1.c: New test.
+	* gcc.target/i386/pr46865-2.c: New test.
+
+	PR tree-optimization/46864
+	* g++.dg/opt/pr46864.C: New test.
+
+2011-01-13  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* gfortran.dg/cray_pointers_2.f90: Use dg-timeout-factor 4.
+
+2011-01-12  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR testsuite/33033
+	* gcc.dg/20061124-1.c: Pass -mcpu=v9 on the SPARC.
+
+2011-02-01  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from mainline
+	PR fortran/45338
+	* gfortran.dg/userdef_operator_2.f90:  New test case.
+
+2010-12-27  Yao Qi  <yao@codesourcery.com>
+
+	Backport from mainline:
+	2010-10-14  Yao Qi  <yao@codesourcery.com>
+
+	PR target/45447
+	* gcc.target/arm/pr45447.c: New test.
+
+2010-12-24  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/opt13_pkg.ad[sb]: Fix line ending.
+
+2010-12-22  Sebastian Pop  <sebastian.pop@amd.com>
+
+	PR tree-optimization/46758
+	* gcc.dg/graphite/run-id-pr46758.c: New.
+
+2010-12-23  Sebastian Pop  <sebastian.pop@amd.com>
+
+	PR tree-optimization/45552
+	* gcc.dg/graphite/pr45552.c
+
+
+2010-12-23  Sebastian Pop  <sebastian.pop@amd.com>
+
+	PR tree-optimization/43023
+	* gfortran.dg/ldist-1.f90: Adjust pattern.
+	* gfortran.dg/ldist-pr43023.f90: New.
+
+2010-12-21  Martin Jambor  <mjambor@suse.cz>
+
+	PR middle-end/46734
+	* g++.dg/tree-ssa/pr46734.C: New test.
+
+2010-12-18  Alexandre Oliva  <aoliva@redhat.com>
+
+	PR debug/46756
+	* gfortran.dg/debug/pr46756.f: New.
+
+2010-12-18  Alexandre Oliva  <aoliva@redhat.com>
+
+	PR debug/46782
+	* gcc.dg/debug/pr46782.c: New.
+
+2010-12-17  Daniel Kraft  <d@domob.eu>
+
+	PR fortran/46794
+	* gfortran.dg/power2.f90: Initialize variables.
+
+2010-12-16  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/opt13.adb: New test.
+	* gnat.dg/opt13_pkg.ad[sb]: New helper.
+
 2010-12-16  Release Manager
 
 	* GCC 4.5.2 released.
Index: gcc/testsuite/g++.old-deja/g++.other/init19.C
===================================================================
--- gcc/testsuite/g++.old-deja/g++.other/init19.C	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/testsuite/g++.old-deja/g++.other/init19.C	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1,4 +1,4 @@
-// { dg-do run { xfail { { ! cxa_atexit } && { ! *-*-solaris2* } } } }
+// { dg-do run { xfail { { ! cxa_atexit } && { ! { mips-sgi-irix* *-*-solaris2* } } } } }
 #include <stdlib.h>
 
 #define assert(x) do { if (! (x)) abort(); } while (0)
Index: gcc/testsuite/g++.dg/other/anon5.C
===================================================================
--- gcc/testsuite/g++.dg/other/anon5.C	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/testsuite/g++.dg/other/anon5.C	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1,5 +1,5 @@
 // PR c++/34094
-// { dg-do link { target { ! { *-*-darwin* *-*-hpux* *-*-solaris2.* alpha*-dec-osf* } } } }
+// { dg-do link { target { ! { *-*-darwin* *-*-hpux* *-*-solaris2.* alpha*-dec-osf* mips-sgi-irix* } } } }
 // { dg-options "-g" }
 
 namespace {
Index: gcc/testsuite/g++.dg/pr47589.C
===================================================================
--- gcc/testsuite/g++.dg/pr47589.C	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/pr47589.C	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -0,0 +1,26 @@
+// PR c++/47589
+// { dg-do compile }
+
+struct F
+{
+    typedef void(*Cb)();
+
+    F(Cb);
+};
+
+struct C
+{
+    template<class D> static void f();
+};
+
+template<class D>
+struct TF : F
+{
+    TF() : F(C::f<D>) { }
+};
+
+struct DTC : TF<DTC>
+{
+    DTC() { }
+};
+
Index: gcc/testsuite/g++.dg/tree-ssa/pr46734.C
===================================================================
--- gcc/testsuite/g++.dg/tree-ssa/pr46734.C	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/tree-ssa/pr46734.C	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -0,0 +1,34 @@
+/* { dg-do compile } */
+/* { dg-options "-O -fipa-sra" } */
+
+struct A
+{
+  int *p;
+  A() {p = (int *) -1;}
+  ~A() {if (p && p != (int *) -1) *p = 0;}
+};
+
+struct B
+{
+  A a;
+  char data[23];
+  B() : a() {data[0] = 0;}
+};
+
+extern A ga;
+extern int *gi;
+extern void *gz;
+extern B *gb;
+
+static int * __attribute__ ((noinline)) foo (B *b, void *z)
+{
+  __builtin_memcpy (gz, z, 28);
+  ga = b->a;
+  return b->a.p;
+}
+
+int *bar (B *b, void *z)
+{
+  gb = b;
+  return foo (b, z);
+}
Index: gcc/testsuite/g++.dg/opt/pr43655.C
===================================================================
--- gcc/testsuite/g++.dg/opt/pr43655.C	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/opt/pr43655.C	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -0,0 +1,34 @@
+// PR tree-optimization/43655
+// { dg-do run }
+// { dg-options "-O0 -ftree-ter" }
+
+extern "C" void abort ();
+
+struct C
+{
+  C (int i) : val(i) { }
+  C (const C& c) : val(c.val) { }
+  ~C (void) { val = 999; }
+  C& operator = (const C& c) { val = c.val; return *this; }
+  C& inc (int i) { val += i; return *this; }
+  int val;
+};
+
+C
+f ()
+{
+  return C (3);
+}
+
+C
+f (int i)
+{
+  return f ().inc (i);
+}
+
+int
+main ()
+{
+  if (f (2).val != 5)
+    abort ();
+}
Index: gcc/testsuite/g++.dg/opt/pr46864.C
===================================================================
--- gcc/testsuite/g++.dg/opt/pr46864.C	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/opt/pr46864.C	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -0,0 +1,26 @@
+// PR tree-optimization/46864
+// { dg-do compile }
+// { dg-options "-O -fnon-call-exceptions" }
+
+int baz ();
+
+struct S
+{
+  int k;
+  bool bar () throw ()
+  {
+    int m = baz ();
+    for (int i = 0; i < m; i++)
+      k = i;
+    return m;
+  }
+};
+
+extern S *s;
+
+void
+foo ()
+{
+  while (baz () && s->bar ())
+    ;
+}
Index: gcc/testsuite/g++.dg/tree-prof/partition1.C
===================================================================
--- gcc/testsuite/g++.dg/tree-prof/partition1.C	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/testsuite/g++.dg/tree-prof/partition1.C	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1,5 +1,6 @@
 /* { dg-require-effective-target freorder } */
 /* { dg-options "-O2 -freorder-blocks-and-partition" } */
+/* { dg-skip-if "PR target/47683" { mips-sgi-irix* } } */
 
 struct A { A () __attribute__((noinline)); ~A () __attribute__((noinline)); };
 A::A () { asm volatile ("" : : : "memory"); }
Index: gcc/testsuite/g++.dg/tree-prof/partition2.C
===================================================================
--- gcc/testsuite/g++.dg/tree-prof/partition2.C	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/testsuite/g++.dg/tree-prof/partition2.C	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1,6 +1,7 @@
 // PR middle-end/45458
 // { dg-require-effective-target freorder }
 // { dg-options "-fnon-call-exceptions -freorder-blocks-and-partition" }
+// { dg-skip-if "PR target/47683" { mips-sgi-irix* } }
 
 int
 main ()
Index: gcc/testsuite/g++.dg/torture/pr47541.C
===================================================================
--- gcc/testsuite/g++.dg/torture/pr47541.C	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/torture/pr47541.C	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -0,0 +1,27 @@
+/* { dg-do run } */
+
+struct Dummy {};
+struct RefCount : public Dummy {
+    ~RefCount(); /* Has to be non-pod.  */
+    int *a;
+    int *b;
+};
+RefCount::~RefCount(){}
+struct Wrapper : public Dummy { RefCount ref; };
+void __attribute__((noinline,noclone))
+Push(Wrapper ptr)
+{
+  *ptr.ref.b = 0;
+}
+extern "C" void abort (void);
+int main()
+{
+  int a = 1, b = 1;
+  Wrapper x;
+  x.ref.a = &a;
+  x.ref.b = &b;
+  Push(x);
+  if (b != 0)
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/lib/target-supports.exp
===================================================================
--- gcc/testsuite/lib/target-supports.exp	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/testsuite/lib/target-supports.exp	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1,5 +1,5 @@
-#   Copyright (C) 1999, 2001, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
-#    Free Software Foundation, Inc.
+#   Copyright (C) 1999, 2001, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
+#   2011 Free Software Foundation, Inc.
 
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
@@ -1005,6 +1005,30 @@
     }]
 }
 
+# Return 1 if the target supports executing AVX instructions, 0
+# otherwise.  Cache the result.
+
+proc check_avx_hw_available { } {
+    return [check_cached_effective_target avx_hw_available {
+	# If this is not the right target then we can skip the test.
+	if { !([istarget x86_64-*-*] || [istarget i?86-*-*]) } {
+	    expr 0
+	} else {
+	    check_runtime_nocache avx_hw_available {
+		#include "cpuid.h"
+		int main ()
+		{
+		  unsigned int eax, ebx, ecx, edx;
+		  if (__get_cpuid (1, &eax, &ebx, &ecx, &edx))
+		    return ((ecx & (bit_AVX | bit_OSXSAVE))
+			    != (bit_AVX | bit_OSXSAVE));
+		  return 1;
+		}
+	    } ""
+	}
+    }]
+}
+
 # Return 1 if the target supports running SSE executables, 0 otherwise.
 
 proc check_effective_target_sse_runtime { } {
@@ -1025,6 +1049,16 @@
     }
 }
 
+# Return 1 if the target supports running AVX executables, 0 otherwise.
+
+proc check_effective_target_avx_runtime { } {
+    if { [check_effective_target_avx]
+	 && [check_avx_hw_available] } {
+	return 1
+    }
+    return 0
+}
+
 # Return 1 if the target supports executing VSX instructions, 0
 # otherwise.  Cache the result.
 
Index: gcc/testsuite/gfortran.dg/gomp/pr47331.f90
===================================================================
--- gcc/testsuite/gfortran.dg/gomp/pr47331.f90	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/gomp/pr47331.f90	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -0,0 +1,24 @@
+! PR fortran/47331
+! { dg-do compile }
+! { dg-options "-fopenmp -fwhole-file" }
+
+subroutine foo
+  !$omp parallel
+    call bar ()
+  !$omp end parallel
+end subroutine foo
+
+subroutine bar
+  integer :: k
+  do k=1,5
+    call baz (k)
+  end do
+end subroutine bar
+
+subroutine baz (k)
+  integer :: k
+end subroutine
+
+program pr47331
+  call foo
+end program pr47331
Index: gcc/testsuite/gfortran.dg/ldist-1.f90
===================================================================
--- gcc/testsuite/gfortran.dg/ldist-1.f90	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/testsuite/gfortran.dg/ldist-1.f90	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -29,5 +29,8 @@
   return
 end Subroutine PADEC
 
-! { dg-final { scan-tree-dump-times "distributed: split to 4 loops" 1 "ldist" } }
+! There are 5 legal partitions in this code.  Based on the data
+! locality heuristic, this loop should not be split.
+
+! { dg-final { scan-tree-dump-not "distributed: split to" "ldist" } }
 ! { dg-final { cleanup-tree-dump "ldist" } }
Index: gcc/testsuite/gfortran.dg/redefined_intrinsic_assignment_2.f90
===================================================================
--- gcc/testsuite/gfortran.dg/redefined_intrinsic_assignment_2.f90	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/redefined_intrinsic_assignment_2.f90	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -0,0 +1,68 @@
+! { dg-do compile }
+!
+! PR fortran/47448
+!
+! ASSIGNMENT(=) checks. Defined assignment is allowed if and only if
+! it does not override an intrinsic assignment.
+!
+
+module test1
+  interface assignment(=)
+     module procedure valid, valid2
+  end interface
+contains
+  ! Valid: scalar = array
+  subroutine valid (lhs,rhs)
+    integer, intent(out) ::  lhs
+    integer, intent(in) :: rhs(:)
+    lhs = rhs(1) 
+  end subroutine valid
+
+  ! Valid: array of different ranks
+  subroutine valid2 (lhs,rhs)
+    integer, intent(out) ::  lhs(:)
+    integer, intent(in) :: rhs(:,:)
+    lhs(:) = rhs(:,1) 
+  end subroutine valid2
+end module test1
+
+module test2
+  interface assignment(=)
+     module procedure invalid
+  end interface
+contains
+  ! Invalid: scalar = scalar
+  subroutine invalid (lhs,rhs) ! { dg-error "must not redefine an INTRINSIC type assignment" }
+    integer, intent(out) ::  lhs
+    integer, intent(in) :: rhs
+    lhs = rhs
+  end subroutine invalid
+end module test2
+
+module test3
+  interface assignment(=)
+     module procedure invalid2
+  end interface
+contains
+  ! Invalid: array = scalar
+  subroutine invalid2 (lhs,rhs) ! { dg-error "must not redefine an INTRINSIC type assignment" }
+    integer, intent(out) ::  lhs(:)
+    integer, intent(in) :: rhs
+    lhs(:) = rhs
+  end subroutine invalid2
+end module test3
+
+module test4
+  interface assignment(=)
+     module procedure invalid3
+  end interface
+contains
+  ! Invalid: array = array for same rank
+  subroutine invalid3 (lhs,rhs) ! { dg-error "must not redefine an INTRINSIC type assignment" }
+    integer, intent(out) ::  lhs(:)
+    integer, intent(in) :: rhs(:)
+    lhs(:) = rhs(:)
+  end subroutine invalid3
+end module test4
+
+! { dg-final { cleanup-modules "test1" } }
Index: gcc/testsuite/gfortran.dg/debug/pr46756.f
===================================================================
--- gcc/testsuite/gfortran.dg/debug/pr46756.f	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/debug/pr46756.f	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -0,0 +1,29 @@
+C PR debug/46756, reduced from ../20010519-1.f
+C { dg-do compile }
+C { dg-options "-O -fcompare-debug" }
+      LOGICAL QDISK,QDW,QCMPCT
+      LOGICAL LNOMA,LRAISE,LSCI,LBIG
+      ASSIGN 801 TO I800 ! { dg-warning "Deleted feature: ASSIGN" "Deleted feature: ASSIGN" }
+      GOTO 800
+ 801  CONTINUE
+      ASSIGN 761 TO I760 ! { dg-warning "Deleted feature: ASSIGN" "Deleted feature: ASSIGN" }
+ 761  CONTINUE
+      IF(LSCI) THEN
+         DO I=1,LENCM
+         ENDDO
+      ENDIF
+      DO WHILE((CVGMX.GT.TOLDIM).AND.(ITER.LT.ITMX))
+         IF(.NOT.QDW) THEN
+            ASSIGN 641 to I640 ! { dg-warning "Deleted feature: ASSIGN" "Deleted feature: ASSIGN" }
+            GOTO 640
+ 641        CONTINUE
+         ENDIF
+      ENDDO
+      GOTO 700
+ 640  CONTINUE
+      GOTO I640 ! { dg-warning "Deleted feature: Assigned" "Assigned GO TO" }
+ 700  CONTINUE
+      GOTO I760 ! { dg-warning "Deleted feature: Assigned" "Assigned GO TO" }
+ 800  CONTINUE
+      GOTO I800 ! { dg-warning "Deleted feature: Assigned" "Assigned GO TO" }
+      END
Index: gcc/testsuite/gfortran.dg/cray_pointers_2.f90
===================================================================
--- gcc/testsuite/gfortran.dg/cray_pointers_2.f90	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/testsuite/gfortran.dg/cray_pointers_2.f90	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1,5 +1,8 @@
-! { dg-do run }
-! { dg-options "-fcray-pointer -fbounds-check" }
+! Using two spaces between dg-do and run is a hack to keep gfortran-dg-runtest
+! from cycling through optimization options for this expensive test.
+! { dg-do  run }
+! { dg-options "-O3 -fcray-pointer -fbounds-check" }
+! { dg-timeout-factor 4 }
 ! Series of routines for testing a Cray pointer implementation
 program craytest
   common /errors/errors(400)
Index: gcc/testsuite/gfortran.dg/dependency_39.f90
===================================================================
--- gcc/testsuite/gfortran.dg/dependency_39.f90	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/dependency_39.f90	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -0,0 +1,37 @@
+! { dg-do run }
+! PR 45777 - component ref aliases when both are pointers
+module m1
+  type t1
+     integer, dimension(:), allocatable :: data
+  end type t1
+contains
+  subroutine s1(t,d)
+    integer, dimension(:), pointer :: d
+    type(t1), pointer :: t
+    d(1:5)=t%data(3:7)
+  end subroutine s1
+  subroutine s2(d,t)
+    integer, dimension(:), pointer :: d
+    type(t1), pointer :: t
+    t%data(3:7) = d(1:5)
+  end subroutine s2
+end module m1
+
+program main
+  use m1
+  type(t1), pointer :: t
+  integer, dimension(:), pointer :: d
+  allocate(t)
+  allocate(t%data(10))
+  t%data=(/(i,i=1,10)/)
+  d=>t%data(5:9)
+  call s1(t,d)
+  if (any(d.ne.(/3,4,5,6,7/))) call abort()
+  t%data=(/(i,i=1,10)/)
+  d=>t%data(1:5)
+  call s2(d,t)
+  if (any(t%data.ne.(/1,2,1,2,3,4,5,8,9,10/))) call abort
+  deallocate(t%data)
+  deallocate(t)
+end program main
+! { dg-final { cleanup-modules "m1" } }
Index: gcc/testsuite/gfortran.dg/ldist-pr43023.f90
===================================================================
--- gcc/testsuite/gfortran.dg/ldist-pr43023.f90	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/ldist-pr43023.f90	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -0,0 +1,31 @@
+! { dg-do compile }
+! { dg-options "-O2 -ftree-loop-distribution" }
+
+MODULE NFT_mod
+
+implicit none
+integer :: Nangle
+real:: Z0
+real, dimension(:,:), allocatable :: Angle
+real, dimension(:), allocatable :: exth, ezth, hxth, hyth, hyphi
+
+CONTAINS
+
+SUBROUTINE NFT_Init()
+
+real :: th, fi
+integer :: n
+
+do n = 1,Nangle
+  th = Angle(n,1)
+  fi = Angle(n,2)
+
+  exth(n) =  cos(fi)*cos(th)
+  ezth(n) = -sin(th)
+  hxth(n) = -sin(fi)
+  hyth(n) =  cos(fi)
+  hyphi(n) = -sin(fi)
+end do
+END SUBROUTINE NFT_Init
+
+END MODULE NFT_mod
Index: gcc/testsuite/gfortran.dg/pr44592.f90
===================================================================
--- gcc/testsuite/gfortran.dg/pr44592.f90	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/pr44592.f90	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -0,0 +1,20 @@
+! { dg-do run }
+! { dg-options "-O3" }
+! From forall_12.f90
+! Fails with loop reversal at -O3
+!
+  character(len=1) :: b(4) = (/"1","2","3","4"/), c(4)
+  c = b
+  i = 1
+  ! This statement must be here for the abort below
+  b(1:3)(i:i) = b(2:4)(i:i)
+
+  b = c
+  b(4:2:-1)(i:i) = b(3:1:-1)(i:i)
+
+  ! This fails.  If the condition is printed, the result is F F F F
+  if (any (b .ne. (/"1","1","2","3"/))) i = 2
+  print *, b
+  print *, b .ne. (/"1","1","2","3"/)
+  if (i == 2) call abort
+end
Index: gcc/testsuite/gfortran.dg/userdef_operator_2.f90
===================================================================
--- gcc/testsuite/gfortran.dg/userdef_operator_2.f90	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/userdef_operator_2.f90	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -0,0 +1,17 @@
+! { dg-do compile }
+! PR 45338 - no ICE when cmp is not used explicitly.
+! Test case by Simon Smart 
+module test_mod
+  implicit none
+contains
+  subroutine test_fn (cmp)
+    interface operator(.myop.)
+       pure function cmp (a, b) result(ret)
+         integer, intent(in) :: a, b
+         logical ret
+       end function cmp
+    end interface
+    integer :: a, b
+    print*, a .myop. b
+  end subroutine test_fn
+end module test_mod
Index: gcc/testsuite/gfortran.dg/array_constructor_33.f90
===================================================================
--- gcc/testsuite/gfortran.dg/array_constructor_33.f90	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/testsuite/gfortran.dg/array_constructor_33.f90	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1,4 +1,5 @@
 ! { dg-do compile }
+! { dg-timeout-factor 4 }
 ! PR20923 gfortran slow for large array constructors.
 ! Test case prepared from PR by Jerry DeLisle <jvdelisle@gcc.gnu.org>
 program sel
Index: gcc/testsuite/gfortran.dg/pr46804.f90
===================================================================
--- gcc/testsuite/gfortran.dg/pr46804.f90	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/pr46804.f90	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -0,0 +1,36 @@
+! PR rtl-optimization/46804
+! { dg-do run }
+! { dg-options "-O -fPIC -fexpensive-optimizations -fgcse -foptimize-register-move -fpeel-loops -fno-tree-loop-optimize" }
+
+program main
+  integer, parameter :: n1 = 2, n2 = 3, n3 = 4, slen = 3
+  character (len = slen), dimension (n1, n2, n3) :: a
+  integer (kind = 1), dimension (2, 4) :: shift1
+  integer (kind = 2), dimension (2, 4) :: shift2
+  integer (kind = 4), dimension (2, 4) :: shift3
+  do i3 = 1, n3
+    do i2 = 1, n2
+      do i1 = 1, n1
+        a (i1, i2, i3) = 'ab'(i1:i1) // 'cde'(i2:i2) // 'fghi'(i3:i3)
+      end do
+    end do
+  end do
+  shift1 (1, :) = (/ 4, 11, 19, 20 /)
+  shift1 (2, :) = (/ 55, 5, 1, 2 /)
+  shift2 = shift1
+  shift3 = shift1
+  call test (cshift (a, shift2, 2))
+  call test (cshift (a, shift3, 2))
+contains
+  subroutine test (b)
+    character (len = slen), dimension (n1, n2, n3) :: b
+    do i3 = 1, n3
+      do i2 = 1, n2
+        do i1 = 1, n1
+          i2p = mod (shift1 (i1, i3) + i2 - 1, n2) + 1
+          if (b (i1, i2, i3) .ne. a (i1, i2p, i3)) call abort
+        end do
+      end do
+    end do
+  end subroutine test
+end program main
Index: gcc/testsuite/gfortran.dg/power2.f90
===================================================================
--- gcc/testsuite/gfortran.dg/power2.f90	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/testsuite/gfortran.dg/power2.f90	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -13,6 +13,9 @@
   INTEGER(KIND=1) :: k1
   INTEGER(KIND=2) :: k2
 
+  k1 = 1_1
+  k2 = 1_2
+
   k1 = 1_1 + 1_1**k1
   k2 = 1_2 + 1_2**k2
 
Index: gcc/tree-ssa-copyrename.c
===================================================================
--- gcc/tree-ssa-copyrename.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/tree-ssa-copyrename.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -225,11 +225,16 @@
       ign2 = false;
     }
 
-  /* Don't coalesce if the two variables are not of the same type.  */
-  if (TREE_TYPE (root1) != TREE_TYPE (root2))
+  /* Don't coalesce if the two variables aren't type compatible .  */
+  if (!types_compatible_p (TREE_TYPE (root1), TREE_TYPE (root2))
+      /* There is a disconnect between the middle-end type-system and
+         VRP, avoid coalescing enum types with different bounds.  */
+      || ((TREE_CODE (TREE_TYPE (root1)) == ENUMERAL_TYPE
+	   || TREE_CODE (TREE_TYPE (root2)) == ENUMERAL_TYPE)
+	  && TREE_TYPE (root1) != TREE_TYPE (root2)))
     {
       if (debug)
-	fprintf (debug, " : Different types.  No coalesce.\n");
+	fprintf (debug, " : Incompatible types.  No coalesce.\n");
       return false;
     }
 
Index: gcc/tree-ssa-ccp.c
===================================================================
--- gcc/tree-ssa-ccp.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/tree-ssa-ccp.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -3355,7 +3355,9 @@
    is replaced.  If the call is expected to produces a result, then it
    is replaced by an assignment of the new RHS to the result variable.
    If the result is to be ignored, then the call is replaced by a
-   GIMPLE_NOP.  */
+   GIMPLE_NOP.  A proper VDEF chain is retained by making the first
+   VUSE and the last VDEF of the whole sequence be the same as the replaced
+   statement and using new SSA names for stores in between.  */
 
 static void
 gimplify_and_update_call_from_tree (gimple_stmt_iterator *si_p, tree expr)
@@ -3366,17 +3368,36 @@
   gimple_stmt_iterator i;
   gimple_seq stmts = gimple_seq_alloc();
   struct gimplify_ctx gctx;
+  gimple last = NULL;
+  gimple laststore = NULL;
+  tree reaching_vuse;
 
   stmt = gsi_stmt (*si_p);
 
   gcc_assert (is_gimple_call (stmt));
 
   lhs = gimple_call_lhs (stmt);
+  reaching_vuse = gimple_vuse (stmt);
 
   push_gimplify_context (&gctx);
 
   if (lhs == NULL_TREE)
-    gimplify_and_add (expr, &stmts);
+    {
+      gimplify_and_add (expr, &stmts);
+      /* We can end up with folding a memcpy of an empty class assignment
+	 which gets optimized away by C++ gimplification.  */
+      if (gimple_seq_empty_p (stmts))
+	{
+	  pop_gimplify_context (NULL);
+	  if (gimple_in_ssa_p (cfun))
+	    {
+	      unlink_stmt_vdef (stmt);
+	      release_defs (stmt);
+	    }
+	  gsi_remove (si_p, true);
+	  return;
+	}
+    }
   else
     tmp = get_initialized_tmp_var (expr, &stmts, NULL);
 
@@ -3387,26 +3408,95 @@
 
   /* The replacement can expose previously unreferenced variables.  */
   for (i = gsi_start (stmts); !gsi_end_p (i); gsi_next (&i))
-  {
-    new_stmt = gsi_stmt (i);
-    find_new_referenced_vars (new_stmt);
-    gsi_insert_before (si_p, new_stmt, GSI_NEW_STMT);
-    mark_symbols_for_renaming (new_stmt);
-    gsi_next (si_p);
-  }
+    {
+      if (last)
+	{
+	  gsi_insert_before (si_p, last, GSI_NEW_STMT);
+	  gsi_next (si_p);
+	}
+      new_stmt = gsi_stmt (i);
+      if (gimple_in_ssa_p (cfun))
+	{
+	  find_new_referenced_vars (new_stmt);
+	  mark_symbols_for_renaming (new_stmt);
+	}
+      /* If the new statement has a VUSE, update it with exact SSA name we
+         know will reach this one.  */
+      if (gimple_vuse (new_stmt))
+	{
+	  /* If we've also seen a previous store create a new VDEF for
+	     the latter one, and make that the new reaching VUSE.  */
+	  if (laststore)
+	    {
+	      reaching_vuse = make_ssa_name (gimple_vop (cfun), laststore);
+	      gimple_set_vdef (laststore, reaching_vuse);
+	      update_stmt (laststore);
+	      laststore = NULL;
+	    }
+	  gimple_set_vuse (new_stmt, reaching_vuse);
+	  gimple_set_modified (new_stmt, true);
+	}
+      if (gimple_assign_single_p (new_stmt)
+	  && !is_gimple_reg (gimple_assign_lhs (new_stmt)))
+	{
+	  laststore = new_stmt;
+	}
+      last = new_stmt;
+    }
 
   if (lhs == NULL_TREE)
     {
-      new_stmt = gimple_build_nop ();
-      unlink_stmt_vdef (stmt);
-      release_defs (stmt);
+      /* If we replace a call without LHS that has a VDEF and our new
+         sequence ends with a store we must make that store have the same
+	 vdef in order not to break the sequencing.  This can happen
+	 for instance when folding memcpy calls into assignments.  */
+      if (gimple_vdef (stmt) && laststore)
+	{
+	  gimple_set_vdef (laststore, gimple_vdef (stmt));
+	  if (TREE_CODE (gimple_vdef (stmt)) == SSA_NAME)
+	    SSA_NAME_DEF_STMT (gimple_vdef (stmt)) = laststore;
+	  update_stmt (laststore);
+	}
+      else if (gimple_in_ssa_p (cfun))
+	{
+	  unlink_stmt_vdef (stmt);
+	  release_defs (stmt);
+	}
+      new_stmt = last;
     }
   else
     {
+      if (last)
+	{
+	  gsi_insert_before (si_p, last, GSI_NEW_STMT);
+	  gsi_next (si_p);
+	}
+      if (laststore && is_gimple_reg (lhs))
+	{
+	  gimple_set_vdef (laststore, gimple_vdef (stmt));
+	  update_stmt (laststore);
+	  if (TREE_CODE (gimple_vdef (stmt)) == SSA_NAME)
+	    SSA_NAME_DEF_STMT (gimple_vdef (stmt)) = laststore;
+	  laststore = NULL;
+	}
+      else if (laststore)
+	{
+	  reaching_vuse = make_ssa_name (gimple_vop (cfun), laststore);
+	  gimple_set_vdef (laststore, reaching_vuse);
+	  update_stmt (laststore);
+	  laststore = NULL;
+	}
       new_stmt = gimple_build_assign (lhs, tmp);
-      gimple_set_vuse (new_stmt, gimple_vuse (stmt));
-      gimple_set_vdef (new_stmt, gimple_vdef (stmt));
-      move_ssa_defining_stmt_for_defs (new_stmt, stmt);
+      if (!is_gimple_reg (tmp))
+	gimple_set_vuse (new_stmt, reaching_vuse);
+      if (!is_gimple_reg (lhs))
+	{
+	  gimple_set_vdef (new_stmt, gimple_vdef (stmt));
+	  if (TREE_CODE (gimple_vdef (stmt)) == SSA_NAME)
+	    SSA_NAME_DEF_STMT (gimple_vdef (stmt)) = new_stmt;
+	}
+      else if (reaching_vuse == gimple_vuse (stmt))
+	unlink_stmt_vdef (stmt);
     }
 
   gimple_set_location (new_stmt, gimple_location (stmt));
Index: gcc/xcoffout.c
===================================================================
--- gcc/xcoffout.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/xcoffout.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -81,8 +81,15 @@
 #define ASM_OUTPUT_LINE(FILE,LINENUM)					   \
   do									   \
     {									   \
+      /* Make sure we're in a function and prevent output of .line 0, as   \
+	 line # 0 is meant for symbol addresses in xcoff.  Additionally,   \
+	 line numbers are 'unsigned short' in 32-bit mode.  */		   \
       if (xcoff_begin_function_line >= 0)				   \
-	fprintf (FILE, "\t.line\t%d\n", ABS_OR_RELATIVE_LINENO (LINENUM)); \
+	{								   \
+	  int lno = ABS_OR_RELATIVE_LINENO (LINENUM);			   \
+	  if (lno > 0 && (TARGET_64BIT || lno <= (int)USHRT_MAX))	   \
+	    fprintf (FILE, "\t.line\t%d\n", lno);			   \
+	}								   \
     }									   \
   while (0)
 
Index: gcc/jump.c
===================================================================
--- gcc/jump.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/jump.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -194,7 +194,7 @@
   rtx prev_nonjump_insn = NULL;
 
   for (insn = f; insn; insn = NEXT_INSN (insn))
-    if (INSN_P (insn))
+    if (NONDEBUG_INSN_P (insn))
       {
 	mark_jump_label (PATTERN (insn), insn, 0);
 
@@ -1728,7 +1728,13 @@
 
 	case 'i':
 	  if (XINT (x, i) != XINT (y, i))
-	    return 0;
+	    {
+	      if (((code == ASM_OPERANDS && i == 6)
+		   || (code == ASM_INPUT && i == 1))
+		  && locator_eq (XINT (x, i), XINT (y, i)))
+		break;
+	      return 0;
+	    }
 	  break;
 
 	case 't':
Index: gcc/expr.c
===================================================================
--- gcc/expr.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/expr.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -4730,7 +4730,10 @@
       /* If store_expr stores a DECL whose DECL_RTL(exp) == TARGET,
 	 but TARGET is not valid memory reference, TEMP will differ
 	 from TARGET although it is really the same location.  */
-      && !(alt_rtl && rtx_equal_p (alt_rtl, target))
+      && !(alt_rtl
+	   && rtx_equal_p (alt_rtl, target)
+	   && !side_effects_p (alt_rtl)
+	   && !side_effects_p (target))
       /* If there's nothing to copy, don't bother.  Don't call
 	 expr_size unless necessary, because some front-ends (C++)
 	 expr_size-hook must not be given objects that are not
Index: gcc/ada/ChangeLog
===================================================================
--- gcc/ada/ChangeLog	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/ada/ChangeLog	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1,3 +1,13 @@
+2011-02-08  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/Makefile.in (x86-64 darwin): Handle multilibs.
+
+2011-01-04  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/trans.c (Subprogram_Body_to_gnu): Evaluate the
+	expressions of the parameter cache within the statement group of
+	the CICO mechanism.
+
 2010-12-16  Release Manager
 
 	* GCC 4.5.2 released.
Index: gcc/ada/gcc-interface/Makefile.in
===================================================================
--- gcc/ada/gcc-interface/Makefile.in	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/ada/gcc-interface/Makefile.in	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -2143,11 +2143,17 @@
     s-taprop.adb<s-taprop-posix.adb \
     s-taspri.ads<s-taspri-posix.ads \
     s-tpopsp.adb<s-tpopsp-posix-foreign.adb \
-    a-numaux.ads<a-numaux-x86.ads \
-    a-numaux.adb<a-numaux-x86.adb \
     g-trasym.ads<g-trasym-unimplemented.ads \
     g-trasym.adb<g-trasym-unimplemented.adb \
-    system.ads<system-darwin-x86_64.ads
+    a-numaux.ads<a-numaux-x86.ads \
+    a-numaux.adb<a-numaux-x86.adb
+    ifeq ($(strip $(MULTISUBDIR)),/i386)
+      LIBGNAT_TARGET_PAIRS += \
+      system.ads<system-darwin-x86.ads
+    else
+      LIBGNAT_TARGET_PAIRS += \
+      system.ads<system-darwin-x86_64.ads
+    endif
   endif
 
   ifeq ($(strip $(filter-out powerpc%,$(arch))),)
Index: gcc/ada/gcc-interface/trans.c
===================================================================
--- gcc/ada/gcc-interface/trans.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/ada/gcc-interface/trans.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -2303,6 +2303,31 @@
   gnat_poplevel ();
   gnu_result = end_stmt_group ();
 
+  /* If we populated the parameter attributes cache, we need to make sure that
+     the cached expressions are evaluated on all the possible paths leading to
+     their uses.  So we force their evaluation on entry of the function.  */
+  cache = DECL_STRUCT_FUNCTION (gnu_subprog_decl)->language->parm_attr_cache;
+  if (cache)
+    {
+      struct parm_attr_d *pa;
+      int i;
+
+      start_stmt_group ();
+
+      for (i = 0; VEC_iterate (parm_attr, cache, i, pa); i++)
+	{
+	  if (pa->first)
+	    add_stmt_with_node (pa->first, gnat_node);
+	  if (pa->last)
+	    add_stmt_with_node (pa->last, gnat_node);
+	  if (pa->length)
+	    add_stmt_with_node (pa->length, gnat_node);
+	}
+
+      add_stmt (gnu_result);
+      gnu_result = end_stmt_group ();
+    }
+
   /* If we are dealing with a return from an Ada procedure with parameters
      passed by copy-in/copy-out, we need to return a record containing the
      final values of these parameters.  If the list contains only one entry,
@@ -2341,30 +2366,6 @@
 
   pop_stack (&gnu_return_label_stack);
 
-  /* If we populated the parameter attributes cache, we need to make sure
-     that the cached expressions are evaluated on all possible paths.  */
-  cache = DECL_STRUCT_FUNCTION (gnu_subprog_decl)->language->parm_attr_cache;
-  if (cache)
-    {
-      struct parm_attr_d *pa;
-      int i;
-
-      start_stmt_group ();
-
-      for (i = 0; VEC_iterate (parm_attr, cache, i, pa); i++)
-	{
-	  if (pa->first)
-	    add_stmt_with_node (pa->first, gnat_node);
-	  if (pa->last)
-	    add_stmt_with_node (pa->last, gnat_node);
-	  if (pa->length)
-	    add_stmt_with_node (pa->length, gnat_node);
-	}
-
-      add_stmt (gnu_result);
-      gnu_result = end_stmt_group ();
-    }
-
   /* Set the end location.  */
   Sloc_to_locus
     ((Present (End_Label (Handled_Statement_Sequence (gnat_node)))
Index: gcc/fortran/openmp.c
===================================================================
--- gcc/fortran/openmp.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/fortran/openmp.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1363,6 +1363,31 @@
 }
 
 
+/* Save and clear openmp.c private state.  */
+
+void
+gfc_omp_save_and_clear_state (struct gfc_omp_saved_state *state)
+{
+  state->ptrs[0] = omp_current_ctx;
+  state->ptrs[1] = omp_current_do_code;
+  state->ints[0] = omp_current_do_collapse;
+  omp_current_ctx = NULL;
+  omp_current_do_code = NULL;
+  omp_current_do_collapse = 0;
+}
+
+
+/* Restore openmp.c private state from the saved state.  */
+
+void
+gfc_omp_restore_state (struct gfc_omp_saved_state *state)
+{
+  omp_current_ctx = (struct omp_context *) state->ptrs[0];
+  omp_current_do_code = (gfc_code *) state->ptrs[1];
+  omp_current_do_collapse = state->ints[0];
+}
+
+
 /* Note a DO iterator variable.  This is special in !$omp parallel
    construct, where they are predetermined private.  */
 
Index: gcc/fortran/interface.c
===================================================================
--- gcc/fortran/interface.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/fortran/interface.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -624,11 +624,12 @@
 
       /* Allowed are (per F2003, 12.3.2.1.2 Defined assignments):
 	 - First argument an array with different rank than second,
-	 - Types and kinds do not conform, and
+	 - First argument is a scalar and second an array,
+	 - Types and kinds do not conform, or
 	 - First argument is of derived type.  */
       if (sym->formal->sym->ts.type != BT_DERIVED
 	  && sym->formal->sym->ts.type != BT_CLASS
-	  && (r1 == 0 || r1 == r2)
+	  && (r2 == 0 || r1 == r2)
 	  && (sym->formal->sym->ts.type == sym->formal->next->sym->ts.type
 	      || (gfc_numeric_ts (&sym->formal->sym->ts)
 		  && gfc_numeric_ts (&sym->formal->next->sym->ts))))
Index: gcc/fortran/trans-array.c
===================================================================
--- gcc/fortran/trans-array.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/fortran/trans-array.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -3389,7 +3389,38 @@
     }
 }
 
+/* Return true if both symbols could refer to the same data object.  Does
+   not take account of aliasing due to equivalence statements.  */
 
+static int
+symbols_could_alias (gfc_symbol *lsym, gfc_symbol *rsym, bool lsym_pointer,
+		     bool lsym_target, bool rsym_pointer, bool rsym_target)
+{
+  /* Aliasing isn't possible if the symbols have different base types.  */
+  if (gfc_compare_types (&lsym->ts, &rsym->ts) == 0)
+    return 0;
+
+  /* Pointers can point to other pointers and target objects.  */
+
+  if ((lsym_pointer && (rsym_pointer || rsym_target))
+      || (rsym_pointer && (lsym_pointer || lsym_target)))
+    return 1;
+
+  /* Special case: Argument association, cf. F90 12.4.1.6, F2003 12.4.1.7
+     and F2008 12.5.2.13 items 3b and 4b. The pointer case (a) is already
+     checked above.  */
+  if (lsym->attr.target && rsym->attr.target
+      && ((lsym->attr.dummy
+	   && (!lsym->attr.dimension || lsym->as->type == AS_ASSUMED_SHAPE))
+	  || (rsym->attr.dummy
+	      && (!rsym->attr.dimension
+		  || rsym->as->type == AS_ASSUMED_SHAPE))))
+    return 1;
+
+  return 0;
+}
+
+
 /* Return true if the two SS could be aliased, i.e. both point to the same data
    object.  */
 /* TODO: resolve aliases based on frontend expressions.  */
@@ -3401,10 +3432,18 @@
   gfc_ref *rref;
   gfc_symbol *lsym;
   gfc_symbol *rsym;
+  bool lsym_pointer, lsym_target, rsym_pointer, rsym_target;
 
   lsym = lss->expr->symtree->n.sym;
   rsym = rss->expr->symtree->n.sym;
-  if (gfc_symbols_could_alias (lsym, rsym))
+
+  lsym_pointer = lsym->attr.pointer;
+  lsym_target = lsym->attr.target;
+  rsym_pointer = rsym->attr.pointer;
+  rsym_target = rsym->attr.target;
+
+  if (symbols_could_alias (lsym, rsym, lsym_pointer, lsym_target,
+			   rsym_pointer, rsym_target))
     return 1;
 
   if (rsym->ts.type != BT_DERIVED
@@ -3419,27 +3458,75 @@
       if (lref->type != REF_COMPONENT)
 	continue;
 
-      if (gfc_symbols_could_alias (lref->u.c.sym, rsym))
+      lsym_pointer = lsym_pointer || lref->u.c.sym->attr.pointer;
+      lsym_target  = lsym_target  || lref->u.c.sym->attr.target;
+
+      if (symbols_could_alias (lref->u.c.sym, rsym, lsym_pointer, lsym_target,
+			       rsym_pointer, rsym_target))
 	return 1;
 
+      if ((lsym_pointer && (rsym_pointer || rsym_target))
+	  || (rsym_pointer && (lsym_pointer || lsym_target)))
+	{
+	  if (gfc_compare_types (&lref->u.c.component->ts,
+				 &rsym->ts))
+	    return 1;
+	}
+
       for (rref = rss->expr->ref; rref != rss->data.info.ref;
 	   rref = rref->next)
 	{
 	  if (rref->type != REF_COMPONENT)
 	    continue;
 
-	  if (gfc_symbols_could_alias (lref->u.c.sym, rref->u.c.sym))
+	  rsym_pointer = rsym_pointer || rref->u.c.sym->attr.pointer;
+	  rsym_target  = lsym_target  || rref->u.c.sym->attr.target;
+
+	  if (symbols_could_alias (lref->u.c.sym, rref->u.c.sym,
+				   lsym_pointer, lsym_target,
+				   rsym_pointer, rsym_target))
 	    return 1;
+
+	  if ((lsym_pointer && (rsym_pointer || rsym_target))
+	      || (rsym_pointer && (lsym_pointer || lsym_target)))
+	    {
+	      if (gfc_compare_types (&lref->u.c.component->ts,
+				     &rref->u.c.sym->ts))
+		return 1;
+	      if (gfc_compare_types (&lref->u.c.sym->ts,
+				     &rref->u.c.component->ts))
+		return 1;
+	      if (gfc_compare_types (&lref->u.c.component->ts,
+				     &rref->u.c.component->ts))
+		return 1;
+	    }
 	}
     }
 
+  lsym_pointer = lsym->attr.pointer;
+  lsym_target = lsym->attr.target;
+  lsym_pointer = lsym->attr.pointer;
+  lsym_target = lsym->attr.target;
+
   for (rref = rss->expr->ref; rref != rss->data.info.ref; rref = rref->next)
     {
       if (rref->type != REF_COMPONENT)
 	break;
 
-      if (gfc_symbols_could_alias (rref->u.c.sym, lsym))
+      rsym_pointer = rsym_pointer || rref->u.c.sym->attr.pointer;
+      rsym_target  = lsym_target  || rref->u.c.sym->attr.target;
+
+      if (symbols_could_alias (rref->u.c.sym, lsym,
+			       lsym_pointer, lsym_target,
+			       rsym_pointer, rsym_target))
 	return 1;
+
+      if ((lsym_pointer && (rsym_pointer || rsym_target))
+	  || (rsym_pointer && (lsym_pointer || lsym_target)))
+	{
+	  if (gfc_compare_types (&lsym->ts, &rref->u.c.component->ts))
+	    return 1;
+	}
     }
 
   return 0;
Index: gcc/fortran/symbol.c
===================================================================
--- gcc/fortran/symbol.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/fortran/symbol.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -2733,41 +2733,6 @@
   return i;
 }
 
-/* Return true if both symbols could refer to the same data object.  Does
-   not take account of aliasing due to equivalence statements.  */
-
-int
-gfc_symbols_could_alias (gfc_symbol *lsym, gfc_symbol *rsym)
-{
-  /* Aliasing isn't possible if the symbols have different base types.  */
-  if (gfc_compare_types (&lsym->ts, &rsym->ts) == 0)
-    return 0;
-
-  /* Pointers can point to other pointers, target objects and allocatable
-     objects.  Two allocatable objects cannot share the same storage.  */
-  if (lsym->attr.pointer
-      && (rsym->attr.pointer || rsym->attr.allocatable || rsym->attr.target))
-    return 1;
-  if (lsym->attr.target && rsym->attr.pointer)
-    return 1;
-  if (lsym->attr.allocatable && rsym->attr.pointer)
-    return 1;
-
-  /* Special case: Argument association, cf. F90 12.4.1.6, F2003 12.4.1.7
-     and F2008 12.5.2.13 items 3b and 4b. The pointer case (a) is already
-     checked above.  */
-  if (lsym->attr.target && rsym->attr.target
-      && ((lsym->attr.dummy
-	   && (!lsym->attr.dimension || lsym->as->type == AS_ASSUMED_SHAPE))
-	  || (rsym->attr.dummy
-	      && (!rsym->attr.dimension
-		  || rsym->as->type == AS_ASSUMED_SHAPE))))
-    return 1;
-
-  return 0;
-}
-
-
 /* Undoes all the changes made to symbols in the current statement.
    This subroutine is made simpler due to the fact that attributes are
    never removed once added.  */
Index: gcc/fortran/trans-openmp.c
===================================================================
--- gcc/fortran/trans-openmp.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/fortran/trans-openmp.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -480,13 +480,23 @@
   gfc_symbol init_val_sym, outer_sym, intrinsic_sym;
   gfc_expr *e1, *e2, *e3, *e4;
   gfc_ref *ref;
-  tree decl, backend_decl, stmt;
+  tree decl, backend_decl, stmt, type, outer_decl;
   locus old_loc = gfc_current_locus;
   const char *iname;
   gfc_try t;
 
   decl = OMP_CLAUSE_DECL (c);
   gfc_current_locus = where;
+  type = TREE_TYPE (decl);
+  outer_decl = create_tmp_var_raw (type, NULL);
+  if (TREE_CODE (decl) == PARM_DECL
+      && TREE_CODE (type) == REFERENCE_TYPE
+      && GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (type))
+      && GFC_TYPE_ARRAY_AKIND (TREE_TYPE (type)) == GFC_ARRAY_ALLOCATABLE)
+    {
+      decl = build_fold_indirect_ref (decl);
+      type = TREE_TYPE (type);
+    }
 
   /* Create a fake symbol for init value.  */
   memset (&init_val_sym, 0, sizeof (init_val_sym));
@@ -505,7 +515,9 @@
   outer_sym.attr.dummy = 0;
   outer_sym.attr.result = 0;
   outer_sym.attr.flavor = FL_VARIABLE;
-  outer_sym.backend_decl = create_tmp_var_raw (TREE_TYPE (decl), NULL);
+  outer_sym.backend_decl = outer_decl;
+  if (decl != OMP_CLAUSE_DECL (c))
+    outer_sym.backend_decl = build_fold_indirect_ref (outer_decl);
 
   /* Create fake symtrees for it.  */
   symtree1 = gfc_new_symtree (&root1, sym->name);
@@ -622,12 +634,12 @@
 
   /* Create the init statement list.  */
   pushlevel (0);
-  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (decl))
-      && GFC_TYPE_ARRAY_AKIND (TREE_TYPE (decl)) == GFC_ARRAY_ALLOCATABLE)
+  if (GFC_DESCRIPTOR_TYPE_P (type)
+      && GFC_TYPE_ARRAY_AKIND (type) == GFC_ARRAY_ALLOCATABLE)
     {
       /* If decl is an allocatable array, it needs to be allocated
 	 with the same bounds as the outer var.  */
-      tree type = TREE_TYPE (decl), rank, size, esize, ptr;
+      tree rank, size, esize, ptr;
       stmtblock_t block;
 
       gfc_start_block (&block);
@@ -663,8 +675,8 @@
 
   /* Create the merge statement list.  */
   pushlevel (0);
-  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (decl))
-      && GFC_TYPE_ARRAY_AKIND (TREE_TYPE (decl)) == GFC_ARRAY_ALLOCATABLE)
+  if (GFC_DESCRIPTOR_TYPE_P (type)
+      && GFC_TYPE_ARRAY_AKIND (type) == GFC_ARRAY_ALLOCATABLE)
     {
       /* If decl is an allocatable array, it needs to be deallocated
 	 afterwards.  */
@@ -684,7 +696,7 @@
   OMP_CLAUSE_REDUCTION_MERGE (c) = stmt;
 
   /* And stick the placeholder VAR_DECL into the clause as well.  */
-  OMP_CLAUSE_REDUCTION_PLACEHOLDER (c) = outer_sym.backend_decl;
+  OMP_CLAUSE_REDUCTION_PLACEHOLDER (c) = outer_decl;
 
   gfc_current_locus = old_loc;
 
Index: gcc/fortran/gfortran.h
===================================================================
--- gcc/fortran/gfortran.h	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/fortran/gfortran.h	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -2483,8 +2483,6 @@
 int gfc_get_ha_symbol (const char *, gfc_symbol **);
 int gfc_get_ha_sym_tree (const char *, gfc_symtree **);
 
-int gfc_symbols_could_alias (gfc_symbol *, gfc_symbol *);
-
 void gfc_undo_symbols (void);
 void gfc_commit_symbols (void);
 void gfc_commit_symbol (gfc_symbol *);
@@ -2577,11 +2575,14 @@
 gfc_expr *gfc_get_parentheses (gfc_expr *);
 
 /* openmp.c */
+struct gfc_omp_saved_state { void *ptrs[2]; int ints[1]; };
 void gfc_free_omp_clauses (gfc_omp_clauses *);
 void gfc_resolve_omp_directive (gfc_code *, gfc_namespace *);
 void gfc_resolve_do_iterator (gfc_code *, gfc_symbol *);
 void gfc_resolve_omp_parallel_blocks (gfc_code *, gfc_namespace *);
 void gfc_resolve_omp_do_blocks (gfc_code *, gfc_namespace *);
+void gfc_omp_save_and_clear_state (struct gfc_omp_saved_state *);
+void gfc_omp_restore_state (struct gfc_omp_saved_state *);
 
 /* expr.c */
 void gfc_free_actual_arglist (gfc_actual_arglist *);
Index: gcc/fortran/error.c
===================================================================
--- gcc/fortran/error.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/fortran/error.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -939,7 +939,7 @@
   buffer_flag = i;
 
   if (flag_fatal_errors)
-    exit (1);
+    exit (FATAL_EXIT_CODE);
 }
 
 
@@ -956,7 +956,7 @@
   error_print (_("Fatal Error:"), _(gmsgid), argp);
   va_end (argp);
 
-  exit (3);
+  exit (FATAL_EXIT_CODE);
 }
 
 
@@ -1019,7 +1019,7 @@
       gfc_increment_error_count();
 
       if (flag_fatal_errors)
-	exit (1);
+	exit (FATAL_EXIT_CODE);
     }
 
   return rc;
Index: gcc/fortran/ChangeLog
===================================================================
--- gcc/fortran/ChangeLog	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/fortran/ChangeLog	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1,3 +1,61 @@
+2011-01-25  Tobias Burnus  <burnus@net-b.de>
+
+	Backport from mainline
+	2011-01-17  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/47331
+	* gfortran.h (struct gfc_omp_saved_state): New type.
+	(gfc_omp_save_and_clear_state, gfc_omp_restore_state): New prototypes.
+	* resolve.c (resolve_global_procedure): Call it around gfc_resolve
+	call.
+	* openmp.c (gfc_omp_save_and_clear_state, gfc_omp_restore_state): New
+	functions.
+
+2011-01-25  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/47448
+	* interface.c (gfc_check_operator_interface): Fix
+	defined-assignment check.
+
+2011-01-21  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/47394
+	* error.c (gfc_error_now, gfc_fatal_error, gfc_error_check):
+	Use defined instead of magic number exit status codes.
+	* scanner.c (include_line, gfc_new_file): Ditto.
+	* gfortranspec.c (lang_specific_driver): Ditto.
+
+2011-01-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline
+	2010-12-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/46874
+	* trans-openmp.c (gfc_trans_omp_array_reduction): Handle allocatable
+	dummy variables.
+
+2011-01-16  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/45777
+	* symbol.c (gfc_symbols_could_alias):  Strip gfc_ prefix,
+	make static and move in front of its only caller, to ...
+	* trans-array.c (symbols_could_alias): ... here.
+	Pass information about pointer and target status as
+	arguments.  Allocatable arrays don't alias anything
+	unless they have the POINTER attribute.
+	(gfc_could_be_alias):  Keep track of pointer and target
+	status when following references.  Also check if typespecs
+	of components match those of other components or symbols.
+	* gfortran.h:  Remove prototype for gfc_symbols_could_alias.
+
+2011-01-02  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from mainline
+	PR fortran/45338
+	* resolve.c (resolve_operator):  Mark function for user-defined
+	operator as referenced.
+
 2010-12-16  Release Manager
 
 	* GCC 4.5.2 released.
Index: gcc/fortran/scanner.c
===================================================================
--- gcc/fortran/scanner.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/fortran/scanner.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1841,7 +1841,7 @@
 
   filename = gfc_widechar_to_char (begin, -1);
   if (load_file (filename, NULL, false) == FAILURE)
-    exit (1);
+    exit (FATAL_EXIT_CODE);
 
   gfc_free (filename);
   return true;
@@ -2045,7 +2045,7 @@
     printf ("%s:%3d %s\n", LOCATION_FILE (line_head->location),
 	    LOCATION_LINE (line_head->location), line_head->line);
 
-  exit (0);
+  exit (SUCCESS_EXIT_CODE);
 #endif
 
   return result;
Index: gcc/fortran/gfortranspec.c
===================================================================
--- gcc/fortran/gfortranspec.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/fortran/gfortranspec.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -375,7 +375,7 @@
 You may redistribute copies of GNU Fortran\n\
 under the terms of the GNU General Public License.\n\
 For more information about these matters, see the file named COPYING\n\n"));
-	  exit (0);
+	  exit (SUCCESS_EXIT_CODE);
 	  break;
 
 	case OPTION_help:
Index: gcc/fortran/resolve.c
===================================================================
--- gcc/fortran/resolve.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/fortran/resolve.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1810,11 +1810,14 @@
       if (!gsym->ns->resolved)
 	{
 	  gfc_dt_list *old_dt_list;
+	  struct gfc_omp_saved_state old_omp_state;
 
 	  /* Stash away derived types so that the backend_decls do not
 	     get mixed up.  */
 	  old_dt_list = gfc_derived_types;
 	  gfc_derived_types = NULL;
+	  /* And stash away openmp state.  */
+	  gfc_omp_save_and_clear_state (&old_omp_state);
 
 	  gfc_resolve (gsym->ns);
 
@@ -1824,6 +1827,8 @@
 
 	  /* Restore the derived types of this namespace.  */
 	  gfc_derived_types = old_dt_list;
+	  /* And openmp state.  */
+	  gfc_omp_restore_state (&old_omp_state);
 	}
 
       /* Make sure that translation for the gsymbol occurs before
@@ -3577,9 +3582,12 @@
 	sprintf (msg, _("Operand of user operator '%s' at %%L is %s"),
 		 e->value.op.uop->name, gfc_typename (&op1->ts));
       else
-	sprintf (msg, _("Operands of user operator '%s' at %%L are %s/%s"),
-		 e->value.op.uop->name, gfc_typename (&op1->ts),
-		 gfc_typename (&op2->ts));
+	{
+	  sprintf (msg, _("Operands of user operator '%s' at %%L are %s/%s"),
+		   e->value.op.uop->name, gfc_typename (&op1->ts),
+		   gfc_typename (&op2->ts));
+	  e->value.op.uop->op->sym->attr.referenced = 1;
+	}
 
       goto bad_op;
 
Index: gcc/regmove.c
===================================================================
--- gcc/regmove.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/regmove.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -513,7 +513,7 @@
   rtx src_reg = XEXP (src, 0);
   int src_no = REGNO (src_reg);
   int dst_no = REGNO (dest);
-  rtx p, set;
+  rtx p, set, set_insn;
   enum machine_mode old_mode;
   basic_block bb = BLOCK_FOR_INSN (insn);
 
@@ -551,6 +551,7 @@
 				 GET_MODE_BITSIZE (GET_MODE (src_reg))))
     return;
 
+  set_insn = p;
   old_mode = GET_MODE (src_reg);
   PUT_MODE (src_reg, GET_MODE (src));
   XEXP (src, 0) = SET_SRC (set);
@@ -583,9 +584,19 @@
     }
   else
     {
-      rtx note = find_reg_note (p, REG_EQUAL, NULL_RTX);
+      rtx note = find_reg_note (set_insn, REG_EQUAL, NULL_RTX);
       if (note)
-	remove_note (p, note);
+	{
+	  if (rtx_equal_p (XEXP (note, 0), XEXP (src, 0)))
+	    {
+	      XEXP (note, 0)
+		= gen_rtx_fmt_e (GET_CODE (src), GET_MODE (src),
+				 XEXP (note, 0));
+	      df_notes_rescan (set_insn);
+	    }
+	  else
+	    remove_note (set_insn, note);
+	}
     }
 }
 
Index: gcc/BASE-VER
===================================================================
--- gcc/BASE-VER	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/BASE-VER	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1 +1 @@
-4.5.2
+4.5.3
Index: gcc/tree-data-ref.c
===================================================================
--- gcc/tree-data-ref.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/tree-data-ref.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -4594,7 +4594,7 @@
     for (e = v->succ; e; e = e->succ_next)
       fprintf (file, " %d", e->dest);
 
-  fprintf (file, ") \n");
+  fprintf (file, ")\n");
   print_gimple_stmt (file, RDGV_STMT (v), 0, TDF_VOPS|TDF_MEMSYMS);
   fprintf (file, ")\n");
 }
@@ -4991,6 +4991,38 @@
   free (bbs);
 }
 
+/* Returns true when the statement at STMT is of the form "A[i] = 0"
+   that contains a data reference on its LHS with a stride of the same
+   size as its unit type.  */
+
+bool
+stmt_with_adjacent_zero_store_dr_p (gimple stmt)
+{
+  tree op0, op1;
+  bool res;
+  struct data_reference *dr;
+
+  if (!stmt
+      || !gimple_vdef (stmt)
+      || !is_gimple_assign (stmt)
+      || !gimple_assign_single_p (stmt)
+      || !(op1 = gimple_assign_rhs1 (stmt))
+      || !(integer_zerop (op1) || real_zerop (op1)))
+    return false;
+
+  dr = XCNEW (struct data_reference);
+  op0 = gimple_assign_lhs (stmt);
+
+  DR_STMT (dr) = stmt;
+  DR_REF (dr) = op0;
+
+  res = dr_analyze_innermost (dr)
+    && stride_of_unit_type_p (DR_STEP (dr), TREE_TYPE (op0));
+
+  free_data_ref (dr);
+  return res;
+}
+
 /* For a data reference REF, return the declaration of its base
    address or NULL_TREE if the base is not determined.  */
 
Index: gcc/tree-data-ref.h
===================================================================
--- gcc/tree-data-ref.h	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/tree-data-ref.h	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -567,7 +567,19 @@
 void remove_similar_memory_refs (VEC (gimple, heap) **);
 bool rdg_defs_used_in_other_loops_p (struct graph *, int);
 bool have_similar_memory_accesses (gimple, gimple);
+bool stmt_with_adjacent_zero_store_dr_p (gimple);
 
+/* Returns true when STRIDE is equal in absolute value to the size of
+   the unit type of TYPE.  */
+
+static inline bool
+stride_of_unit_type_p (tree stride, tree type)
+{
+  return tree_int_cst_equal (fold_unary (ABS_EXPR, TREE_TYPE (stride),
+					 stride),
+			     TYPE_SIZE_UNIT (type));
+}
+
 /* Determines whether RDG vertices V1 and V2 access to similar memory
    locations, in which case they have to be in the same partition.  */
 
Index: gcc/c-typeck.c
===================================================================
--- gcc/c-typeck.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/c-typeck.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -5025,10 +5025,10 @@
     {
       tree ret;
       bool save = in_late_binary_op;
-      if (codel == BOOLEAN_TYPE)
+      if (codel == BOOLEAN_TYPE || codel == COMPLEX_TYPE)
 	in_late_binary_op = true;
       ret = convert_and_check (type, orig_rhs);
-      if (codel == BOOLEAN_TYPE)
+      if (codel == BOOLEAN_TYPE || codel == COMPLEX_TYPE)
 	in_late_binary_op = save;
       return ret;
     }
Index: gcc/cfgexpand.c
===================================================================
--- gcc/cfgexpand.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/cfgexpand.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -2578,7 +2578,7 @@
 	    enum machine_mode opmode = GET_MODE (op0);
 
 	    if (opmode == VOIDmode)
-	      opmode = mode1;
+	      opmode = TYPE_MODE (TREE_TYPE (tem));
 
 	    /* This condition may hold if we're expanding the address
 	       right past the end of an array that turned out not to
@@ -2599,7 +2599,8 @@
 				     ? SIGN_EXTRACT
 				     : ZERO_EXTRACT, mode,
 				     GET_MODE (op0) != VOIDmode
-				     ? GET_MODE (op0) : mode1,
+				     ? GET_MODE (op0)
+				     : TYPE_MODE (TREE_TYPE (tem)),
 				     op0, GEN_INT (bitsize), GEN_INT (bitpos));
       }
 
Index: gcc/graphite.c
===================================================================
--- gcc/graphite.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/graphite.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -210,6 +210,7 @@
       return false;
     }
 
+  scev_reset ();
   recompute_all_dominators ();
   initialize_original_copy_tables ();
   cloog_initialize ();
Index: gcc/tree-ssa-pre.c
===================================================================
--- gcc/tree-ssa-pre.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/tree-ssa-pre.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1701,7 +1701,7 @@
 	    tree result = vn_reference_lookup_pieces (newvuse, ref->set,
 						      ref->type,
 						      newoperands,
-						      &newref, true);
+						      &newref, VN_WALK);
 	    if (newref)
 	      VEC_free (vn_reference_op_s, heap, newoperands);
 
@@ -2558,6 +2558,10 @@
     {
       if (dump_file && (dump_flags & TDF_DETAILS))
 	fprintf (dump_file, "Starting iteration %d\n", num_iterations);
+      /* ???  We need to clear our PHI translation cache here as the
+         ANTIC sets shrink and we restrict valid translations to
+	 those having operands with leaders in ANTIC.  Same below
+	 for PA ANTIC computation.  */
       num_iterations++;
       changed = false;
       for (i = n_basic_blocks - NUM_FIXED_BLOCKS - 1; i >= 0; i--)
@@ -3965,7 +3969,7 @@
 		copy_reference_ops_from_call (stmt, &ops);
 		vn_reference_lookup_pieces (gimple_vuse (stmt), 0,
 					    gimple_expr_type (stmt),
-					    ops, &ref, false);
+					    ops, &ref, VN_NOWALK);
 		VEC_free (vn_reference_op_s, heap, ops);
 		if (!ref)
 		  continue;
@@ -4035,7 +4039,7 @@
 
 		      vn_reference_lookup (gimple_assign_rhs1 (stmt),
 					   gimple_vuse (stmt),
-					   true, &ref);
+					   VN_WALK, &ref);
 		      if (!ref)
 			continue;
 
@@ -4265,7 +4269,7 @@
 	      tree rhs = gimple_assign_rhs1 (stmt);
 	      tree val;
 	      val = vn_reference_lookup (gimple_assign_lhs (stmt),
-					 gimple_vuse (stmt), true, NULL);
+					 gimple_vuse (stmt), VN_WALK, NULL);
 	      if (TREE_CODE (rhs) == SSA_NAME)
 		rhs = VN_INFO (rhs)->valnum;
 	      if (val
Index: gcc/cfgcleanup.c
===================================================================
--- gcc/cfgcleanup.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/cfgcleanup.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -482,15 +482,20 @@
 		  /* When not optimizing, ensure that edges or forwarder
 		     blocks with different locus are not optimized out.  */
 		  int locus = single_succ_edge (target)->goto_locus;
+		  rtx last ;
 
 		  if (locus && goto_locus && !locator_eq (locus, goto_locus))
 		    counter = n_basic_blocks;
 		  else if (locus)
 		    goto_locus = locus;
 
-		  if (INSN_P (BB_END (target)))
+		  last = BB_END (target);
+		  if (DEBUG_INSN_P (last))
+		    last = prev_nondebug_insn (last);
+
+		  if (last && INSN_P (last))
 		    {
-		      locus = INSN_LOCATOR (BB_END (target));
+		      locus = INSN_LOCATOR (last);
 
 		      if (locus && goto_locus
 			  && !locator_eq (locus, goto_locus))
@@ -1923,8 +1928,7 @@
 			}
 		    }
 		  delete_basic_block (b);
-		  if (!(mode & CLEANUP_CFGLAYOUT))
-		    changed = true;
+		  changed = true;
 		  /* Avoid trying to remove ENTRY_BLOCK_PTR.  */
 		  b = (c == ENTRY_BLOCK_PTR ? c->next_bb : c);
 		  continue;
Index: gcc/tree-sra.c
===================================================================
--- gcc/tree-sra.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/tree-sra.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -3413,7 +3413,10 @@
 	  else if (ac2->size != access->size)
 	    return NULL;
 
-	  if (access_precludes_ipa_sra_p (ac2))
+	  if (access_precludes_ipa_sra_p (ac2)
+	      || (ac2->type != access->type
+		  && (TREE_ADDRESSABLE (ac2->type)
+		      || TREE_ADDRESSABLE (access->type))))
 	    return NULL;
 
 	  modification |= ac2->write;
Index: gcc/c-convert.c
===================================================================
--- gcc/c-convert.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/c-convert.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -131,6 +131,32 @@
       goto maybe_fold;
 
     case COMPLEX_TYPE:
+      /* If converting from COMPLEX_TYPE to a different COMPLEX_TYPE
+	 and e is not COMPLEX_EXPR, convert_to_complex uses save_expr,
+	 but for the C FE c_save_expr needs to be called instead.  */
+      if (TREE_CODE (TREE_TYPE (e)) == COMPLEX_TYPE)
+	{
+	  tree subtype = TREE_TYPE (type);
+	  tree elt_type = TREE_TYPE (TREE_TYPE (e));
+
+	  if (TYPE_MAIN_VARIANT (elt_type) != TYPE_MAIN_VARIANT (subtype)
+	      && TREE_CODE (e) != COMPLEX_EXPR)
+	    {
+	      if (in_late_binary_op)
+		e = save_expr (e);
+	      else
+		e = c_save_expr (e);
+	      ret
+		= fold_build2 (COMPLEX_EXPR, type,
+			       convert (subtype,
+					fold_build1 (REALPART_EXPR,
+						     elt_type, e)),
+			       convert (subtype,
+					fold_build1 (IMAGPART_EXPR,
+						     elt_type, e)));
+	      goto maybe_fold;
+	    }
+	}
       ret = convert_to_complex (type, e);
       goto maybe_fold;
 
Index: gcc/tree-ssa-ter.c
===================================================================
--- gcc/tree-ssa-ter.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/tree-ssa-ter.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -416,7 +416,9 @@
     return false;
 
   /* Without alias info we can't move around loads.  */
-  if (gimple_references_memory_p (stmt) && !optimize)
+  if (!optimize
+      && gimple_assign_single_p (stmt)
+      && !is_gimple_val (gimple_assign_rhs1 (stmt)))
     return false;
 
   /* Float expressions must go through memory if float-store is on.  */
Index: gcc/rtl.c
===================================================================
--- gcc/rtl.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/rtl.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -429,7 +429,15 @@
 	case 'n':
 	case 'i':
 	  if (XINT (x, i) != XINT (y, i))
-	    return 0;
+	    {
+#ifndef GENERATOR_FILE
+	      if (((code == ASM_OPERANDS && i == 6)
+		   || (code == ASM_INPUT && i == 1))
+		  && locator_eq (XINT (x, i), XINT (y, i)))
+		break;
+#endif
+	      return 0;
+	    }
 	  break;
 
 	case 'V':
@@ -549,7 +557,15 @@
 	case 'n':
 	case 'i':
 	  if (XINT (x, i) != XINT (y, i))
-	    return 0;
+	    {
+#ifndef GENERATOR_FILE
+	      if (((code == ASM_OPERANDS && i == 6)
+		   || (code == ASM_INPUT && i == 1))
+		  && locator_eq (XINT (x, i), XINT (y, i)))
+		break;
+#endif
+	      return 0;
+	    }
 	  break;
 
 	case 'V':
Index: gcc/graphite-sese-to-poly.c
===================================================================
--- gcc/graphite-sese-to-poly.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/graphite-sese-to-poly.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -715,7 +715,7 @@
       gcc_assert (TREE_CODE (e) == INTEGER_CST);
 
       value_init (val);
-      value_set_si (val, int_cst_value (e));
+      tree_int_to_gmp (e, val);
       add_value_to_dim (l, expr, val);
       value_clear (val);
     }
@@ -729,16 +729,13 @@
 {
   Value val;
   ppl_Coefficient_t coef;
-  int v = int_cst_value (cst);
+  tree type = TREE_TYPE (cst);
 
   value_init (val);
-  value_set_si (val, 0);
 
   /* Necessary to not get "-1 = 2^n - 1". */
-  if (v < 0)
-    value_sub_int (val, val, -v);
-  else
-    value_add_int (val, val, v);
+  mpz_set_double_int (val, double_int_sext (tree_to_double_int (cst),
+					    TYPE_PRECISION (type)), false);
 
   value_multiply (val, val, k);
   ppl_new_Coefficient (&coef);
@@ -816,7 +813,7 @@
 	      Value val;
 	      gcc_assert (host_integerp (TREE_OPERAND (e, 1), 0));
 	      value_init (val);
-	      value_set_si (val, int_cst_value (TREE_OPERAND (e, 1)));
+	      tree_int_to_gmp (TREE_OPERAND (e, 1), val);
 	      value_multiply (val, val, k);
 	      scan_tree_for_params (s, TREE_OPERAND (e, 0), c, val);
 	      value_clear (val);
@@ -831,7 +828,7 @@
 	      Value val;
 	      gcc_assert (host_integerp (TREE_OPERAND (e, 0), 0));
 	      value_init (val);
-	      value_set_si (val, int_cst_value (TREE_OPERAND (e, 0)));
+	      tree_int_to_gmp (TREE_OPERAND (e, 0), val);
 	      value_multiply (val, val, k);
 	      scan_tree_for_params (s, TREE_OPERAND (e, 1), c, val);
 	      value_clear (val);
@@ -1717,10 +1714,13 @@
       /* subscript - low >= 0 */
       if (host_integerp (low, 0))
 	{
+	  tree minus_low;
+
 	  ppl_new_Linear_Expression_with_dimension (&expr, accessp_nb_dims);
 	  ppl_set_coef (expr, subscript, 1);
 
-	  ppl_set_inhomogeneous (expr, -int_cst_value (low));
+	  minus_low = fold_build1 (NEGATE_EXPR, TREE_TYPE (low), low);
+	  ppl_set_inhomogeneous_tree (expr, minus_low);
 
 	  ppl_new_Constraint (&cstr, expr, PPL_CONSTRAINT_TYPE_GREATER_OR_EQUAL);
 	  ppl_Polyhedron_add_constraint (accesses, cstr);
@@ -1740,7 +1740,7 @@
 	  ppl_new_Linear_Expression_with_dimension (&expr, accessp_nb_dims);
 	  ppl_set_coef (expr, subscript, -1);
 
-	  ppl_set_inhomogeneous (expr, int_cst_value (high));
+	  ppl_set_inhomogeneous_tree (expr, high);
 
 	  ppl_new_Constraint (&cstr, expr, PPL_CONSTRAINT_TYPE_GREATER_OR_EQUAL);
 	  ppl_Polyhedron_add_constraint (accesses, cstr);
Index: gcc/config.gcc
===================================================================
--- gcc/config.gcc	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/config.gcc	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1,6 +1,6 @@
 # GCC target-specific configuration file.
 # Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
-# 2008, 2009, 2010 Free Software Foundation, Inc.
+# 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
 
 #This file is part of GCC.
 
Index: gcc/tree-ssa-structalias.c
===================================================================
--- gcc/tree-ssa-structalias.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/tree-ssa-structalias.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -369,7 +369,11 @@
   ret->may_have_pointers = true;
   ret->is_global_var = (t == NULL_TREE);
   if (t && DECL_P (t))
-    ret->is_global_var = is_global_var (t);
+    ret->is_global_var = (is_global_var (t)
+			  /* We have to treat even local register variables
+			     as escape points.  */
+			  || (TREE_CODE (t) == VAR_DECL
+			      && DECL_HARD_REGISTER (t)));
   ret->solution = BITMAP_ALLOC (&pta_obstack);
   ret->oldsolution = BITMAP_ALLOC (&oldpta_obstack);
   ret->next = NULL;
@@ -4305,6 +4309,17 @@
 	    if (!VEC_empty (fieldoff_s, *fieldstack))
 	      pair = VEC_last (fieldoff_s, *fieldstack);
 
+	    if (!pair
+		&& offset + foff != 0)
+	      {
+		pair = VEC_safe_push (fieldoff_s, heap, *fieldstack, NULL);
+		pair->offset = 0;
+		pair->size = offset + foff;
+		pair->has_unknown_size = false;
+		pair->may_have_pointers = false;
+		pair->only_restrict_pointers = false;
+	      }
+
 	    if (!DECL_SIZE (field)
 		|| !host_integerp (DECL_SIZE (field), 1))
 	      has_unknown_size = true;
Index: gcc/gthr-posix.h
===================================================================
--- gcc/gthr-posix.h	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/gthr-posix.h	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1,7 +1,7 @@
 /* Threads compatibility routines for libgcc2 and libobjc.  */
 /* Compile this one with gcc.  */
 /* Copyright (C) 1997, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
-   2008, 2009 Free Software Foundation, Inc.
+   2008, 2009, 2011 Free Software Foundation, Inc.
 
 This file is part of GCC.
 
@@ -250,61 +250,34 @@
    calls in shared flavors of the HP-UX C library.  Most of the stubs
    have no functionality.  The details are described in the "libc cumulative
    patch" for each subversion of HP-UX 11.  There are two special interfaces
-   provided for checking whether an application is linked to a pthread
+   provided for checking whether an application is linked to a shared pthread
    library or not.  However, these interfaces aren't available in early
-   libc versions.  We also can't use pthread_once as some libc versions
-   call the init function.  So, we use pthread_create to check whether it
-   is possible to create a thread or not.  The stub implementation returns
-   the error number ENOSYS.  */
+   libpthread libraries.  We also need a test that works for archive
+   libraries.  We can't use pthread_once as some libc versions call the
+   init function.  We also can't use pthread_create or pthread_attr_init
+   as these create a thread and thereby prevent changing the default stack
+   size.  The function pthread_default_stacksize_np is available in both
+   the archive and shared versions of libpthread.   It can be used to
+   determine the default pthread stack size.  There is a stub in some
+   shared libc versions which returns a zero size if pthreads are not
+   active.  We provide an equivalent stub to handle cases where libc
+   doesn't provide one.  */
 
 #if defined(__hppa__) && defined(__hpux__)
 
-#include <errno.h>
-
 static volatile int __gthread_active = -1;
 
-static void *
-__gthread_start (void *__arg __attribute__((unused)))
-{
-  return NULL;
-}
-
-static void __gthread_active_init (void) __attribute__((noinline));
-static void
-__gthread_active_init (void)
-{
-  static pthread_mutex_t __gthread_active_mutex = PTHREAD_MUTEX_INITIALIZER;
-  pthread_t __t;
-  pthread_attr_t __a;
-  int __result;
-
-  __gthrw_(pthread_mutex_lock) (&__gthread_active_mutex);
-  if (__gthread_active < 0)
-    {
-      __gthrw_(pthread_attr_init) (&__a);
-      __gthrw_(pthread_attr_setdetachstate) (&__a, PTHREAD_CREATE_DETACHED);
-      __result = __gthrw_(pthread_create) (&__t, &__a, __gthread_start, NULL);
-      if (__result != ENOSYS)
-	__gthread_active = 1;
-      else
-	__gthread_active = 0;
-      __gthrw_(pthread_attr_destroy) (&__a);
-    }
-  __gthrw_(pthread_mutex_unlock) (&__gthread_active_mutex);
-}
-
 static inline int
 __gthread_active_p (void)
 {
   /* Avoid reading __gthread_active twice on the main code path.  */
   int __gthread_active_latest_value = __gthread_active;
+  size_t __s;
 
-  /* This test is not protected to avoid taking a lock on the main code
-     path so every update of __gthread_active in a threaded program must
-     be atomic with regard to the result of the test.  */
   if (__builtin_expect (__gthread_active_latest_value < 0, 0))
     {
-      __gthread_active_init ();
+      pthread_default_stacksize_np (0, &__s);
+      __gthread_active = __s ? 1 : 0;
       __gthread_active_latest_value = __gthread_active;
     }
 
Index: gcc/config/sparc/sparc.md
===================================================================
--- gcc/config/sparc/sparc.md	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/config/sparc/sparc.md	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1106,14 +1106,15 @@
 
 ;; Load in operand 0 the (absolute) address of operand 1, which is a symbolic
 ;; value subject to a PC-relative relocation.  Operand 2 is a helper function
-;; that adds the PC value at the call point to operand 0.
+;; that adds the PC value at the call point to register #(operand 3).
 
 (define_insn "load_pcrel_sym<P:mode>"
   [(set (match_operand:P 0 "register_operand" "=r")
 	(unspec:P [(match_operand:P 1 "symbolic_operand" "")
-		   (match_operand:P 2 "call_address_operand" "")] UNSPEC_LOAD_PCREL_SYM))
+		   (match_operand:P 2 "call_address_operand" "")
+		   (match_operand:P 3 "const_int_operand" "")] UNSPEC_LOAD_PCREL_SYM))
    (clobber (reg:P 15))]
-  ""
+  "REGNO (operands[0]) == INTVAL (operands[3])"
 {
   if (flag_delayed_branch)
     return "sethi\t%%hi(%a1-4), %0\n\tcall\t%a2\n\t add\t%0, %%lo(%a1+4), %0";
Index: gcc/config/sparc/sparc.c
===================================================================
--- gcc/config/sparc/sparc.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/config/sparc/sparc.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -363,7 +363,7 @@
 static int epilogue_renumber (rtx *, int);
 static bool sparc_assemble_integer (rtx, unsigned int, int);
 static int set_extends (rtx);
-static void load_pic_register (void);
+static void load_got_register (void);
 static int save_or_restore_regs (int, int, rtx, int, int);
 static void emit_save_or_restore_regs (int);
 static void sparc_asm_function_prologue (FILE *, HOST_WIDE_INT);
@@ -966,6 +966,36 @@
   return 0;
 }
 
+/* Return true if the address of LABEL can be loaded by means of the
+   mov{si,di}_pic_label_ref patterns in PIC mode.  */
+
+static bool
+can_use_mov_pic_label_ref (rtx label)
+{
+  /* VxWorks does not impose a fixed gap between segments; the run-time
+     gap can be different from the object-file gap.  We therefore can't
+     assume X - _GLOBAL_OFFSET_TABLE_ is a link-time constant unless we
+     are absolutely sure that X is in the same segment as the GOT.
+     Unfortunately, the flexibility of linker scripts means that we
+     can't be sure of that in general, so assume that GOT-relative
+     accesses are never valid on VxWorks.  */
+  if (TARGET_VXWORKS_RTP)
+    return false;
+
+  /* Similarly, if the label is non-local, it might end up being placed
+     in a different section than the current one; now mov_pic_label_ref
+     requires the label and the code to be in the same section.  */
+  if (LABEL_REF_NONLOCAL_P (label))
+    return false;
+
+  /* Finally, if we are reordering basic blocks and partition into hot
+     and cold sections, this might happen for any label.  */
+  if (flag_reorder_blocks_and_partition)
+    return false;
+
+  return true;
+}
+
 /* Expand a move instruction.  Return true if all work is done.  */
 
 bool
@@ -1000,14 +1030,9 @@
       if (pic_address_needs_scratch (operands[1]))
 	operands[1] = legitimize_pic_address (operands[1], NULL_RTX);
 
-      /* VxWorks does not impose a fixed gap between segments; the run-time
-	 gap can be different from the object-file gap.  We therefore can't
-	 assume X - _GLOBAL_OFFSET_TABLE_ is a link-time constant unless we
-	 are absolutely sure that X is in the same segment as the GOT.
-	 Unfortunately, the flexibility of linker scripts means that we
-	 can't be sure of that in general, so assume that _G_O_T_-relative
-	 accesses are never valid on VxWorks.  */
-      if (GET_CODE (operands[1]) == LABEL_REF && !TARGET_VXWORKS_RTP)
+      /* We cannot use the mov{si,di}_pic_label_ref patterns in all cases.  */
+      if (GET_CODE (operands[1]) == LABEL_REF
+	  && can_use_mov_pic_label_ref (operands[1]))
 	{
 	  if (mode == SImode)
 	    {
@@ -2907,26 +2932,39 @@
     }
 }
 
-/* PIC support.  */
-static GTY(()) bool pic_helper_needed = false;
-static GTY(()) rtx pic_helper_symbol;
-static GTY(()) rtx global_offset_table;
+/* Global Offset Table support.  */
+static GTY(()) rtx got_helper_rtx = NULL_RTX;
+static GTY(()) rtx global_offset_table_rtx = NULL_RTX;
 
+/* Return the SYMBOL_REF for the Global Offset Table.  */
+
+static GTY(()) rtx sparc_got_symbol = NULL_RTX;
+
+static rtx
+sparc_got (void)
+{
+  if (!sparc_got_symbol)
+    sparc_got_symbol = gen_rtx_SYMBOL_REF (Pmode, "_GLOBAL_OFFSET_TABLE_");
+
+  return sparc_got_symbol;
+}
+
 /* Ensure that we are not using patterns that are not OK with PIC.  */
 
 int
 check_pic (int i)
 {
+  rtx op;
+
   switch (flag_pic)
     {
     case 1:
-      gcc_assert (GET_CODE (recog_data.operand[i]) != SYMBOL_REF
-	  	  && (GET_CODE (recog_data.operand[i]) != CONST
-	          || (GET_CODE (XEXP (recog_data.operand[i], 0)) == MINUS
-		      && (XEXP (XEXP (recog_data.operand[i], 0), 0)
-			  == global_offset_table)
-		      && (GET_CODE (XEXP (XEXP (recog_data.operand[i], 0), 1))
-			  == CONST))));
+      op = recog_data.operand[i];
+      gcc_assert (GET_CODE (op) != SYMBOL_REF
+	  	  && (GET_CODE (op) != CONST
+		      || (GET_CODE (XEXP (op, 0)) == MINUS
+			  && XEXP (XEXP (op, 0), 0) == sparc_got ()
+			  && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST)));
     case 2:
     default:
       return 1;
@@ -3161,9 +3199,9 @@
   return 1;
 }
 
-/* Construct the SYMBOL_REF for the tls_get_offset function.  */
+/* Return the SYMBOL_REF for the tls_get_addr function.  */
 
-static GTY(()) rtx sparc_tls_symbol;
+static GTY(()) rtx sparc_tls_symbol = NULL_RTX;
 
 static rtx
 sparc_tls_get_addr (void)
@@ -3174,21 +3212,28 @@
   return sparc_tls_symbol;
 }
 
+/* Return the Global Offset Table to be used in TLS mode.  */
+
 static rtx
 sparc_tls_got (void)
 {
-  rtx temp;
+  /* In PIC mode, this is just the PIC offset table.  */
   if (flag_pic)
     {
       crtl->uses_pic_offset_table = 1;
       return pic_offset_table_rtx;
     }
 
-  if (!global_offset_table)
-    global_offset_table = gen_rtx_SYMBOL_REF (Pmode, "_GLOBAL_OFFSET_TABLE_");
-  temp = gen_reg_rtx (Pmode);
-  emit_move_insn (temp, global_offset_table);
-  return temp;
+  /* In non-PIC mode, Sun as (unlike GNU as) emits PC-relative relocations for
+     the GOT symbol with the 32-bit ABI, so we reload the GOT register.  */
+  if (TARGET_SUN_TLS && TARGET_ARCH32)
+    {
+      load_got_register ();
+      return global_offset_table_rtx;
+    }
+
+  /* In all other cases, we load a new pseudo with the GOT symbol.  */
+  return copy_to_reg (sparc_got ());
 }
 
 /* Return true if X contains a thread-local symbol.  */
@@ -3369,7 +3414,7 @@
 
   if (GET_CODE (orig) == SYMBOL_REF
       /* See the comment in sparc_expand_move.  */
-      || (TARGET_VXWORKS_RTP && GET_CODE (orig) == LABEL_REF))
+      || (GET_CODE (orig) == LABEL_REF && !can_use_mov_pic_label_ref (orig)))
     {
       rtx pic_ref, address;
       rtx insn;
@@ -3420,11 +3465,13 @@
 	}
       else
 	{
-	  pic_ref = gen_const_mem (Pmode,
-				   gen_rtx_PLUS (Pmode,
-						 pic_offset_table_rtx, address));
+	  pic_ref
+	    = gen_const_mem (Pmode,
+			     gen_rtx_PLUS (Pmode,
+					   pic_offset_table_rtx, address));
 	  insn = emit_move_insn (reg, pic_ref);
 	}
+
       /* Put a REG_EQUAL note on this insn, so that it can be optimized
 	 by loop.  */
       set_unique_reg_note (insn, REG_EQUAL, orig);
@@ -3462,9 +3509,8 @@
       return gen_rtx_PLUS (Pmode, base, offset);
     }
   else if (GET_CODE (orig) == LABEL_REF)
-    /* ??? Why do we do this?  */
-    /* Now movsi_pic_label_ref uses it, but we ought to be checking that
-       the register is live instead, in case it is eliminated.  */
+    /* ??? We ought to be checking that the register is live instead, in case
+       it is eliminated.  */
     crtl->uses_pic_offset_table = 1;
 
   return orig;
@@ -3529,59 +3575,69 @@
 static void
 get_pc_thunk_name (char name[32], unsigned int regno)
 {
-  const char *pic_name = reg_names[regno];
+  const char *reg_name = reg_names[regno];
 
   /* Skip the leading '%' as that cannot be used in a
      symbol name.  */
-  pic_name += 1;
+  reg_name += 1;
 
   if (USE_HIDDEN_LINKONCE)
-    sprintf (name, "__sparc_get_pc_thunk.%s", pic_name);
+    sprintf (name, "__sparc_get_pc_thunk.%s", reg_name);
   else
     ASM_GENERATE_INTERNAL_LABEL (name, "LADDPC", regno);
 }
 
-/* Emit code to load the PIC register.  */
+/* Wrapper around the load_pcrel_sym{si,di} patterns.  */
 
-static void
-load_pic_register (void)
+static rtx
+gen_load_pcrel_sym (rtx op0, rtx op1, rtx op2, rtx op3)
 {
   int orig_flag_pic = flag_pic;
+  rtx insn;
 
-  if (TARGET_VXWORKS_RTP)
-    {
-      emit_insn (gen_vxworks_load_got ());
-      emit_use (pic_offset_table_rtx);
-      return;
-    }
+  /* The load_pcrel_sym{si,di} patterns require absolute addressing.  */
+  flag_pic = 0;
+  if (TARGET_ARCH64)
+    insn = gen_load_pcrel_symdi (op0, op1, op2, op3);
+  else
+    insn = gen_load_pcrel_symsi (op0, op1, op2, op3);
+  flag_pic = orig_flag_pic;
 
-  /* If we haven't initialized the special PIC symbols, do so now.  */
-  if (!pic_helper_needed)
-    {
-      char name[32];
+  return insn;
+}
 
-      pic_helper_needed = true;
+/* Emit code to load the GOT register.  */
 
-      get_pc_thunk_name (name, REGNO (pic_offset_table_rtx));
-      pic_helper_symbol = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (name));
+static void
+load_got_register (void)
+{
+  /* In PIC mode, this will retrieve pic_offset_table_rtx.  */
+  if (!global_offset_table_rtx)
+    global_offset_table_rtx = gen_rtx_REG (Pmode, GLOBAL_OFFSET_TABLE_REGNUM);
 
-      global_offset_table = gen_rtx_SYMBOL_REF (Pmode, "_GLOBAL_OFFSET_TABLE_");
+  if (TARGET_VXWORKS_RTP)
+    emit_insn (gen_vxworks_load_got ());
+  else
+    {
+      /* The GOT symbol is subject to a PC-relative relocation so we need a
+	 helper function to add the PC value and thus get the final value.  */
+      if (!got_helper_rtx)
+	{
+	  char name[32];
+	  get_pc_thunk_name (name, GLOBAL_OFFSET_TABLE_REGNUM);
+	  got_helper_rtx = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (name));
+	}
+
+      emit_insn (gen_load_pcrel_sym (global_offset_table_rtx, sparc_got (),
+				     got_helper_rtx,
+				     GEN_INT (GLOBAL_OFFSET_TABLE_REGNUM)));
     }
 
-  flag_pic = 0;
-  if (TARGET_ARCH64)
-    emit_insn (gen_load_pcrel_symdi (pic_offset_table_rtx, global_offset_table,
-				     pic_helper_symbol));
-  else
-    emit_insn (gen_load_pcrel_symsi (pic_offset_table_rtx, global_offset_table,
-				     pic_helper_symbol));
-  flag_pic = orig_flag_pic;
-
   /* Need to emit this whether or not we obey regdecls,
      since setjmp/longjmp can cause life info to screw up.
      ??? In the case where we don't obey regdecls, this is not sufficient
      since we may not fall out the bottom.  */
-  emit_use (pic_offset_table_rtx);
+  emit_use (global_offset_table_rtx);
 }
 
 /* Emit a call instruction with the pattern given by PAT.  ADDR is the
@@ -4113,7 +4169,7 @@
 
 /* Expand the function prologue.  The prologue is responsible for reserving
    storage for the frame, saving the call-saved registers and loading the
-   PIC register if needed.  */
+   GOT register if needed.  */
 
 void
 sparc_expand_prologue (void)
@@ -4215,9 +4271,9 @@
   if (num_gfregs)
     emit_save_or_restore_regs (SORR_SAVE);
 
-  /* Load the PIC register if needed.  */
-  if (flag_pic && crtl->uses_pic_offset_table)
-    load_pic_register ();
+  /* Load the GOT register if needed.  */
+  if (crtl->uses_pic_offset_table)
+    load_got_register ();
 }
 
 /* This function generates the assembly code for function entry, which boils
@@ -8705,7 +8761,7 @@
 /* Emit the sequence of insns SEQ while preserving the registers REG and REG2.
    This is achieved by means of a manual dynamic stack space allocation in
    the current frame.  We make the assumption that SEQ doesn't contain any
-   function calls, with the possible exception of calls to the PIC helper.  */
+   function calls, with the possible exception of calls to the GOT helper.  */
 
 static void
 emit_and_preserve (rtx seq, rtx reg, rtx reg2)
@@ -8868,20 +8924,19 @@
     {
       /* The hoops we have to jump through in order to generate a sibcall
 	 without using delay slots...  */
-      rtx spill_reg, spill_reg2, seq, scratch = gen_rtx_REG (Pmode, 1);
+      rtx spill_reg, seq, scratch = gen_rtx_REG (Pmode, 1);
 
       if (flag_pic)
         {
 	  spill_reg = gen_rtx_REG (word_mode, 15);  /* %o7 */
-	  spill_reg2 = gen_rtx_REG (word_mode, PIC_OFFSET_TABLE_REGNUM);
 	  start_sequence ();
-	  /* Delay emitting the PIC helper function because it needs to
+	  /* Delay emitting the GOT helper function because it needs to
 	     change the section and we are emitting assembly code.  */
-	  load_pic_register ();  /* clobbers %o7 */
+	  load_got_register ();  /* clobbers %o7 */
 	  scratch = legitimize_pic_address (funexp, scratch);
 	  seq = get_insns ();
 	  end_sequence ();
-	  emit_and_preserve (seq, spill_reg, spill_reg2);
+	  emit_and_preserve (seq, spill_reg, pic_offset_table_rtx);
 	}
       else if (TARGET_ARCH32)
 	{
@@ -9032,17 +9087,15 @@
 static void
 sparc_file_end (void)
 {
-  /* If need to emit the special PIC helper function, do so now.  */
-  if (pic_helper_needed)
+  /* If we need to emit the special GOT helper function, do so now.  */
+  if (got_helper_rtx)
     {
-      unsigned int regno = REGNO (pic_offset_table_rtx);
-      const char *pic_name = reg_names[regno];
-      char name[32];
+      const char *name = XSTR (got_helper_rtx, 0);
+      const char *reg_name = reg_names[GLOBAL_OFFSET_TABLE_REGNUM];
 #ifdef DWARF2_UNWIND_INFO
       bool do_cfi;
 #endif
 
-      get_pc_thunk_name (name, regno);
       if (USE_HIDDEN_LINKONCE)
 	{
 	  tree decl = build_decl (BUILTINS_LOCATION, FUNCTION_DECL,
@@ -9055,7 +9108,9 @@
 	  make_decl_one_only (decl, DECL_ASSEMBLER_NAME (decl));
 	  DECL_VISIBILITY (decl) = VISIBILITY_HIDDEN;
 	  DECL_VISIBILITY_SPECIFIED (decl) = 1;
+	  resolve_unique_section (decl, 0, flag_function_sections);
 	  allocate_struct_function (decl, true);
+	  cfun->is_thunk = 1;
 	  current_function_decl = decl;
 	  init_varasm_status ();
 	  assemble_start_function (decl, name);
@@ -9076,10 +9131,10 @@
 #endif
       if (flag_delayed_branch)
 	fprintf (asm_out_file, "\tjmp\t%%o7+8\n\t add\t%%o7, %s, %s\n",
-		 pic_name, pic_name);
+		 reg_name, reg_name);
       else
 	fprintf (asm_out_file, "\tadd\t%%o7, %s, %s\n\tjmp\t%%o7+8\n\t nop\n",
-		 pic_name, pic_name);
+		 reg_name, reg_name);
 #ifdef DWARF2_UNWIND_INFO
       if (do_cfi)
 	fprintf (asm_out_file, "\t.cfi_endproc\n");
Index: gcc/config/sparc/sparc.h
===================================================================
--- gcc/config/sparc/sparc.h	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/config/sparc/sparc.h	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -964,10 +964,15 @@
    not be a register used by the prologue.  */
 #define STATIC_CHAIN_REGNUM (TARGET_ARCH64 ? 5 : 2)
 
+/* Register which holds the global offset table, if any.  */
+
+#define GLOBAL_OFFSET_TABLE_REGNUM 23
+
 /* Register which holds offset table for position-independent
    data references.  */
 
-#define PIC_OFFSET_TABLE_REGNUM (flag_pic ? 23 : INVALID_REGNUM)
+#define PIC_OFFSET_TABLE_REGNUM \
+  (flag_pic ? GLOBAL_OFFSET_TABLE_REGNUM : INVALID_REGNUM)
 
 /* Pick a default value we can notice from override_options:
    !v9: Default is on.
Index: gcc/config/rx/rx.h
===================================================================
--- gcc/config/rx/rx.h	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/config/rx/rx.h	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1,5 +1,5 @@
 /* GCC backend definitions for the Renesas RX processor.
-   Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.
+   Copyright (C) 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
    Contributed by Red Hat.
 
    This file is part of GCC.
@@ -25,7 +25,10 @@
       builtin_define ("__RX__"); 		\
       builtin_assert ("cpu=RX"); 		\
       if (rx_cpu_type == RX610)			\
-        builtin_assert ("machine=RX610");	\
+	{					\
+          builtin_define ("__RX610__");		\
+          builtin_assert ("machine=RX610");	\
+	}					\
      else					\
         builtin_assert ("machine=RX600");	\
       						\
@@ -144,6 +147,10 @@
 #define SIZE_TYPE			"long unsigned int"
 #undef  PTRDIFF_TYPE
 #define PTRDIFF_TYPE			"long int"
+#undef  WCHAR_TYPE
+#define WCHAR_TYPE			"long int"
+#undef  WCHAR_TYPE_SIZE
+#define WCHAR_TYPE_SIZE			BITS_PER_WORD
 #define POINTERS_EXTEND_UNSIGNED	1
 #define FUNCTION_MODE 			QImode
 #define CASE_VECTOR_MODE		Pmode
@@ -260,6 +267,7 @@
 
 #define LIBCALL_VALUE(MODE)				\
   gen_rtx_REG (((GET_MODE_CLASS (MODE) != MODE_INT	\
+                 || COMPLEX_MODE_P (MODE)		\
 		 || GET_MODE_SIZE (MODE) >= 4)		\
 		? (MODE)				\
 		: SImode),				\
@@ -354,7 +362,7 @@
   {								\
     "r0",  "r1",  "r2",   "r3",   "r4",   "r5",   "r6",   "r7",	\
       "r8",  "r9",  "r10",  "r11",  "r12",  "r13",  "r14",  "r15", "cc"	\
-  };
+  }
 
 #define ADDITIONAL_REGISTER_NAMES	\
 {					\
@@ -616,8 +624,6 @@
 #define PRINT_OPERAND_ADDRESS(FILE, ADDR)	\
   rx_print_operand_address (FILE, ADDR)
 
-extern int rx_float_compare_mode;
-
 /* This is a version of REG_P that also returns TRUE for SUBREGs.  */
 #define RX_REG_P(rtl) (REG_P (rtl) || GET_CODE (rtl) == SUBREG)
 
@@ -655,12 +661,5 @@
 #define REGISTER_MOVE_COST(MODE, FROM, TO)    2
 #define MEMORY_MOVE_COST(MODE, REGCLASS, IN) (2 + memory_move_secondary_cost (MODE, REGCLASS, IN))
   
-#define SELECT_CC_MODE(OP,X,Y)						\
-  (GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT ? CC_ZSmode :		\
-    (GET_CODE (X) == PLUS || GET_CODE (X) == MINUS ? CC_ZSCmode :	\
-    (GET_CODE (X) == ABS ? CC_ZSOmode :					\
-    (GET_CODE (X) == AND || GET_CODE (X) == NOT || GET_CODE (X) == IOR	\
-     || GET_CODE (X) == XOR || GET_CODE (X) == ROTATE			\
-     || GET_CODE (X) == ROTATERT || GET_CODE (X) == ASHIFTRT		\
-     || GET_CODE (X) == LSHIFTRT || GET_CODE (X) == ASHIFT ? CC_ZSmode : \
-     CCmode))))
+#define SELECT_CC_MODE(OP,X,Y)  rx_select_cc_mode ((OP), (X), (Y))
+
Index: gcc/config/rx/predicates.md
===================================================================
--- gcc/config/rx/predicates.md	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/config/rx/predicates.md	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1,5 +1,5 @@
 ;; Predicate definitions for Renesas RX.
-;; Copyright (C) 2008, 2009 Free Software Foundation, Inc.
+;; Copyright (C) 2008, 2009, 2011 Free Software Foundation, Inc.
 ;; Contributed by Red Hat.
 ;;
 ;; This file is part of GCC.
@@ -37,40 +37,29 @@
 ;; Only small integers or a value in a register are permitted.
 
 (define_predicate "rx_shift_operand"
-  (match_code "const_int,reg")
-  {
-    if (CONST_INT_P (op))
-      return IN_RANGE (INTVAL (op), 0, 31);
-    return true;
-  }
+  (ior (match_operand 0 "register_operand")
+       (and (match_code "const_int")
+	    (match_test "IN_RANGE (INTVAL (op), 0, 31)")))
 )
 
 (define_predicate "rx_constshift_operand"
-  (match_code "const_int")
-  {
-    return IN_RANGE (INTVAL (op), 0, 31);
-  }
+  (and (match_code "const_int")
+       (match_test "IN_RANGE (INTVAL (op), 0, 31)"))
 )
 
+(define_predicate "rx_restricted_mem_operand"
+  (and (match_code "mem")
+       (match_test "rx_is_restricted_memory_address (XEXP (op, 0), mode)"))
+)
+
 ;; Check that the operand is suitable as the source operand
 ;; for a logic or arithmeitc instruction.  Registers, integers
 ;; and a restricted subset of memory addresses are allowed.
 
 (define_predicate "rx_source_operand"
-  (match_code "const_int,const_double,const,symbol_ref,label_ref,reg,mem")
-  {
-    if (CONSTANT_P (op))
-      return rx_is_legitimate_constant (op);
-
-    if (! MEM_P (op))
-      return true;
-      
-    /* Do not allow size conversions whilst accessing memory.  */
-    if (GET_MODE (op) != mode)
-      return false;
-
-    return rx_is_restricted_memory_address (XEXP (op, 0), mode);
-  }
+  (ior (match_operand 0 "register_operand")
+       (match_operand 0 "immediate_operand")
+       (match_operand 0 "rx_restricted_mem_operand"))
 )
 
 ;; Check that the operand is suitable as the source operand
@@ -79,16 +68,8 @@
 ;; CONST_INTs are not.
 
 (define_predicate "rx_compare_operand"
-  (match_code "subreg,reg,mem")
-  {
-    if (GET_CODE (op) == SUBREG)
-      return REG_P (XEXP (op, 0));
-    
-    if (! MEM_P (op))
-      return true;
-
-    return rx_is_restricted_memory_address (XEXP (op, 0), mode);
-  }
+  (ior (match_operand 0 "register_operand")
+       (match_operand 0 "rx_restricted_mem_operand"))
 )
 
 ;; Return true if OP is a store multiple operation.  This looks like:
@@ -293,3 +274,24 @@
   element = XVECEXP (op, 0, count - 1);
   return GET_CODE (element) == RETURN;
 })
+
+(define_predicate "label_ref_operand"
+  (match_code "label_ref")
+)
+
+(define_predicate "rx_z_comparison_operator"
+  (match_code "eq,ne")
+)
+
+(define_predicate "rx_zs_comparison_operator"
+  (match_code "eq,ne")
+)
+
+;; GT and LE omitted due to operand swap required.
+(define_predicate "rx_fp_comparison_operator"
+  (match_code "eq,ne,lt,ge,ordered,unordered")
+)
+
+(define_predicate "rshift_operator"
+  (match_code "ashiftrt,lshiftrt")
+)
Index: gcc/config/rx/rx-protos.h
===================================================================
--- gcc/config/rx/rx-protos.h	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/config/rx/rx-protos.h	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1,5 +1,5 @@
 /* Exported function prototypes from the Renesas RX backend.
-   Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.
+   Copyright (C) 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
    Contributed by Red Hat.
 
    This file is part of GCC.
@@ -35,15 +35,17 @@
 extern void             rx_emit_stack_popm (rtx *, bool);
 extern void             rx_emit_stack_pushm (rtx *);
 extern void		rx_expand_epilogue (bool);
-extern bool		rx_expand_insv (rtx *);
 extern const char *	rx_gen_cond_branch_template (rtx, bool);
 extern char *		rx_gen_move_template (rtx *, bool);
 extern bool		rx_is_legitimate_constant (rtx);
 extern bool 		rx_is_mode_dependent_addr (rtx);
 extern bool		rx_is_restricted_memory_address (rtx, Mmode);
+extern bool		rx_match_ccmode (rtx, Mmode);
 extern void		rx_notice_update_cc (rtx body, rtx insn);
 extern void		rx_print_operand (FILE *, rtx, int);
 extern void		rx_print_operand_address (FILE *, rtx);
+extern Mmode		rx_select_cc_mode (enum rtx_code, rtx, rtx);
+extern void		rx_split_cbranch (Mmode, enum rtx_code, rtx, rtx, rtx);
 #endif
 
 #ifdef TREE_CODE
Index: gcc/config/rx/rx.md
===================================================================
--- gcc/config/rx/rx.md	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/config/rx/rx.md	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1,5 +1,5 @@
 ;;  Machine Description for Renesas RX processors
-;;  Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.
+;;  Copyright (C) 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
 ;;  Contributed by Red Hat.
 
 ;; This file is part of GCC.
@@ -19,14 +19,6 @@
 ;; <http://www.gnu.org/licenses/>.
 
 
-;; This code iterator allows all branch instructions to
-;; be generated from a single define_expand template.
-(define_code_iterator most_cond [eq ne gt ge lt le gtu geu ltu leu
-				 unordered ordered ])
-
-;; Likewise, but only the ones that use Z or S.
-(define_code_iterator zs_cond [eq ne gtu geu ltu leu ])
-
 ;; This code iterator is used for sign- and zero- extensions.
 (define_mode_iterator small_int_modes [(HI "") (QI "")])
 
@@ -38,15 +30,6 @@
   [(SF "ALLOW_RX_FPU_INSNS") (SI "") (HI "") (QI "")])
 
 
-;; Used to map RX condition names to GCC
-;; condition names for builtin instructions.
-(define_code_iterator gcc_conds [eq ne gt ge lt le gtu geu ltu leu
-				unge unlt uneq ltgt])
-(define_code_attr rx_conds [(eq "eq") (ne "ne") (gt "gt") (ge "ge") (lt "lt")
-			    (le "le") (gtu "gtu") (geu "geu") (ltu "ltu")
-			    (leu "leu") (unge "pz") (unlt "n") (uneq "o")
-			    (ltgt "no")])
-
 (define_constants
   [
    (SP_REG 0)
@@ -58,6 +41,7 @@
    (UNSPEC_RTE             10)
    (UNSPEC_RTFI            11)
    (UNSPEC_NAKED           12)
+   (UNSPEC_CONST           13)
    
    (UNSPEC_MOVSTR          20)
    (UNSPEC_MOVMEM          21)
@@ -150,6 +134,8 @@
 (define_insn_reservation "throughput_18_latency_18"  1
   (eq_attr "timings" "1818") "throughput*18")
 
+;; ----------------------------------------------------------------------------
+
 ;; Comparisons
 
 ;; Note - we do not specify the two instructions necessary to perform
@@ -160,254 +146,164 @@
 
 (define_expand "cbranchsi4"
   [(set (pc)
-	(if_then_else (match_operator 0 "comparison_operator"
-				      [(match_operand:SI 1 "register_operand")
-				       (match_operand:SI 2 "rx_source_operand")])
-		      (label_ref (match_operand 3 ""))
-		      (pc)))
-   ]
+	(if_then_else
+	  (match_operator 0 "comparison_operator"
+	    [(match_operand:SI 1 "register_operand")
+	     (match_operand:SI 2 "rx_source_operand")])
+	  (label_ref (match_operand 3 ""))
+	  (pc)))]
   ""
-  ""
 )
 
-(define_insn_and_split "*cbranchsi4_<code>"
+(define_insn_and_split "*cbranchsi4"
   [(set (pc)
-	(if_then_else (most_cond (match_operand:SI  0 "register_operand"  "r")
-				    (match_operand:SI  1 "rx_source_operand" "riQ"))
-		      (label_ref (match_operand        2 "" ""))
-		      (pc)))
-   ]
+	(if_then_else
+	  (match_operator 3 "comparison_operator"
+	    [(match_operand:SI  0 "register_operand"  "r")
+	     (match_operand:SI  1 "rx_source_operand" "riQ")])
+	  (match_operand        2 "label_ref_operand" "")
+	  (pc)))]
   ""
   "#"
   "reload_completed"
   [(const_int 0)]
-  "
-  /* We contstruct the split by hand as otherwise the JUMP_LABEL
-     attribute is not set correctly on the jump insn.  */
-  emit_insn (gen_cmpsi (operands[0], operands[1]));
-  
-  emit_jump_insn (gen_conditional_branch (operands[2],
-  		 gen_rtx_fmt_ee (<most_cond:CODE>, CCmode,
-				 gen_rtx_REG (CCmode, CC_REG), const0_rtx)));
-  "
+{
+  rx_split_cbranch (CCmode, GET_CODE (operands[3]),
+		    operands[0], operands[1], operands[2]);
+  DONE;
+})
+
+(define_insn "*cmpsi"
+  [(set (reg:CC CC_REG)
+	(compare:CC (match_operand:SI 0 "register_operand"  "r,r,r,r,r,r,r")
+		    (match_operand:SI 1 "rx_source_operand" "r,Uint04,Int08,Sint16,Sint24,i,Q")))]
+  "reload_completed"
+  "cmp\t%Q1, %0"
+  [(set_attr "timings" "11,11,11,11,11,11,33")
+   (set_attr "length"  "2,2,3,4,5,6,5")]
 )
 
-;; -----------------------------------------------------------------------------
-;; These two are the canonical TST/branch insns.  However, GCC
-;; generates a wide variety of tst-like patterns, we catch those
-;; below.
-(define_insn_and_split "*tstbranchsi4_<code>"
+;; Canonical method for representing TST.
+(define_insn_and_split "*cbranchsi4_tst"
   [(set (pc)
-	(if_then_else (zs_cond (and:SI (match_operand:SI  0 "register_operand"  "r")
-				       (match_operand:SI  1 "rx_source_operand" "riQ"))
-			       (const_int 0))
-		      (label_ref (match_operand 2 "" ""))
-		      (pc)))
-   ]
+	(if_then_else
+	  (match_operator 3 "rx_zs_comparison_operator"
+	    [(and:SI (match_operand:SI  0 "register_operand"  "r")
+		     (match_operand:SI  1 "rx_source_operand" "riQ"))
+	     (const_int 0)])
+	  (match_operand 2 "label_ref_operand" "")
+	  (pc)))]
   ""
   "#"
   "reload_completed"
   [(const_int 0)]
-  "
-  emit_insn (gen_tstsi (operands[0], operands[1]));
-  
-  emit_jump_insn (gen_conditional_branch (operands[2],
-  		 gen_rtx_fmt_ee (<zs_cond:CODE>, CCmode,
-				 gen_rtx_REG (CCmode, CC_REG), const0_rtx)));
-  "
-)
+{
+  rx_split_cbranch (CC_ZSmode, GET_CODE (operands[3]),
+		    XEXP (operands[3], 0), XEXP (operands[3], 1),
+		    operands[2]);
+  DONE;
+})
 
-;; Inverse of above
-(define_insn_and_split "*tstbranchsi4_<code>"
+;; Various other ways that GCC codes "var & const"
+(define_insn_and_split "*cbranchsi4_tst_ext"
   [(set (pc)
-	(if_then_else (zs_cond (and:SI (match_operand:SI  0 "register_operand"  "r")
-				       (match_operand:SI  1 "rx_source_operand" "riQ"))
-			       (const_int 0))
-		      (pc)
-		      (label_ref (match_operand 2 "" ""))))
-   ]
+	(if_then_else
+	  (match_operator 4 "rx_z_comparison_operator"
+	    [(zero_extract:SI
+		(match_operand:SI 0 "register_operand" "r")
+		(match_operand:SI 1 "rx_constshift_operand" "")
+		(match_operand:SI 2 "rx_constshift_operand" ""))
+	     (const_int 0)])
+	  (match_operand 3 "label_ref_operand" "")
+	  (pc)))]
   ""
   "#"
   "reload_completed"
   [(const_int 0)]
-  "
-  emit_insn (gen_tstsi (operands[0], operands[1]));
-  
-  emit_jump_insn (gen_conditional_branch (operands[2],
-  		 gen_rtx_fmt_ee (reverse_condition (<zs_cond:CODE>), CCmode,
-				 gen_rtx_REG (CCmode, CC_REG), const0_rtx)));
-  "
-)
+{
+  HOST_WIDE_INT mask;
+  rtx x;
 
-;; Various other ways that GCC codes "var & const"
+  mask = 1;
+  mask <<= INTVAL (operands[1]);
+  mask -= 1;
+  mask <<= INTVAL (operands[2]);
+  x = gen_rtx_AND (SImode, operands[0], gen_int_mode (mask, SImode));
 
-(define_insn_and_split "*tstbranchsi4m_eq"
-  [(set (pc)
-	(if_then_else (eq (zero_extract:SI (match_operand:SI  0 "register_operand"  "r")
-					   (match_operand  1 "rx_constshift_operand" "i")
-					   (match_operand  2 "rx_constshift_operand" "i"))
-			  (const_int 0))
-		      (label_ref (match_operand        3 "" ""))
-		      (pc)))
-   ]
-  ""
-  "#"
-  ""
-  [(set (pc)
-	(if_then_else (eq (and:SI (match_dup  0)
-				  (match_dup 4))
-			  (const_int 0))
-		      (label_ref (match_dup 3))
-		      (pc)))
-   ]
-  "operands[4] = GEN_INT (((1 << INTVAL (operands[1]))-1) << INTVAL (operands[2]));"
-)
+  rx_split_cbranch (CC_ZSmode, GET_CODE (operands[4]),
+		    x, const0_rtx, operands[3]);
+  DONE;
+})
 
-(define_insn_and_split "*tstbranchsi4m_ne"
-  [(set (pc)
-	(if_then_else (ne (zero_extract:SI (match_operand:SI  0 "register_operand"  "r")
-					   (match_operand  1 "rx_constshift_operand" "i")
-					   (match_operand  2 "rx_constshift_operand" "i"))
-			  (const_int 0))
-		      (label_ref (match_operand        3 "" ""))
-		      (pc)))
-   ]
-  ""
-  "#"
-  ""
-  [(set (pc)
-	(if_then_else (ne (and:SI (match_dup  0)
-				  (match_dup 4))
-			  (const_int 0))
-		      (label_ref (match_dup 3))
-		      (pc)))
-   ]
-  "operands[4] = GEN_INT (((1 << INTVAL (operands[1]))-1) << INTVAL (operands[2]));"
+(define_insn "*tstsi"
+  [(set (reg:CC_ZS CC_REG)
+	(compare:CC_ZS
+	  (and:SI (match_operand:SI 0 "register_operand"  "r,r,r")
+		  (match_operand:SI 1 "rx_source_operand" "r,i,Q"))
+	  (const_int 0)))]
+  "reload_completed"
+  "tst\t%Q1, %0"
+  [(set_attr "timings" "11,11,33")
+   (set_attr "length"  "3,7,6")]
 )
 
-;; -----------------------------------------------------------------------------
-
 (define_expand "cbranchsf4"
   [(set (pc)
-	(if_then_else (match_operator 0 "comparison_operator"
-				      [(match_operand:SF 1 "register_operand")
-				       (match_operand:SF 2 "rx_source_operand")])
-		      (label_ref (match_operand 3 ""))
-		      (pc)))
-   ]
+	(if_then_else
+	  (match_operator 0 "rx_fp_comparison_operator"
+	    [(match_operand:SF 1 "register_operand")
+	     (match_operand:SF 2 "rx_source_operand")])
+	  (label_ref (match_operand 3 ""))
+	  (pc)))]
   "ALLOW_RX_FPU_INSNS"
-  ""
 )
 
-(define_insn_and_split "*cbranchsf4_<code>"
+(define_insn_and_split "*cbranchsf4"
   [(set (pc)
-	(if_then_else (most_cond (match_operand:SF  0 "register_operand"  "r")
-				 (match_operand:SF  1 "rx_source_operand" "rFiQ"))
-		      (label_ref (match_operand        2 "" ""))
-		      (pc)))
-   ]
+	(if_then_else
+	  (match_operator 3 "rx_fp_comparison_operator"
+	    [(match_operand:SF  0 "register_operand"  "r")
+	     (match_operand:SF  1 "rx_source_operand" "rFQ")])
+	  (match_operand        2 "label_ref_operand" "")
+	  (pc)))]
   "ALLOW_RX_FPU_INSNS"
   "#"
   "&& reload_completed"
   [(const_int 0)]
-  "
-  /* We contstruct the split by hand as otherwise the JUMP_LABEL
-     attribute is not set correctly on the jump insn.  */
-  emit_insn (gen_cmpsf (operands[0], operands[1]));
-  
-  emit_jump_insn (gen_conditional_branch (operands[2],
-  		 gen_rtx_fmt_ee (<most_cond:CODE>, CCmode,
- 		 		 gen_rtx_REG (CCmode, CC_REG), const0_rtx)));
-  "
-)
+{
+  rx_split_cbranch (CC_Fmode, GET_CODE (operands[3]),
+		    operands[0], operands[1], operands[2]);
+  DONE;
+})
 
-(define_insn "tstsi"
-  [(set (reg:CC_ZS CC_REG)
-	(compare:CC_ZS (and:SI (match_operand:SI 0 "register_operand"  "r,r,r")
-			       (match_operand:SI 1 "rx_source_operand" "r,i,Q"))
-		       (const_int 0)))]
-  ""
-  {
-    rx_float_compare_mode = false;
-    return "tst\t%Q1, %0";
-  }
+(define_insn "*cmpsf"
+  [(set (reg:CC_F CC_REG)
+	(compare:CC_F
+	  (match_operand:SF 0 "register_operand"  "r,r,r")
+	  (match_operand:SF 1 "rx_source_operand" "r,F,Q")))]
+  "ALLOW_RX_FPU_INSNS && reload_completed"
+  "fcmp\t%1, %0"
   [(set_attr "timings" "11,11,33")
-   (set_attr "length"   "3,7,6")]
-)
-
-(define_insn "cmpsi"
-  [(set (reg:CC CC_REG)
-	(compare:CC (match_operand:SI 0 "register_operand"  "r,r,r,r,r,r,r")
-		    (match_operand:SI 1 "rx_source_operand" "r,Uint04,Int08,Sint16,Sint24,i,Q")))]
-  ""
-  {
-    rx_float_compare_mode = false;
-    if (rx_compare_redundant (insn))
-      return "; Compare Eliminated: cmp %Q1, %0";
-    return "cmp\t%Q1, %0";
-  }
-  [(set_attr "timings" "11,11,11,11,11,11,33")
-   (set_attr "length"  "2,2,3,4,5,6,5")]
-)
-
-;; This pattern is disabled when -fnon-call-exceptions is active because
-;; it could generate a floating point exception, which would introduce an
-;; edge into the flow graph between this insn and the conditional branch
-;; insn to follow, thus breaking the cc0 relationship.  Run the g++ test
-;; g++.dg/eh/080514-1.C to see this happen.
-(define_insn "cmpsf"
-  [(set (reg:CC_ZSO CC_REG)
-	(compare:CC_ZSO (match_operand:SF 0 "register_operand"  "r,r,r")
-			(match_operand:SF 1 "rx_source_operand" "r,iF,Q")))]
-  "ALLOW_RX_FPU_INSNS"
-  {
-    rx_float_compare_mode = true;
-    return "fcmp\t%1, %0";
-  }
-  [(set_attr "timings" "11,11,33")
    (set_attr "length" "3,7,5")]
 )
 
 ;; Flow Control Instructions:
 
-(define_expand "b<code>"
+(define_insn "*conditional_branch"
   [(set (pc)
-        (if_then_else (most_cond (reg:CC CC_REG) (const_int 0))
-                      (label_ref (match_operand 0))
-                      (pc)))]
-  ""
-  ""
-)
-
-(define_insn "conditional_branch"
-  [(set (pc)
-	(if_then_else (match_operator           1 "comparison_operator"
-						[(reg:CC CC_REG) (const_int 0)])
-		      (label_ref (match_operand 0 "" ""))
-		      (pc)))]
-  ""
-  {
-    return rx_gen_cond_branch_template (operands[1], false);
-  }
+	(if_then_else
+	  (match_operator 1 "comparison_operator"
+	    [(reg CC_REG) (const_int 0)])
+	  (label_ref (match_operand 0 "" ""))
+	  (pc)))]
+  "reload_completed"
+  "b%B1\t%0"
   [(set_attr "length" "8")    ;; This length is wrong, but it is
                               ;; too hard to compute statically.
    (set_attr "timings" "33")] ;; The timing assumes that the branch is taken.
 )
 
-(define_insn "*reveresed_conditional_branch"
-  [(set (pc)
-	(if_then_else (match_operator 1 "comparison_operator"
-				      [(reg:CC CC_REG) (const_int 0)])
-		      (pc)
-		      (label_ref (match_operand 0 "" ""))))]
-  ""
-  {
-    return rx_gen_cond_branch_template (operands[1], true);
-  }
-  [(set_attr "length" "8")    ;; This length is wrong, but it is
-                              ;; too hard to compute statically.
-   (set_attr "timings" "33")] ;; The timing assumes that the branch is taken.
-)
+;; ----------------------------------------------------------------------------
 
 (define_insn "jump"
   [(set (pc)
@@ -448,10 +344,12 @@
    (set_attr "timings" "55")]
 )
 
+;; Unspec used so that the constant will not be invalid
+;; if -mmax-constant-size has been specified.
 (define_insn "deallocate_and_return"
   [(set (reg:SI SP_REG)
 	(plus:SI (reg:SI SP_REG)
-		 (match_operand:SI 0 "immediate_operand" "i")))
+		 (const:SI (unspec:SI [(match_operand 0 "const_int_operand" "n")] UNSPEC_CONST))))
    (return)]
   ""
   "rtsd\t%0"
@@ -461,9 +359,10 @@
 
 (define_insn "pop_and_return"
   [(match_parallel 1 "rx_rtsd_vector"
-		   [(set:SI (reg:SI SP_REG)
-			    (plus:SI (reg:SI SP_REG)
-				     (match_operand:SI 0 "const_int_operand" "n")))])]
+     [(set (reg:SI SP_REG)
+	   (plus:SI (reg:SI SP_REG)
+		    (match_operand:SI 0 "const_int_operand" "n")))])
+   (return)]
   "reload_completed"
   {
     rx_emit_stack_popm (operands, false);
@@ -513,14 +412,14 @@
 
     if (! rx_call_operand (dest, Pmode))
       dest = force_reg (Pmode, dest);
-    emit_call_insn (gen_call_internal (dest, operands[1]));
+    emit_call_insn (gen_call_internal (dest));
     DONE;
   }
 )
 
 (define_insn "call_internal"
   [(call (mem:QI (match_operand:SI 0 "rx_call_operand" "r,Symbol"))
-	 (match_operand:SI         1 "general_operand" "g,g"))
+	 (const_int 0))
    (clobber (reg:CC CC_REG))]
   ""
   "@
@@ -540,7 +439,7 @@
 
     if (! rx_call_operand (dest, Pmode))
       dest = force_reg (Pmode, dest);
-    emit_call_insn (gen_call_value_internal (operands[0], dest, operands[2]));
+    emit_call_insn (gen_call_value_internal (operands[0], dest));
     DONE;
   }
 )
@@ -548,7 +447,7 @@
 (define_insn "call_value_internal"
   [(set (match_operand                  0 "register_operand" "=r,r")
 	(call (mem:QI (match_operand:SI 1 "rx_call_operand"   "r,Symbol"))
-	      (match_operand:SI         2 "general_operand"   "g,g")))
+	      (const_int 0)))
    (clobber (reg:CC CC_REG))]
   ""
   "@
@@ -572,12 +471,14 @@
   {
     if (MEM_P (operands[0]))
       operands[0] = XEXP (operands[0], 0);
+    emit_call_insn (gen_sibcall_internal (operands[0]));
+    DONE;
   }
 )
 
 (define_insn "sibcall_internal"
   [(call (mem:QI (match_operand:SI 0 "rx_symbolic_call_operand" "Symbol"))
-	 (match_operand:SI         1 "general_operand"          "g"))
+	 (const_int 0))
    (return)]
   ""
   "bra\t%A0"
@@ -595,13 +496,15 @@
   {
     if (MEM_P (operands[1]))
       operands[1] = XEXP (operands[1], 0);
+    emit_call_insn (gen_sibcall_value_internal (operands[0], operands[1]));
+    DONE;
   }
 )
 
 (define_insn "sibcall_value_internal"
  [(set (match_operand                  0 "register_operand"         "=r")
        (call (mem:QI (match_operand:SI 1 "rx_symbolic_call_operand" "Symbol"))
-	     (match_operand:SI         2 "general_operand"          "g")))
+	     (const_int 0)))
   (return)]
   ""
   "bra\t%A1"
@@ -653,6 +556,9 @@
   {
     if (MEM_P (operand0) && MEM_P (operand1))
       operands[1] = copy_to_mode_reg (<register_modes:MODE>mode, operand1);
+    if (CONST_INT_P (operand1)
+        && ! rx_is_legitimate_constant (operand1))
+      FAIL;
   }
 )
 
@@ -688,11 +594,11 @@
 )
 
 (define_insn "stack_push"
-  [(set:SI (reg:SI SP_REG)
-	   (minus:SI (reg:SI SP_REG)
-		     (const_int 4)))
-   (set:SI (mem:SI (reg:SI SP_REG))
-	   (match_operand:SI 0 "register_operand" "r"))]
+  [(set (reg:SI SP_REG)
+	(minus:SI (reg:SI SP_REG)
+		  (const_int 4)))
+   (set (mem:SI (reg:SI SP_REG))
+	(match_operand:SI 0 "register_operand" "r"))]
   ""
   "push.l\t%0"
   [(set_attr "length" "2")]
@@ -700,9 +606,9 @@
 
 (define_insn "stack_pushm"
   [(match_parallel 1 "rx_store_multiple_vector"
-		   [(set:SI (reg:SI SP_REG)
-			    (minus:SI (reg:SI SP_REG)
-				      (match_operand:SI 0 "const_int_operand" "n")))])]
+     [(set (reg:SI SP_REG)
+	   (minus:SI (reg:SI SP_REG)
+		     (match_operand:SI 0 "const_int_operand" "n")))])]
   "reload_completed"
   {
     rx_emit_stack_pushm (operands);
@@ -713,11 +619,11 @@
 )
 
 (define_insn "stack_pop"
-  [(set:SI (match_operand:SI 0 "register_operand" "=r")
-	   (mem:SI (reg:SI SP_REG)))
-   (set:SI (reg:SI SP_REG)
-	   (plus:SI (reg:SI SP_REG)
-		    (const_int 4)))]
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(mem:SI (reg:SI SP_REG)))
+   (set (reg:SI SP_REG)
+	(plus:SI (reg:SI SP_REG)
+		 (const_int 4)))]
   ""
   "pop\t%0"
   [(set_attr "length" "2")
@@ -726,9 +632,9 @@
 
 (define_insn "stack_popm"
   [(match_parallel 1 "rx_load_multiple_vector"
-		   [(set:SI (reg:SI SP_REG)
-			    (plus:SI (reg:SI SP_REG)
-				     (match_operand:SI 0 "const_int_operand" "n")))])]
+     [(set (reg:SI SP_REG)
+	   (plus:SI (reg:SI SP_REG)
+		    (match_operand:SI 0 "const_int_operand" "n")))])]
   "reload_completed"
   {
     rx_emit_stack_popm (operands, true);
@@ -738,68 +644,139 @@
    (set_attr "timings" "45")] ;; The timing is a guesstimate average timing.
 )
 
-;; FIXME: Add memory destination options ?
-(define_insn "cstoresi4"
-  [(set (match_operand:SI   0 "register_operand" "=r,r,r,r,r,r,r")
+(define_insn_and_split "cstoresi4"
+  [(set (match_operand:SI   0 "register_operand" "=r")
 	(match_operator:SI  1 "comparison_operator"
-	 [(match_operand:SI 2 "register_operand"  "r,r,r,r,r,r,r")
-	  (match_operand:SI 3 "rx_source_operand" "r,Uint04,Int08,Sint16,Sint24,i,Q")]))
-   (clobber (reg:CC CC_REG))] ;; Because the cc flags are set based on comparing ops 2 & 3 not the value in op 0.
+	  [(match_operand:SI 2 "register_operand"  "r")
+	   (match_operand:SI 3 "rx_source_operand" "riQ")]))
+   (clobber (reg:CC CC_REG))]
   ""
-  {
-    rx_float_compare_mode = false;
-    return "cmp\t%Q3, %Q2\n\tsc%B1.L\t%0";
-  }
-  [(set_attr "timings" "22,22,22,22,22,22,44")
-   (set_attr "length"  "5,5,6,7,8,9,8")]
+  "#"
+  "reload_completed"
+  [(const_int 0)]
+{
+  rtx flags, x;
+
+  flags = gen_rtx_REG (CCmode, CC_REG);
+  x = gen_rtx_COMPARE (CCmode, operands[2], operands[3]);
+  x = gen_rtx_SET (VOIDmode, flags, x);
+  emit_insn (x);
+
+  x = gen_rtx_fmt_ee (GET_CODE (operands[1]), SImode, flags, const0_rtx);
+  x = gen_rtx_SET (VOIDmode, operands[0], x);
+  emit_insn (x);
+  DONE;
+})
+
+(define_insn "*sccc"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(match_operator:SI 1 "comparison_operator"
+	  [(reg CC_REG) (const_int 0)]))]
+  "reload_completed"
+  "sc%B1.L\t%0"
+  [(set_attr "length" "3")]
 )
 
+(define_insn_and_split "cstoresf4"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(match_operator:SI 1 "rx_fp_comparison_operator"
+	 [(match_operand:SF 2 "register_operand" "r")
+	  (match_operand:SF 3 "rx_source_operand" "rFQ")]))]
+  "ALLOW_RX_FPU_INSNS"
+  "#"
+  "reload_completed"
+  [(const_int 0)]
+{
+  rtx flags, x;
+
+  flags = gen_rtx_REG (CC_Fmode, CC_REG);
+  x = gen_rtx_COMPARE (CC_Fmode, operands[2], operands[3]);
+  x = gen_rtx_SET (VOIDmode, flags, x);
+  emit_insn (x);
+
+  x = gen_rtx_fmt_ee (GET_CODE (operands[1]), SImode, flags, const0_rtx);
+  x = gen_rtx_SET (VOIDmode, operands[0], x);
+  emit_insn (x);
+  DONE;
+})
+
 (define_expand "movsicc"
   [(parallel
     [(set (match_operand:SI                  0 "register_operand")
 	  (if_then_else:SI (match_operand:SI 1 "comparison_operator")
 			   (match_operand:SI 2 "nonmemory_operand")
-			   (match_operand:SI 3 "immediate_operand")))
-     (clobber (reg:CC CC_REG))])] ;; See cstoresi4
+			   (match_operand:SI 3 "nonmemory_operand")))
+     (clobber (reg:CC CC_REG))])]
   ""
-  {
-    if (GET_CODE (operands[1]) != EQ && GET_CODE (operands[1]) != NE)
-      FAIL;
-    if (! CONST_INT_P (operands[3]))
-      FAIL;
-  }
-)
+{
+  /* ??? Support other conditions via cstore into a temporary?  */
+  if (GET_CODE (operands[1]) != EQ && GET_CODE (operands[1]) != NE)
+    FAIL;
+  /* One operand must be a constant.  */
+  if (!CONSTANT_P (operands[2]) && !CONSTANT_P (operands[3]))
+    FAIL;
+})
 
-(define_insn "*movsieq"
-  [(set (match_operand:SI                      0 "register_operand" "=r,r,r")
-	(if_then_else:SI (eq (match_operand:SI 3 "register_operand"  "r,r,r")
-			     (match_operand:SI 4 "rx_source_operand" "riQ,riQ,riQ"))
-			 (match_operand:SI     1 "nonmemory_operand" "0,i,r")
-			 (match_operand:SI     2 "immediate_operand" "i,i,i")))
-   (clobber (reg:CC CC_REG))] ;; See cstoresi4
-  ""
-  "@
-  cmp\t%Q4, %Q3\n\tstnz\t%2, %0
-  cmp\t%Q4, %Q3\n\tmov.l\t%2, %0\n\tstz\t%1, %0
-  cmp\t%Q4, %Q3\n\tmov.l\t%1, %0\n\tstnz\t%2, %0"
-  [(set_attr "length"  "13,19,15")
-   (set_attr "timings" "22,33,33")]
-)
+(define_insn_and_split "*movsicc"
+  [(set (match_operand:SI     0 "register_operand" "=r,r")
+	(if_then_else:SI
+	  (match_operator 5 "rx_z_comparison_operator"
+	   [(match_operand:SI 3 "register_operand"  "r,r")
+	    (match_operand:SI 4 "rx_source_operand" "riQ,riQ")])
+	  (match_operand:SI   1 "nonmemory_operand" "i,ri")
+	  (match_operand:SI   2 "nonmemory_operand" "ri,i")))
+   (clobber (reg:CC CC_REG))]
+  "CONSTANT_P (operands[1]) || CONSTANT_P (operands[2])"
+  "#"
+  "&& reload_completed"
+  [(const_int 0)]
+{
+  rtx x, flags, op0, op1, op2;
+  enum rtx_code cmp_code;
 
-(define_insn "*movsine"
-  [(set (match_operand:SI                      0 "register_operand" "=r,r,r")
-	(if_then_else:SI (ne (match_operand:SI 3 "register_operand"  "r,r,r")
-			     (match_operand:SI 4 "rx_source_operand" "riQ,riQ,riQ"))
-			 (match_operand:SI     1 "nonmemory_operand" "0,i,r")
-			 (match_operand:SI     2 "immediate_operand" "i,i,i")))
-   (clobber (reg:CC CC_REG))] ;; See cstoresi4
-  ""
-  "@
-  cmp\t%Q4, %Q3\n\tstz\t%2, %0
-  cmp\t%Q4, %Q3\n\tmov.l\t%2, %0\n\tstnz\t%1, %0
-  cmp\t%Q4, %Q3\n\tmov.l\t%1, %0\n\tstz\t%2, %0"
-  [(set_attr "length"  "13,19,15")
-   (set_attr "timings" "22,33,33")]
+  flags = gen_rtx_REG (CCmode, CC_REG);
+  x = gen_rtx_COMPARE (CCmode, operands[3], operands[4]);
+  emit_insn (gen_rtx_SET (VOIDmode, flags, x));
+
+  cmp_code = GET_CODE (operands[5]);
+  op0 = operands[0];
+  op1 = operands[1];
+  op2 = operands[2];
+
+  /* If OP2 is the constant, reverse the sense of the move.  */
+  if (!CONSTANT_P (operands[1]))
+    {
+      x = op1, op1 = op2, op2 = x;
+      cmp_code = reverse_condition (cmp_code);
+    }
+
+  /* If OP2 does not match the output, copy it into place.  We have allowed
+     these alternatives so that the destination can legitimately be one of
+     the comparison operands without increasing register pressure.  */
+  if (!rtx_equal_p (op0, op2))
+    emit_move_insn (op0, op2);
+
+  x = gen_rtx_fmt_ee (cmp_code, VOIDmode, flags, const0_rtx);
+  x = gen_rtx_IF_THEN_ELSE (SImode, x, op1, op0);
+  emit_insn (gen_rtx_SET (VOIDmode, op0, x));
+  DONE;
+})
+
+(define_insn "*stcc"
+  [(set (match_operand:SI 0 "register_operand" "+r,r,r,r")
+	(if_then_else:SI
+	  (match_operator 2 "rx_z_comparison_operator"
+	    [(reg CC_REG) (const_int 0)])
+	  (match_operand:SI 1 "immediate_operand" "Sint08,Sint16,Sint24,i")
+	  (match_dup 0)))]
+  "reload_completed"
+{
+  if (GET_CODE (operands[2]) == EQ)
+    return "stz\t%1, %0";
+  else
+    return "stnz\t%1, %0";
+}
+  [(set_attr "length" "4,5,6,7")]
 )
 
 ;; Arithmetic Instructions
@@ -807,9 +784,7 @@
 (define_insn "abssi2"
   [(set (match_operand:SI         0 "register_operand" "=r,r")
         (abs:SI (match_operand:SI 1 "register_operand"  "0,r")))
-   (set (reg:CC_ZSO CC_REG)
-	(compare:CC_ZSO (abs:SI (match_dup 1))
-			(const_int 0)))]
+   (clobber (reg:CC CC_REG))]
   ""
   "@
   abs\t%0
@@ -817,13 +792,24 @@
   [(set_attr "length" "2,3")]
 )
 
+(define_insn "*abssi2_flags"
+  [(set (match_operand:SI         0 "register_operand" "=r,r")
+        (abs:SI (match_operand:SI 1 "register_operand"  "0,r")))
+   (set (reg CC_REG)
+	(compare (abs:SI (match_dup 1))
+		 (const_int 0)))]
+  "reload_completed && rx_match_ccmode (insn, CC_ZSOmode)"
+  "@
+  abs\t%0
+  abs\t%1, %0"
+  [(set_attr "length" "2,3")]
+)
+
 (define_insn "addsi3"
   [(set (match_operand:SI          0 "register_operand"  "=r,r,r,r,r,r,r,r,r,r,r,r,r,r")
 	(plus:SI (match_operand:SI 1 "register_operand"  "%0,0,0,0,0,0,0,r,r,r,r,r,r,0")
 		 (match_operand:SI 2 "rx_source_operand" "r,Uint04,NEGint4,Sint08,Sint16,Sint24,i,0,r,Sint08,Sint16,Sint24,i,Q")))
-   (set (reg:CC_ZSC CC_REG) ;; See subsi3
-	(compare:CC_ZSC (plus:SI (match_dup 1) (match_dup 2))
-			(const_int 0)))]
+   (clobber (reg:CC CC_REG))]
   ""
   "@
   add\t%2, %0
@@ -844,27 +830,170 @@
    (set_attr "length"   "2,2,2,3,4,5,6,2,3,3,4,5,6,5")]
 )
 
-(define_insn "adddi3"
-  [(set (match_operand:DI          0 "register_operand" "=r,r,r,r,r,r")
-	(plus:DI (match_operand:DI 1 "register_operand" "%0,0,0,0,0,0")
-		 (match_operand:DI 2 "rx_source_operand"
-				   "r,Sint08,Sint16,Sint24,i,Q")))
-   (set (reg:CC_ZSC CC_REG) ;; See subsi3
-	(compare:CC_ZSC (plus:DI (match_dup 1) (match_dup 2))
-			(const_int 0)))]
-  ""
-  "add\t%L2, %L0\n\tadc\t%H2, %H0"
-  [(set_attr "timings" "22,22,22,22,22,44")
-   (set_attr "length" "5,7,9,11,13,11")]
+(define_insn "*addsi3_flags"
+  [(set (match_operand:SI          0 "register_operand"  "=r,r,r,r,r,r,r,r,r,r,r,r,r,r")
+	(plus:SI (match_operand:SI 1 "register_operand"  "%0,0,0,0,0,0,0,r,r,r,r,r,r,0")
+		 (match_operand:SI 2 "rx_source_operand" "r,Uint04,NEGint4,Sint08,Sint16,Sint24,i,0,r,Sint08,Sint16,Sint24,i,Q")))
+   (set (reg CC_REG)
+	(compare (plus:SI (match_dup 1) (match_dup 2))
+		 (const_int 0)))]
+  "reload_completed && rx_match_ccmode (insn, CC_ZSCmode)"
+  "@
+  add\t%2, %0
+  add\t%2, %0
+  sub\t%N2, %0
+  add\t%2, %0
+  add\t%2, %0
+  add\t%2, %0
+  add\t%2, %0
+  add\t%1, %0
+  add\t%2, %1, %0
+  add\t%2, %1, %0
+  add\t%2, %1, %0
+  add\t%2, %1, %0
+  add\t%2, %1, %0
+  add\t%Q2, %0"
+  [(set_attr "timings" "11,11,11,11,11,11,11,11,11,11,11,11,11,33")
+   (set_attr "length"   "2,2,2,3,4,5,6,2,3,3,4,5,6,5")]
 )
 
+;; A helper to expand the above with the CC_MODE filled in.
+(define_expand "addsi3_flags"
+  [(parallel [(set (match_operand:SI 0 "register_operand")
+		   (plus:SI (match_operand:SI 1 "register_operand")
+			    (match_operand:SI 2 "rx_source_operand")))
+	      (set (reg:CC_ZSC CC_REG)
+		   (compare:CC_ZSC (plus:SI (match_dup 1) (match_dup 2))
+				   (const_int 0)))])]
+)
+
+(define_insn "adc_internal"
+  [(set (match_operand:SI     0 "register_operand"  "=r,r,r,r,r,r")
+	(plus:SI
+	  (plus:SI
+	    (ltu:SI (reg:CC CC_REG) (const_int 0))
+	    (match_operand:SI 1 "register_operand"  "%0,0,0,0,0,0"))
+	  (match_operand:SI   2 "rx_source_operand" "r,Sint08,Sint16,Sint24,i,Q")))
+    (clobber (reg:CC CC_REG))]
+  "reload_completed"
+  "adc %2,%0"
+  [(set_attr "timings" "11,11,11,11,11,33")
+   (set_attr "length"   "3,4,5,6,7,6")]
+)
+
+(define_insn "*adc_flags"
+  [(set (match_operand:SI     0 "register_operand"  "=r,r,r,r,r,r")
+	(plus:SI
+	  (plus:SI
+	    (ltu:SI (reg:CC CC_REG) (const_int 0))
+	    (match_operand:SI 1 "register_operand"  "%0,0,0,0,0,0"))
+	  (match_operand:SI   2 "rx_source_operand" "r,Sint08,Sint16,Sint24,i,Q")))
+   (set (reg CC_REG)
+	(compare 
+	  (plus:SI
+	    (plus:SI
+	      (ltu:SI (reg:CC CC_REG) (const_int 0))
+	      (match_dup 1))
+	    (match_dup 2))
+	  (const_int 0)))]
+  "reload_completed && rx_match_ccmode (insn, CC_ZSCmode)"
+  "adc %2,%0"
+  [(set_attr "timings" "11,11,11,11,11,33")
+   (set_attr "length"   "3,4,5,6,7,6")]
+)
+
+(define_expand "adddi3"
+  [(set (match_operand:DI          0 "register_operand")
+	(plus:DI (match_operand:DI 1 "register_operand")
+		 (match_operand:DI 2 "rx_source_operand")))]
+  ""
+{
+  rtx op0l, op0h, op1l, op1h, op2l, op2h;
+
+  op0l = gen_lowpart (SImode, operands[0]);
+  op1l = gen_lowpart (SImode, operands[1]);
+  op2l = gen_lowpart (SImode, operands[2]);
+  op0h = gen_highpart (SImode, operands[0]);
+  op1h = gen_highpart (SImode, operands[1]);
+  op2h = gen_highpart_mode (SImode, DImode, operands[2]);
+
+  emit_insn (gen_adddi3_internal (op0l, op0h, op1l, op2l, op1h, op2h));
+  DONE;
+})
+
+(define_insn_and_split "adddi3_internal"
+  [(set (match_operand:SI          0 "register_operand"  "=r")
+	(plus:SI (match_operand:SI 2 "register_operand"  "r")
+		 (match_operand:SI 3 "rx_source_operand" "riQ")))
+   (set (match_operand:SI          1 "register_operand"  "=r")
+	(plus:SI
+	  (plus:SI
+	    (ltu:SI (plus:SI (match_dup 2) (match_dup 3)) (match_dup 2))
+	    (match_operand:SI      4 "register_operand"  "%1"))
+	  (match_operand:SI        5 "rx_source_operand" "riQ")))
+   (clobber (match_scratch:SI      6                     "=&r"))
+   (clobber (reg:CC CC_REG))]
+  ""
+  "#"
+  "reload_completed"
+  [(const_int 0)]
+{
+  rtx op0l = operands[0];
+  rtx op0h = operands[1];
+  rtx op1l = operands[2];
+  rtx op2l = operands[3];
+  rtx op1h = operands[4];
+  rtx op2h = operands[5];
+  rtx scratch = operands[6];
+  rtx x;
+
+  if (reg_overlap_mentioned_p (op0l, op1h))
+    {
+      emit_move_insn (scratch, op0l);
+      op1h = scratch;
+      if (reg_overlap_mentioned_p (op0l, op2h))
+	op2h = scratch;
+    }
+  else if (reg_overlap_mentioned_p (op0l, op2h))
+    {
+      emit_move_insn (scratch, op0l);
+      op2h = scratch;
+    }
+
+  if (rtx_equal_p (op0l, op1l))
+    ;
+  /* It is preferable that op0l == op1l...  */
+  else if (rtx_equal_p (op0l, op2l))
+    x = op1l, op1l = op2l, op2l = x;
+  /* ... but it is only a requirement if op2l == MEM.  */
+  else if (MEM_P (op2l))
+    {
+      /* Let's hope that we still have a scratch register free.  */
+      gcc_assert (op1h != scratch);
+      emit_move_insn (scratch, op2l);
+      op2l = scratch;
+    }
+
+  emit_insn (gen_addsi3_flags (op0l, op1l, op2l));
+
+  if (rtx_equal_p (op0h, op1h))
+    ;
+  else if (rtx_equal_p (op0h, op2h))
+    x = op1h, op1h = op2h, op2h = x;
+  else
+    {
+      emit_move_insn (op0h, op1h);
+      op1h = op0h;
+    }
+  emit_insn (gen_adc_internal (op0h, op1h, op2h));
+  DONE;
+})
+
 (define_insn "andsi3"
   [(set (match_operand:SI         0 "register_operand"  "=r,r,r,r,r,r,r,r,r")
 	(and:SI (match_operand:SI 1 "register_operand"  "%0,0,0,0,0,0,r,r,0")
 		(match_operand:SI 2 "rx_source_operand" "r,Uint04,Sint08,Sint16,Sint24,i,0,r,Q")))
-   (set (reg:CC_ZS CC_REG)
-	(compare:CC_ZS (and:SI (match_dup 1) (match_dup 2))
-		       (const_int 0)))]
+   (clobber (reg:CC CC_REG))]
   ""
   "@
   and\t%2, %0
@@ -880,9 +1009,31 @@
    (set_attr "length" "2,2,3,4,5,6,2,5,5")]
 )
 
+(define_insn "*andsi3_flags"
+  [(set (match_operand:SI         0 "register_operand"  "=r,r,r,r,r,r,r,r,r")
+	(and:SI (match_operand:SI 1 "register_operand"  "%0,0,0,0,0,0,r,r,0")
+		(match_operand:SI 2 "rx_source_operand" "r,Uint04,Sint08,Sint16,Sint24,i,0,r,Q")))
+   (set (reg CC_REG)
+	(compare (and:SI (match_dup 1) (match_dup 2))
+		 (const_int 0)))]
+  "reload_completed && rx_match_ccmode (insn, CC_ZSmode)"
+  "@
+  and\t%2, %0
+  and\t%2, %0
+  and\t%2, %0
+  and\t%2, %0
+  and\t%2, %0
+  and\t%2, %0
+  and\t%1, %0
+  and\t%2, %1, %0
+  and\t%Q2, %0"
+  [(set_attr "timings" "11,11,11,11,11,11,11,33,33")
+   (set_attr "length" "2,2,3,4,5,6,2,5,5")]
+)
+
 ;; Byte swap (single 32-bit value).
 (define_insn "bswapsi2"
-  [(set (match_operand:SI           0 "register_operand" "+r")
+  [(set (match_operand:SI           0 "register_operand" "=r")
 	(bswap:SI (match_operand:SI 1 "register_operand"  "r")))]
   ""
   "revl\t%1, %0"
@@ -891,7 +1042,7 @@
 
 ;; Byte swap (single 16-bit value).  Note - we ignore the swapping of the high 16-bits.
 (define_insn "bswaphi2"
-  [(set (match_operand:HI           0 "register_operand" "+r")
+  [(set (match_operand:HI           0 "register_operand" "=r")
 	(bswap:HI (match_operand:HI 1 "register_operand"  "r")))]
   ""
   "revw\t%1, %0"
@@ -999,24 +1150,33 @@
 (define_insn "negsi2"
   [(set (match_operand:SI         0 "register_operand" "=r,r")
         (neg:SI (match_operand:SI 1 "register_operand"  "0,r")))
-   (set (reg:CC CC_REG)
-	(compare:CC (neg:SI (match_dup 1))
-		    (const_int 0)))]
-  ;; The NEG instruction does not comply with -fwrapv semantics.
-  ;; See gcc.c-torture/execute/pr22493-1.c for an example of this.
-  "! flag_wrapv"
+   (clobber (reg:CC CC_REG))]
+  ""
   "@
   neg\t%0
   neg\t%1, %0"
   [(set_attr "length" "2,3")]
 )
 
+;; Note that the O and C flags are not set as per a normal compare,
+;; and thus are unusable in that context.
+(define_insn "*negsi2_flags"
+  [(set (match_operand:SI         0 "register_operand" "=r,r")
+        (neg:SI (match_operand:SI 1 "register_operand"  "0,r")))
+   (set (reg CC_REG)
+	(compare (neg:SI (match_dup 1))
+		 (const_int 0)))]
+  "reload_completed && rx_match_ccmode (insn, CC_ZSmode)"
+  "@
+  neg\t%0
+  neg\t%1, %0"
+  [(set_attr "length" "2,3")]
+)
+
 (define_insn "one_cmplsi2"
   [(set (match_operand:SI         0 "register_operand" "=r,r")
 	(not:SI (match_operand:SI 1 "register_operand"  "0,r")))
-   (set (reg:CC_ZS CC_REG)
-	(compare:CC_ZS (not:SI (match_dup 1))
-		       (const_int 0)))]
+   (clobber (reg:CC CC_REG))]
   ""
   "@
   not\t%0
@@ -1024,13 +1184,24 @@
   [(set_attr "length" "2,3")]
 )
 
+(define_insn "*one_cmplsi2_flags"
+  [(set (match_operand:SI         0 "register_operand" "=r,r")
+	(not:SI (match_operand:SI 1 "register_operand"  "0,r")))
+   (set (reg CC_REG)
+	(compare (not:SI (match_dup 1))
+		 (const_int 0)))]
+  "reload_completed && rx_match_ccmode (insn, CC_ZSmode)"
+  "@
+  not\t%0
+  not\t%1, %0"
+  [(set_attr "length" "2,3")]
+)
+
 (define_insn "iorsi3"
   [(set (match_operand:SI         0 "register_operand" "=r,r,r,r,r,r,r,r,r")
 	(ior:SI (match_operand:SI 1 "register_operand" "%0,0,0,0,0,0,r,r,0")
 	        (match_operand:SI 2 "rx_source_operand" "r,Uint04,Sint08,Sint16,Sint24,i,0,r,Q")))
-   (set (reg:CC_ZS CC_REG)
-	(compare:CC_ZS (ior:SI (match_dup 1) (match_dup 2))
-		       (const_int 0)))]
+   (clobber (reg:CC CC_REG))]
   ""
   "@
   or\t%2, %0
@@ -1046,37 +1217,77 @@
    (set_attr "length"  "2,2,3,4,5,6,2,3,5")]
 )
 
+(define_insn "*iorsi3_flags"
+  [(set (match_operand:SI         0 "register_operand" "=r,r,r,r,r,r,r,r,r")
+	(ior:SI (match_operand:SI 1 "register_operand" "%0,0,0,0,0,0,r,r,0")
+	        (match_operand:SI 2 "rx_source_operand" "r,Uint04,Sint08,Sint16,Sint24,i,0,r,Q")))
+   (set (reg CC_REG)
+	(compare (ior:SI (match_dup 1) (match_dup 2))
+		 (const_int 0)))]
+  "reload_completed && rx_match_ccmode (insn, CC_ZSmode)"
+  "@
+  or\t%2, %0
+  or\t%2, %0
+  or\t%2, %0
+  or\t%2, %0
+  or\t%2, %0
+  or\t%Q2, %0
+  or\t%1, %0
+  or\t%2, %1, %0
+  or\t%Q2, %0"
+  [(set_attr "timings" "11,11,11,11,11,11,11,11,33")
+   (set_attr "length"  "2,2,3,4,5,6,2,3,5")]
+)
+
 (define_insn "rotlsi3"
   [(set (match_operand:SI            0 "register_operand" "=r")
 	(rotate:SI (match_operand:SI 1 "register_operand"  "0")
 		   (match_operand:SI 2 "rx_shift_operand" "rn")))
-   (set (reg:CC_ZS CC_REG)
-	(compare:CC_ZS (rotate:SI (match_dup 1) (match_dup 2))
-		       (const_int 0)))]
+   (clobber (reg:CC CC_REG))]
   ""
   "rotl\t%2, %0"
   [(set_attr "length" "3")]
 )
 
+(define_insn "*rotlsi3_flags"
+  [(set (match_operand:SI            0 "register_operand" "=r")
+	(rotate:SI (match_operand:SI 1 "register_operand"  "0")
+		   (match_operand:SI 2 "rx_shift_operand" "rn")))
+   (set (reg CC_REG)
+	(compare (rotate:SI (match_dup 1) (match_dup 2))
+		 (const_int 0)))]
+  "reload_completed && rx_match_ccmode (insn, CC_ZSmode)"
+  "rotl\t%2, %0"
+  [(set_attr "length" "3")]
+)
+
 (define_insn "rotrsi3"
   [(set (match_operand:SI              0 "register_operand" "=r")
 	(rotatert:SI (match_operand:SI 1 "register_operand"  "0")
 		     (match_operand:SI 2 "rx_shift_operand" "rn")))
-   (set (reg:CC_ZS CC_REG)
-	(compare:CC_ZS (rotatert:SI (match_dup 1) (match_dup 2))
-		       (const_int 0)))]
+   (clobber (reg:CC CC_REG))]
   ""
   "rotr\t%2, %0"
   [(set_attr "length" "3")]
 )
 
+(define_insn "*rotrsi3_flags"
+  [(set (match_operand:SI              0 "register_operand" "=r")
+	(rotatert:SI (match_operand:SI 1 "register_operand"  "0")
+		     (match_operand:SI 2 "rx_shift_operand" "rn")))
+   (set (reg CC_REG)
+	(compare (rotatert:SI (match_dup 1) (match_dup 2))
+		 (const_int 0)))]
+  "reload_completed && rx_match_ccmode (insn, CC_ZSmode)"
+  "rotr\t%2, %0"
+  [(set_attr "length" "3")]
+)
+
 (define_insn "ashrsi3"
   [(set (match_operand:SI              0 "register_operand" "=r,r,r")
 	(ashiftrt:SI (match_operand:SI 1 "register_operand"  "0,0,r")
 		     (match_operand:SI 2 "rx_shift_operand"  "r,n,n")))
-   (set (reg:CC_ZS CC_REG)
-	(compare:CC_ZS (ashiftrt:SI (match_dup 1) (match_dup 2))
-		       (const_int 0)))]
+   (clobber (reg:CC CC_REG))]
   ""
   "@
   shar\t%2, %0
@@ -1085,13 +1296,26 @@
   [(set_attr "length" "3,2,3")]
 )
 
+(define_insn "*ashrsi3_flags"
+  [(set (match_operand:SI              0 "register_operand" "=r,r,r")
+	(ashiftrt:SI (match_operand:SI 1 "register_operand"  "0,0,r")
+		     (match_operand:SI 2 "rx_shift_operand"  "r,n,n")))
+   (set (reg CC_REG)
+	(compare (ashiftrt:SI (match_dup 1) (match_dup 2))
+		 (const_int 0)))]
+  "reload_completed && rx_match_ccmode (insn, CC_ZSmode)"
+  "@
+  shar\t%2, %0
+  shar\t%2, %0
+  shar\t%2, %1, %0"
+  [(set_attr "length" "3,2,3")]
+)
+
 (define_insn "lshrsi3"
   [(set (match_operand:SI              0 "register_operand" "=r,r,r")
 	(lshiftrt:SI (match_operand:SI 1 "register_operand"  "0,0,r")
 		     (match_operand:SI 2 "rx_shift_operand"  "r,n,n")))
-   (set (reg:CC_ZS CC_REG)
-	(compare:CC_ZS (lshiftrt:SI (match_dup 1) (match_dup 2))
-		       (const_int 0)))]
+   (clobber (reg:CC CC_REG))]
   ""
   "@
   shlr\t%2, %0
@@ -1100,13 +1324,26 @@
   [(set_attr "length" "3,2,3")]
 )
 
+(define_insn "*lshrsi3_flags"
+  [(set (match_operand:SI              0 "register_operand" "=r,r,r")
+	(lshiftrt:SI (match_operand:SI 1 "register_operand"  "0,0,r")
+		     (match_operand:SI 2 "rx_shift_operand"  "r,n,n")))
+   (set (reg CC_REG)
+	(compare (lshiftrt:SI (match_dup 1) (match_dup 2))
+		 (const_int 0)))]
+  "reload_completed && rx_match_ccmode (insn, CC_ZSmode)"
+  "@
+  shlr\t%2, %0
+  shlr\t%2, %0
+  shlr\t%2, %1, %0"
+  [(set_attr "length" "3,2,3")]
+)
+
 (define_insn "ashlsi3"
   [(set (match_operand:SI            0 "register_operand" "=r,r,r")
 	(ashift:SI (match_operand:SI 1 "register_operand"  "0,0,r")
 	           (match_operand:SI 2 "rx_shift_operand"  "r,n,n")))
-   (set (reg:CC_ZS CC_REG)
-	(compare:CC_ZS (ashift:SI (match_dup 1) (match_dup 2))
-		       (const_int 0)))]
+   (clobber (reg:CC CC_REG))]
   ""
   "@
   shll\t%2, %0
@@ -1115,16 +1352,57 @@
   [(set_attr "length" "3,2,3")]
 )
 
+(define_insn "*ashlsi3_flags"
+  [(set (match_operand:SI            0 "register_operand" "=r,r,r")
+	(ashift:SI (match_operand:SI 1 "register_operand"  "0,0,r")
+	           (match_operand:SI 2 "rx_shift_operand"  "r,n,n")))
+   (set (reg CC_REG)
+	(compare (ashift:SI (match_dup 1) (match_dup 2))
+		 (const_int 0)))]
+  "reload_completed && rx_match_ccmode (insn, CC_ZSmode)"
+  "@
+  shll\t%2, %0
+  shll\t%2, %0
+  shll\t%2, %1, %0"
+  [(set_attr "length" "3,2,3")]
+)
+
+;; Saturate to 32-bits
+(define_insn_and_split "ssaddsi3"
+  [(set (match_operand:SI             0 "register_operand" "=r")
+	(ss_plus:SI (match_operand:SI 1 "register_operand"  "r")
+		    (match_operand:SI 2 "rx_source_operand" "riQ")))
+   (clobber (reg:CC CC_REG))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0)
+		   (plus:SI (match_dup 1) (match_dup 2)))
+	      (set (reg:CC_ZSC CC_REG)
+		   (compare:CC_ZSC
+		     (plus:SI (match_dup 1) (match_dup 2))
+		     (const_int 0)))])
+   (set (match_dup 0)
+	(unspec:SI [(match_dup 0) (reg:CC CC_REG)] 
+		   UNSPEC_BUILTIN_SAT))]
+   ""
+)
+
+(define_insn "*sat"
+  [(set (match_operand:SI             0 "register_operand" "=r")
+	(unspec:SI [(match_operand:SI 1 "register_operand"  "0")
+		    (reg:CC CC_REG)]
+		   UNSPEC_BUILTIN_SAT))]
+  "reload_completed"
+  "sat\t%0"
+  [(set_attr "length" "2")]
+)
+
 (define_insn "subsi3"
   [(set (match_operand:SI           0 "register_operand" "=r,r,r,r,r")
 	(minus:SI (match_operand:SI 1 "register_operand"  "0,0,0,r,0")
 		  (match_operand:SI 2 "rx_source_operand" "r,Uint04,n,r,Q")))
-   (set (reg:CC_ZSC CC_REG)
-	;; Note - we do not acknowledge that the SUB instruction sets the Overflow
-	;; flag because its interpretation is different from comparing the result
-	;; against zero.  Compile and run gcc.c-torture/execute/cmpsi-1.c to see this.
-	(compare:CC_ZSC (minus:SI (match_dup 1) (match_dup 2))
-			(const_int 0)))]
+   (clobber (reg:CC CC_REG))]
   ""
   "@
   sub\t%2, %0
@@ -1136,32 +1414,134 @@
    (set_attr "length" "2,2,6,3,5")]
 )
 
-(define_insn "subdi3"
-  [(set (match_operand:DI           0 "register_operand" "=r,r")
-	(minus:DI (match_operand:DI 1 "register_operand"  "0,0")
-		  (match_operand:DI 2 "rx_source_operand" "r,Q")))
-   (set (reg:CC_ZSC CC_REG) ;; See subsi3
-	(compare:CC_ZSC (minus:DI (match_dup 1) (match_dup 2))
-			(const_int 0)))]
-  ""
-  "sub\t%L2, %L0\n\tsbb\t%H2, %H0"
-  [(set_attr "timings" "22,44")
-   (set_attr "length" "5,11")]
+;; Note that the O flag is set as if (compare op1 op2) not for
+;; what is described here, (compare op0 0).
+(define_insn "*subsi3_flags"
+  [(set (match_operand:SI           0 "register_operand" "=r,r,r,r,r")
+	(minus:SI (match_operand:SI 1 "register_operand"  "0,0,0,r,0")
+		  (match_operand:SI 2 "rx_source_operand" "r,Uint04,n,r,Q")))
+   (set (reg CC_REG)
+	(compare (minus:SI (match_dup 1) (match_dup 2))
+		 (const_int 0)))]
+  "reload_completed && rx_match_ccmode (insn, CC_ZSCmode)"
+  "@
+  sub\t%2, %0
+  sub\t%2, %0
+  add\t%N2, %0
+  sub\t%2, %1, %0
+  sub\t%Q2, %0"
+  [(set_attr "timings" "11,11,11,11,33")
+   (set_attr "length" "2,2,6,3,5")]
 )
 
+;; A helper to expand the above with the CC_MODE filled in.
+(define_expand "subsi3_flags"
+  [(parallel [(set (match_operand:SI 0 "register_operand")
+		   (minus:SI (match_operand:SI 1 "register_operand")
+			     (match_operand:SI 2 "rx_source_operand")))
+	      (set (reg:CC_ZSC CC_REG)
+		   (compare:CC_ZSC (minus:SI (match_dup 1) (match_dup 2))
+				   (const_int 0)))])]
+)
+
+(define_insn "sbb_internal"
+  [(set (match_operand:SI     0 "register_operand"   "=r,r")
+	(minus:SI
+	  (minus:SI
+	    (match_operand:SI 1 "register_operand"   " 0,0")
+	    (match_operand:SI 2 "rx_compare_operand" " r,Q"))
+	  (geu:SI (reg:CC CC_REG) (const_int 0))))
+    (clobber (reg:CC CC_REG))]
+  "reload_completed"
+  "sbb\t%2, %0"
+  [(set_attr "timings" "11,33")
+   (set_attr "length"  "3,6")]
+)
+
+(define_insn "*sbb_flags"
+  [(set (match_operand:SI     0 "register_operand"   "=r,r")
+	(minus:SI
+	  (minus:SI
+	    (match_operand:SI 1 "register_operand"   " 0,0")
+	    (match_operand:SI 2 "rx_compare_operand" " r,Q"))
+	  (geu:SI (reg:CC CC_REG) (const_int 0))))
+   (set (reg CC_REG)
+	(compare
+	  (minus:SI
+	    (minus:SI (match_dup 1) (match_dup 2))
+	    (geu:SI (reg:CC CC_REG) (const_int 0)))
+	  (const_int 0)))]
+  "reload_completed"
+  "sbb\t%2, %0"
+  [(set_attr "timings" "11,33")
+   (set_attr "length"  "3,6")]
+)
+
+(define_expand "subdi3"
+  [(set (match_operand:DI           0 "register_operand")
+	(minus:DI (match_operand:DI 1 "register_operand")
+		  (match_operand:DI 2 "rx_compare_operand")))]
+  ""
+{
+  rtx op0l, op0h, op1l, op1h, op2l, op2h;
+
+  op0l = gen_lowpart (SImode, operands[0]);
+  op1l = gen_lowpart (SImode, operands[1]);
+  op2l = gen_lowpart (SImode, operands[2]);
+  op0h = gen_highpart (SImode, operands[0]);
+  op1h = gen_highpart (SImode, operands[1]);
+  op2h = gen_highpart_mode (SImode, DImode, operands[2]);
+
+  emit_insn (gen_subdi3_internal (op0l, op0h, op1l, op2l, op1h, op2h));
+  DONE;
+})
+
+(define_insn_and_split "subdi3_internal"
+  [(set (match_operand:SI          0 "register_operand"   "=&r,&r")
+	(minus:SI (match_operand:SI 2 "register_operand"  "  0, r")
+		  (match_operand:SI 3 "rx_compare_operand" "rQ, r")))
+   (set (match_operand:SI          1 "register_operand"   "= r, r")
+	(minus:SI
+	  (minus:SI
+	    (match_operand:SI      4 "register_operand"   "  1, 1")
+	    (match_operand:SI      5 "rx_compare_operand" " rQ,rQ"))
+	  (geu:SI (match_dup 2) (match_dup 3))))
+   (clobber (reg:CC CC_REG))]
+  ""
+  "#"
+  "reload_completed"
+  [(const_int 0)]
+{
+  emit_insn (gen_subsi3_flags (operands[0], operands[2], operands[3]));
+  emit_insn (gen_sbb_internal (operands[1], operands[4], operands[5]));
+  DONE;
+})
+
 (define_insn "xorsi3"
   [(set (match_operand:SI         0 "register_operand" "=r,r,r,r,r,r")
 	(xor:SI (match_operand:SI 1 "register_operand" "%0,0,0,0,0,0")
 	        (match_operand:SI 2 "rx_source_operand"
 				  "r,Sint08,Sint16,Sint24,i,Q")))
-   (set (reg:CC_ZS CC_REG)
-	(compare:CC_ZS (xor:SI (match_dup 1) (match_dup 2))
-		       (const_int 0)))]
+   (clobber (reg:CC CC_REG))]
   ""
   "xor\t%Q2, %0"
   [(set_attr "timings" "11,11,11,11,11,33")
    (set_attr "length" "3,4,5,6,7,6")]
 )
+
+(define_insn "*xorsi3_flags"
+  [(set (match_operand:SI         0 "register_operand" "=r,r,r,r,r,r")
+	(xor:SI (match_operand:SI 1 "register_operand" "%0,0,0,0,0,0")
+	        (match_operand:SI 2 "rx_source_operand"
+				  "r,Sint08,Sint16,Sint24,i,Q")))
+   (set (reg CC_REG)
+	(compare (xor:SI (match_dup 1) (match_dup 2))
+		 (const_int 0)))]
+  "reload_completed && rx_match_ccmode (insn, CC_ZSmode)"
+  "xor\t%Q2, %0"
+  [(set_attr "timings" "11,11,11,11,11,33")
+   (set_attr "length" "3,4,5,6,7,6")]
+)
 
 ;; Floating Point Instructions
 
@@ -1169,9 +1549,7 @@
   [(set (match_operand:SF          0 "register_operand"  "=r,r,r")
 	(plus:SF (match_operand:SF 1 "register_operand"  "%0,0,0")
 		 (match_operand:SF 2 "rx_source_operand"  "r,F,Q")))
-   (set (reg:CC_ZS CC_REG)
-	(compare:CC_ZS (plus:SF (match_dup 1) (match_dup 2))
-			(const_int 0)))]
+   (clobber (reg:CC CC_REG))]
   "ALLOW_RX_FPU_INSNS"
   "fadd\t%2, %0"
   [(set_attr "timings" "44,44,66")
@@ -1182,9 +1560,7 @@
   [(set (match_operand:SF         0 "register_operand" "=r,r,r")
 	(div:SF (match_operand:SF 1 "register_operand"  "0,0,0")
 		(match_operand:SF 2 "rx_source_operand" "r,F,Q")))
-   (set (reg:CC_ZS CC_REG)
-	(compare:CC_ZS (div:SF (match_dup 1) (match_dup 2))
-			(const_int 0)))]
+   (clobber (reg:CC CC_REG))]
   "ALLOW_RX_FPU_INSNS"
   "fdiv\t%2, %0"
   [(set_attr "timings" "1616,1616,1818")
@@ -1195,9 +1571,7 @@
   [(set (match_operand:SF          0 "register_operand" "=r,r,r")
 	(mult:SF (match_operand:SF 1 "register_operand" "%0,0,0")
 		(match_operand:SF  2 "rx_source_operand" "r,F,Q")))
-   (set (reg:CC_ZS CC_REG)
-	(compare:CC_ZS (mult:SF (match_dup 1) (match_dup 2))
-			(const_int 0)))]
+   (clobber (reg:CC CC_REG))]
   "ALLOW_RX_FPU_INSNS"
   "fmul\t%2, %0"
   [(set_attr "timings" "33,33,55")
@@ -1208,9 +1582,7 @@
   [(set (match_operand:SF           0 "register_operand" "=r,r,r")
 	(minus:SF (match_operand:SF 1 "register_operand"  "0,0,0")
 		  (match_operand:SF 2 "rx_source_operand" "r,F,Q")))
-   (set (reg:CC_ZS CC_REG)
-	(compare:CC_ZS (minus:SF (match_dup 1) (match_dup 2))
-		       (const_int 0)))]
+   (clobber (reg:CC CC_REG))]
   "ALLOW_RX_FPU_INSNS"
   "fsub\t%Q2, %0"
   [(set_attr "timings" "44,44,66")
@@ -1220,9 +1592,7 @@
 (define_insn "fix_truncsfsi2"
   [(set (match_operand:SI         0 "register_operand"  "=r,r")
 	(fix:SI (match_operand:SF 1 "rx_compare_operand" "r,Q")))
-   (set (reg:CC_ZS CC_REG)
-	(compare:CC_ZS (fix:SI (match_dup 1))
-		       (const_int 0)))]
+   (clobber (reg:CC CC_REG))]
   "ALLOW_RX_FPU_INSNS"
   "ftoi\t%Q1, %0"
   [(set_attr "timings" "22,44")
@@ -1232,9 +1602,7 @@
 (define_insn "floatsisf2"
   [(set (match_operand:SF           0 "register_operand"  "=r,r")
 	(float:SF (match_operand:SI 1 "rx_compare_operand" "r,Q")))
-   (set (reg:CC_ZS CC_REG)
-	(compare:CC_ZS (float:SF (match_dup 1))
-			(const_int 0)))]
+   (clobber (reg:CC CC_REG))]
   "ALLOW_RX_FPU_INSNS"
   "itof\t%Q1, %0"
   [(set_attr "timings" "22,44")
@@ -1242,217 +1610,216 @@
 )
 
 ;; Bit manipulation instructions.
-;; Note - there are two versions of each pattern because the memory
-;; accessing versions use QImode whilst the register accessing
-;; versions use SImode.
-;; The peephole are here because the combiner only looks at a maximum
-;; of three instructions at a time.
 
-(define_insn "bitset"
-  [(set:SI (match_operand:SI                    0 "register_operand" "=r")
-	   (ior:SI (match_operand:SI            1 "register_operand" "0")
-		   (ashift:SI (const_int 1)
-			      (match_operand:SI 2 "nonmemory_operand" "ri"))))]
+;; ??? The *_in_memory patterns will not be matched without further help.
+;; At one time we had the insv expander generate them, but I suspect that
+;; in general we get better performance by exposing the register load to
+;; the optimizers.
+;;
+;; An alternate solution would be to re-organize these patterns such
+;; that allow both register and memory operands.  This would allow the
+;; register allocator to spill and not load the register operand.  This
+;; would be possible only for operations for which we have a constant
+;; bit offset, so that we can adjust the address by ofs/8 and replace
+;; the offset in the insn by ofs%8.
+
+(define_insn "*bitset"
+  [(set (match_operand:SI                    0 "register_operand" "=r")
+	(ior:SI (ashift:SI (const_int 1)
+			   (match_operand:SI 1 "rx_shift_operand" "ri"))
+		(match_operand:SI            2 "register_operand" "0")))]
   ""
-  "bset\t%2, %0"
+  "bset\t%1, %0"
   [(set_attr "length" "3")]
 )
 
-(define_insn "bitset_in_memory"
-  [(set:QI (match_operand:QI                    0 "memory_operand" "=m")
-	   (ior:QI (match_operand:QI            1 "memory_operand" "0")
-		   (ashift:QI (const_int 1)
-			      (match_operand:QI 2 "nonmemory_operand" "ri"))))]
+(define_insn "*bitset_in_memory"
+  [(set (match_operand:QI                    0 "memory_operand" "+Q")
+	(ior:QI (ashift:QI (const_int 1)
+			   (match_operand:QI 1 "nonmemory_operand" "ri"))
+		(match_dup 0)))]
   ""
-  "bset\t%2, %0.B"
+  "bset\t%1, %0.B"
   [(set_attr "length" "3")
    (set_attr "timings" "34")]
 )
 
-;; (set (reg A) (const_int 1))
-;; (set (reg A) (ashift (reg A) (reg B)))
-;; (set (reg C) (ior (reg A) (reg C)))
-(define_peephole2
-  [(set:SI (match_operand:SI 0 "register_operand" "")
-	   (const_int 1))
-   (set:SI (match_dup 0)
-	   (ashift:SI (match_dup 0)
-		      (match_operand:SI 1 "register_operand" "")))
-   (set:SI (match_operand:SI 2 "register_operand" "")
-	   (ior:SI (match_dup 0)
-		   (match_dup 2)))]
-  "dead_or_set_p (insn, operands[0])"
-  [(set:SI (match_dup 2)
-	   (ior:SI (match_dup 2)
-		   (ashift:SI (const_int 1)
-			      (match_dup 1))))]
-)
-  
-;; (set (reg A) (const_int 1))
-;; (set (reg A) (ashift (reg A) (reg B)))
-;; (set (reg A) (ior (reg A) (reg C)))
-;; (set (reg C) (reg A)
-(define_peephole2
-  [(set:SI (match_operand:SI 0 "register_operand" "")
-	   (const_int 1))
-   (set:SI (match_dup 0)
-	   (ashift:SI (match_dup 0)
-		      (match_operand:SI 1 "register_operand" "")))
-   (set:SI (match_dup 0)
-	   (ior:SI (match_dup 0)
-		   (match_operand:SI 2 "register_operand" "")))
-   (set:SI (match_dup 2) (match_dup 0))]
-  "dead_or_set_p (insn, operands[0])"
-  [(set:SI (match_dup 2)
-	   (ior:SI (match_dup 2)
-		   (ashift:SI (const_int 1)
-			      (match_dup 1))))]
-)
-  
-(define_insn "bitinvert"
-  [(set:SI (match_operand:SI 0 "register_operand" "+r")
-	   (xor:SI (match_operand:SI 1 "register_operand" "0")
-		   (ashift:SI (const_int 1)
-			      (match_operand:SI 2 "nonmemory_operand" "ri"))))]
+(define_insn "*bitinvert"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(xor:SI (ashift:SI (const_int 1)
+			   (match_operand:SI 1 "rx_shift_operand" "ri"))
+		(match_operand:SI 2 "register_operand" "0")))]
   ""
-  "bnot\t%2, %0"
+  "bnot\t%1, %0"
   [(set_attr "length" "3")]
 )
 
-(define_insn "bitinvert_in_memory"
-  [(set:QI (match_operand:QI 0 "memory_operand" "+m")
-	   (xor:QI (match_operand:QI 1 "register_operand" "0")
-		   (ashift:QI (const_int 1)
-			      (match_operand:QI 2 "nonmemory_operand" "ri"))))]
+(define_insn "*bitinvert_in_memory"
+  [(set (match_operand:QI 0 "memory_operand" "+Q")
+	(xor:QI (ashift:QI (const_int 1)
+			   (match_operand:QI 1 "nonmemory_operand" "ri"))
+		(match_dup 0)))]
   ""
-  "bnot\t%2, %0.B"
+  "bnot\t%1, %0.B"
   [(set_attr "length" "5")
    (set_attr "timings" "33")]
 )
 
-;; (set (reg A) (const_int 1))
-;; (set (reg A) (ashift (reg A) (reg B)))
-;; (set (reg C) (xor (reg A) (reg C)))
-(define_peephole2
-  [(set:SI (match_operand:SI 0 "register_operand" "")
-	   (const_int 1))
-   (set:SI (match_dup 0)
-	   (ashift:SI (match_dup 0)
-		      (match_operand:SI 1 "register_operand" "")))
-   (set:SI (match_operand:SI 2 "register_operand" "")
-	   (xor:SI (match_dup 0)
-		   (match_dup 2)))]
-  "dead_or_set_p (insn, operands[0])"
-  [(set:SI (match_dup 2)
-	   (xor:SI (match_dup 2)
-		   (ashift:SI (const_int 1)
-			      (match_dup 1))))]
+(define_insn "*bitclr"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(and:SI (not:SI
+		  (ashift:SI
+		    (const_int 1)
+		    (match_operand:SI 1 "rx_shift_operand" "ri")))
+		(match_operand:SI 2 "register_operand" "0")))]
   ""
+  "bclr\t%1, %0"
+  [(set_attr "length" "3")]
 )
-  
-;; (set (reg A) (const_int 1))
-;; (set (reg A) (ashift (reg A) (reg B)))
-;; (set (reg A) (xor (reg A) (reg C)))
-;; (set (reg C) (reg A))
-(define_peephole2
-  [(set:SI (match_operand:SI 0 "register_operand" "")
-	   (const_int 1))
-   (set:SI (match_dup 0)
-	   (ashift:SI (match_dup 0)
-		      (match_operand:SI 1 "register_operand" "")))
-   (set:SI (match_dup 0)
-	   (xor:SI (match_dup 0)
-		   (match_operand:SI 2 "register_operand" "")))
-   (set:SI (match_dup 2) (match_dup 0))]
-  "dead_or_set_p (insn, operands[0])"
-  [(set:SI (match_dup 2)
-	   (xor:SI (match_dup 2)
-		   (ashift:SI (const_int 1)
-			      (match_dup 1))))]
+
+(define_insn "*bitclr_in_memory"
+  [(set (match_operand:QI 0 "memory_operand" "+Q")
+	(and:QI (not:QI
+		  (ashift:QI
+		    (const_int 1)
+		    (match_operand:QI 1 "nonmemory_operand" "ri")))
+		(match_dup 0)))]
   ""
+  "bclr\t%1, %0.B"
+  [(set_attr "length" "3")
+   (set_attr "timings" "34")]
 )
 
-(define_insn "bitclr"
-  [(set:SI (match_operand:SI 0 "register_operand" "+r")
-	   (and:SI (match_operand:SI 1 "register_operand" "0")
-		   (not:SI (ashift:SI (const_int 1)
-				      (match_operand:SI 2 "nonmemory_operand" "ri")))))]
+(define_insn "*insv_imm"
+  [(set (zero_extract:SI
+	  (match_operand:SI 0 "register_operand" "+r")
+	  (const_int 1)
+	  (match_operand:SI 1 "rx_shift_operand" "ri"))
+	(match_operand:SI 2 "const_int_operand" ""))]
   ""
-  "bclr\t%2, %0"
+{
+  if (INTVAL (operands[2]) & 1)
+    return "bset\t%1, %0";
+  else
+    return "bclr\t%1, %0";
+}
   [(set_attr "length" "3")]
 )
 
-(define_insn "bitclr_in_memory"
-  [(set:QI (match_operand:QI 0 "memory_operand" "+m")
-	   (and:QI (match_operand:QI 1 "memory_operand" "0")
-		   (not:QI (ashift:QI (const_int 1)
-				      (match_operand:QI 2 "nonmemory_operand" "ri")))))]
+(define_insn_and_split "rx_insv_reg"
+  [(set (zero_extract:SI
+	  (match_operand:SI 0 "register_operand" "+r")
+	  (const_int 1)
+	  (match_operand:SI 1 "const_int_operand" ""))
+	(match_operand:SI 2 "register_operand" "r"))
+   (clobber (reg:CC CC_REG))]
   ""
-  "bclr\t%2, %0.B"
-  [(set_attr "length" "3")
-   (set_attr "timings" "34")]
+  "#"
+  "reload_completed"
+  [(set (zero_extract:SI (match_dup 0) (const_int 1) (match_dup 1))
+	(match_dup 3))]
+{
+  rtx flags, x;
+
+  /* Emit tst #1, op2.  */
+  flags = gen_rtx_REG (CC_ZSmode, CC_REG);
+  x = gen_rtx_AND (SImode, operands[2], const1_rtx);
+  x = gen_rtx_COMPARE (CC_ZSmode, x, const0_rtx);
+  x = gen_rtx_SET (VOIDmode, flags, x);
+  emit_insn (x);
+
+  /* Emit bmne.  */
+  operands[3] = gen_rtx_NE (SImode, flags, const0_rtx);
+})
+
+(define_insn_and_split "*insv_cond"
+  [(set (zero_extract:SI
+	  (match_operand:SI 0 "register_operand" "+r")
+	  (const_int 1)
+	  (match_operand:SI 1 "const_int_operand" ""))
+	(match_operator:SI 4 "comparison_operator"
+	  [(match_operand:SI 2 "register_operand" "r")
+	   (match_operand:SI 3 "rx_source_operand" "riQ")]))
+   (clobber (reg:CC CC_REG))]
+  ""
+  "#"
+  "reload_completed"
+  [(set (zero_extract:SI (match_dup 0) (const_int 1) (match_dup 1))
+	(match_dup 4))]
+{
+  rtx flags, x;
+
+  flags = gen_rtx_REG (CCmode, CC_REG);
+  x = gen_rtx_COMPARE (CCmode, operands[2], operands[3]);
+  x = gen_rtx_SET (VOIDmode, flags, x);
+  emit_insn (x);
+
+  operands[4] = gen_rtx_fmt_ee (GET_CODE (operands[4]), SImode,
+			        flags, const0_rtx);
+})
+
+(define_insn "*bmcc"
+  [(set (zero_extract:SI
+	  (match_operand:SI 0 "register_operand" "+r")
+	  (const_int 1)
+	  (match_operand:SI 1 "const_int_operand" ""))
+	(match_operator:SI 2 "comparison_operator"
+	  [(reg CC_REG) (const_int 0)]))]
+  "reload_completed"
+  "bm%B2\t%1, %0"
+  [(set_attr "length" "3")]
 )
 
-;; (set (reg A) (const_int -2))
-;; (set (reg A) (rotate (reg A) (reg B)))
-;; (set (reg C) (and (reg A) (reg C)))
-(define_peephole2
-  [(set:SI (match_operand:SI 0 "register_operand" "")
-	   (const_int -2))
-   (set:SI (match_dup 0)
-	   (rotate:SI (match_dup 0)
-		      (match_operand:SI 1 "register_operand" "")))
-   (set:SI (match_operand:SI 2 "register_operand" "")
-	   (and:SI (match_dup 0)
-		   (match_dup 2)))]
-  "dead_or_set_p (insn, operands[0])"
-  [(set:SI (match_dup 2)
-	   (and:SI (match_dup 2)
-		   (not:SI (ashift:SI (const_int 1)
-				      (match_dup 1)))))]
+;; Work around the fact that X=Y<0 is preferentially expanded as a shift.
+(define_insn_and_split "*insv_cond_lt"
+  [(set (zero_extract:SI
+	  (match_operand:SI 0 "register_operand" "+r")
+	  (const_int 1)
+	  (match_operand:SI 1 "const_int_operand" ""))
+	(match_operator:SI 3 "rshift_operator"
+	  [(match_operand:SI 2 "register_operand" "r")
+	   (const_int 31)]))
+   (clobber (reg:CC CC_REG))]
+  ""
+  "#"
+  ""
+  [(parallel [(set (zero_extract:SI (match_dup 0) (const_int 1) (match_dup 1))
+		   (lt:SI (match_dup 2) (const_int 0)))
+	      (clobber (reg:CC CC_REG))])]
+  ""
 )
-  
-;; (set (reg A) (const_int -2))
-;; (set (reg A) (rotate (reg A) (reg B)))
-;; (set (reg A) (and (reg A) (reg C)))
-;; (set (reg C) (reg A)
-(define_peephole2
-  [(set:SI (match_operand:SI 0 "register_operand" "")
-	   (const_int -2))
-   (set:SI (match_dup 0)
-	   (rotate:SI (match_dup 0)
-		      (match_operand:SI 1 "register_operand" "")))
-   (set:SI (match_dup 0)
-	   (and:SI (match_dup 0)
-		   (match_operand:SI 2 "register_operand" "")))
-   (set:SI (match_dup 2) (match_dup 0))]
-  "dead_or_set_p (insn, operands[0])"
-  [(set:SI (match_dup 2)
-	   (and:SI (match_dup 2)
-		   (not:SI (ashift:SI (const_int 1)
-				      (match_dup 1)))))]
-)
 
 (define_expand "insv"
-  [(set:SI (zero_extract:SI (match_operand:SI 0 "nonimmediate_operand") ;; Destination
-		            (match_operand    1 "immediate_operand")    ;; # of bits to set
-			    (match_operand    2 "immediate_operand"))   ;; Starting bit
-	   (match_operand	              3 "immediate_operand"))]  ;; Bits to insert
+  [(set (zero_extract:SI
+	  (match_operand:SI 0 "register_operand")	;; Destination
+	  (match_operand:SI 1 "const_int_operand")	;; # of bits to set
+	  (match_operand:SI 2 "nonmemory_operand"))	;; Starting bit
+	(match_operand:SI   3 "nonmemory_operand"))]	;; Bits to insert
   ""
-  {
-    if (rx_expand_insv (operands))
+{
+  /* We only handle single-bit inserts.  */
+  if (!CONST_INT_P (operands[1]) || INTVAL (operands[1]) != 1)
+    FAIL;
+
+  /* Either the bit to insert or the position must be constant.  */
+  if (CONST_INT_P (operands[3]))
+    operands[3] = GEN_INT (INTVAL (operands[3]) & 1);
+  else if (CONST_INT_P (operands[2]))
+    {
+      emit_insn (gen_rx_insv_reg (operands[0], operands[2], operands[3]));
       DONE;
+    }
+  else
     FAIL;
-  }
-)   
+})
 
 ;; Atomic exchange operation.
 
 (define_insn "sync_lock_test_and_setsi"
-  [(set:SI (match_operand:SI 0 "register_operand"   "=r,r")
-	   (match_operand:SI 1 "rx_compare_operand" "=r,Q"))
-   (set:SI (match_dup 1)
-	   (match_operand:SI 2 "register_operand"    "0,0"))]
+  [(set (match_operand:SI 0 "register_operand"   "=r,r")
+	(match_operand:SI 1 "rx_compare_operand" "=r,Q"))
+   (set (match_dup 1)
+	(match_operand:SI 2 "register_operand"    "0,0"))]
   ""
   "xchg\t%1, %0"
   [(set_attr "length" "3,6")
@@ -1462,9 +1829,9 @@
 ;; Block move functions.
 
 (define_expand "movstr"
-  [(set:SI (match_operand:BLK 1 "memory_operand")    ;; Dest
-	   (match_operand:BLK 2 "memory_operand"))   ;; Source
-   (use (match_operand:SI     0 "register_operand")) ;; Updated Dest
+  [(set (match_operand:BLK 1 "memory_operand")    ;; Dest
+	(match_operand:BLK 2 "memory_operand"))   ;; Source
+   (use (match_operand:SI  0 "register_operand")) ;; Updated Dest
   ]
   ""
   {
@@ -1487,8 +1854,8 @@
 )
 
 (define_insn "rx_movstr"
-  [(set:SI (mem:BLK (reg:SI 1))
-	   (mem:BLK (reg:SI 2)))
+  [(set (mem:BLK (reg:SI 1))
+	(mem:BLK (reg:SI 2)))
    (unspec_volatile:BLK [(reg:SI 1) (reg:SI 2) (reg:SI 3)] UNSPEC_MOVSTR)
    (clobber (reg:SI 1))
    (clobber (reg:SI 2))
@@ -1500,8 +1867,8 @@
 )
 
 (define_insn "rx_strend"
-  [(set:SI (match_operand:SI                      0 "register_operand" "=r")
-	   (unspec_volatile:SI [(match_operand:SI 1 "register_operand"  "r")
+  [(set (match_operand:SI                      0 "register_operand" "=r")
+	(unspec_volatile:SI [(match_operand:SI 1 "register_operand"  "r")
 				(reg:SI 3)] UNSPEC_STRLEN))
    (clobber (reg:SI 1))
    (clobber (reg:SI 2))
@@ -1582,8 +1949,8 @@
 )
 
 (define_insn "rx_setmem"
-  [(set:BLK (mem:BLK (reg:SI 1)) (reg 2))
-   (unspec_volatile:BLK [(reg:SI 1) (reg:SI 2) (reg:SI 3)] UNSPEC_SETMEM)
+  [(set (mem:BLK (reg:SI 1))
+	(unspec_volatile:BLK [(reg:SI 1) (reg:SI 2) (reg:SI 3)] UNSPEC_SETMEM))
    (clobber (reg:SI 1))
    (clobber (reg:SI 3))]
   ""
@@ -1636,11 +2003,11 @@
 )
 
 (define_insn "rx_cmpstrn"
-  [(set:SI (match_operand:SI 0 "register_operand" "=r")
-	   (unspec_volatile:SI [(reg:SI 1) (reg:SI 2) (reg:SI 3)]
-			       UNSPEC_CMPSTRN))
-   (use (match_operand:BLK   1 "memory_operand" "m"))
-   (use (match_operand:BLK   2 "memory_operand" "m"))
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(unspec_volatile:SI [(reg:SI 1) (reg:SI 2) (reg:SI 3)]
+			    UNSPEC_CMPSTRN))
+   (use (match_operand:BLK 1 "memory_operand" "m"))
+   (use (match_operand:BLK 2 "memory_operand" "m"))
    (clobber (reg:SI 1))
    (clobber (reg:SI 2))
    (clobber (reg:SI 3))
@@ -1773,7 +2140,7 @@
 
 ;; Byte swap (two 16-bit values).
 (define_insn "revw"
-  [(set (match_operand:SI             0 "register_operand" "+r")
+  [(set (match_operand:SI             0 "register_operand" "=r")
 	(unspec:SI [(match_operand:SI 1 "register_operand"  "r")]
 		   UNSPEC_BUILTIN_REVW))]
   ""
@@ -1807,7 +2174,7 @@
 
 ;; Clear Processor Status Word
 (define_insn "clrpsw"
-  [(unspec:SI [(match_operand:SI 0 "immediate_operand" "i")]
+  [(unspec_volatile:SI [(match_operand:SI 0 "immediate_operand" "i")]
 	      UNSPEC_BUILTIN_CLRPSW)
    (clobber (reg:CC CC_REG))]
   ""
@@ -1817,7 +2184,7 @@
 
 ;; Set Processor Status Word
 (define_insn "setpsw"
-  [(unspec:SI [(match_operand:SI 0 "immediate_operand" "i")]
+  [(unspec_volatile:SI [(match_operand:SI 0 "immediate_operand" "i")]
 	      UNSPEC_BUILTIN_SETPSW)
    (clobber (reg:CC CC_REG))]
   ""
@@ -1828,7 +2195,7 @@
 ;; Move from control register
 (define_insn "mvfc"
   [(set (match_operand:SI             0 "register_operand" "=r")
-	(unspec:SI [(match_operand:SI 1 "immediate_operand" "i")]
+	(unspec_volatile:SI [(match_operand:SI 1 "immediate_operand" "i")]
 		   UNSPEC_BUILTIN_MVFC))]
   ""
   "mvfc\t%C1, %0"
@@ -1837,7 +2204,7 @@
 
 ;; Move to control register
 (define_insn "mvtc"
-  [(unspec:SI [(match_operand:SI 0 "immediate_operand" "i,i")
+  [(unspec_volatile:SI [(match_operand:SI 0 "immediate_operand" "i,i")
 	       (match_operand:SI 1 "nonmemory_operand" "r,i")]
 	      UNSPEC_BUILTIN_MVTC)]
   ""
@@ -1852,7 +2219,7 @@
 
 ;; Move to interrupt priority level
 (define_insn "mvtipl"
-  [(unspec:SI [(match_operand:SI 0 "immediate_operand" "Uint04")]
+  [(unspec_volatile:SI [(match_operand:SI 0 "immediate_operand" "Uint04")]
 	      UNSPEC_BUILTIN_MVTIPL)]
   ""
   "mvtipl\t%0"
Index: gcc/config/rx/rx.c
===================================================================
--- gcc/config/rx/rx.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/config/rx/rx.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1,5 +1,5 @@
 /* Subroutines used for code generation on Renesas RX processors.
-   Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.
+   Copyright (C) 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
    Contributed by Red Hat.
 
    This file is part of GCC.
@@ -51,6 +51,12 @@
 #include "target-def.h"
 #include "langhooks.h"
 
+#define CC_FLAG_S	(1 << 0)
+#define CC_FLAG_Z	(1 << 1)
+#define CC_FLAG_O	(1 << 2)
+#define CC_FLAG_C	(1 << 3)
+#define CC_FLAG_FP	(1 << 4)	/* Fake, to differentiate CC_Fmode.  */
+
 enum rx_cpu_types  rx_cpu_type = RX600;
 
 /* Return true if OP is a reference to an object in a small data area.  */
@@ -312,9 +318,18 @@
 	break;
       }
 
+    case CONST:
+      if (GET_CODE (XEXP (addr, 0)) == UNSPEC)
+	{
+	  addr = XEXP (addr, 0);
+	  gcc_assert (XINT (addr, 1) == UNSPEC_CONST);
+      
+	  addr = XVECEXP (addr, 0, 0);
+	  gcc_assert (CONST_INT_P (addr));
+	}
+      /* Fall through.  */
     case LABEL_REF:
     case SYMBOL_REF:
-    case CONST:
       fprintf (file, "#");
     default:
       output_addr_const (file, addr);
@@ -351,9 +366,76 @@
   return true;
 }
 
+/* Convert a CC_MODE to the set of flags that it represents.  */
 
-int rx_float_compare_mode;
+static unsigned int
+flags_from_mode (enum machine_mode mode)
+{
+  switch (mode)
+    {
+    case CC_ZSmode:
+      return CC_FLAG_S | CC_FLAG_Z;
+    case CC_ZSOmode:
+      return CC_FLAG_S | CC_FLAG_Z | CC_FLAG_O;
+    case CC_ZSCmode:
+      return CC_FLAG_S | CC_FLAG_Z | CC_FLAG_C;
+    case CCmode:
+      return CC_FLAG_S | CC_FLAG_Z | CC_FLAG_O | CC_FLAG_C;
+    case CC_Fmode:
+      return CC_FLAG_FP;
+    default:
+      gcc_unreachable ();
+    }
+}
 
+/* Convert a set of flags to a CC_MODE that can implement it.  */
+
+static enum machine_mode
+mode_from_flags (unsigned int f)
+{
+  if (f & CC_FLAG_FP)
+    return CC_Fmode;
+  if (f & CC_FLAG_O)
+    {
+      if (f & CC_FLAG_C)
+	return CCmode;
+      else
+	return CC_ZSOmode;
+    }
+  else if (f & CC_FLAG_C)
+    return CC_ZSCmode;
+  else
+    return CC_ZSmode;
+}
+
+/* Convert an RTX_CODE to the set of flags needed to implement it.
+   This assumes an integer comparison.  */
+
+static unsigned int
+flags_from_code (enum rtx_code code)
+{
+  switch (code)
+    {
+    case LT:
+    case GE:
+      return CC_FLAG_S | CC_FLAG_O;
+    case GT:
+    case LE:
+      return CC_FLAG_S | CC_FLAG_O | CC_FLAG_Z;
+    case GEU:
+    case LTU:
+      return CC_FLAG_C;
+    case GTU:
+    case LEU:
+      return CC_FLAG_C | CC_FLAG_Z;
+    case EQ:
+    case NE:
+      return CC_FLAG_Z;
+    default:
+      gcc_unreachable ();
+    }
+}
+
 /* Handles the insertion of a single operand into the assembler output.
    The %<letter> directives supported are:
 
@@ -393,22 +475,49 @@
       break;
 
     case 'B':
-      switch (GET_CODE (op))
-	{
-	case LT:  fprintf (file, "lt"); break;
-	case GE:  fprintf (file, "ge"); break;
-	case GT:  fprintf (file, "gt"); break;
-	case LE:  fprintf (file, "le"); break;
-	case GEU: fprintf (file, "geu"); break;
-	case LTU: fprintf (file, "ltu"); break;
-	case GTU: fprintf (file, "gtu"); break;
-	case LEU: fprintf (file, "leu"); break;
-	case EQ:  fprintf (file, "eq"); break;
-	case NE:  fprintf (file, "ne"); break;
-	default:  debug_rtx (op); gcc_unreachable ();
-	}
-      break;
+      {
+	enum rtx_code code = GET_CODE (op);
+	enum machine_mode mode = GET_MODE (XEXP (op, 0));
+	const char * ret;
 
+	if (mode == CC_Fmode)
+	  {
+	    /* C flag is undefined, and O flag carries unordered.  None of the
+	       branch combinations that include O use it helpfully.  */
+	    switch (code)
+	      {
+	      case ORDERED:	ret = "no";		break;
+	      case UNORDERED:	ret = "o";		break;
+	      case LT:		ret = "n";		break;
+	      case GE:		ret = "pz";		break;
+	      case EQ:		ret = "eq";		break;
+	      case NE:		ret = "ne";		break;
+	      default:		gcc_unreachable ();
+	      }
+	  }
+	else
+	  {
+	    switch (code)
+	      {
+	      case LT:		ret = "lt";		break;
+	      case GE:		ret = "ge";		break;
+	      case GT:		ret = "gt";		break;
+	      case LE:		ret = "le";		break;
+	      case GEU:		ret = "geu";		break;
+	      case LTU:		ret = "ltu";		break;
+	      case GTU:		ret = "gtu";		break;
+	      case LEU:		ret = "leu";		break;
+	      case EQ:		ret = "eq";		break;
+	      case NE:		ret = "ne";		break;
+	      default:		gcc_unreachable ();
+	      }
+	    gcc_assert ((flags_from_code (code)
+			 & ~flags_from_mode (mode)) == 0);
+	  }
+	fputs (ret, file);
+	break;
+      }
+
     case 'C':
       gcc_assert (CONST_INT_P (op));
       switch (INTVAL (op))
@@ -698,51 +807,6 @@
 	   extension, src_template, dst_template);
   return out_template;
 }
-
-/* Returns an assembler template for a conditional branch instruction.  */
-
-const char *
-rx_gen_cond_branch_template (rtx condition, bool reversed)
-{
-  enum rtx_code code = GET_CODE (condition);
-
-  if (reversed)
-    {
-      if (rx_float_compare_mode)
-	code = reverse_condition_maybe_unordered (code);
-      else
-	code = reverse_condition (code);
-    }
-
-  /* We do not worry about encoding the branch length here as GAS knows
-     how to choose the smallest version, and how to expand a branch that
-     is to a destination that is out of range.  */
-
-  switch (code)
-    {
-    case UNEQ:	    return "bo\t1f\n\tbeq\t%0\n1:";
-    case LTGT:	    return "bo\t1f\n\tbne\t%0\n1:";
-    case UNLT:      return "bo\t1f\n\tbn\t%0\n1:";
-    case UNGE:      return "bo\t1f\n\tbpz\t%0\n1:";
-    case UNLE:      return "bo\t1f\n\tbgt\t1f\n\tbra\t%0\n1:";
-    case UNGT:      return "bo\t1f\n\tble\t1f\n\tbra\t%0\n1:";
-    case UNORDERED: return "bo\t%0";
-    case ORDERED:   return "bno\t%0";
-
-    case LT:        return rx_float_compare_mode ? "bn\t%0" : "blt\t%0";
-    case GE:        return rx_float_compare_mode ? "bpz\t%0" : "bge\t%0";
-    case GT:        return "bgt\t%0";
-    case LE:        return "ble\t%0";
-    case GEU:       return "bgeu\t%0";
-    case LTU:       return "bltu\t%0";
-    case GTU:       return "bgtu\t%0";
-    case LEU:       return "bleu\t%0";
-    case EQ:        return "beq\t%0";
-    case NE:        return "bne\t%0";
-    default:
-      gcc_unreachable ();
-    }
-}
 
 /* Return VALUE rounded up to the next ALIGNMENT boundary.  */
 
@@ -821,9 +885,37 @@
 		   const_tree fn_decl_or_type ATTRIBUTE_UNUSED,
 		   bool       outgoing ATTRIBUTE_UNUSED)
 {
-  return gen_rtx_REG (TYPE_MODE (ret_type), FUNC_RETURN_REGNUM);
+  enum machine_mode mode = TYPE_MODE (ret_type);
+
+  /* RX ABI specifies that small integer types are
+     promoted to int when returned by a function.  */
+  if (GET_MODE_SIZE (mode) > 0
+      && GET_MODE_SIZE (mode) < 4
+      && ! COMPLEX_MODE_P (mode))
+    return gen_rtx_REG (SImode, FUNC_RETURN_REGNUM);
+    
+  return gen_rtx_REG (mode, FUNC_RETURN_REGNUM);
 }
 
+/* TARGET_PROMOTE_FUNCTION_MODE must behave in the same way with
+   regard to function returns as does TARGET_FUNCTION_VALUE.  */
+
+static enum machine_mode
+rx_promote_function_mode (const_tree type ATTRIBUTE_UNUSED,
+			  enum machine_mode mode,
+			  int * punsignedp ATTRIBUTE_UNUSED,
+			  const_tree funtype ATTRIBUTE_UNUSED,
+			  int for_return)
+{
+  if (for_return != 1
+      || GET_MODE_SIZE (mode) >= 4
+      || COMPLEX_MODE_P (mode)
+      || GET_MODE_SIZE (mode) < 1)
+    return mode;
+
+  return SImode;
+}
+
 static bool
 rx_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)
 {
@@ -1058,7 +1150,13 @@
 
   for (save_mask = high = low = 0, reg = 1; reg < CC_REGNUM; reg++)
     {
-      if (df_regs_ever_live_p (reg)
+      if ((df_regs_ever_live_p (reg)
+	   /* Always save all call clobbered registers inside non-leaf
+	      interrupt handlers, even if they are not live - they may
+	      be used in (non-interrupt aware) routines called from this one.  */
+	   || (call_used_regs[reg]
+	       && is_interrupt_func (NULL_TREE)
+	       && ! current_function_is_leaf))
 	  && (! call_used_regs[reg]
 	      /* Even call clobbered registered must
 		 be pushed inside interrupt handlers.  */
@@ -1213,6 +1311,59 @@
     }
 }
 
+static bool
+ok_for_max_constant (HOST_WIDE_INT val)
+{
+  if (rx_max_constant_size == 0  || rx_max_constant_size == 4)
+    /* If there is no constraint on the size of constants
+       used as operands, then any value is legitimate.  */
+    return true;
+
+  /* rx_max_constant_size specifies the maximum number
+     of bytes that can be used to hold a signed value.  */
+  return IN_RANGE (val, (-1 << (rx_max_constant_size * 8)),
+		        ( 1 << (rx_max_constant_size * 8)));
+}
+
+/* Generate an ADD of SRC plus VAL into DEST.
+   Handles the case where VAL is too big for max_constant_value.
+   Sets FRAME_RELATED_P on the insn if IS_FRAME_RELATED is true.  */
+
+static void
+gen_safe_add (rtx dest, rtx src, rtx val, bool is_frame_related)
+{
+  rtx insn;
+
+  if (val == NULL_RTX || INTVAL (val) == 0)
+    {
+      gcc_assert (dest != src);
+
+      insn = emit_move_insn (dest, src);
+    }
+  else if (ok_for_max_constant (INTVAL (val)))
+    insn = emit_insn (gen_addsi3 (dest, src, val));
+  else
+    {
+      /* Wrap VAL in an UNSPEC so that rx_is_legitimate_constant
+	 will not reject it.  */
+      val = gen_rtx_CONST (SImode, gen_rtx_UNSPEC (SImode, gen_rtvec (1, val), UNSPEC_CONST));
+      insn = emit_insn (gen_addsi3 (dest, src, val));
+
+      if (is_frame_related)
+	/* We have to provide our own frame related note here
+	   as the dwarf2out code cannot be expected to grok
+	   our unspec.  */
+	add_reg_note (insn, REG_FRAME_RELATED_EXPR,
+		      gen_rtx_SET (SImode, dest,
+				   gen_rtx_PLUS (SImode, src, val)));
+      return;
+    }
+
+  if (is_frame_related)
+    RTX_FRAME_RELATED_P (insn) = 1;
+  return;
+}
+
 void
 rx_expand_prologue (void)
 {
@@ -1298,24 +1449,13 @@
 	  emit_insn (gen_stack_pushm (GEN_INT (2 * UNITS_PER_WORD),
 				      gen_rx_store_vector (acc_low, acc_high)));
 	}
-
-      frame_size += 2 * UNITS_PER_WORD;
     }
 
   /* If needed, set up the frame pointer.  */
   if (frame_pointer_needed)
-    {
-      if (frame_size)
-	insn = emit_insn (gen_addsi3 (frame_pointer_rtx, stack_pointer_rtx,
-				      GEN_INT (- (HOST_WIDE_INT) frame_size)));
-      else
-	insn = emit_move_insn (frame_pointer_rtx, stack_pointer_rtx);
+    gen_safe_add (frame_pointer_rtx, stack_pointer_rtx,
+		  GEN_INT (- (HOST_WIDE_INT) frame_size), true);
 
-      RTX_FRAME_RELATED_P (insn) = 1;
-    }
-
-  insn = NULL_RTX;
-
   /* Allocate space for the outgoing args.
      If the stack frame has not already been set up then handle this as well.  */
   if (stack_size)
@@ -1323,29 +1463,26 @@
       if (frame_size)
 	{
 	  if (frame_pointer_needed)
-	    insn = emit_insn (gen_addsi3 (stack_pointer_rtx, frame_pointer_rtx,
-					  GEN_INT (- (HOST_WIDE_INT)
-						   stack_size)));
+	    gen_safe_add (stack_pointer_rtx, frame_pointer_rtx,
+			  GEN_INT (- (HOST_WIDE_INT) stack_size), true);
 	  else
-	    insn = emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,
-					  GEN_INT (- (HOST_WIDE_INT)
-						   (frame_size + stack_size))));
+	    gen_safe_add (stack_pointer_rtx, stack_pointer_rtx,
+			  GEN_INT (- (HOST_WIDE_INT) (frame_size + stack_size)),
+			  true);
 	}
       else
-	insn = emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,
-				      GEN_INT (- (HOST_WIDE_INT) stack_size)));
+	gen_safe_add (stack_pointer_rtx, stack_pointer_rtx,
+		      GEN_INT (- (HOST_WIDE_INT) stack_size), true);
     }
   else if (frame_size)
     {
       if (! frame_pointer_needed)
-	insn = emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,
-				      GEN_INT (- (HOST_WIDE_INT) frame_size)));
+	gen_safe_add (stack_pointer_rtx, stack_pointer_rtx,
+		      GEN_INT (- (HOST_WIDE_INT) frame_size), true);
       else
-	insn = emit_move_insn (stack_pointer_rtx, frame_pointer_rtx);
+	gen_safe_add (stack_pointer_rtx, frame_pointer_rtx, NULL_RTX,
+		      true);
     }
-
-  if (insn != NULL_RTX)
-    RTX_FRAME_RELATED_P (insn) = 1;
 }
 
 static void
@@ -1523,8 +1660,8 @@
     {
       /* Cannot use the special instructions - deconstruct by hand.  */
       if (total_size)
-	emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,
-			       GEN_INT (total_size)));
+	gen_safe_add (stack_pointer_rtx, stack_pointer_rtx,
+		      GEN_INT (total_size), false);
 
       if (MUST_SAVE_ACC_REGISTER)
 	{
@@ -1615,8 +1752,8 @@
 	  return;
 	}
 
-      emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,
-			     GEN_INT (total_size)));
+      gen_safe_add (stack_pointer_rtx, stack_pointer_rtx,
+		    GEN_INT (total_size), false);
     }
 
   if (low)
@@ -1893,7 +2030,7 @@
   if (rx_cpu_type == RX610)
     return NULL_RTX;
 
-  if (! CONST_INT_P (arg) || ! IN_RANGE (arg, 0, (1 << 4) - 1))
+  if (! CONST_INT_P (arg) || ! IN_RANGE (INTVAL (arg), 0, (1 << 4) - 1))
     return NULL_RTX;
 
   emit_insn (gen_mvtipl (arg));
@@ -1962,6 +2099,31 @@
   return target;
 }
 
+static int
+valid_psw_flag (rtx op, const char *which)
+{
+  static int mvtc_inform_done = 0;
+
+  if (GET_CODE (op) == CONST_INT)
+    switch (INTVAL (op))
+      {
+      case 0: case 'c': case 'C':
+      case 1: case 'z': case 'Z':
+      case 2: case 's': case 'S':
+      case 3: case 'o': case 'O':
+      case 8: case 'i': case 'I':
+      case 9: case 'u': case 'U':
+	return 1;
+      }
+
+  error ("__builtin_rx_%s takes 'C', 'Z', 'S', 'O', 'I', or 'U'", which);
+  if (!mvtc_inform_done)
+    error ("use __builtin_rx_mvtc (0, ... ) to write arbitrary values to PSW");
+  mvtc_inform_done = 1;
+
+  return 0;
+}
+
 static rtx
 rx_expand_builtin (tree exp,
 		   rtx target,
@@ -1977,10 +2139,14 @@
   switch (fcode)
     {
     case RX_BUILTIN_BRK:     emit_insn (gen_brk ()); return NULL_RTX;
-    case RX_BUILTIN_CLRPSW:  return rx_expand_void_builtin_1_arg
-	(op, gen_clrpsw, false);
-    case RX_BUILTIN_SETPSW:  return rx_expand_void_builtin_1_arg
-	(op, gen_setpsw, false);
+    case RX_BUILTIN_CLRPSW:  
+      if (! valid_psw_flag (op, "clrpsw"))
+	return NULL_RTX;
+      return rx_expand_void_builtin_1_arg (op, gen_clrpsw, false);
+      if (! valid_psw_flag (op, "setpsw"))
+	return NULL_RTX;
+      return rx_expand_void_builtin_1_arg (op, gen_setpsw, false);
+    case RX_BUILTIN_SETPSW:  
     case RX_BUILTIN_INT:     return rx_expand_void_builtin_1_arg
 	(op, gen_int, false);
     case RX_BUILTIN_MACHI:   return rx_expand_builtin_mac (exp, gen_machi);
@@ -2186,7 +2352,6 @@
 	error ("Changing the FPU insns/math optimizations pairing is not supported");
     }
 }
-
 
 static bool
 rx_allocate_stack_slots_for_args (void)
@@ -2233,50 +2398,10 @@
 static bool
 rx_is_ms_bitfield_layout (const_tree record_type ATTRIBUTE_UNUSED)
 {
-  return TRUE;
+  /* The packed attribute overrides the MS behaviour.  */
+  return ! TYPE_PACKED (record_type);
 }
 
-/* Try to generate code for the "isnv" pattern which inserts bits
-   into a word.
-     operands[0] => Location to be altered.
-     operands[1] => Number of bits to change.
-     operands[2] => Starting bit.
-     operands[3] => Value to insert.
-   Returns TRUE if successful, FALSE otherwise.  */
-
-bool
-rx_expand_insv (rtx * operands)
-{
-  if (INTVAL (operands[1]) != 1
-      || ! CONST_INT_P (operands[3]))
-    return false;
-
-  if (MEM_P (operands[0])
-      && INTVAL (operands[2]) > 7)
-    return false;
-
-  switch (INTVAL (operands[3]))
-    {
-    case 0:
-      if (MEM_P (operands[0]))
-	emit_insn (gen_bitclr_in_memory (operands[0], operands[0],
-					 operands[2]));
-      else
-	emit_insn (gen_bitclr (operands[0], operands[0], operands[2]));
-      break;
-    case 1:
-    case -1:
-      if (MEM_P (operands[0]))
-	emit_insn (gen_bitset_in_memory (operands[0], operands[0],
-					 operands[2]));
-      else
-	emit_insn (gen_bitset (operands[0], operands[0], operands[2]));
-      break;
-   default:
-      return false;
-    }
-  return true;
-}
 
 /* Returns true if X a legitimate constant for an immediate
    operand on the RX.  X is already known to satisfy CONSTANT_P.  */
@@ -2284,8 +2409,6 @@
 bool
 rx_is_legitimate_constant (rtx x)
 {
-  HOST_WIDE_INT val;
-
   switch (GET_CODE (x))
     {
     case CONST:
@@ -2308,7 +2431,9 @@
 	case SYMBOL_REF:
 	  return true;
 
-	  /* One day we may have to handle UNSPEC constants here.  */
+	case UNSPEC:
+	  return XINT (x, 1) == UNSPEC_CONST;
+
 	default:
 	  /* FIXME: Can this ever happen ?  */
 	  abort ();
@@ -2328,17 +2453,7 @@
       break;
     }
 
-  if (rx_max_constant_size == 0  || rx_max_constant_size == 4)
-    /* If there is no constraint on the size of constants
-       used as operands, then any value is legitimate.  */
-    return true;
-
-  val = INTVAL (x);
-
-  /* rx_max_constant_size specifies the maximum number
-     of bytes that can be used to hold a signed value.  */
-  return IN_RANGE (val, (-1 << (rx_max_constant_size * 8)),
-		        ( 1 << (rx_max_constant_size * 8)));
+  return ok_for_max_constant (INTVAL (x));
 }
 
 static int
@@ -2462,211 +2577,83 @@
     }
 }
 
+/* Return a CC_MODE of which both M1 and M2 are subsets.  */
+
 static enum machine_mode
 rx_cc_modes_compatible (enum machine_mode m1, enum machine_mode m2)
 {
-  if (m1 == CCmode)
-    return m2;
-  if (m2 == CCmode)
-    return m1;
+  unsigned f;
+
+  /* Early out for identical modes.  */
   if (m1 == m2)
     return m1;
-  if (m1 == CC_ZSmode)
-    return m1;
-  if (m2 == CC_ZSmode)
-    return m2;
-  return VOIDmode;   
+
+  /* There's no valid combination for FP vs non-FP.  */
+  f = flags_from_mode (m1) | flags_from_mode (m2);
+  if (f & CC_FLAG_FP)
+    return VOIDmode;
+
+  /* Otherwise, see what mode can implement all the flags.  */
+  return mode_from_flags (f);
 }
 
-#define CC_FLAG_S (1 << 0)
-#define CC_FLAG_Z (1 << 1)
-#define CC_FLAG_O (1 << 2)
-#define CC_FLAG_C (1 << 3)
+/* Return the minimal CC mode needed to implement (CMP_CODE X Y).  */
 
-static unsigned int
-flags_needed_for_conditional (rtx conditional)
+enum machine_mode
+rx_select_cc_mode (enum rtx_code cmp_code, rtx x, rtx y ATTRIBUTE_UNUSED)
 {
-  switch (GET_CODE (conditional))
-    {
-    case LE:
-    case GT:	return CC_FLAG_S | CC_FLAG_Z | CC_FLAG_O;
+  if (GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)
+    return CC_Fmode;
 
-    case LEU:
-    case GTU:	return CC_FLAG_Z | CC_FLAG_C;
+  return mode_from_flags (flags_from_code (cmp_code));
+}
 
-    case LT:
-    case GE:	return CC_FLAG_S | CC_FLAG_O;
+/* Split the conditional branch.  Emit (COMPARE C1 C2) into CC_REG with
+   CC_MODE, and use that in branches based on that compare.  */
 
-    case LTU:
-    case GEU:	return CC_FLAG_C;
+void
+rx_split_cbranch (enum machine_mode cc_mode, enum rtx_code cmp1,
+		  rtx c1, rtx c2, rtx label)
+{
+  rtx flags, x;
 
-    case EQ:
-    case NE:	return CC_FLAG_Z;
+  flags = gen_rtx_REG (cc_mode, CC_REG);
+  x = gen_rtx_COMPARE (cc_mode, c1, c2);
+  x = gen_rtx_SET (VOIDmode, flags, x);
+  emit_insn (x);
 
-    default:	gcc_unreachable ();
-    }
+  x = gen_rtx_fmt_ee (cmp1, VOIDmode, flags, const0_rtx);
+  x = gen_rtx_IF_THEN_ELSE (VOIDmode, x, label, pc_rtx);
+  x = gen_rtx_SET (VOIDmode, pc_rtx, x);
+  emit_jump_insn (x);
 }
 
-static unsigned int
-flags_from_mode (enum machine_mode mode)
-{
-  switch (mode)
-    {
-    case CCmode:     return CC_FLAG_S | CC_FLAG_Z | CC_FLAG_O | CC_FLAG_C;
-    case CC_ZSmode:  return CC_FLAG_S | CC_FLAG_Z;
-    case CC_ZSOmode: return CC_FLAG_S | CC_FLAG_Z | CC_FLAG_O;
-    case CC_ZSCmode: return CC_FLAG_S | CC_FLAG_Z | CC_FLAG_C;
-    default:         gcc_unreachable ();
-    }
-}
+/* A helper function for matching parallels that set the flags.  */
 
-/* Returns true if a compare insn is redundant because it
-   would only set flags that are already set correctly.  */
-
 bool
-rx_compare_redundant (rtx cmp)
+rx_match_ccmode (rtx insn, enum machine_mode cc_mode)
 {
-  unsigned int flags_needed;
-  unsigned int flags_set;
-  rtx next;
-  rtx prev;
-  rtx source;
-  rtx dest;
-  static rtx cc_reg = NULL_RTX;
+  rtx op1, flags;
+  enum machine_mode flags_mode;
 
-  if (cc_reg == NULL_RTX)
-    cc_reg = gen_rtx_REG (CCmode, CC_REGNUM);
+  gcc_assert (XVECLEN (PATTERN (insn), 0) == 2);
 
-  /* We can only eliminate compares against 0.  */
-  if (GET_CODE (XEXP (SET_SRC (PATTERN (cmp)), 1)) != CONST_INT
-      || INTVAL (XEXP (SET_SRC (PATTERN (cmp)), 1)) != 0)
-    return false;
+  op1 = XVECEXP (PATTERN (insn), 0, 1);
+  gcc_assert (GET_CODE (SET_SRC (op1)) == COMPARE);
 
-  /* Locate the branch insn that follows the
-     compare and which tests the bits in the PSW.  */
-  next = cmp;
-  do
-    {
-      /* If we have found an insn that sets or clobbers the CC
-	 register and it was not the IF_THEN_ELSE insn that we
-	 are looking for, then the comparison is redundant.  */
-      if (next != cmp && reg_mentioned_p (cc_reg, PATTERN (next)))
-	return true;
+  flags = SET_DEST (op1);
+  flags_mode = GET_MODE (flags);
 
-      next = next_nonnote_insn (next);
+  if (GET_MODE (SET_SRC (op1)) != flags_mode)
+    return false;
+  if (GET_MODE_CLASS (flags_mode) != MODE_CC)
+    return false;
 
-      /* If we run out of insns without finding the
-	 user then the comparison is unnecessary.  */
-      if (next == NULL_RTX)
-	return true;
+  /* Ensure that the mode of FLAGS is compatible with CC_MODE.  */
+  if (flags_from_mode (flags_mode) & ~flags_from_mode (cc_mode))
+    return false;
 
-      /* If we have found another comparison
-	 insn then the first one is redundant.  */
-      if (INSN_P (next)
-	  && GET_CODE (PATTERN (next)) == SET
-	  && REG_P (SET_DEST (PATTERN (next)))
-	  && REGNO (SET_DEST (PATTERN (next))) == CC_REGNUM)
-	return true;
-
-      /* If we have found another arithmetic/logic insn that
-	 sets the PSW flags then the comparison is redundant.  */
-      if (INSN_P (next)
-	  && GET_CODE (PATTERN (next)) == PARALLEL
-	  && GET_CODE (XVECEXP (PATTERN (next), 0, 1)) == SET
-	  && REG_P (SET_DEST (XVECEXP (PATTERN (next), 0, 1)))
-	  && REGNO (SET_DEST (XVECEXP (PATTERN (next), 0, 1))) == CC_REGNUM)
-	return true;
-
-      /* If we have found an unconditional branch then the
-	 PSW flags might be carried along with the jump, so
-	 the comparison is necessary.  */
-      if (INSN_P (next) && JUMP_P (next))
-	{
-	  if (GET_CODE (PATTERN (next)) != SET)
-	    /* If the jump does not involve setting the PC
-	       then it is a return of some kind, and we know
-	       that the comparison is not used.  */
-	    return true;
-
-	  if (GET_CODE (SET_SRC (PATTERN (next))) != IF_THEN_ELSE)
-	    return false;
-	}
-    }
-  while (! INSN_P (next)
-	 || DEBUG_INSN_P (next)
-	 || GET_CODE (PATTERN (next)) != SET
-	 || GET_CODE (SET_SRC (PATTERN (next))) != IF_THEN_ELSE);
-
-  flags_needed = flags_needed_for_conditional (XEXP (SET_SRC (PATTERN (next)), 0));
-
-  /* Now look to see if there was a previous
-     instruction which set the PSW bits.  */
-  source = XEXP (SET_SRC (PATTERN (cmp)), 0);
-  prev = cmp;
-  do
-    {
-      /* If this insn uses/sets/clobbers the CC register
-	 and it is not the insn that we are looking for
-	 below, then we must need the comparison.  */
-      if (prev != cmp && reg_mentioned_p (cc_reg, PATTERN (prev)))
-	return false;
-
-      prev = prev_nonnote_insn (prev);
-
-      if (prev == NULL_RTX)
-	return false;
-
-      /* If we encounter an insn which changes the contents of
-	 the register which is the source of the comparison then
-	 we will definitely need the comparison.  */
-      if (INSN_P (prev)
-	  && GET_CODE (PATTERN (prev)) == SET
-	  && rtx_equal_p (SET_DEST (PATTERN (prev)), source))
-	{
-	  /* Unless this instruction is a simple register move
-	     instruction.  In which case we can continue our
-	     scan backwards, but now using the *source* of this
-	     set instruction.  */
-	  if (REG_P (SET_SRC (PATTERN (prev))))
-	    source = SET_SRC (PATTERN (prev));
-	  /* We can also survive a sign-extension if the test is
-	     for EQ/NE.  Note the same does not apply to zero-
-	     extension as this can turn a non-zero bit-pattern
-	     into zero.  */
-	  else if (flags_needed == CC_FLAG_Z
-		   && GET_CODE (SET_SRC (PATTERN (prev))) == SIGN_EXTEND)
-	    source = XEXP (SET_SRC (PATTERN (prev)), 0);
-	  else
-	    return false;
-	}
-
-      /* A label means a possible branch into the
-	 code here, so we have to stop scanning.  */
-      if (LABEL_P (prev))
-	return false;
-    }
-  while (! INSN_P (prev)
-	 || DEBUG_INSN_P (prev)
-	 || GET_CODE (PATTERN (prev)) != PARALLEL
-	 || GET_CODE (XVECEXP (PATTERN (prev), 0, 1)) != SET
-	 || ! REG_P (SET_DEST (XVECEXP (PATTERN (prev), 0, 1)))
-	 || REGNO (SET_DEST (XVECEXP (PATTERN (prev), 0, 1))) != CC_REGNUM);
-
-  flags_set = flags_from_mode (GET_MODE (SET_DEST (XVECEXP (PATTERN (prev), 0, 1))));
-
-  dest = SET_DEST (XVECEXP (PATTERN (prev), 0, 0));
-  /* The destination of the previous arithmetic/logic instruction
-     must match the source in the comparison operation.  For registers
-     we ignore the mode as there may have been a sign-extension involved.  */
-  if (! rtx_equal_p (source, dest))
-    {
-      if (REG_P (source) && REG_P (dest) && REGNO (dest) == REGNO (source))
-	;
-      else
-	return false;
-    }
-
-  return ((flags_set & flags_needed) == flags_needed);
+  return true;
 }
 
 #undef  TARGET_FUNCTION_VALUE
@@ -2759,6 +2746,9 @@
 #undef  TARGET_CC_MODES_COMPATIBLE
 #define TARGET_CC_MODES_COMPATIBLE		rx_cc_modes_compatible
 
+#undef  TARGET_PROMOTE_FUNCTION_MODE
+#define TARGET_PROMOTE_FUNCTION_MODE		rx_promote_function_mode
+
 struct gcc_target targetm = TARGET_INITIALIZER;
 
 /* #include "gt-rx.h" */
Index: gcc/config/rx/rx-modes.def
===================================================================
--- gcc/config/rx/rx-modes.def	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/config/rx/rx-modes.def	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1,5 +1,6 @@
-/* Definitions of target machine for GNU compiler, for RX.
-   Copyright (C) 2010 by Nick Clifton (nickc@redhat.com).
+/* Definitions of target specific machine modes for the RX.
+   Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.
+   Contributed by Red Hat.
 
    This file is part of GCC.
 
@@ -20,3 +21,5 @@
 CC_MODE (CC_ZS);
 CC_MODE (CC_ZSO);
 CC_MODE (CC_ZSC);
+
+CC_MODE (CC_F);		/* fcmp */
Index: gcc/config/i386/i386.md
===================================================================
--- gcc/config/i386/i386.md	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/config/i386/i386.md	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -92,6 +92,7 @@
    (UNSPEC_TLS_GD		21)
    (UNSPEC_TLS_LD_BASE		22)
    (UNSPEC_TLSDESC		23)
+   (UNSPEC_TLS_IE_SUN		24)
 
    ; Other random patterns
    (UNSPEC_SCAS			30)
@@ -14702,6 +14703,18 @@
    (set_attr "memory" "load")
    (set_attr "imm_disp" "false")])
 
+;; The Sun linker took the AMD64 TLS spec literally and can only handle
+;; %rax as destination of the initial executable code sequence.
+(define_insn "tls_initial_exec_64_sun"
+  [(set (match_operand:DI 0 "register_operand" "=a")
+	(unspec:DI
+	 [(match_operand:DI 1 "tls_symbolic_operand" "")]
+	 UNSPEC_TLS_IE_SUN))
+   (clobber (reg:CC FLAGS_REG))]
+  "TARGET_64BIT && TARGET_SUN_TLS"
+  "mov{q}\t{%%fs:0, %0|%0, QWORD PTR fs:0}\n\tadd{q}\t{%a1@gottpoff(%%rip), %0|%0, %a1@gottpoff[rip]}"
+  [(set_attr "type" "multi")])
+
 ;; GNU2 TLS patterns can be split.
 
 (define_expand "tls_dynamic_gnu2_32"
Index: gcc/config/i386/sse.md
===================================================================
--- gcc/config/i386/sse.md	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/config/i386/sse.md	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -5011,7 +5011,7 @@
    movsd\t{%2, %0|%0, %2}
    movlpd\t{%2, %0|%0, %2}
    movsd\t{%2, %0|%0, %2}
-   shufpd\t{$2, %2, %0|%0, %2, 2}
+   shufpd\t{$2, %1, %0|%0, %1, 2}
    movhpd\t{%H1, %0|%0, %H1}
    #
    #
@@ -5090,7 +5090,7 @@
    movsd\t{%2, %0|%0, %2}
    movlpd\t{%2, %0|%0, %2}
    movlpd\t{%2, %0|%0, %2}
-   shufpd\t{$2, %2, %0|%0, %2, 2}
+   shufpd\t{$2, %1, %0|%0, %1, 2}
    movhps\t{%H1, %0|%0, %H1}
    movhps\t{%1, %H0|%H0, %1}"
   [(set_attr "type" "ssemov,ssemov,ssemov,sselog,ssemov,ssemov")
@@ -12097,7 +12097,7 @@
   [(set (match_operand:AVXMODEF2P 0 "register_operand" "=x")
 	(unspec:AVXMODEF2P
 	  [(match_operand:AVXMODEF2P 1 "memory_operand" "m")
-	   (match_operand:AVXMODEF2P 2 "register_operand" "x")
+	   (match_operand:<avxpermvecmode> 2 "register_operand" "x")
 	   (match_dup 0)]
 	  UNSPEC_MASKLOAD))]
   "TARGET_AVX"
@@ -12110,7 +12110,7 @@
 (define_insn "avx_maskstorep<avxmodesuffixf2c><avxmodesuffix>"
   [(set (match_operand:AVXMODEF2P 0 "memory_operand" "=m")
 	(unspec:AVXMODEF2P
-	  [(match_operand:AVXMODEF2P 1 "register_operand" "x")
+	  [(match_operand:<avxpermvecmode> 1 "register_operand" "x")
 	   (match_operand:AVXMODEF2P 2 "register_operand" "x")
 	   (match_dup 0)]
 	  UNSPEC_MASKSTORE))]
Index: gcc/config/i386/i386-builtin-types.def
===================================================================
--- gcc/config/i386/i386-builtin-types.def	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/config/i386/i386-builtin-types.def	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -229,7 +229,7 @@
 DEF_FUNCTION_TYPE (V1DI, V1DI, V1DI)
 DEF_FUNCTION_TYPE (V1DI, V2SI, V2SI)
 DEF_FUNCTION_TYPE (V1DI, V8QI, V8QI)
-DEF_FUNCTION_TYPE (V2DF, PCV2DF, V2DF)
+DEF_FUNCTION_TYPE (V2DF, PCV2DF, V2DI)
 DEF_FUNCTION_TYPE (V2DF, V2DF, DI)
 DEF_FUNCTION_TYPE (V2DF, V2DF, INT)
 DEF_FUNCTION_TYPE (V2DF, V2DF, PCDOUBLE)
@@ -251,7 +251,7 @@
 DEF_FUNCTION_TYPE (V2SI, V2SI, SI)
 DEF_FUNCTION_TYPE (V2SI, V2SI, V2SI)
 DEF_FUNCTION_TYPE (V2SI, V4HI, V4HI)
-DEF_FUNCTION_TYPE (V4DF, PCV4DF, V4DF)
+DEF_FUNCTION_TYPE (V4DF, PCV4DF, V4DI)
 DEF_FUNCTION_TYPE (V4DF, V4DF, INT)
 DEF_FUNCTION_TYPE (V4DF, V4DF, V4DF)
 DEF_FUNCTION_TYPE (V4DF, V4DF, V4DI)
@@ -260,7 +260,7 @@
 DEF_FUNCTION_TYPE (V4HI, V4HI, SI)
 DEF_FUNCTION_TYPE (V4HI, V4HI, V4HI)
 DEF_FUNCTION_TYPE (V4HI, V8QI, V8QI)
-DEF_FUNCTION_TYPE (V4SF, PCV4SF, V4SF)
+DEF_FUNCTION_TYPE (V4SF, PCV4SF, V4SI)
 DEF_FUNCTION_TYPE (V4SF, V4SF, DI)
 DEF_FUNCTION_TYPE (V4SF, V4SF, INT)
 DEF_FUNCTION_TYPE (V4SF, V4SF, PCV2SF)
@@ -284,7 +284,7 @@
 DEF_FUNCTION_TYPE (V8HI, V8HI, V8HI)
 DEF_FUNCTION_TYPE (V8QI, V4HI, V4HI)
 DEF_FUNCTION_TYPE (V8QI, V8QI, V8QI)
-DEF_FUNCTION_TYPE (V8SF, PCV8SF, V8SF)
+DEF_FUNCTION_TYPE (V8SF, PCV8SF, V8SI)
 DEF_FUNCTION_TYPE (V8SF, V8SF, INT)
 DEF_FUNCTION_TYPE (V8SF, V8SF, V8SF)
 DEF_FUNCTION_TYPE (V8SF, V8SF, V8SI)
@@ -343,10 +343,10 @@
 DEF_FUNCTION_TYPE (V8SI, V8SI, V8SI, INT)
 DEF_FUNCTION_TYPE (V8SI, V8SI, V8SI, V8SI)
 DEF_FUNCTION_TYPE (VOID, PCVOID, UNSIGNED, UNSIGNED)
-DEF_FUNCTION_TYPE (VOID, PV2DF, V2DF, V2DF)
-DEF_FUNCTION_TYPE (VOID, PV4DF, V4DF, V4DF)
-DEF_FUNCTION_TYPE (VOID, PV4SF, V4SF, V4SF)
-DEF_FUNCTION_TYPE (VOID, PV8SF, V8SF, V8SF)
+DEF_FUNCTION_TYPE (VOID, PV2DF, V2DI, V2DF)
+DEF_FUNCTION_TYPE (VOID, PV4DF, V4DI, V4DF)
+DEF_FUNCTION_TYPE (VOID, PV4SF, V4SI, V4SF)
+DEF_FUNCTION_TYPE (VOID, PV8SF, V8SI, V8SF)
 DEF_FUNCTION_TYPE (VOID, UINT, UINT, UINT)
 DEF_FUNCTION_TYPE (VOID, UINT64, UINT, UINT)
 DEF_FUNCTION_TYPE (VOID, V16QI, V16QI, PCHAR)
Index: gcc/config/i386/avxintrin.h
===================================================================
--- gcc/config/i386/avxintrin.h	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/config/i386/avxintrin.h	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -890,55 +890,55 @@
 }
 
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
-_mm_maskload_pd (double const *__P, __m128d __M)
+_mm_maskload_pd (double const *__P, __m128i __M)
 {
   return (__m128d) __builtin_ia32_maskloadpd ((const __v2df *)__P,
-					      (__v2df)__M);
+					      (__v2di)__M);
 }
 
 extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
-_mm_maskstore_pd (double *__P, __m128d __M, __m128d __A)
+_mm_maskstore_pd (double *__P, __m128i __M, __m128d __A)
 {
-  __builtin_ia32_maskstorepd ((__v2df *)__P, (__v2df)__M, (__v2df)__A);
+  __builtin_ia32_maskstorepd ((__v2df *)__P, (__v2di)__M, (__v2df)__A);
 }
 
 extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
-_mm256_maskload_pd (double const *__P, __m256d __M)
+_mm256_maskload_pd (double const *__P, __m256i __M)
 {
   return (__m256d) __builtin_ia32_maskloadpd256 ((const __v4df *)__P,
-						 (__v4df)__M);
+						 (__v4di)__M);
 }
 
 extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
-_mm256_maskstore_pd (double *__P, __m256d __M, __m256d __A)
+_mm256_maskstore_pd (double *__P, __m256i __M, __m256d __A)
 {
-  __builtin_ia32_maskstorepd256 ((__v4df *)__P, (__v4df)__M, (__v4df)__A);
+  __builtin_ia32_maskstorepd256 ((__v4df *)__P, (__v4di)__M, (__v4df)__A);
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
-_mm_maskload_ps (float const *__P, __m128 __M)
+_mm_maskload_ps (float const *__P, __m128i __M)
 {
   return (__m128) __builtin_ia32_maskloadps ((const __v4sf *)__P,
-					     (__v4sf)__M);
+					     (__v4si)__M);
 }
 
 extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
-_mm_maskstore_ps (float *__P, __m128 __M, __m128 __A)
+_mm_maskstore_ps (float *__P, __m128i __M, __m128 __A)
 {
-  __builtin_ia32_maskstoreps ((__v4sf *)__P, (__v4sf)__M, (__v4sf)__A);
+  __builtin_ia32_maskstoreps ((__v4sf *)__P, (__v4si)__M, (__v4sf)__A);
 }
 
 extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
-_mm256_maskload_ps (float const *__P, __m256 __M)
+_mm256_maskload_ps (float const *__P, __m256i __M)
 {
   return (__m256) __builtin_ia32_maskloadps256 ((const __v8sf *)__P,
-						(__v8sf)__M);
+						(__v8si)__M);
 }
 
 extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
-_mm256_maskstore_ps (float *__P, __m256 __M, __m256 __A)
+_mm256_maskstore_ps (float *__P, __m256i __M, __m256 __A)
 {
-  __builtin_ia32_maskstoreps256 ((__v8sf *)__P, (__v8sf)__M, (__v8sf)__A);
+  __builtin_ia32_maskstoreps256 ((__v8sf *)__P, (__v8si)__M, (__v8sf)__A);
 }
 
 extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
Index: gcc/config/i386/i386.c
===================================================================
--- gcc/config/i386/i386.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/config/i386/i386.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -10438,6 +10438,17 @@
     case TLS_MODEL_INITIAL_EXEC:
       if (TARGET_64BIT)
 	{
+	  if (TARGET_SUN_TLS)
+	    {
+	      /* The Sun linker took the AMD64 TLS spec literally
+		 and can only handle %rax as destination of the
+		 initial executable code sequence.  */
+
+	      dest = gen_reg_rtx (Pmode);
+	      emit_insn (gen_tls_initial_exec_64_sun (dest, x));
+	      return dest;
+	    }
+
 	  pic = NULL;
 	  type = UNSPEC_GOTNTPOFF;
 	}
@@ -11027,7 +11038,11 @@
 	return orig_x;
       x = XVECEXP (XEXP (x, 0), 0, 0);
       if (GET_MODE (orig_x) != Pmode)
-	return simplify_gen_subreg (GET_MODE (orig_x), x, Pmode, 0);
+	{
+	  x = simplify_gen_subreg (GET_MODE (orig_x), x, Pmode, 0);
+	  if (x == NULL_RTX)
+	    return orig_x;
+	}
       return x;
     }
 
@@ -11096,7 +11111,11 @@
 	return orig_x;
     }
   if (GET_MODE (orig_x) != Pmode && MEM_P (orig_x))
-    return simplify_gen_subreg (GET_MODE (orig_x), result, Pmode, 0);
+    {
+      result = simplify_gen_subreg (GET_MODE (orig_x), result, Pmode, 0);
+      if (result == NULL_RTX)
+	return orig_x;
+    }
   return result;
 }
 
@@ -21638,14 +21657,14 @@
   { OPTION_MASK_ISA_AVX, CODE_FOR_avx_movntv4df, "__builtin_ia32_movntpd256", IX86_BUILTIN_MOVNTPD256, UNKNOWN, (int) VOID_FTYPE_PDOUBLE_V4DF },
   { OPTION_MASK_ISA_AVX, CODE_FOR_avx_movntv8sf, "__builtin_ia32_movntps256", IX86_BUILTIN_MOVNTPS256, UNKNOWN, (int) VOID_FTYPE_PFLOAT_V8SF },
 
-  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_maskloadpd, "__builtin_ia32_maskloadpd", IX86_BUILTIN_MASKLOADPD, UNKNOWN, (int) V2DF_FTYPE_PCV2DF_V2DF },
-  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_maskloadps, "__builtin_ia32_maskloadps", IX86_BUILTIN_MASKLOADPS, UNKNOWN, (int) V4SF_FTYPE_PCV4SF_V4SF },
-  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_maskloadpd256, "__builtin_ia32_maskloadpd256", IX86_BUILTIN_MASKLOADPD256, UNKNOWN, (int) V4DF_FTYPE_PCV4DF_V4DF },
-  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_maskloadps256, "__builtin_ia32_maskloadps256", IX86_BUILTIN_MASKLOADPS256, UNKNOWN, (int) V8SF_FTYPE_PCV8SF_V8SF },
-  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_maskstorepd, "__builtin_ia32_maskstorepd", IX86_BUILTIN_MASKSTOREPD, UNKNOWN, (int) VOID_FTYPE_PV2DF_V2DF_V2DF },
-  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_maskstoreps, "__builtin_ia32_maskstoreps", IX86_BUILTIN_MASKSTOREPS, UNKNOWN, (int) VOID_FTYPE_PV4SF_V4SF_V4SF },
-  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_maskstorepd256, "__builtin_ia32_maskstorepd256", IX86_BUILTIN_MASKSTOREPD256, UNKNOWN, (int) VOID_FTYPE_PV4DF_V4DF_V4DF },
-  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_maskstoreps256, "__builtin_ia32_maskstoreps256", IX86_BUILTIN_MASKSTOREPS256, UNKNOWN, (int) VOID_FTYPE_PV8SF_V8SF_V8SF },
+  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_maskloadpd, "__builtin_ia32_maskloadpd", IX86_BUILTIN_MASKLOADPD, UNKNOWN, (int) V2DF_FTYPE_PCV2DF_V2DI },
+  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_maskloadps, "__builtin_ia32_maskloadps", IX86_BUILTIN_MASKLOADPS, UNKNOWN, (int) V4SF_FTYPE_PCV4SF_V4SI },
+  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_maskloadpd256, "__builtin_ia32_maskloadpd256", IX86_BUILTIN_MASKLOADPD256, UNKNOWN, (int) V4DF_FTYPE_PCV4DF_V4DI },
+  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_maskloadps256, "__builtin_ia32_maskloadps256", IX86_BUILTIN_MASKLOADPS256, UNKNOWN, (int) V8SF_FTYPE_PCV8SF_V8SI },
+  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_maskstorepd, "__builtin_ia32_maskstorepd", IX86_BUILTIN_MASKSTOREPD, UNKNOWN, (int) VOID_FTYPE_PV2DF_V2DI_V2DF },
+  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_maskstoreps, "__builtin_ia32_maskstoreps", IX86_BUILTIN_MASKSTOREPS, UNKNOWN, (int) VOID_FTYPE_PV4SF_V4SI_V4SF },
+  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_maskstorepd256, "__builtin_ia32_maskstorepd256", IX86_BUILTIN_MASKSTOREPD256, UNKNOWN, (int) VOID_FTYPE_PV4DF_V4DI_V4DF },
+  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_maskstoreps256, "__builtin_ia32_maskstoreps256", IX86_BUILTIN_MASKSTOREPS256, UNKNOWN, (int) VOID_FTYPE_PV8SF_V8SI_V8SF },
 
   { OPTION_MASK_ISA_LWP, CODE_FOR_lwp_llwpcb, "__builtin_ia32_llwpcb", IX86_BUILTIN_LLWPCB, UNKNOWN, (int) VOID_FTYPE_PVOID },
   { OPTION_MASK_ISA_LWP, CODE_FOR_lwp_slwpcb, "__builtin_ia32_slwpcb", IX86_BUILTIN_SLWPCB, UNKNOWN, (int) PVOID_FTYPE_VOID },
@@ -23927,18 +23946,18 @@
       klass = load;
       memory = 1;
       break;
-    case V8SF_FTYPE_PCV8SF_V8SF:
-    case V4DF_FTYPE_PCV4DF_V4DF:
-    case V4SF_FTYPE_PCV4SF_V4SF:
-    case V2DF_FTYPE_PCV2DF_V2DF:
+    case V8SF_FTYPE_PCV8SF_V8SI:
+    case V4DF_FTYPE_PCV4DF_V4DI:
+    case V4SF_FTYPE_PCV4SF_V4SI:
+    case V2DF_FTYPE_PCV2DF_V2DI:
       nargs = 2;
       klass = load;
       memory = 0;
       break;
-    case VOID_FTYPE_PV8SF_V8SF_V8SF:
-    case VOID_FTYPE_PV4DF_V4DF_V4DF:
-    case VOID_FTYPE_PV4SF_V4SF_V4SF:
-    case VOID_FTYPE_PV2DF_V2DF_V2DF:
+    case VOID_FTYPE_PV8SF_V8SI_V8SF:
+    case VOID_FTYPE_PV4DF_V4DI_V4DF:
+    case VOID_FTYPE_PV4SF_V4SI_V4SF:
+    case VOID_FTYPE_PV2DF_V2DI_V2DF:
       nargs = 2;
       klass = store;
       /* Reserve memory operand for target.  */
Index: gcc/config/rs6000/vector.md
===================================================================
--- gcc/config/rs6000/vector.md	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/config/rs6000/vector.md	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -3,7 +3,7 @@
 ;; expander, and the actual vector instructions will be in altivec.md and
 ;; vsx.md
 
-;; Copyright (C) 2009, 2010
+;; Copyright (C) 2009, 2010, 2011
 ;; Free Software Foundation, Inc.
 ;; Contributed by Michael Meissner <meissner@linux.vnet.ibm.com>
 
@@ -123,6 +123,43 @@
   DONE;
 })
 
+;; Vector floating point load/store instructions that uses the Altivec
+;; instructions even if we are compiling for VSX, since the Altivec
+;; instructions silently ignore the bottom 3 bits of the address, and VSX does
+;; not.
+(define_expand "vector_altivec_load_<mode>"
+  [(set (match_operand:VEC_M 0 "vfloat_operand" "")
+	(match_operand:VEC_M 1 "memory_operand" ""))]
+  "VECTOR_MEM_ALTIVEC_OR_VSX_P (<MODE>mode)"
+  "
+{
+  gcc_assert (VECTOR_MEM_ALTIVEC_OR_VSX_P (<MODE>mode));
+
+  if (VECTOR_MEM_VSX_P (<MODE>mode))
+    {
+      operands[1] = rs6000_address_for_altivec (operands[1]);
+      emit_insn (gen_altivec_lvx_<mode> (operands[0], operands[1]));
+      DONE;
+    }
+}")
+
+(define_expand "vector_altivec_store_<mode>"
+  [(set (match_operand:VEC_M 0 "memory_operand" "")
+	(match_operand:VEC_M 1 "vfloat_operand" ""))]
+  "VECTOR_MEM_ALTIVEC_OR_VSX_P (<MODE>mode)"
+  "
+{
+  gcc_assert (VECTOR_MEM_ALTIVEC_OR_VSX_P (<MODE>mode));
+
+  if (VECTOR_MEM_VSX_P (<MODE>mode))
+    {
+      operands[0] = rs6000_address_for_altivec (operands[0]);
+      emit_insn (gen_altivec_stvx_<mode> (operands[0], operands[1]));
+      DONE;
+    }
+}")
+
+
 
 ;; Reload patterns for vector operations.  We may need an addtional base
 ;; register to convert the reg+offset addressing to reg+reg for vector
Index: gcc/config/rs6000/rs6000-protos.h
===================================================================
--- gcc/config/rs6000/rs6000-protos.h	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/config/rs6000/rs6000-protos.h	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1,5 +1,6 @@
 /* Definitions of target machine for GNU compiler, for IBM RS/6000.
-   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
+   2010, 2011
    Free Software Foundation, Inc.
    Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)
 
@@ -130,6 +131,7 @@
 
 extern rtx rs6000_machopic_legitimize_pic_address (rtx, enum machine_mode,
 						   rtx);
+extern rtx rs6000_address_for_altivec (rtx);
 #endif /* RTX_CODE */
 
 #ifdef TREE_CODE
Index: gcc/config/rs6000/rs6000-builtin.def
===================================================================
--- gcc/config/rs6000/rs6000-builtin.def	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/config/rs6000/rs6000-builtin.def	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1,5 +1,5 @@
 /* Builtin functions for rs6000/powerpc.
-   Copyright (C) 2009, 2010
+   Copyright (C) 2009, 2010, 2011
    Free Software Foundation, Inc.
    Contributed by Michael Meissner (meissner@linux.vnet.ibm.com)
 
@@ -37,6 +37,10 @@
 RS6000_BUILTIN(ALTIVEC_BUILTIN_LD_INTERNAL_16qi,	RS6000_BTC_MEM)
 RS6000_BUILTIN(ALTIVEC_BUILTIN_ST_INTERNAL_4sf,		RS6000_BTC_MEM)
 RS6000_BUILTIN(ALTIVEC_BUILTIN_LD_INTERNAL_4sf,		RS6000_BTC_MEM)
+RS6000_BUILTIN(ALTIVEC_BUILTIN_ST_INTERNAL_2df,		RS6000_BTC_MEM)
+RS6000_BUILTIN(ALTIVEC_BUILTIN_LD_INTERNAL_2df,		RS6000_BTC_MEM)
+RS6000_BUILTIN(ALTIVEC_BUILTIN_ST_INTERNAL_2di,		RS6000_BTC_MEM)
+RS6000_BUILTIN(ALTIVEC_BUILTIN_LD_INTERNAL_2di,		RS6000_BTC_MEM)
 RS6000_BUILTIN(ALTIVEC_BUILTIN_VADDUBM,			RS6000_BTC_CONST)
 RS6000_BUILTIN(ALTIVEC_BUILTIN_VADDUHM,			RS6000_BTC_CONST)
 RS6000_BUILTIN(ALTIVEC_BUILTIN_VADDUWM,			RS6000_BTC_CONST)
@@ -774,12 +778,20 @@
 
   /* VSX builtins.  */
 RS6000_BUILTIN(VSX_BUILTIN_LXSDX,			RS6000_BTC_MEM)
-RS6000_BUILTIN(VSX_BUILTIN_LXVD2X,			RS6000_BTC_MEM)
+RS6000_BUILTIN(VSX_BUILTIN_LXVD2X_V2DF,			RS6000_BTC_MEM)
+RS6000_BUILTIN(VSX_BUILTIN_LXVD2X_V2DI,			RS6000_BTC_MEM)
 RS6000_BUILTIN(VSX_BUILTIN_LXVDSX,			RS6000_BTC_MEM)
-RS6000_BUILTIN(VSX_BUILTIN_LXVW4X,			RS6000_BTC_MEM)
+RS6000_BUILTIN(VSX_BUILTIN_LXVW4X_V4SF,			RS6000_BTC_MEM)
+RS6000_BUILTIN(VSX_BUILTIN_LXVW4X_V4SI,			RS6000_BTC_MEM)
+RS6000_BUILTIN(VSX_BUILTIN_LXVW4X_V8HI,			RS6000_BTC_MEM)
+RS6000_BUILTIN(VSX_BUILTIN_LXVW4X_V16QI,		RS6000_BTC_MEM)
 RS6000_BUILTIN(VSX_BUILTIN_STXSDX,			RS6000_BTC_MEM)
-RS6000_BUILTIN(VSX_BUILTIN_STXVD2X,			RS6000_BTC_MEM)
-RS6000_BUILTIN(VSX_BUILTIN_STXVW4X,			RS6000_BTC_MEM)
+RS6000_BUILTIN(VSX_BUILTIN_STXVD2X_V2DF,		RS6000_BTC_MEM)
+RS6000_BUILTIN(VSX_BUILTIN_STXVD2X_V2DI,		RS6000_BTC_MEM)
+RS6000_BUILTIN(VSX_BUILTIN_STXVW4X_V4SF,		RS6000_BTC_MEM)
+RS6000_BUILTIN(VSX_BUILTIN_STXVW4X_V4SI,		RS6000_BTC_MEM)
+RS6000_BUILTIN(VSX_BUILTIN_STXVW4X_V8HI,		RS6000_BTC_MEM)
+RS6000_BUILTIN(VSX_BUILTIN_STXVW4X_V16QI,		RS6000_BTC_MEM)
 RS6000_BUILTIN(VSX_BUILTIN_XSABSDP,			RS6000_BTC_CONST)
 RS6000_BUILTIN(VSX_BUILTIN_XSADDDP,			RS6000_BTC_FP_PURE)
 RS6000_BUILTIN(VSX_BUILTIN_XSCMPODP,			RS6000_BTC_FP_PURE)
@@ -975,8 +987,10 @@
 RS6000_BUILTIN(VSX_BUILTIN_VEC_XXSLDWI,			RS6000_BTC_MISC)
 RS6000_BUILTIN(VSX_BUILTIN_VEC_XXSPLTD,			RS6000_BTC_MISC)
 RS6000_BUILTIN(VSX_BUILTIN_VEC_XXSPLTW,			RS6000_BTC_MISC)
+RS6000_BUILTIN(VSX_BUILTIN_VEC_LD,			RS6000_BTC_MISC)
+RS6000_BUILTIN(VSX_BUILTIN_VEC_ST,			RS6000_BTC_MISC)
 RS6000_BUILTIN_EQUATE(VSX_BUILTIN_OVERLOADED_LAST,
-		      VSX_BUILTIN_VEC_XXSPLTW)
+		      VSX_BUILTIN_VEC_ST)
 
 /* Combined VSX/Altivec builtins.  */
 RS6000_BUILTIN(VECTOR_BUILTIN_FLOAT_V4SI_V4SF,		RS6000_BTC_FP_PURE)
Index: gcc/config/rs6000/rs6000-c.c
===================================================================
--- gcc/config/rs6000/rs6000-c.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/config/rs6000/rs6000-c.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -965,6 +965,15 @@
   { VSX_BUILTIN_VEC_DIV, VSX_BUILTIN_XVDIVDP,
     RS6000_BTI_V2DF, RS6000_BTI_V2DF, RS6000_BTI_V2DF, 0 },
   { ALTIVEC_BUILTIN_VEC_LD, ALTIVEC_BUILTIN_LVX,
+    RS6000_BTI_V2DF, RS6000_BTI_INTSI, ~RS6000_BTI_V2DF, 0 },
+  { ALTIVEC_BUILTIN_VEC_LD, ALTIVEC_BUILTIN_LVX,
+    RS6000_BTI_V2DI, RS6000_BTI_INTSI, ~RS6000_BTI_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LD, ALTIVEC_BUILTIN_LVX,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_unsigned_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LD, ALTIVEC_BUILTIN_LVX,
+    RS6000_BTI_bool_V2DI, RS6000_BTI_INTSI, ~RS6000_BTI_bool_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LD, ALTIVEC_BUILTIN_LVX,
     RS6000_BTI_V4SF, RS6000_BTI_INTSI, ~RS6000_BTI_V4SF, 0 },
   { ALTIVEC_BUILTIN_VEC_LD, ALTIVEC_BUILTIN_LVX,
     RS6000_BTI_V4SF, RS6000_BTI_INTSI, ~RS6000_BTI_float, 0 },
@@ -1077,9 +1086,19 @@
   { ALTIVEC_BUILTIN_VEC_LDL, ALTIVEC_BUILTIN_LVXL,
     RS6000_BTI_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_INTQI, 0 },
   { ALTIVEC_BUILTIN_VEC_LDL, ALTIVEC_BUILTIN_LVXL,
-    RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_unsigned_V16QI, 0 },
+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_unsigned_V16QI, 0 },
   { ALTIVEC_BUILTIN_VEC_LDL, ALTIVEC_BUILTIN_LVXL,
     RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTQI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LDL, ALTIVEC_BUILTIN_LVXL,
+    RS6000_BTI_V2DF, RS6000_BTI_INTSI, ~RS6000_BTI_V2DF, 0 },
+  { ALTIVEC_BUILTIN_VEC_LDL, ALTIVEC_BUILTIN_LVXL,
+    RS6000_BTI_V2DI, RS6000_BTI_INTSI, ~RS6000_BTI_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LDL, ALTIVEC_BUILTIN_LVXL,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_unsigned_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LDL, ALTIVEC_BUILTIN_LVXL,
+    RS6000_BTI_bool_V2DI, RS6000_BTI_INTSI, ~RS6000_BTI_bool_V2DI, 0 },
   { ALTIVEC_BUILTIN_VEC_LVSL, ALTIVEC_BUILTIN_LVSL,
     RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTQI, 0 },
   { ALTIVEC_BUILTIN_VEC_LVSL, ALTIVEC_BUILTIN_LVSL,
@@ -1098,6 +1117,17 @@
     RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_long, 0 },
   { ALTIVEC_BUILTIN_VEC_LVSL, ALTIVEC_BUILTIN_LVSL,
     RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_float, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSL, ALTIVEC_BUILTIN_LVSL,
+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_double, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSL, ALTIVEC_BUILTIN_LVSL,
+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTDI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSL, ALTIVEC_BUILTIN_LVSL,
+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_INTDI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSL, ALTIVEC_BUILTIN_LVSL,
+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_long_long, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSL, ALTIVEC_BUILTIN_LVSL,
+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_unsigned_long_long, 0 },
   { ALTIVEC_BUILTIN_VEC_LVSR, ALTIVEC_BUILTIN_LVSR,
     RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTQI, 0 },
   { ALTIVEC_BUILTIN_VEC_LVSR, ALTIVEC_BUILTIN_LVSR,
@@ -1116,6 +1146,17 @@
     RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_long, 0 },
   { ALTIVEC_BUILTIN_VEC_LVSR, ALTIVEC_BUILTIN_LVSR,
     RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_float, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSR, ALTIVEC_BUILTIN_LVSR,
+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_double, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSR, ALTIVEC_BUILTIN_LVSR,
+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTDI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSR, ALTIVEC_BUILTIN_LVSR,
+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_INTDI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSR, ALTIVEC_BUILTIN_LVSR,
+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_long_long, 0 },
+  { ALTIVEC_BUILTIN_VEC_LVSR, ALTIVEC_BUILTIN_LVSR,
+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_unsigned_long_long, 0 },
   { ALTIVEC_BUILTIN_VEC_LVLX, ALTIVEC_BUILTIN_LVLX,
     RS6000_BTI_V4SF, RS6000_BTI_INTSI, ~RS6000_BTI_V4SF, 0 },
   { ALTIVEC_BUILTIN_VEC_LVLX, ALTIVEC_BUILTIN_LVLX,
@@ -2609,6 +2650,16 @@
   { ALTIVEC_BUILTIN_VEC_SLD, ALTIVEC_BUILTIN_VSLDOI_16QI,
     RS6000_BTI_bool_V16QI, RS6000_BTI_bool_V16QI, RS6000_BTI_bool_V16QI, RS6000_BTI_NOT_OPAQUE },
   { ALTIVEC_BUILTIN_VEC_ST, ALTIVEC_BUILTIN_STVX,
+    RS6000_BTI_void, RS6000_BTI_V2DF, RS6000_BTI_INTSI, ~RS6000_BTI_V2DF },
+  { ALTIVEC_BUILTIN_VEC_ST, ALTIVEC_BUILTIN_STVX,
+    RS6000_BTI_void, RS6000_BTI_V2DI, RS6000_BTI_INTSI, ~RS6000_BTI_V2DI },
+  { ALTIVEC_BUILTIN_VEC_ST, ALTIVEC_BUILTIN_STVX,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V2DI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_unsigned_V2DI },
+  { ALTIVEC_BUILTIN_VEC_ST, ALTIVEC_BUILTIN_STVX,
+    RS6000_BTI_void, RS6000_BTI_bool_V2DI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_bool_V2DI },
+  { ALTIVEC_BUILTIN_VEC_ST, ALTIVEC_BUILTIN_STVX,
     RS6000_BTI_void, RS6000_BTI_V4SF, RS6000_BTI_INTSI, ~RS6000_BTI_V4SF },
   { ALTIVEC_BUILTIN_VEC_ST, ALTIVEC_BUILTIN_STVX,
     RS6000_BTI_void, RS6000_BTI_V4SF, RS6000_BTI_INTSI, ~RS6000_BTI_float },
@@ -2774,6 +2825,18 @@
     RS6000_BTI_void, RS6000_BTI_bool_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_INTQI },
   { ALTIVEC_BUILTIN_VEC_STL, ALTIVEC_BUILTIN_STVXL,
     RS6000_BTI_void, RS6000_BTI_pixel_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_pixel_V8HI },
+  { ALTIVEC_BUILTIN_VEC_STL, ALTIVEC_BUILTIN_STVXL,
+    RS6000_BTI_void, RS6000_BTI_V2DF, RS6000_BTI_INTSI, ~RS6000_BTI_V2DF },
+  { ALTIVEC_BUILTIN_VEC_STL, ALTIVEC_BUILTIN_STVXL,
+    RS6000_BTI_void, RS6000_BTI_V2DF, RS6000_BTI_INTSI, ~RS6000_BTI_double },
+  { ALTIVEC_BUILTIN_VEC_STL, ALTIVEC_BUILTIN_STVXL,
+    RS6000_BTI_void, RS6000_BTI_V2DI, RS6000_BTI_INTSI, ~RS6000_BTI_V2DI },
+  { ALTIVEC_BUILTIN_VEC_STL, ALTIVEC_BUILTIN_STVXL,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V2DI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_unsigned_V2DI },
+  { ALTIVEC_BUILTIN_VEC_STL, ALTIVEC_BUILTIN_STVXL,
+    RS6000_BTI_void, RS6000_BTI_bool_V2DI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_bool_V2DI },
   { ALTIVEC_BUILTIN_VEC_STVLX, ALTIVEC_BUILTIN_STVLX,
     RS6000_BTI_void, RS6000_BTI_V4SF, RS6000_BTI_INTSI, ~RS6000_BTI_V4SF },
   { ALTIVEC_BUILTIN_VEC_STVLX, ALTIVEC_BUILTIN_STVLX,
@@ -2967,6 +3030,135 @@
     RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI,
     RS6000_BTI_NOT_OPAQUE },
 
+  { VSX_BUILTIN_VEC_LD, VSX_BUILTIN_LXVD2X_V2DF,
+    RS6000_BTI_V2DF, RS6000_BTI_INTSI, ~RS6000_BTI_V2DF, 0 },
+  { VSX_BUILTIN_VEC_LD, VSX_BUILTIN_LXVD2X_V2DI,
+    RS6000_BTI_V2DI, RS6000_BTI_INTSI, ~RS6000_BTI_V2DI, 0 },
+  { VSX_BUILTIN_VEC_LD, VSX_BUILTIN_LXVD2X_V2DI,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_unsigned_V2DI, 0 },
+  { VSX_BUILTIN_VEC_LD, VSX_BUILTIN_LXVD2X_V2DI,
+    RS6000_BTI_bool_V2DI, RS6000_BTI_INTSI, ~RS6000_BTI_bool_V2DI, 0 },
+  { VSX_BUILTIN_VEC_LD, VSX_BUILTIN_LXVW4X_V4SF,
+    RS6000_BTI_V4SF, RS6000_BTI_INTSI, ~RS6000_BTI_V4SF, 0 },
+  { VSX_BUILTIN_VEC_LD, VSX_BUILTIN_LXVW4X_V4SF,
+    RS6000_BTI_V4SF, RS6000_BTI_INTSI, ~RS6000_BTI_float, 0 },
+  { VSX_BUILTIN_VEC_LD, VSX_BUILTIN_LXVW4X_V4SI,
+    RS6000_BTI_bool_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_bool_V4SI, 0 },
+  { VSX_BUILTIN_VEC_LD, VSX_BUILTIN_LXVW4X_V4SI,
+    RS6000_BTI_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_V4SI, 0 },
+  { VSX_BUILTIN_VEC_LD, VSX_BUILTIN_LXVW4X_V4SI,
+    RS6000_BTI_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_INTSI, 0 },
+  { VSX_BUILTIN_VEC_LD, VSX_BUILTIN_LXVW4X_V4SI,
+    RS6000_BTI_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_long, 0 },
+  { VSX_BUILTIN_VEC_LD, VSX_BUILTIN_LXVW4X_V4SI,
+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_unsigned_V4SI, 0 },
+  { VSX_BUILTIN_VEC_LD, VSX_BUILTIN_LXVW4X_V4SI,
+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTSI, 0 },
+  { VSX_BUILTIN_VEC_LD, VSX_BUILTIN_LXVW4X_V4SI,
+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_unsigned_long, 0 },
+  { VSX_BUILTIN_VEC_LD, VSX_BUILTIN_LXVW4X_V8HI,
+    RS6000_BTI_bool_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_bool_V8HI, 0 },
+  { VSX_BUILTIN_VEC_LD, VSX_BUILTIN_LXVW4X_V8HI,
+    RS6000_BTI_pixel_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_pixel_V8HI, 0 },
+  { VSX_BUILTIN_VEC_LD, VSX_BUILTIN_LXVW4X_V8HI,
+    RS6000_BTI_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_V8HI, 0 },
+  { VSX_BUILTIN_VEC_LD, VSX_BUILTIN_LXVW4X_V8HI,
+    RS6000_BTI_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_INTHI, 0 },
+  { VSX_BUILTIN_VEC_LD, VSX_BUILTIN_LXVW4X_V8HI,
+    RS6000_BTI_unsigned_V8HI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_unsigned_V8HI, 0 },
+  { VSX_BUILTIN_VEC_LD, VSX_BUILTIN_LXVW4X_V8HI,
+    RS6000_BTI_unsigned_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTHI, 0 },
+  { VSX_BUILTIN_VEC_LD, VSX_BUILTIN_LXVW4X_V16QI,
+    RS6000_BTI_bool_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_bool_V16QI, 0 },
+  { VSX_BUILTIN_VEC_LD, VSX_BUILTIN_LXVW4X_V16QI,
+    RS6000_BTI_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_V16QI, 0 },
+  { VSX_BUILTIN_VEC_LD, VSX_BUILTIN_LXVW4X_V16QI,
+    RS6000_BTI_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_INTQI, 0 },
+  { VSX_BUILTIN_VEC_LD, VSX_BUILTIN_LXVW4X_V16QI,
+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_unsigned_V16QI, 0 },
+  { VSX_BUILTIN_VEC_LD, VSX_BUILTIN_LXVW4X_V16QI,
+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTQI, 0 },
+
+  { VSX_BUILTIN_VEC_ST, VSX_BUILTIN_STXVD2X_V2DF,
+    RS6000_BTI_void, RS6000_BTI_V2DF, RS6000_BTI_INTSI, ~RS6000_BTI_V2DF },
+  { VSX_BUILTIN_VEC_ST, VSX_BUILTIN_STXVD2X_V2DI,
+    RS6000_BTI_void, RS6000_BTI_V2DI, RS6000_BTI_INTSI, ~RS6000_BTI_V2DI },
+  { VSX_BUILTIN_VEC_ST, VSX_BUILTIN_STXVD2X_V2DI,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V2DI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_unsigned_V2DI },
+  { VSX_BUILTIN_VEC_ST, VSX_BUILTIN_STXVD2X_V2DI,
+    RS6000_BTI_void, RS6000_BTI_bool_V2DI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_bool_V2DI },
+  { VSX_BUILTIN_VEC_ST, VSX_BUILTIN_STXVW4X_V4SF,
+    RS6000_BTI_void, RS6000_BTI_V4SF, RS6000_BTI_INTSI, ~RS6000_BTI_V4SF },
+  { VSX_BUILTIN_VEC_ST, VSX_BUILTIN_STXVW4X_V4SF,
+    RS6000_BTI_void, RS6000_BTI_V4SF, RS6000_BTI_INTSI, ~RS6000_BTI_float },
+  { VSX_BUILTIN_VEC_ST, VSX_BUILTIN_STXVW4X_V4SI,
+    RS6000_BTI_void, RS6000_BTI_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_V4SI },
+  { VSX_BUILTIN_VEC_ST, VSX_BUILTIN_STXVW4X_V4SI,
+    RS6000_BTI_void, RS6000_BTI_V4SI, RS6000_BTI_INTSI, ~RS6000_BTI_INTSI },
+  { VSX_BUILTIN_VEC_ST, VSX_BUILTIN_STXVW4X_V4SI,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V4SI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_unsigned_V4SI },
+  { VSX_BUILTIN_VEC_ST, VSX_BUILTIN_STXVW4X_V4SI,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V4SI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_UINTSI },
+  { VSX_BUILTIN_VEC_ST, VSX_BUILTIN_STXVW4X_V4SI,
+    RS6000_BTI_void, RS6000_BTI_bool_V4SI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_bool_V4SI },
+  { VSX_BUILTIN_VEC_ST, VSX_BUILTIN_STXVW4X_V4SI,
+    RS6000_BTI_void, RS6000_BTI_bool_V4SI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_UINTSI },
+  { VSX_BUILTIN_VEC_ST, VSX_BUILTIN_STXVW4X_V4SI,
+    RS6000_BTI_void, RS6000_BTI_bool_V4SI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_INTSI },
+  { VSX_BUILTIN_VEC_ST, VSX_BUILTIN_STXVW4X_V8HI,
+    RS6000_BTI_void, RS6000_BTI_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_V8HI },
+  { VSX_BUILTIN_VEC_ST, VSX_BUILTIN_STXVW4X_V8HI,
+    RS6000_BTI_void, RS6000_BTI_V8HI, RS6000_BTI_INTSI, ~RS6000_BTI_INTHI },
+  { VSX_BUILTIN_VEC_ST, VSX_BUILTIN_STXVW4X_V8HI,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V8HI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_unsigned_V8HI },
+  { VSX_BUILTIN_VEC_ST, VSX_BUILTIN_STXVW4X_V8HI,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V8HI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_UINTHI },
+  { VSX_BUILTIN_VEC_ST, VSX_BUILTIN_STXVW4X_V8HI,
+    RS6000_BTI_void, RS6000_BTI_bool_V8HI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_bool_V8HI },
+  { VSX_BUILTIN_VEC_ST, VSX_BUILTIN_STXVW4X_V8HI,
+    RS6000_BTI_void, RS6000_BTI_bool_V8HI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_UINTHI },
+  { VSX_BUILTIN_VEC_ST, VSX_BUILTIN_STXVW4X_V8HI,
+    RS6000_BTI_void, RS6000_BTI_bool_V8HI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_INTHI },
+  { VSX_BUILTIN_VEC_ST, VSX_BUILTIN_STXVW4X_V16QI,
+    RS6000_BTI_void, RS6000_BTI_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_V16QI },
+  { VSX_BUILTIN_VEC_ST, VSX_BUILTIN_STXVW4X_V16QI,
+    RS6000_BTI_void, RS6000_BTI_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_INTQI },
+  { VSX_BUILTIN_VEC_ST, VSX_BUILTIN_STXVW4X_V16QI,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_unsigned_V16QI },
+  { VSX_BUILTIN_VEC_ST, VSX_BUILTIN_STXVW4X_V16QI,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_UINTQI },
+  { VSX_BUILTIN_VEC_ST, VSX_BUILTIN_STXVW4X_V16QI,
+    RS6000_BTI_void, RS6000_BTI_bool_V16QI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_bool_V16QI },
+  { VSX_BUILTIN_VEC_ST, VSX_BUILTIN_STXVW4X_V16QI,
+    RS6000_BTI_void, RS6000_BTI_bool_V16QI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_UINTQI },
+  { VSX_BUILTIN_VEC_ST, VSX_BUILTIN_STXVW4X_V16QI,
+    RS6000_BTI_void, RS6000_BTI_bool_V16QI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_INTQI },
+  { VSX_BUILTIN_VEC_ST, VSX_BUILTIN_STXVW4X_V16QI,
+    RS6000_BTI_void, RS6000_BTI_pixel_V8HI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_pixel_V8HI },
+
   /* Predicates.  */
   { ALTIVEC_BUILTIN_VCMPGT_P, ALTIVEC_BUILTIN_VCMPGTUB_P,
     RS6000_BTI_INTSI, RS6000_BTI_INTSI, RS6000_BTI_bool_V16QI, RS6000_BTI_unsigned_V16QI },
Index: gcc/config/rs6000/rs6000.c
===================================================================
--- gcc/config/rs6000/rs6000.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/config/rs6000/rs6000.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -2865,9 +2865,12 @@
   /* If not explicitly specified via option, decide whether to generate indexed
      load/store instructions.  */
   if (TARGET_AVOID_XFORM == -1)
-    /* Avoid indexed addressing when targeting Power6 in order to avoid
-     the DERAT mispredict penalty.  */
-    TARGET_AVOID_XFORM = (rs6000_cpu == PROCESSOR_POWER6 && TARGET_CMPB);
+    /* Avoid indexed addressing when targeting Power6 in order to avoid the
+     DERAT mispredict penalty.  However the LVE and STVE altivec instructions
+     need indexed accesses and the type used is the scalar type of the element
+     being loaded or stored.  */
+    TARGET_AVOID_XFORM = (rs6000_cpu == PROCESSOR_POWER6 && TARGET_CMPB
+			  && !TARGET_ALTIVEC);
 
   rs6000_init_hard_regno_mode_ok ();
 }
@@ -4472,7 +4475,7 @@
 {
   enum machine_mode mode = GET_MODE (vec);
   enum machine_mode inner_mode = GET_MODE_INNER (mode);
-  rtx mem, x;
+  rtx mem;
 
   if (VECTOR_MEM_VSX_P (mode) && (mode == V2DFmode || mode == V2DImode))
     {
@@ -4485,17 +4488,11 @@
   /* Allocate mode-sized buffer.  */
   mem = assign_stack_temp (mode, GET_MODE_SIZE (mode), 0);
 
+  emit_move_insn (mem, vec);
+
   /* Add offset to field within buffer matching vector element.  */
-  mem = adjust_address_nv (mem, mode, elt * GET_MODE_SIZE (inner_mode));
+  mem = adjust_address_nv (mem, inner_mode, elt * GET_MODE_SIZE (inner_mode));
 
-  /* Store single field into mode-sized buffer.  */
-  x = gen_rtx_UNSPEC (VOIDmode,
-		      gen_rtvec (1, const0_rtx), UNSPEC_STVE);
-  emit_insn (gen_rtx_PARALLEL (VOIDmode,
-			       gen_rtvec (2,
-					  gen_rtx_SET (VOIDmode,
-						       mem, vec),
-					  x)));
   emit_move_insn (target, adjust_address_nv (mem, inner_mode, 0));
 }
 
@@ -9897,6 +9894,7 @@
   rtx op2 = expand_normal (arg2);
   rtx pat, addr;
   enum machine_mode tmode = insn_data[icode].operand[0].mode;
+  enum machine_mode smode = insn_data[icode].operand[1].mode;
   enum machine_mode mode1 = Pmode;
   enum machine_mode mode2 = Pmode;
 
@@ -9906,8 +9904,8 @@
       || arg2 == error_mark_node)
     return const0_rtx;
 
-  if (! (*insn_data[icode].operand[1].predicate) (op0, tmode))
-    op0 = copy_to_mode_reg (tmode, op0);
+  if (! (*insn_data[icode].operand[1].predicate) (op0, smode))
+    op0 = copy_to_mode_reg (smode, op0);
 
   op2 = copy_to_mode_reg (mode2, op2);
 
@@ -10041,17 +10039,23 @@
   switch (fcode)
     {
     case ALTIVEC_BUILTIN_LD_INTERNAL_16qi:
-      icode = CODE_FOR_vector_load_v16qi;
+      icode = CODE_FOR_vector_altivec_load_v16qi;
       break;
     case ALTIVEC_BUILTIN_LD_INTERNAL_8hi:
-      icode = CODE_FOR_vector_load_v8hi;
+      icode = CODE_FOR_vector_altivec_load_v8hi;
       break;
     case ALTIVEC_BUILTIN_LD_INTERNAL_4si:
-      icode = CODE_FOR_vector_load_v4si;
+      icode = CODE_FOR_vector_altivec_load_v4si;
       break;
     case ALTIVEC_BUILTIN_LD_INTERNAL_4sf:
-      icode = CODE_FOR_vector_load_v4sf;
+      icode = CODE_FOR_vector_altivec_load_v4sf;
       break;
+    case ALTIVEC_BUILTIN_LD_INTERNAL_2df:
+      icode = CODE_FOR_vector_altivec_load_v2df;
+      break;
+    case ALTIVEC_BUILTIN_LD_INTERNAL_2di:
+      icode = CODE_FOR_vector_altivec_load_v2di;
+      break;
     default:
       *expandedp = false;
       return NULL_RTX;
@@ -10094,17 +10098,23 @@
   switch (fcode)
     {
     case ALTIVEC_BUILTIN_ST_INTERNAL_16qi:
-      icode = CODE_FOR_vector_store_v16qi;
+      icode = CODE_FOR_vector_altivec_store_v16qi;
       break;
     case ALTIVEC_BUILTIN_ST_INTERNAL_8hi:
-      icode = CODE_FOR_vector_store_v8hi;
+      icode = CODE_FOR_vector_altivec_store_v8hi;
       break;
     case ALTIVEC_BUILTIN_ST_INTERNAL_4si:
-      icode = CODE_FOR_vector_store_v4si;
+      icode = CODE_FOR_vector_altivec_store_v4si;
       break;
     case ALTIVEC_BUILTIN_ST_INTERNAL_4sf:
-      icode = CODE_FOR_vector_store_v4sf;
+      icode = CODE_FOR_vector_altivec_store_v4sf;
       break;
+    case ALTIVEC_BUILTIN_ST_INTERNAL_2df:
+      icode = CODE_FOR_vector_altivec_store_v2df;
+      break;
+    case ALTIVEC_BUILTIN_ST_INTERNAL_2di:
+      icode = CODE_FOR_vector_altivec_store_v2di;
+      break;
     default:
       *expandedp = false;
       return NULL_RTX;
@@ -10336,7 +10346,7 @@
   switch (fcode)
     {
     case ALTIVEC_BUILTIN_STVX:
-      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvx, exp);
+      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvx_v4si, exp);
     case ALTIVEC_BUILTIN_STVEBX:
       return altivec_expand_stv_builtin (CODE_FOR_altivec_stvebx, exp);
     case ALTIVEC_BUILTIN_STVEHX:
@@ -10355,6 +10365,19 @@
     case ALTIVEC_BUILTIN_STVRXL:
       return altivec_expand_stv_builtin (CODE_FOR_altivec_stvrxl, exp);
 
+    case VSX_BUILTIN_STXVD2X_V2DF:
+      return altivec_expand_stv_builtin (CODE_FOR_vsx_store_v2df, exp);
+    case VSX_BUILTIN_STXVD2X_V2DI:
+      return altivec_expand_stv_builtin (CODE_FOR_vsx_store_v2di, exp);
+    case VSX_BUILTIN_STXVW4X_V4SF:
+      return altivec_expand_stv_builtin (CODE_FOR_vsx_store_v4sf, exp);
+    case VSX_BUILTIN_STXVW4X_V4SI:
+      return altivec_expand_stv_builtin (CODE_FOR_vsx_store_v4si, exp);
+    case VSX_BUILTIN_STXVW4X_V8HI:
+      return altivec_expand_stv_builtin (CODE_FOR_vsx_store_v8hi, exp);
+    case VSX_BUILTIN_STXVW4X_V16QI:
+      return altivec_expand_stv_builtin (CODE_FOR_vsx_store_v16qi, exp);
+
     case ALTIVEC_BUILTIN_MFVSCR:
       icode = CODE_FOR_altivec_mfvscr;
       tmode = insn_data[icode].operand[0].mode;
@@ -10479,7 +10502,7 @@
       return altivec_expand_lv_builtin (CODE_FOR_altivec_lvxl,
 					exp, target, false);
     case ALTIVEC_BUILTIN_LVX:
-      return altivec_expand_lv_builtin (CODE_FOR_altivec_lvx,
+      return altivec_expand_lv_builtin (CODE_FOR_altivec_lvx_v4si,
 					exp, target, false);
     case ALTIVEC_BUILTIN_LVLX:
       return altivec_expand_lv_builtin (CODE_FOR_altivec_lvlx,
@@ -10493,6 +10516,25 @@
     case ALTIVEC_BUILTIN_LVRXL:
       return altivec_expand_lv_builtin (CODE_FOR_altivec_lvrxl,
 					exp, target, true);
+    case VSX_BUILTIN_LXVD2X_V2DF:
+      return altivec_expand_lv_builtin (CODE_FOR_vsx_load_v2df,
+					exp, target, false);
+    case VSX_BUILTIN_LXVD2X_V2DI:
+      return altivec_expand_lv_builtin (CODE_FOR_vsx_load_v2di,
+					exp, target, false);
+    case VSX_BUILTIN_LXVW4X_V4SF:
+      return altivec_expand_lv_builtin (CODE_FOR_vsx_load_v4sf,
+					exp, target, false);
+    case VSX_BUILTIN_LXVW4X_V4SI:
+      return altivec_expand_lv_builtin (CODE_FOR_vsx_load_v4si,
+					exp, target, false);
+    case VSX_BUILTIN_LXVW4X_V8HI:
+      return altivec_expand_lv_builtin (CODE_FOR_vsx_load_v8hi,
+					exp, target, false);
+    case VSX_BUILTIN_LXVW4X_V16QI:
+      return altivec_expand_lv_builtin (CODE_FOR_vsx_load_v16qi,
+					exp, target, false);
+      break;
     default:
       break;
       /* Fall through.  */
@@ -11099,6 +11141,8 @@
 
   long_integer_type_internal_node = long_integer_type_node;
   long_unsigned_type_internal_node = long_unsigned_type_node;
+  long_long_integer_type_internal_node = long_long_integer_type_node;
+  long_long_unsigned_type_internal_node = long_long_unsigned_type_node;
   intQI_type_internal_node = intQI_type_node;
   uintQI_type_internal_node = unsigned_intQI_type_node;
   intHI_type_internal_node = intHI_type_node;
@@ -11108,7 +11152,7 @@
   intDI_type_internal_node = intDI_type_node;
   uintDI_type_internal_node = unsigned_intDI_type_node;
   float_type_internal_node = float_type_node;
-  double_type_internal_node = float_type_node;
+  double_type_internal_node = double_type_node;
   void_type_internal_node = void_type_node;
 
   /* Initialize the modes for builtin_function_type, mapping a machine mode to
@@ -11631,20 +11675,12 @@
   size_t i;
   tree ftype;
 
-  tree pfloat_type_node = build_pointer_type (float_type_node);
-  tree pint_type_node = build_pointer_type (integer_type_node);
-  tree pshort_type_node = build_pointer_type (short_integer_type_node);
-  tree pchar_type_node = build_pointer_type (char_type_node);
-
   tree pvoid_type_node = build_pointer_type (void_type_node);
 
-  tree pcfloat_type_node = build_pointer_type (build_qualified_type (float_type_node, TYPE_QUAL_CONST));
-  tree pcint_type_node = build_pointer_type (build_qualified_type (integer_type_node, TYPE_QUAL_CONST));
-  tree pcshort_type_node = build_pointer_type (build_qualified_type (short_integer_type_node, TYPE_QUAL_CONST));
-  tree pcchar_type_node = build_pointer_type (build_qualified_type (char_type_node, TYPE_QUAL_CONST));
+  tree pcvoid_type_node
+    = build_pointer_type (build_qualified_type (void_type_node,
+						TYPE_QUAL_CONST));
 
-  tree pcvoid_type_node = build_pointer_type (build_qualified_type (void_type_node, TYPE_QUAL_CONST));
-
   tree int_ftype_opaque
     = build_function_type_list (integer_type_node,
 				opaque_V4SI_type_node, NULL_TREE);
@@ -11666,26 +11702,6 @@
     = build_function_type_list (integer_type_node,
 				integer_type_node, V4SI_type_node,
 				V4SI_type_node, NULL_TREE);
-  tree v4sf_ftype_pcfloat
-    = build_function_type_list (V4SF_type_node, pcfloat_type_node, NULL_TREE);
-  tree void_ftype_pfloat_v4sf
-    = build_function_type_list (void_type_node,
-				pfloat_type_node, V4SF_type_node, NULL_TREE);
-  tree v4si_ftype_pcint
-    = build_function_type_list (V4SI_type_node, pcint_type_node, NULL_TREE);
-  tree void_ftype_pint_v4si
-    = build_function_type_list (void_type_node,
-				pint_type_node, V4SI_type_node, NULL_TREE);
-  tree v8hi_ftype_pcshort
-    = build_function_type_list (V8HI_type_node, pcshort_type_node, NULL_TREE);
-  tree void_ftype_pshort_v8hi
-    = build_function_type_list (void_type_node,
-				pshort_type_node, V8HI_type_node, NULL_TREE);
-  tree v16qi_ftype_pcchar
-    = build_function_type_list (V16QI_type_node, pcchar_type_node, NULL_TREE);
-  tree void_ftype_pchar_v16qi
-    = build_function_type_list (void_type_node,
-				pchar_type_node, V16QI_type_node, NULL_TREE);
   tree void_ftype_v4si
     = build_function_type_list (void_type_node, V4SI_type_node, NULL_TREE);
   tree v8hi_ftype_void
@@ -11697,16 +11713,32 @@
 
   tree opaque_ftype_long_pcvoid
     = build_function_type_list (opaque_V4SI_type_node,
-				long_integer_type_node, pcvoid_type_node, NULL_TREE);
+				long_integer_type_node, pcvoid_type_node,
+				NULL_TREE);
   tree v16qi_ftype_long_pcvoid
     = build_function_type_list (V16QI_type_node,
-				long_integer_type_node, pcvoid_type_node, NULL_TREE);
+				long_integer_type_node, pcvoid_type_node,
+				NULL_TREE);
   tree v8hi_ftype_long_pcvoid
     = build_function_type_list (V8HI_type_node,
-				long_integer_type_node, pcvoid_type_node, NULL_TREE);
+				long_integer_type_node, pcvoid_type_node,
+				NULL_TREE);
   tree v4si_ftype_long_pcvoid
     = build_function_type_list (V4SI_type_node,
-				long_integer_type_node, pcvoid_type_node, NULL_TREE);
+				long_integer_type_node, pcvoid_type_node,
+				NULL_TREE);
+  tree v4sf_ftype_long_pcvoid
+    = build_function_type_list (V4SF_type_node,
+				long_integer_type_node, pcvoid_type_node,
+				NULL_TREE);
+  tree v2df_ftype_long_pcvoid
+    = build_function_type_list (V2DF_type_node,
+				long_integer_type_node, pcvoid_type_node,
+				NULL_TREE);
+  tree v2di_ftype_long_pcvoid
+    = build_function_type_list (V2DI_type_node,
+				long_integer_type_node, pcvoid_type_node,
+				NULL_TREE);
 
   tree void_ftype_opaque_long_pvoid
     = build_function_type_list (void_type_node,
@@ -11724,6 +11756,18 @@
     = build_function_type_list (void_type_node,
 				V8HI_type_node, long_integer_type_node,
 				pvoid_type_node, NULL_TREE);
+  tree void_ftype_v4sf_long_pvoid
+    = build_function_type_list (void_type_node,
+				V4SF_type_node, long_integer_type_node,
+				pvoid_type_node, NULL_TREE);
+  tree void_ftype_v2df_long_pvoid
+    = build_function_type_list (void_type_node,
+				V2DF_type_node, long_integer_type_node,
+				pvoid_type_node, NULL_TREE);
+  tree void_ftype_v2di_long_pvoid
+    = build_function_type_list (void_type_node,
+				V2DI_type_node, long_integer_type_node,
+				pvoid_type_node, NULL_TREE);
   tree int_ftype_int_v8hi_v8hi
     = build_function_type_list (integer_type_node,
 				integer_type_node, V8HI_type_node,
@@ -11755,22 +11799,6 @@
 				pcvoid_type_node, integer_type_node,
 				integer_type_node, NULL_TREE);
 
-  def_builtin (MASK_ALTIVEC, "__builtin_altivec_ld_internal_4sf", v4sf_ftype_pcfloat,
-	       ALTIVEC_BUILTIN_LD_INTERNAL_4sf);
-  def_builtin (MASK_ALTIVEC, "__builtin_altivec_st_internal_4sf", void_ftype_pfloat_v4sf,
-	       ALTIVEC_BUILTIN_ST_INTERNAL_4sf);
-  def_builtin (MASK_ALTIVEC, "__builtin_altivec_ld_internal_4si", v4si_ftype_pcint,
-	       ALTIVEC_BUILTIN_LD_INTERNAL_4si);
-  def_builtin (MASK_ALTIVEC, "__builtin_altivec_st_internal_4si", void_ftype_pint_v4si,
-	       ALTIVEC_BUILTIN_ST_INTERNAL_4si);
-  def_builtin (MASK_ALTIVEC, "__builtin_altivec_ld_internal_8hi", v8hi_ftype_pcshort,
-	       ALTIVEC_BUILTIN_LD_INTERNAL_8hi);
-  def_builtin (MASK_ALTIVEC, "__builtin_altivec_st_internal_8hi", void_ftype_pshort_v8hi,
-	       ALTIVEC_BUILTIN_ST_INTERNAL_8hi);
-  def_builtin (MASK_ALTIVEC, "__builtin_altivec_ld_internal_16qi", v16qi_ftype_pcchar,
-	       ALTIVEC_BUILTIN_LD_INTERNAL_16qi);
-  def_builtin (MASK_ALTIVEC, "__builtin_altivec_st_internal_16qi", void_ftype_pchar_v16qi,
-	       ALTIVEC_BUILTIN_ST_INTERNAL_16qi);
   def_builtin (MASK_ALTIVEC, "__builtin_altivec_mtvscr", void_ftype_v4si, ALTIVEC_BUILTIN_MTVSCR);
   def_builtin (MASK_ALTIVEC, "__builtin_altivec_mfvscr", v8hi_ftype_void, ALTIVEC_BUILTIN_MFVSCR);
   def_builtin (MASK_ALTIVEC, "__builtin_altivec_dssall", void_ftype_void, ALTIVEC_BUILTIN_DSSALL);
@@ -11802,6 +11830,35 @@
   def_builtin (MASK_ALTIVEC, "__builtin_vec_stvebx", void_ftype_opaque_long_pvoid, ALTIVEC_BUILTIN_VEC_STVEBX);
   def_builtin (MASK_ALTIVEC, "__builtin_vec_stvehx", void_ftype_opaque_long_pvoid, ALTIVEC_BUILTIN_VEC_STVEHX);
 
+  def_builtin (MASK_VSX, "__builtin_vsx_lxvd2x_v2df", v2df_ftype_long_pcvoid,
+	       VSX_BUILTIN_LXVD2X_V2DF);
+  def_builtin (MASK_VSX, "__builtin_vsx_lxvd2x_v2di", v2di_ftype_long_pcvoid,
+	       VSX_BUILTIN_LXVD2X_V2DI);
+  def_builtin (MASK_VSX, "__builtin_vsx_lxvw4x_v4sf", v4sf_ftype_long_pcvoid,
+	       VSX_BUILTIN_LXVW4X_V4SF);
+  def_builtin (MASK_VSX, "__builtin_vsx_lxvw4x_v4si", v4si_ftype_long_pcvoid,
+	       VSX_BUILTIN_LXVW4X_V4SI);
+  def_builtin (MASK_VSX, "__builtin_vsx_lxvw4x_v8hi",
+	       v8hi_ftype_long_pcvoid, VSX_BUILTIN_LXVW4X_V8HI);
+  def_builtin (MASK_VSX, "__builtin_vsx_lxvw4x_v16qi",
+	       v16qi_ftype_long_pcvoid, VSX_BUILTIN_LXVW4X_V16QI);
+  def_builtin (MASK_VSX, "__builtin_vsx_stxvd2x_v2df",
+	       void_ftype_v2df_long_pvoid, VSX_BUILTIN_STXVD2X_V2DF);
+  def_builtin (MASK_VSX, "__builtin_vsx_stxvd2x_v2di",
+	       void_ftype_v2di_long_pvoid, VSX_BUILTIN_STXVD2X_V2DI);
+  def_builtin (MASK_VSX, "__builtin_vsx_stxvw4x_v4sf",
+	       void_ftype_v4sf_long_pvoid, VSX_BUILTIN_STXVW4X_V4SF);
+  def_builtin (MASK_VSX, "__builtin_vsx_stxvw4x_v4si",
+	       void_ftype_v4si_long_pvoid, VSX_BUILTIN_STXVW4X_V4SI);
+  def_builtin (MASK_VSX, "__builtin_vsx_stxvw4x_v8hi",
+	       void_ftype_v8hi_long_pvoid, VSX_BUILTIN_STXVW4X_V8HI);
+  def_builtin (MASK_VSX, "__builtin_vsx_stxvw4x_v16qi",
+	       void_ftype_v16qi_long_pvoid, VSX_BUILTIN_STXVW4X_V16QI);
+  def_builtin (MASK_VSX, "__builtin_vec_vsx_ld", opaque_ftype_long_pcvoid,
+	       VSX_BUILTIN_VEC_LD);
+  def_builtin (MASK_VSX, "__builtin_vec_vsx_st", void_ftype_opaque_long_pvoid,
+	       VSX_BUILTIN_VEC_ST);
+
   if (rs6000_cpu == PROCESSOR_CELL)
     {
       def_builtin (MASK_ALTIVEC, "__builtin_altivec_lvlx",  v16qi_ftype_long_pcvoid, ALTIVEC_BUILTIN_LVLX);
@@ -25811,4 +25868,29 @@
     }
 }
 
+/* Given a memory reference, if it is not in the form for altivec memory
+   reference instructions (i.e. reg or reg+reg addressing with AND of -16),
+   convert to the altivec format.  */
+
+rtx
+rs6000_address_for_altivec (rtx x)
+{
+  gcc_assert (MEM_P (x));
+  if (!altivec_indexed_or_indirect_operand (x, GET_MODE (x)))
+    {
+      rtx addr = XEXP (x, 0);
+      int strict_p = (reload_in_progress || reload_completed);
+
+      if (!legitimate_indexed_address_p (addr, strict_p)
+	  && !legitimate_indirect_address_p (addr, strict_p))
+	addr = copy_to_mode_reg (Pmode, addr);
+
+      addr = gen_rtx_AND (Pmode, addr, GEN_INT (-16));
+      x = change_address (x, GET_MODE (x), addr);
+    }
+
+  return x;
+}
+
+
 #include "gt-rs6000.h"
Index: gcc/config/rs6000/vsx.md
===================================================================
--- gcc/config/rs6000/vsx.md	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/config/rs6000/vsx.md	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1,5 +1,5 @@
 ;; VSX patterns.
-;; Copyright (C) 2009
+;; Copyright (C) 2009, 2010, 2011
 ;; Free Software Foundation, Inc.
 ;; Contributed by Michael Meissner <meissner@linux.vnet.ibm.com>
 
@@ -309,6 +309,19 @@
 }
   [(set_attr "type" "vecstore,vecload,vecsimple,*,*,*,vecsimple,*,vecstore,vecload")])
 
+;; Explicit  load/store expanders for the builtin functions
+(define_expand "vsx_load_<mode>"
+  [(set (match_operand:VSX_M 0 "vsx_register_operand" "")
+	(match_operand:VSX_M 1 "memory_operand" ""))]
+  "VECTOR_MEM_VSX_P (<MODE>mode)"
+  "")
+
+(define_expand "vsx_store_<mode>"
+  [(set (match_operand:VEC_M 0 "memory_operand" "")
+	(match_operand:VEC_M 1 "vsx_register_operand" ""))]
+  "VECTOR_MEM_VSX_P (<MODE>mode)"
+  "")
+
 
 ;; VSX scalar and vector floating point arithmetic instructions
 (define_insn "*vsx_add<mode>3"
@@ -866,33 +879,34 @@
 ;; the fprs because we don't want to add the altivec registers to movdi/movsi.
 ;; For the unsigned tests, there isn't a generic double -> unsigned conversion
 ;; in rs6000.md so don't test VECTOR_UNIT_VSX_P, just test against VSX.
+;; Don't use vsx_register_operand here, use gpc_reg_operand to match rs6000.md.
 (define_insn "vsx_float<VSi><mode>2"
-  [(set (match_operand:VSX_B 0 "vsx_register_operand" "=<VSr>,?wa")
-	(float:VSX_B (match_operand:<VSI> 1 "vsx_register_operand" "<VSr2>,<VSr3>")))]
+  [(set (match_operand:VSX_B 0 "gpc_reg_operand" "=<VSr>,?wa")
+	(float:VSX_B (match_operand:<VSI> 1 "gpc_reg_operand" "<VSr2>,<VSr3>")))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "x<VSv>cvsx<VSc><VSs> %x0,%x1"
   [(set_attr "type" "<VStype_simple>")
    (set_attr "fp_type" "<VSfptype_simple>")])
 
 (define_insn "vsx_floatuns<VSi><mode>2"
-  [(set (match_operand:VSX_B 0 "vsx_register_operand" "=<VSr>,?wa")
-	(unsigned_float:VSX_B (match_operand:<VSI> 1 "vsx_register_operand" "<VSr2>,<VSr3>")))]
+  [(set (match_operand:VSX_B 0 "gpc_reg_operand" "=<VSr>,?wa")
+	(unsigned_float:VSX_B (match_operand:<VSI> 1 "gpc_reg_operand" "<VSr2>,<VSr3>")))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "x<VSv>cvux<VSc><VSs> %x0,%x1"
   [(set_attr "type" "<VStype_simple>")
    (set_attr "fp_type" "<VSfptype_simple>")])
 
 (define_insn "vsx_fix_trunc<mode><VSi>2"
-  [(set (match_operand:<VSI> 0 "vsx_register_operand" "=<VSr2>,?<VSr3>")
-	(fix:<VSI> (match_operand:VSX_B 1 "vsx_register_operand" "<VSr>,wa")))]
+  [(set (match_operand:<VSI> 0 "gpc_reg_operand" "=<VSr2>,?<VSr3>")
+	(fix:<VSI> (match_operand:VSX_B 1 "gpc_reg_operand" "<VSr>,wa")))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "x<VSv>cv<VSs>sx<VSc>s %x0,%x1"
   [(set_attr "type" "<VStype_simple>")
    (set_attr "fp_type" "<VSfptype_simple>")])
 
 (define_insn "vsx_fixuns_trunc<mode><VSi>2"
-  [(set (match_operand:<VSI> 0 "vsx_register_operand" "=<VSr2>,?<VSr3>")
-	(unsigned_fix:<VSI> (match_operand:VSX_B 1 "vsx_register_operand" "<VSr>,wa")))]
+  [(set (match_operand:<VSI> 0 "gpc_reg_operand" "=<VSr2>,?<VSr3>")
+	(unsigned_fix:<VSI> (match_operand:VSX_B 1 "gpc_reg_operand" "<VSr>,wa")))]
   "VECTOR_UNIT_VSX_P (<MODE>mode)"
   "x<VSv>cv<VSs>ux<VSc>s %x0,%x1"
   [(set_attr "type" "<VStype_simple>")
Index: gcc/config/rs6000/rs6000.h
===================================================================
--- gcc/config/rs6000/rs6000.h	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/config/rs6000/rs6000.h	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1,6 +1,7 @@
 /* Definitions of target machine for GNU compiler, for IBM RS/6000.
    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
-   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
+   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
+   2010, 2011
    Free Software Foundation, Inc.
    Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)
 
@@ -2489,6 +2490,8 @@
   RS6000_BTI_pixel_V8HI,         /* __vector __pixel */
   RS6000_BTI_long,	         /* long_integer_type_node */
   RS6000_BTI_unsigned_long,      /* long_unsigned_type_node */
+  RS6000_BTI_long_long,	         /* long_long_integer_type_node */
+  RS6000_BTI_unsigned_long_long, /* long_long_unsigned_type_node */
   RS6000_BTI_INTQI,	         /* intQI_type_node */
   RS6000_BTI_UINTQI,		 /* unsigned_intQI_type_node */
   RS6000_BTI_INTHI,	         /* intHI_type_node */
@@ -2532,6 +2535,8 @@
 #define bool_V2DI_type_node	      (rs6000_builtin_types[RS6000_BTI_bool_V2DI])
 #define pixel_V8HI_type_node	      (rs6000_builtin_types[RS6000_BTI_pixel_V8HI])
 
+#define long_long_integer_type_internal_node  (rs6000_builtin_types[RS6000_BTI_long_long])
+#define long_long_unsigned_type_internal_node (rs6000_builtin_types[RS6000_BTI_unsigned_long_long])
 #define long_integer_type_internal_node  (rs6000_builtin_types[RS6000_BTI_long])
 #define long_unsigned_type_internal_node (rs6000_builtin_types[RS6000_BTI_unsigned_long])
 #define intQI_type_internal_node	 (rs6000_builtin_types[RS6000_BTI_INTQI])
Index: gcc/config/rs6000/altivec.md
===================================================================
--- gcc/config/rs6000/altivec.md	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/config/rs6000/altivec.md	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1,5 +1,5 @@
 ;; AltiVec patterns.
-;; Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
+;; Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
 ;; Free Software Foundation, Inc.
 ;; Contributed by Aldy Hernandez (aldy@quesejoda.com)
 
@@ -98,7 +98,7 @@
    (UNSPEC_STVE         203)
    (UNSPEC_SET_VSCR     213)
    (UNSPEC_GET_VRSAVE   214)
-   ;; 215 deleted
+   (UNSPEC_LVX		215)
    (UNSPEC_REDUC_PLUS   217)
    (UNSPEC_VECSH        219)
    (UNSPEC_EXTEVEN_V4SI 220)
@@ -171,6 +171,7 @@
 (define_mode_iterator VM2 [V4SI V8HI V16QI V4SF V2DF V2DI])
 
 (define_mode_attr VI_char [(V4SI "w") (V8HI "h") (V16QI "b")])
+(define_mode_attr VI_scalar [(V4SI "SI") (V8HI "HI") (V16QI "QI")])
 
 ;; Vector move instructions.
 (define_insn "*altivec_mov<mode>"
@@ -1751,17 +1752,19 @@
   "lvxl %0,%y1"
   [(set_attr "type" "vecload")])
 
-(define_insn "altivec_lvx"
-  [(set (match_operand:V4SI 0 "register_operand" "=v")
-	(match_operand:V4SI 1 "memory_operand" "Z"))]
+(define_insn "altivec_lvx_<mode>"
+  [(parallel
+    [(set (match_operand:VM2 0 "register_operand" "=v")
+	  (match_operand:VM2 1 "memory_operand" "Z"))
+     (unspec [(const_int 0)] UNSPEC_LVX)])]
   "TARGET_ALTIVEC"
   "lvx %0,%y1"
   [(set_attr "type" "vecload")])
 
-(define_insn "altivec_stvx"
+(define_insn "altivec_stvx_<mode>"
   [(parallel
-    [(set (match_operand:V4SI 0 "memory_operand" "=Z")
-	  (match_operand:V4SI 1 "register_operand" "v"))
+    [(set (match_operand:VM2 0 "memory_operand" "=Z")
+	  (match_operand:VM2 1 "register_operand" "v"))
      (unspec [(const_int 0)] UNSPEC_STVX)])]
   "TARGET_ALTIVEC"
   "stvx %1,%y0"
@@ -1777,19 +1780,15 @@
   [(set_attr "type" "vecstore")])
 
 (define_insn "altivec_stve<VI_char>x"
-  [(parallel
-    [(set (match_operand:VI 0 "memory_operand" "=Z")
-	  (match_operand:VI 1 "register_operand" "v"))
-     (unspec [(const_int 0)] UNSPEC_STVE)])]
+  [(set (match_operand:<VI_scalar> 0 "memory_operand" "=Z")
+	(unspec:<VI_scalar> [(match_operand:VI 1 "register_operand" "v")] UNSPEC_STVE))]
   "TARGET_ALTIVEC"
   "stve<VI_char>x %1,%y0"
   [(set_attr "type" "vecstore")])
 
 (define_insn "*altivec_stvesfx"
-  [(parallel
-    [(set (match_operand:V4SF 0 "memory_operand" "=Z")
-	  (match_operand:V4SF 1 "register_operand" "v"))
-     (unspec [(const_int 0)] UNSPEC_STVE)])]
+  [(set (match_operand:SF 0 "memory_operand" "=Z")
+	(unspec:SF [(match_operand:V4SF 1 "register_operand" "v")] UNSPEC_STVE))]
   "TARGET_ALTIVEC"
   "stvewx %1,%y0"
   [(set_attr "type" "vecstore")])
Index: gcc/config/rs6000/altivec.h
===================================================================
--- gcc/config/rs6000/altivec.h	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/config/rs6000/altivec.h	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1,5 +1,6 @@
 /* PowerPC AltiVec include file.
-   Copyright (C) 2002, 2003, 2004, 2005, 2008, 2009 Free Software Foundation, Inc.
+   Copyright (C) 2002, 2003, 2004, 2005, 2008, 2009, 2010, 2011
+   Free Software Foundation, Inc.
    Contributed by Aldy Hernandez (aldyh@redhat.com).
    Rewritten by Paolo Bonzini (bonzini@gnu.org).
 
@@ -315,6 +316,8 @@
 #define vec_nearbyint __builtin_vec_nearbyint
 #define vec_rint __builtin_vec_rint
 #define vec_sqrt __builtin_vec_sqrt
+#define vec_vsx_ld __builtin_vec_vsx_ld
+#define vec_vsx_st __builtin_vec_vsx_st
 #endif
 
 /* Predicates.
Index: gcc/config/arm/arm.c
===================================================================
--- gcc/config/arm/arm.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/config/arm/arm.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1114,6 +1114,7 @@
 			     va_list_type);
   DECL_ARTIFICIAL (va_list_name) = 1;
   TYPE_NAME (va_list_type) = va_list_name;
+  TYPE_STUB_DECL (va_list_type) = va_list_name;
   /* Create the __ap field.  */
   ap_field = build_decl (BUILTINS_LOCATION,
 			 FIELD_DECL, 
Index: gcc/config/arm/arm.md
===================================================================
--- gcc/config/arm/arm.md	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/config/arm/arm.md	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -11273,34 +11273,29 @@
 (define_expand "bswapsi2"
   [(set (match_operand:SI 0 "s_register_operand" "=r")
   	(bswap:SI (match_operand:SI 1 "s_register_operand" "r")))]
-"TARGET_EITHER"
+"TARGET_EITHER && (arm_arch6 || !optimize_size)"
 "
-  if (!arm_arch6)
-    {
-      if (!optimize_size)
-	{
-	  rtx op2 = gen_reg_rtx (SImode);
-	  rtx op3 = gen_reg_rtx (SImode);
+    if (!arm_arch6)
+      {
+	rtx op2 = gen_reg_rtx (SImode);
+	rtx op3 = gen_reg_rtx (SImode);
 
-	  if (TARGET_THUMB)
-	    {
-	      rtx op4 = gen_reg_rtx (SImode);
-	      rtx op5 = gen_reg_rtx (SImode);
+	if (TARGET_THUMB)
+	  {
+	    rtx op4 = gen_reg_rtx (SImode);
+	    rtx op5 = gen_reg_rtx (SImode);
 
-	      emit_insn (gen_thumb_legacy_rev (operands[0], operands[1],
-					       op2, op3, op4, op5));
-	    }
-	  else
-	    {
-	      emit_insn (gen_arm_legacy_rev (operands[0], operands[1],
-					     op2, op3));
-	    }
+	    emit_insn (gen_thumb_legacy_rev (operands[0], operands[1],
+					     op2, op3, op4, op5));
+	  }
+	else
+	  {
+	    emit_insn (gen_arm_legacy_rev (operands[0], operands[1],
+					   op2, op3));
+	  }
 
-	  DONE;
-	}
-      else
-	FAIL;
-    }
+	DONE;
+      }
   "
 )
 
Index: gcc/config/pa/pa64-hpux.h
===================================================================
--- gcc/config/pa/pa64-hpux.h	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/config/pa/pa64-hpux.h	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1,6 +1,6 @@
 /* Definitions of target machine for GNU compiler, for HPs running
    HPUX using the 64bit runtime model.
-   Copyright (C) 1999, 2000, 2001, 2002, 2004, 2005, 2007, 2008
+   Copyright (C) 1999, 2000, 2001, 2002, 2004, 2005, 2007, 2008, 2011
    Free Software Foundation, Inc.
 
 This file is part of GCC.
@@ -59,36 +59,42 @@
 #if ((TARGET_DEFAULT | TARGET_CPU_DEFAULT) & MASK_GNU_LD)
 #define LIB_SPEC \
   "%{!shared:\
-     %{!p:%{!pg:%{static|mt|pthread:%{fopenmp:%{static:-a shared} -lrt\
-		  %{static:-a archive}} -lpthread} -lc\
-	    %{static:%{!nolibdld:-a shared -ldld -a archive -lc}}}}\
+     %{!p:%{!pg:%{fopenmp:%{static:-a shared} -lrt %{static:-a archive}}\
+	    %{mt|pthread:-lpthread} -lc\
+	    %{static:%{!nolibdld:-a shared -ldld -a archive -lc}\
+		%{!mt:%{!pthread:-a shared -lc -a archive}}}}}\
      %{p:%{!pg:%{static:%{!mhp-ld:-a shared}%{mhp-ld:-a archive_shared}}\
 	   -lprof %{static:-a archive}\
-	   %{static|mt|pthread:%{fopenmp:%{static:-a shared} -lrt\
-	     %{static:-a archive}} -lpthread} -lc\
-	   %{static:%{!nolibdld:-a shared -ldld -a archive -lc}}}}\
+	   %{fopenmp:%{static:-a shared} -lrt %{static:-a archive}}\
+	   %{mt|pthread:-lpthread} -lc\
+	   %{static:%{!nolibdld:-a shared -ldld -a archive -lc}\
+		%{!mt:%{!pthread:-a shared -lc -a archive}}}}}\
      %{pg:%{static:%{!mhp-ld:-a shared}%{mhp-ld:-a archive_shared}}\
        -lgprof %{static:-a archive}\
-       %{static|mt|pthread:%{fopenmp:%{static:-a shared} -lrt\
-	 %{static:-a archive}} -lpthread} -lc\
-       %{static:%{!nolibdld:-a shared -ldld -a archive -lc}}}}\
+       %{fopenmp:%{static:-a shared} -lrt %{static:-a archive}}\
+       %{mt|pthread:-lpthread} -lc\
+       %{static:%{!nolibdld:-a shared -ldld -a archive -lc}\
+		%{!mt:%{!pthread:-a shared -lc -a archive}}}}}\
    %{shared:%{mt|pthread:-lpthread}}"
 #else
 #define LIB_SPEC \
   "%{!shared:\
-     %{!p:%{!pg:%{static|mt|pthread:%{fopenmp:%{static:-a shared} -lrt\
-		  %{static:-a archive}} -lpthread} -lc\
-	    %{static:%{!nolibdld:-a shared -ldld -a archive -lc}}}}\
+     %{!p:%{!pg:%{fopenmp:%{static:-a shared} -lrt %{static:-a archive}}\
+	    %{mt|pthread:-lpthread} -lc\
+	    %{static:%{!nolibdld:-a shared -ldld -a archive -lc}\
+		%{!mt:%{!pthread:-a shared -lc -a archive}}}}}\
      %{p:%{!pg:%{static:%{mgnu-ld:-a shared}%{!mgnu-ld:-a archive_shared}}\
 	   -lprof %{static:-a archive}\
-	   %{static|mt|pthread:%{fopenmp:%{static:-a shared} -lrt\
-	     %{static:-a archive}} -lpthread} -lc\
-	   %{static:%{!nolibdld:-a shared -ldld -a archive -lc}}}}\
+	   %{fopenmp:%{static:-a shared} -lrt %{static:-a archive}}\
+	   %{mt|pthread:-lpthread} -lc\
+	   %{static:%{!nolibdld:-a shared -ldld -a archive -lc}\
+		%{!mt:%{!pthread:-a shared -lc -a archive}}}}}\
      %{pg:%{static:%{mgnu-ld:-a shared}%{!mgnu-ld:-a archive_shared}}\
        -lgprof %{static:-a archive}\
-       %{static|mt|pthread:%{fopenmp:%{static:-a shared} -lrt\
-	 %{static:-a archive}} -lpthread} -lc\
-       %{static:%{!nolibdld:-a shared -ldld -a archive -lc}}}}\
+       %{fopenmp:%{static:-a shared} -lrt %{static:-a archive}}\
+       %{mt|pthread:-lpthread} -lc\
+       %{static:%{!nolibdld:-a shared -ldld -a archive -lc}\
+		%{!mt:%{!pthread:-a shared -lc -a archive}}}}}\
    %{shared:%{mt|pthread:-lpthread}}"
 #endif
 
Index: gcc/config/pa/pa.md
===================================================================
--- gcc/config/pa/pa.md	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/config/pa/pa.md	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -811,7 +811,7 @@
 			 (match_operand:DI 3 "arith11_operand" "rI"))
 		 (match_operand:DI 1 "register_operand" "r")))]
   "TARGET_64BIT"
-  "sub%I3 %3,%2,%%r0\;add,dc %%r0,%1,%0"
+  "sub%I3,* %3,%2,%%r0\;add,dc %%r0,%1,%0"
   [(set_attr "type" "binary")
    (set_attr "length" "8")])
 
@@ -833,7 +833,7 @@
 			 (match_operand:DI 3 "register_operand" "r"))
 		 (match_operand:DI 1 "register_operand" "r")))]
   "TARGET_64BIT"
-  "sub %2,%3,%%r0\;add,dc %%r0,%1,%0"
+  "sub,* %2,%3,%%r0\;add,dc %%r0,%1,%0"
   [(set_attr "type" "binary")
    (set_attr "length" "8")])
 
@@ -856,7 +856,7 @@
 			 (match_operand:DI 3 "int11_operand" "I"))
 		 (match_operand:DI 1 "register_operand" "r")))]
   "TARGET_64BIT"
-  "addi %k3,%2,%%r0\;add,dc %%r0,%1,%0"
+  "addi,* %k3,%2,%%r0\;add,dc %%r0,%1,%0"
   [(set_attr "type" "binary")
    (set_attr "length" "8")])
 
@@ -902,7 +902,7 @@
 		  (gtu:DI (match_operand:DI 2 "register_operand" "r")
 			  (match_operand:DI 3 "arith11_operand" "rI"))))]
   "TARGET_64BIT"
-  "sub%I3 %3,%2,%%r0\;sub,db %1,%%r0,%0"
+  "sub%I3,* %3,%2,%%r0\;sub,db %1,%%r0,%0"
   [(set_attr "type" "binary")
    (set_attr "length" "8")])
 
@@ -924,7 +924,7 @@
 				    (match_operand:DI 3 "arith11_operand" "rI")))
 		  (match_operand:DI 4 "register_operand" "r")))]
   "TARGET_64BIT"
-  "sub%I3 %3,%2,%%r0\;sub,db %1,%4,%0"
+  "sub%I3,* %3,%2,%%r0\;sub,db %1,%4,%0"
   [(set_attr "type" "binary")
    (set_attr "length" "8")])
 
@@ -946,7 +946,7 @@
 		  (ltu:DI (match_operand:DI 2 "register_operand" "r")
 			  (match_operand:DI 3 "register_operand" "r"))))]
   "TARGET_64BIT"
-  "sub %2,%3,%%r0\;sub,db %1,%%r0,%0"
+  "sub,* %2,%3,%%r0\;sub,db %1,%%r0,%0"
   [(set_attr "type" "binary")
    (set_attr "length" "8")])
 
@@ -968,7 +968,7 @@
 				    (match_operand:DI 3 "register_operand" "r")))
 		  (match_operand:DI 4 "register_operand" "r")))]
   "TARGET_64BIT"
-  "sub %2,%3,%%r0\;sub,db %1,%4,%0"
+  "sub,* %2,%3,%%r0\;sub,db %1,%4,%0"
   [(set_attr "type" "binary")
    (set_attr "length" "8")])
 
@@ -991,7 +991,7 @@
 		  (leu:DI (match_operand:DI 2 "register_operand" "r")
 			  (match_operand:DI 3 "int11_operand" "I"))))]
   "TARGET_64BIT"
-  "addi %k3,%2,%%r0\;sub,db %1,%%r0,%0"
+  "addi,* %k3,%2,%%r0\;sub,db %1,%%r0,%0"
   [(set_attr "type" "binary")
    (set_attr "length" "8")])
 
@@ -1013,7 +1013,7 @@
 				    (match_operand:DI 3 "int11_operand" "I")))
 		  (match_operand:DI 4 "register_operand" "r")))]
   "TARGET_64BIT"
-  "addi %k3,%2,%%r0\;sub,db %1,%4,%0"
+  "addi,* %k3,%2,%%r0\;sub,db %1,%4,%0"
   [(set_attr "type" "binary")
    (set_attr "length" "8")])
 
Index: gcc/config/pa/pa-hpux11.h
===================================================================
--- gcc/config/pa/pa-hpux11.h	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/config/pa/pa-hpux11.h	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1,5 +1,5 @@
 /* Definitions of target machine for GNU compiler, for HP PA-RISC
-   Copyright (C) 1998, 1999, 2000, 2002, 2003, 2004, 2005, 2007, 2008
+   Copyright (C) 1998, 1999, 2000, 2002, 2003, 2004, 2005, 2007, 2008, 2011
    Free Software Foundation, Inc.
 
 This file is part of GCC.
@@ -114,16 +114,17 @@
    -z %{mlinker-opt:-O} %{!shared:-u main -u __gcc_plt_call}\
    %{static:-a archive} %{shared:-b}"
 
-/* HP-UX 11 has posix threads.  HP libc contains pthread stubs so that
-   non-threaded applications can be linked with a thread-safe libc
-   without a subsequent loss of performance.  For more details, see
-   <http://docs.hp.com/en/1896/pthreads.html>.  */
+/* HP-UX 11 has posix threads.  HP's shared libc contains pthread stubs
+   so that non-threaded applications can be linked with a thread-safe
+   libc without a subsequent loss of performance.  For more details,
+   see <http://docs.hp.com/en/1896/pthreads.html>.  */
 #undef LIB_SPEC
 #define LIB_SPEC \
   "%{!shared:\
-     %{static|mt|pthread:%{fopenmp:%{static:-a archive_shared} -lrt\
-       %{static:-a archive}} -lpthread} -lc\
-     %{static:%{!nolibdld:-a archive_shared -ldld -a archive -lc}}}\
+     %{fopenmp:%{static:-a archive_shared} -lrt %{static:-a archive}}\
+     %{mt|pthread:-lpthread} -lc\
+     %{static:%{!nolibdld:-a archive_shared -ldld -a archive -lc}\
+       %{!mt:%{!pthread:-a shared -lc -a archive}}}}\
    %{shared:%{mt|pthread:-lpthread}}"
 
 #undef STARTFILE_SPEC
Index: gcc/config/pa/t-pa64
===================================================================
--- gcc/config/pa/t-pa64	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/config/pa/t-pa64	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1,5 +1,5 @@
 # Copyright (C) 2000, 2001, 2002, 2004, 2006,
-# 2007 Free Software Foundation, Inc.
+# 2007, 2011 Free Software Foundation, Inc.
 #
 # This file is part of GCC.
 #
Index: gcc/config/pa/pa.c
===================================================================
--- gcc/config/pa/pa.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/config/pa/pa.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -6097,37 +6097,94 @@
 }
 
 /* Return TRUE if INSN, a jump insn, has an unfilled delay slot and
-   it branches to the next real instruction.  Otherwise, return FALSE.  */
+   it branches into the delay slot.  Otherwise, return FALSE.  */
 
 static bool
 branch_to_delay_slot_p (rtx insn)
 {
+  rtx jump_insn;
+
   if (dbr_sequence_length ())
     return FALSE;
 
-  return next_real_insn (JUMP_LABEL (insn)) == next_real_insn (insn);
+  jump_insn = next_active_insn (JUMP_LABEL (insn));
+  while (insn)
+    {
+      insn = next_active_insn (insn);
+      if (jump_insn == insn)
+	return TRUE;
+
+      /* We can't rely on the length of asms.  So, we return FALSE when
+	 the branch is followed by an asm.  */
+      if (!insn
+	  || GET_CODE (PATTERN (insn)) == ASM_INPUT
+	  || extract_asm_operands (PATTERN (insn)) != NULL_RTX
+	  || get_attr_length (insn) > 0)
+	break;
+    }
+
+  return FALSE;
 }
 
-/* Return TRUE if INSN, a jump insn, needs a nop in its delay slot.
+/* Return TRUE if INSN, a forward jump insn, needs a nop in its delay slot.
 
    This occurs when INSN has an unfilled delay slot and is followed
-   by an ASM_INPUT.  Disaster can occur if the ASM_INPUT is empty and
-   the jump branches into the delay slot.  So, we add a nop in the delay
-   slot just to be safe.  This messes up our instruction count, but we
-   don't know how big the ASM_INPUT insn is anyway.  */
+   by an asm.  Disaster can occur if the asm is empty and the jump
+   branches into the delay slot.  So, we add a nop in the delay slot
+   when this occurs.  */
 
 static bool
 branch_needs_nop_p (rtx insn)
 {
-  rtx next_insn;
+  rtx jump_insn;
 
   if (dbr_sequence_length ())
     return FALSE;
 
-  next_insn = next_real_insn (insn);
-  return GET_CODE (PATTERN (next_insn)) == ASM_INPUT;
+  jump_insn = next_active_insn (JUMP_LABEL (insn));
+  while (insn)
+    {
+      insn = next_active_insn (insn);
+      if (!insn || jump_insn == insn)
+	return TRUE;
+
+      if (!(GET_CODE (PATTERN (insn)) == ASM_INPUT
+	   || extract_asm_operands (PATTERN (insn)) != NULL_RTX)
+	  && get_attr_length (insn) > 0)
+	break;
+    }
+
+  return FALSE;
 }
 
+/* Return TRUE if INSN, a forward jump insn, can use nullification
+   to skip the following instruction.  This avoids an extra cycle due
+   to a mis-predicted branch when we fall through.  */
+
+static bool
+use_skip_p (rtx insn)
+{
+  rtx jump_insn = next_active_insn (JUMP_LABEL (insn));
+
+  while (insn)
+    {
+      insn = next_active_insn (insn);
+
+      /* We can't rely on the length of asms, so we can't skip asms.  */
+      if (!insn
+	  || GET_CODE (PATTERN (insn)) == ASM_INPUT
+	  || extract_asm_operands (PATTERN (insn)) != NULL_RTX)
+	break;
+      if (get_attr_length (insn) == 4
+	  && jump_insn == next_active_insn (insn))
+	return TRUE;
+      if (get_attr_length (insn) > 0)
+	break;
+    }
+
+  return FALSE;
+}
+
 /* This routine handles all the normal conditional branch sequences we
    might need to generate.  It handles compare immediate vs compare
    register, nullification of delay slots, varying length branches,
@@ -6139,7 +6196,7 @@
 output_cbranch (rtx *operands, int negated, rtx insn)
 {
   static char buf[100];
-  int useskip = 0;
+  bool useskip;
   int nullify = INSN_ANNULLED_BRANCH_P (insn);
   int length = get_attr_length (insn);
   int xdelay;
@@ -6177,12 +6234,7 @@
   /* A forward branch over a single nullified insn can be done with a
      comclr instruction.  This avoids a single cycle penalty due to
      mis-predicted branch if we fall through (branch not taken).  */
-  if (length == 4
-      && next_real_insn (insn) != 0
-      && get_attr_length (next_real_insn (insn)) == 4
-      && JUMP_LABEL (insn) == next_nonnote_insn (next_real_insn (insn))
-      && nullify)
-    useskip = 1;
+  useskip = (length == 4 && nullify) ? use_skip_p (insn) : FALSE;
 
   switch (length)
     {
@@ -6470,7 +6522,7 @@
 output_bb (rtx *operands ATTRIBUTE_UNUSED, int negated, rtx insn, int which)
 {
   static char buf[100];
-  int useskip = 0;
+  bool useskip;
   int nullify = INSN_ANNULLED_BRANCH_P (insn);
   int length = get_attr_length (insn);
   int xdelay;
@@ -6496,14 +6548,8 @@
   /* A forward branch over a single nullified insn can be done with a
      extrs instruction.  This avoids a single cycle penalty due to
      mis-predicted branch if we fall through (branch not taken).  */
+  useskip = (length == 4 && nullify) ? use_skip_p (insn) : FALSE;
 
-  if (length == 4
-      && next_real_insn (insn) != 0
-      && get_attr_length (next_real_insn (insn)) == 4
-      && JUMP_LABEL (insn) == next_nonnote_insn (next_real_insn (insn))
-      && nullify)
-    useskip = 1;
-
   switch (length)
     {
 
@@ -6661,7 +6707,7 @@
 output_bvb (rtx *operands ATTRIBUTE_UNUSED, int negated, rtx insn, int which)
 {
   static char buf[100];
-  int useskip = 0;
+  bool useskip;
   int nullify = INSN_ANNULLED_BRANCH_P (insn);
   int length = get_attr_length (insn);
   int xdelay;
@@ -6687,14 +6733,8 @@
   /* A forward branch over a single nullified insn can be done with a
      extrs instruction.  This avoids a single cycle penalty due to
      mis-predicted branch if we fall through (branch not taken).  */
+  useskip = (length == 4 && nullify) ? use_skip_p (insn) : FALSE;
 
-  if (length == 4
-      && next_real_insn (insn) != 0
-      && get_attr_length (next_real_insn (insn)) == 4
-      && JUMP_LABEL (insn) == next_nonnote_insn (next_real_insn (insn))
-      && nullify)
-    useskip = 1;
-
   switch (length)
     {
 
Index: gcc/config/pa/stublib.c
===================================================================
--- gcc/config/pa/stublib.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/config/pa/stublib.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1,5 +1,5 @@
 /* Stub functions.
-   Copyright (C) 2006, 2009 Free Software Foundation, Inc.
+   Copyright (C) 2006, 2009, 2011 Free Software Foundation, Inc.
 
 This file is part of GCC.
 
Index: gcc/reload1.c
===================================================================
--- gcc/reload1.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/reload1.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1,7 +1,7 @@
 /* Reload pseudo regs into hard regs for insns that require hard regs.
    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
-   Free Software Foundation, Inc.
+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
+   2011 Free Software Foundation, Inc.
 
 This file is part of GCC.
 
@@ -6266,18 +6266,7 @@
 	      && (rld[r].nregs == max_group_size
 		  || ! reg_classes_intersect_p (rld[r].rclass, group_class)))
 	    search_equiv = rld[r].in;
-	  /* If this is an output reload from a simple move insn, look
-	     if an equivalence for the input is available.  */
-	  else if (inheritance && rld[r].in == 0 && rld[r].out != 0)
-	    {
-	      rtx set = single_set (insn);
 
-	      if (set
-		  && rtx_equal_p (rld[r].out, SET_DEST (set))
-		  && CONSTANT_P (SET_SRC (set)))
-		search_equiv = SET_SRC (set);
-	    }
-
 	  if (search_equiv)
 	    {
 	      rtx equiv
@@ -7759,10 +7748,22 @@
 	  /* Maybe the spill reg contains a copy of reload_out.  */
 	  if (rld[r].out != 0
 	      && (REG_P (rld[r].out)
-#ifdef AUTO_INC_DEC
-		  || ! rld[r].out_reg
-#endif
-		  || REG_P (rld[r].out_reg)))
+		  || (rld[r].out_reg
+		      ? REG_P (rld[r].out_reg)
+		      /* The reload value is an auto-modification of
+			 some kind.  For PRE_INC, POST_INC, PRE_DEC
+			 and POST_DEC, we record an equivalence
+			 between the reload register and the operand
+			 on the optimistic assumption that we can make
+			 the equivalence hold.  reload_as_needed must
+			 then either make it hold or invalidate the
+			 equivalence.
+
+			 PRE_MODIFY and POST_MODIFY addresses are reloaded
+			 somewhat differently, and allowing them here leads
+			 to problems.  */
+		      : (GET_CODE (rld[r].out) != POST_MODIFY
+			 && GET_CODE (rld[r].out) != PRE_MODIFY))))
 	    {
 	      rtx reg;
 	      enum machine_mode mode;
@@ -8706,7 +8707,7 @@
 		 be used as an address.  */
 
 	      if (! post)
-		emit_insn (gen_move_insn (reloadreg, incloc));
+		add_insn = emit_insn (gen_move_insn (reloadreg, incloc));
 
 	      return add_insn;
 	    }
Index: gcc/gthr-posix95.h
===================================================================
--- gcc/gthr-posix95.h	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ gcc/gthr-posix95.h	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1,6 +1,7 @@
 /* Threads compatibility routines for libgcc2 and libobjc.  */
 /* Compile this one with gcc.  */
-/* Copyright (C) 2004, 2005, 2007, 2008, 2009 Free Software Foundation, Inc.
+/* Copyright (C) 2004, 2005, 2007, 2008, 2009, 2011
+   Free Software Foundation, Inc.
 
 This file is part of GCC.
 
@@ -184,61 +185,34 @@
    calls in shared flavors of the HP-UX C library.  Most of the stubs
    have no functionality.  The details are described in the "libc cumulative
    patch" for each subversion of HP-UX 11.  There are two special interfaces
-   provided for checking whether an application is linked to a pthread
+   provided for checking whether an application is linked to a shared pthread
    library or not.  However, these interfaces aren't available in early
-   libc versions.  We also can't use pthread_once as some libc versions
-   call the init function.  So, we use pthread_create to check whether it
-   is possible to create a thread or not.  The stub implementation returns
-   the error number ENOSYS.  */
+   pthread libraries.  We also need a test that works for archive
+   libraries.  We can't use pthread_once as some libc versions call the
+   init function.  We also can't use pthread_create or pthread_attr_init
+   as these create a thread and thereby prevent changing the default stack
+   size.  The function pthread_default_stacksize_np is available in both
+   the archive and shared versions of libpthread.   It can be used to
+   determine the default pthread stack size.  There is a stub in some
+   shared libc versions which returns a zero size if pthreads are not
+   active.  We provide an equivalent stub to handle cases where libc
+   doesn't provide one.  */
 
 #if defined(__hppa__) && defined(__hpux__)
 
-#include <errno.h>
-
 static volatile int __gthread_active = -1;
 
-static void *
-__gthread_start (void *arg __attribute__((unused)))
-{
-  return NULL;
-}
-
-static void __gthread_active_init (void) __attribute__((noinline));
-static void
-__gthread_active_init (void)
-{
-  static pthread_mutex_t __gthread_active_mutex = PTHREAD_MUTEX_INITIALIZER;
-  pthread_t t;
-  pthread_attr_t a;
-  int result;
-
-  __gthrw_(pthread_mutex_lock) (&__gthread_active_mutex);
-  if (__gthread_active < 0)
-    {
-      __gthrw_(pthread_attr_init) (&a);
-      __gthrw_(pthread_attr_setdetachstate) (&a, PTHREAD_CREATE_DETACHED);
-      result = __gthrw_(pthread_create) (&t, &a, __gthread_start, NULL);
-      if (result != ENOSYS)
-	__gthread_active = 1;
-      else
-	__gthread_active = 0;
-      __gthrw_(pthread_attr_destroy) (&a);
-    }
-  __gthrw_(pthread_mutex_unlock) (&__gthread_active_mutex);
-}
-
 static inline int
 __gthread_active_p (void)
 {
   /* Avoid reading __gthread_active twice on the main code path.  */
   int __gthread_active_latest_value = __gthread_active;
+  size_t __s;
 
-  /* This test is not protected to avoid taking a lock on the main code
-     path so every update of __gthread_active in a threaded program must
-     be atomic with regard to the result of the test.  */
   if (__builtin_expect (__gthread_active_latest_value < 0, 0))
     {
-      __gthread_active_init ();
+      pthread_default_stacksize_np (0, &__s);
+      __gthread_active = __s ? 1 : 0;
       __gthread_active_latest_value = __gthread_active;
     }
 
Index: libstdc++-v3/src/bitmap_allocator.cc
===================================================================
--- libstdc++-v3/src/bitmap_allocator.cc	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ libstdc++-v3/src/bitmap_allocator.cc	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -49,6 +49,7 @@
   {
 #if defined __GTHREADS
     __mutex_type& __bfl_mutex = _M_get_mutex();
+    __bfl_mutex.lock();
 #endif
     const vector_type& __free_list = _M_get_free_list();
     using __gnu_cxx::__detail::__lower_bound;
Index: libstdc++-v3/doc/xml/gnu/gpl-2.0.xml
===================================================================
--- libstdc++-v3/doc/xml/gnu/gpl-2.0.xml	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ libstdc++-v3/doc/xml/gnu/gpl-2.0.xml	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1,366 +0,0 @@
-<?xml version='1.0' encoding='ISO-8859-1'?>
-<!DOCTYPE appendix PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
-  "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
-<appendix id="appendix.gpl-2.0">
-  <appendixinfo>
-    <title>GNU General Public License</title>
-    <pubdate>Version 2, June 1991</pubdate>
-    <copyright>
-      <year>1989, 1991</year>
-      <holder>Free Software Foundation, Inc.</holder>
-    </copyright>
-    <legalnotice id="gpl-legalnotice">
-      <para>
-	<address>Free Software Foundation, Inc. 
-	  <street>51 Franklin Street, Fifth Floor</street>, 
-	  <city>Boston</city>, <state>MA</state> <postcode>02110-1301</postcode>
-	  <country>USA</country>
-	</address>
-      </para>
-      <para>Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed.</para>
-    </legalnotice>
-    <releaseinfo>Version 2, June 1991</releaseinfo>
-  </appendixinfo>
-  <title>GNU General Public License</title>
-  <section id="gpl-1">
-    <title>Preamble</title>
-    <para>The licenses for most software are designed to take away your 
-      freedom to share and change it. By contrast, the GNU General Public License is 
-      intended to guarantee your freedom to share and change 
-      free software - to make sure the software is free for all its users. 
-      This General Public License applies to most of the Free Software 
-      Foundation&apos;s software and to any other program whose authors commit 
-      to using it. (Some other Free Software Foundation software is covered 
-      by the GNU Library General Public License instead.) You can apply it 
-      to your programs, too.</para>
-
-    <para>When we speak of free software, we are referring to freedom, not price. 
-      Our General Public Licenses are designed to make sure that you have the 
-      freedom to distribute copies of free software (and charge for this 
-      service if you wish), that you receive source code or can get it if you 
-      want it, that you can change the software or use pieces of it in new free 
-      programs; and that you know you can do these things.</para>
-
-    <para>To protect your rights, we need to make restrictions that forbid anyone 
-      to deny you these rights or to ask you to surrender the rights. These 
-      restrictions translate to certain responsibilities for you if you distribute 
-      copies of the software, or if you modify it.</para>
-
-    <para>For example, if you distribute copies of such a program, whether gratis or 
-      for a fee, you must give the recipients all the rights that you have. You 
-      must make sure that they, too, receive or can get the source code. And you 
-      must show them these terms so they know their rights.</para>
-
-    <para>We protect your rights with two steps:
-      <orderedlist>
-	<listitem>
-	  <para>copyright the software, and</para>
-	</listitem>
-	<listitem>
-	  <para>offer you this license which gives you legal permission to copy, 
-	    distribute and/or modify the software.</para>
-	</listitem>
-      </orderedlist>
-    </para>
-
-    <para>Also, for each author&apos;s protection and ours, we want to make certain that 
-      everyone understands that there is no warranty for this free software. If 
-      the software is modified by someone else and passed on, we want its 
-      recipients to know that what they have is not the original, so that any 
-      problems introduced by others will not reflect on the original authors&apos; 
-      reputations.</para>
-
-    <para>Finally, any free program is threatened constantly by software patents. 
-      We wish to avoid the danger that redistributors of a free program will 
-      individually obtain patent licenses, in effect making the program 
-      proprietary. To prevent this, we have made it clear that any patent must be 
-      licensed for everyone&apos;s free use or not licensed at all.</para>
-
-    <para>The precise terms and conditions for copying, distribution and modification 
-      follow.</para>
-  </section>
-  <section id="gpl-2">
-    <title>TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION</title>
-    <section id="gpl-2-0">
-      <title>Section 0</title>
-      <para>This License applies to any program or other work which contains a notice 
-	placed by the copyright holder saying it may be distributed under the terms 
-	of this General Public License. The <quote>Program</quote>, below, refers to any such 
-	program or work, and a 
-	<quote>work based on the Program</quote> means either 
-	the Program or any derivative work under copyright law: that is to say, a 
-	work containing the Program or a portion of it, either verbatim or with 
-	modifications and/or translated into another language. (Hereinafter, translation 
-	is included without limitation in the term 
-	<quote>modification</quote>.) Each licensee is addressed as <quote>you</quote>.</para>
-
-      <para>Activities other than copying, distribution and modification are not covered by 
-	this License; they are outside its scope. The act of running the Program is not 
-	restricted, and the output from the Program is covered only if its contents 
-	constitute a work based on the Program (independent of having been made by running 
-	the Program). Whether that is true depends on what the Program does.</para>
-    </section>
-    <section id="gpl-2-1">
-      <title>Section 1</title>
-      <para>You may copy and distribute verbatim copies of the Program&apos;s source code as you 
-	receive it, in any medium, provided that you conspicuously and appropriately 
-	publish on each copy an appropriate copyright notice and disclaimer of warranty; 
-	keep intact all the notices that refer to this License and to the absence of any 
-	warranty; and give any other recipients of the Program a copy of this License 
-	along with the Program.</para>
-
-      <para>You may charge a fee for the physical act of transferring a copy, and you may at 
-	your option offer warranty protection in exchange for a fee.</para>
-    </section>
-    <section id="gpl-2-2">
-      <title>Section 2</title>
-      <para>You may modify your copy or copies of the Program or any portion of it, thus 
-	forming a work based on the Program, and copy and distribute such modifications 
-	or work under the terms of 
-	<link linkend="gpl-2-1">Section 1</link> above, provided 
-	that you also meet all of these conditions:
-	<orderedlist numeration="loweralpha">
-	  <listitem>
-	    <para>You must cause the modified files to carry prominent notices stating that 
-	      you changed the files and the date of any change.</para>
-	  </listitem>
-	  <listitem>
-	    <para>You must cause any work that you distribute or publish, that in whole or 
-	      in part contains or is derived from the Program or any part thereof, to be 
-	      licensed as a whole at no charge to all third parties under the terms of 
-	      this License.</para>
-	  </listitem>
-	  <listitem>
-	    <para>If the modified program normally reads commands interactively when run, you 
-	      must cause it, when started running for such interactive use in the most 
-	      ordinary way, to print or display an announcement including an appropriate 
-	      copyright notice and a notice that there is no warranty (or else, saying 
-	      that you provide a warranty) and that users may redistribute the program 
-	      under these conditions, and telling the user how to view a copy of this 
-	      License. (Exception: If the Program itself is interactive but does not 
-              normally print such an announcement, your work based on the Program is not 
-              required to print an   announcement.)</para>
-	  </listitem>
-	</orderedlist>
-      </para>
-
-      <para>These requirements apply to the modified work as a whole. If identifiable sections 
-	of that work are not derived from the Program, and can be reasonably considered 
-	independent and separate works in themselves, then this License, and its terms, 
-	do not apply to those sections when you distribute them as separate works. But when 
-	you distribute the same sections as part of a whole which is a work based on the 
-	Program, the distribution of the whole must be on the terms of this License, whose 
-	permissions for other licensees extend to the entire whole, and thus to each and 
-	every part regardless of who wrote it.</para>
-
-      <para>Thus, it is not the intent of this section to claim rights or contest your rights 
-	to work written entirely by you; rather, the intent is to exercise the right to control 
-	the distribution of derivative or collective works based on the Program.</para>
-
-      <para>In addition, mere aggregation of another work not based on the Program with the Program 
-	(or with a work based on the Program) on a volume of a storage or distribution medium 
-	does not bring the other work under the scope of this License.</para>
-    </section>
-    <section id="gpl-2-3">
-      <title>Section 3</title>
-      <para>You may copy and distribute the Program (or a work based on it, under 
-	<link linkend="gpl-2-2">Section 2</link> in object code or executable form under the terms of 
-	<link linkend="gpl-2-1">Sections 1</link> and 
-	<link linkend="gpl-2-2">2</link> above provided that you also do one of the following:
-	<orderedlist numeration="loweralpha">
-	  <listitem>
-	    <para>Accompany it with the complete corresponding machine-readable source code, which 
-	      must be distributed under the terms of Sections 1 and 2 above on a medium 
-	      customarily used for software interchange; or,</para>
-	  </listitem>
-	  <listitem>
-	    <para>Accompany it with a written offer, valid for at least three years, to give any 
-	      third party, for a charge no more than your cost of physically performing source 
-	      distribution, a complete machine-readable copy of the corresponding source code, 
-	      to be distributed under the terms of Sections 1 and 2 above on a medium customarily 
-	      used for software interchange; or,</para>
-	  </listitem>
-	  <listitem>
-	    <para>Accompany it with the information you received as to the offer to distribute 
-	      corresponding source code. (This alternative is allowed only for noncommercial 
-	      distribution and only if you received the program in object code or executable form 
-	      with such an offer, in accord with Subsection b above.)</para>
-	  </listitem>
-	</orderedlist>
-      </para>
-
-      <para>The source code for a work means the preferred form of the work for making modifications 
-	to it. For an executable work, complete source code means all the source code for all modules 
-	it contains, plus any associated interface definition files, plus the scripts used to control 
-	compilation and installation of the executable. However, as a special exception, the source 
-	code distributed need not include anything that is normally distributed (in either source or 
-	binary form) with the major components (compiler, kernel, and so on) of the operating system 
-	on which the executable runs, unless that component itself accompanies the executable.</para>
-
-      <para>If distribution of executable or object code is made by offering access to copy from a 
-	designated place, then offering equivalent access to copy the source code from the same place 
-	counts as distribution of the source code, even though third parties are not compelled to 
-	copy the source along with the object code.</para>
-    </section>
-    <section id="gpl-2-4">
-      <title>Section 4</title>
-      <para>You may not copy, modify, sublicense, or distribute the Program except as expressly provided 
-	under this License. Any attempt otherwise to copy, modify, sublicense or distribute the 
-	Program is void, and will automatically terminate your rights under this License. However, 
-	parties who have received copies, or rights, from you under this License will not have their 
-	licenses terminated so long as such parties remain in full compliance.</para>
-    </section>
-    <section id="gpl-2-5">
-      <title>Section 5</title>
-      <para>You are not required to accept this License, since you have not signed it. However, nothing 
-	else grants you permission to modify or distribute the Program or its derivative works. 
-	These actions are prohibited by law if you do not accept this License. Therefore, by modifying 
-	or distributing the Program (or any work based on the Program), you indicate your acceptance 
-	of this License to do so, and all its terms and conditions for copying, distributing or 
-	modifying the Program or works based on it.</para>
-    </section>
-    <section id="gpl-2-6">
-      <title>Section 6</title>
-      <para>Each time you redistribute the Program (or any work based on the Program), the recipient 
-	automatically receives a license from the original licensor to copy, distribute or modify 
-	the Program subject to these terms and conditions. You may not impose any further restrictions 
-	on the recipients&apos; exercise of the rights granted herein. You are not responsible for enforcing 
-	compliance by third parties to this License.</para>
-    </section>
-    <section id="gpl-2-7">
-      <title>Section 7</title>
-      <para>If, as a consequence of a court judgment or allegation of patent infringement or for any other 
-	reason (not limited to patent issues), conditions are imposed on you (whether by court order, 
-	agreement or otherwise) that contradict the conditions of this License, they do not excuse you 
-	from the conditions of this License. If you cannot distribute so as to satisfy simultaneously 
-	your obligations under this License and any other pertinent obligations, then as a consequence 
-	you may not distribute the Program at all. For example, if a patent license would not permit 
-	royalty-free redistribution of the Program by all those who receive copies directly or 
-	indirectly through you, then the only way you could satisfy both it and this License would be 
-	to refrain entirely from distribution of the Program.</para>
-
-      <para>If any portion of this section is held invalid or unenforceable under any particular circumstance, 
-	the balance of the section is intended to apply and the section as a whole is intended to apply 
-	in other circumstances.</para>
-
-      <para>It is not the purpose of this section to induce you to infringe any patents or other property 
-	right claims or to contest validity of any such claims; this section has the sole purpose of 
-	protecting the integrity of the free software distribution system, which is implemented by public 
-	license practices. Many people have made generous contributions to the wide range of software 
-	distributed through that system in reliance on consistent application of that system; it is up 
-	to the author/donor to decide if he or she is willing to distribute software through any other 
-	system and a licensee cannot impose that choice.</para>
-
-      <para>This section is intended to make thoroughly clear what is believed to be a consequence of the 
-	rest of this License.</para>
-    </section>
-    <section id="gpl-2-8">
-      <title>Section 8</title>
-      <para>If the distribution and/or use of the Program is restricted in certain countries either by patents 
-	or by copyrighted interfaces, the original copyright holder who places the Program under this License 
-	may add an explicit geographical distribution limitation excluding those countries, so that 
-	distribution is permitted only in or among countries not thus excluded. In such case, this License 
-	incorporates the limitation as if written in the body of this License.</para>
-    </section>
-    <section id="gpl-2-9">
-      <title>Section 9</title>
-      <para>The Free Software Foundation may publish revised and/or new versions of the General Public License 
-	from time to time. Such new versions will be similar in spirit to the present version, but may differ 
-	in detail to address new problems or concerns.</para>
-
-      <para>Each version is given a distinguishing version number. If the Program specifies a version number of 
-	this License which applies to it and <quote>any later version</quote>, you have the option of following the terms 
-	and conditions either of that version or of any later version published by the Free Software 
-	Foundation. If the Program does not specify a version number of this License, you may choose any 
-	version ever published by the Free Software Foundation.</para>
-    </section>
-    <section id="gpl-2-10">
-      <title>Section 10</title>
-      <para>If you wish to incorporate parts of the Program into other free programs whose distribution 
-	conditions are different, write to the author to ask for permission. For software which is copyrighted 
-	by the Free Software Foundation, write to the Free Software Foundation; we sometimes make exceptions 
-	for this. Our decision will be guided by the two goals of preserving the free status of all 
-	derivatives of our free software and of promoting the sharing and reuse of software generally.</para>
-    </section>
-    <section id="gpl-2-11">
-      <title>NO WARRANTY Section 11</title>
-      <para>BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT 
-	PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR 
-	OTHER PARTIES PROVIDE THE PROGRAM <quote>AS IS</quote> WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, 
-	INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
-	PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE 
-	PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.</para>
-    </section>
-    <section id="gpl-2-12">
-      <title>Section 12</title>
-      <para>IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR 
-	ANY OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU 
-	FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 
-	USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED 
-	INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH 
-	ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH 
-	DAMAGES.</para>
-
-      <para>END OF TERMS AND CONDITIONS</para>
-    </section>
-  </section>
-  <section id="gpl-3">
-    <title>How to Apply These Terms to Your New Programs</title>
-    <para>If you develop a new program, and you want it to be of the greatest
-      possible use to the public, the best way to achieve this is to make it
-      free software which everyone can redistribute and change under these terms.</para>
-
-    <para>To do so, attach the following notices to the program.  It is safest
-      to attach them to the start of each source file to most effectively
-      convey the exclusion of warranty; and each file should have at least
-      the <quote>copyright</quote> line and a pointer to where the full notice is found.</para>
-
-    <para>&lt;one line to give the program&apos;s name and a brief idea of what it does.&gt;
-      Copyright (C) &lt;year&gt;    &lt;name of author&gt;</para>
-
-    <para>This program is free software; you can redistribute it and/or modify
-      it under the terms of the GNU General Public License as published by
-      the Free Software Foundation; either version 2 of the License, or
-      (at your option) any later version.</para>
-
-    <para>This program is distributed in the hope that it will be useful,
-      but WITHOUT ANY WARRANTY; without even the implied warranty of
-      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-      GNU General Public License for more details.</para>
-
-    <para>You should have received a copy of the GNU General Public License
-      along with this program; if not, write to the Free Software
-      Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA</para>
-
-    <para>Also add information on how to contact you by electronic and paper mail.</para>
-
-    <para>If the program is interactive, make it output a short notice like this
-      when it starts in an interactive mode:</para>
-
-    <para>Gnomovision version 69, Copyright (C) year name of author
-      Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type <quote>show w</quote>.
-      This is free software, and you are welcome to redistribute it
-      under certain conditions; type <quote>show c</quote> for details.</para>
-
-    <para>The hypothetical commands <quote>show w</quote> and <quote>show c</quote> should 
-      show the appropriate parts of the General Public License.  Of course, the commands you 
-      use may be called something other than <quote>show w</quote> and <quote>show c</quote>; 
-      they could even be mouse-clicks or menu items--whatever suits your program.</para>
-
-    <para>You should also get your employer (if you work as a programmer) or your
-      school, if any, to sign a <quote>copyright disclaimer</quote> for the program, if
-      necessary.  Here is a sample; alter the names:</para>
-
-    <para>Yoyodyne, Inc., hereby disclaims all copyright interest in the program
-      <quote>Gnomovision</quote> (which makes passes at compilers) written by James Hacker.</para>
-
-    <para>&lt;signature of Ty Coon&gt;, 1 April 1989
-      Ty Coon, President of Vice</para>
-
-    <para>This General Public License does not permit incorporating your program into
-      proprietary programs.  If your program is a subroutine library, you may
-      consider it more useful to permit linking proprietary applications with the
-      library.  If this is what you want to do, use the GNU Library General
-      Public License instead of this License.</para>
-  </section>
-</appendix>
Index: libstdc++-v3/doc/xml/manual/codecvt.xml
===================================================================
--- libstdc++-v3/doc/xml/manual/codecvt.xml	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ libstdc++-v3/doc/xml/manual/codecvt.xml	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -595,7 +595,7 @@
 
   <biblioentry>
     <biblioid class="uri">
-      <ulink url="http://www.opengroup.org/austin">
+      <ulink url="http://www.opengroup.org/austin/">
 	<citetitle>
 	  System Interface Definitions, Issue 7 (IEEE Std. 1003.1-2008)
 	</citetitle>
Index: libstdc++-v3/doc/xml/manual/using_exceptions.xml
===================================================================
--- libstdc++-v3/doc/xml/manual/using_exceptions.xml	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ libstdc++-v3/doc/xml/manual/using_exceptions.xml	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -440,7 +440,7 @@
 
   <biblioentry>
     <biblioid class="uri">
-      <ulink url="http://www.opengroup.org/austin">
+      <ulink url="http://www.opengroup.org/austin/">
 	<citetitle>
 	  System Interface Definitions, Issue 7 (IEEE Std. 1003.1-2008)
 	</citetitle>
Index: libstdc++-v3/doc/xml/manual/debug.xml
===================================================================
--- libstdc++-v3/doc/xml/manual/debug.xml	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ libstdc++-v3/doc/xml/manual/debug.xml	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -45,7 +45,7 @@
   communicate information about source constructs can be changed via
   <code>-gdwarf-2</code> or <code>-gstabs</code> flags: some debugging
   formats permit more expressive type and scope information to be
-  shown in gdb. Expressiveness can be enhanced by flags like
+  shown in GDB. Expressiveness can be enhanced by flags like
   <code>-g3</code>. The default debug information for a particular
   platform can be identified via the value set by the
   PREFERRED_DEBUGGING_TYPE macro in the gcc sources.
@@ -197,14 +197,14 @@
   </para>
 
 <para>
-  Many options are available for gdb itself: please see <ulink
-  url="http://sources.redhat.com/gdb/current/onlinedocs/gdb_13.html#SEC125">
-  "GDB features for C++" </ulink> in the gdb documentation. Also
+  Many options are available for GDB itself: please see <ulink
+  url="http://sources.redhat.com/gdb/current/onlinedocs/gdb/">
+  "GDB features for C++" </ulink> in the GDB documentation. Also
   recommended: the other parts of this manual.
 </para>
 
 <para>
-  These settings can either be switched on in at the gdb command line,
+  These settings can either be switched on in at the GDB command line,
   or put into a .gdbint file to establish default debugging
   characteristics, like so:
 </para>
Index: libstdc++-v3/doc/xml/manual/locale.xml
===================================================================
--- libstdc++-v3/doc/xml/manual/locale.xml	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ libstdc++-v3/doc/xml/manual/locale.xml	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -571,7 +571,7 @@
 
   <biblioentry>
     <biblioid class="uri">
-      <ulink url="http://www.opengroup.org/austin">
+      <ulink url="http://www.opengroup.org/austin/">
 	<citetitle>
 	  System Interface Definitions, Issue 7 (IEEE Std. 1003.1-2008)
 	</citetitle>
Index: libstdc++-v3/doc/xml/manual/messages.xml
===================================================================
--- libstdc++-v3/doc/xml/manual/messages.xml	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ libstdc++-v3/doc/xml/manual/messages.xml	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -498,7 +498,7 @@
 
   <biblioentry>
     <biblioid class="uri">
-      <ulink url="http://www.opengroup.org/austin">
+      <ulink url="http://www.opengroup.org/austin/">
 	<citetitle>
 	  System Interface Definitions, Issue 7 (IEEE Std. 1003.1-2008)
 	</citetitle>
Index: libstdc++-v3/doc/Makefile.in
===================================================================
--- libstdc++-v3/doc/Makefile.in	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ libstdc++-v3/doc/Makefile.in	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -343,7 +343,6 @@
 
 xml_sources_extra = \
 	${xml_dir}/gnu/fdl-1.2.xml \
-	${xml_dir}/gnu/gpl-2.0.xml \
 	${xml_dir}/gnu/gpl-3.0.xml
 
 xml_sources = \
Index: libstdc++-v3/doc/Makefile.am
===================================================================
--- libstdc++-v3/doc/Makefile.am	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ libstdc++-v3/doc/Makefile.am	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -204,7 +204,6 @@
 
 xml_sources_extra = \
 	${xml_dir}/gnu/fdl-1.2.xml \
-	${xml_dir}/gnu/gpl-2.0.xml \
 	${xml_dir}/gnu/gpl-3.0.xml
 
 xml_sources = \
Index: libstdc++-v3/include/bits/atomic_0.h
===================================================================
--- libstdc++-v3/include/bits/atomic_0.h	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ libstdc++-v3/include/bits/atomic_0.h	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1,6 +1,6 @@
 // -*- C++ -*- header.
 
-// Copyright (C) 2008, 2009
+// Copyright (C) 2008, 2009, 2010, 2011
 // Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
@@ -49,34 +49,34 @@
     atomic_flag_clear_explicit(__g, __x);		       		   \
     __r; })
 
-#define _ATOMIC_STORE_(__a, __m, __x)					   \
+#define _ATOMIC_STORE_(__a, __n, __x)					   \
   ({__typeof__ _ATOMIC_MEMBER_* __p = &_ATOMIC_MEMBER_;	   		   \
-    __typeof__(__m) __v = (__m);			       		   \
+    __typeof__(__n) __w = (__n);			       		   \
     __atomic_flag_base* __g = __atomic_flag_for_address(__p);	  	   \
     __atomic_flag_wait_explicit(__g, __x);				   \
-    *__p = __v;								   \
+    *__p = __w;								   \
     atomic_flag_clear_explicit(__g, __x);		       		   \
-    __v; })
+    __w; })
 
-#define _ATOMIC_MODIFY_(__a, __o, __m, __x)				   \
+#define _ATOMIC_MODIFY_(__a, __o, __n, __x)				   \
   ({__typeof__ _ATOMIC_MEMBER_* __p = &_ATOMIC_MEMBER_;	   		   \
-    __typeof__(__m) __v = (__m);			       		   \
+    __typeof__(__n) __w = (__n);			       		   \
     __atomic_flag_base* __g = __atomic_flag_for_address(__p);	  	   \
     __atomic_flag_wait_explicit(__g, __x);				   \
     __typeof__ _ATOMIC_MEMBER_ __r = *__p;				   \
-    *__p __o __v;					       		   \
+    *__p __o __w;					       		   \
     atomic_flag_clear_explicit(__g, __x);		       		   \
     __r; })
 
-#define _ATOMIC_CMPEXCHNG_(__a, __e, __m, __x)				   \
+#define _ATOMIC_CMPEXCHNG_(__a, __e, __n, __x)				   \
   ({__typeof__ _ATOMIC_MEMBER_* __p = &_ATOMIC_MEMBER_;	   		   \
     __typeof__(__e) __q = (__e);			       		   \
-    __typeof__(__m) __v = (__m);			       		   \
+    __typeof__(__n) __w = (__n);			       		   \
     bool __r;						       		   \
     __atomic_flag_base* __g = __atomic_flag_for_address(__p);	   	   \
     __atomic_flag_wait_explicit(__g, __x);				   \
     __typeof__ _ATOMIC_MEMBER_ __t__ = *__p;		       		   \
-    if (__t__ == *__q) { *__p = __v; __r = true; }			   \
+    if (__t__ == *__q) { *__p = __w; __r = true; }			   \
     else { *__q = __t__; __r = false; }		       			   \
     atomic_flag_clear_explicit(__g, __x);		       		   \
     __r; })
Index: libstdc++-v3/ChangeLog
===================================================================
--- libstdc++-v3/ChangeLog	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ libstdc++-v3/ChangeLog	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1,3 +1,42 @@
+2011-02-08  Jonathan Wakely  <jwakely.gcc@gmail.com>
+
+	* doc/xml/gnu/gpl-2.0.xml: Remove.
+	* doc/Makefile.am: Update.
+	* doc/Makefile.in: Regenerate.
+
+2011-02-06  Gerald Pfeifer  <gerald@pfeifer.com>
+
+	* doc/xml/manual/debug.xml: Use GDB instead of gdb.
+	Adjust link to GDB manual.
+
+2011-02-01  Paolo Carlini  <paolo.carlini@oracle.com>
+
+	PR libstdc++/46914
+	* include/bits/atomic_0.h (_ATOMIC_STORE_, _ATOMIC_MODIFY_,
+	_ATOMIC_CMPEXCHNG_): Rename __v -> __w, and __m -> __n, to
+	avoid name conflicts.
+
+2011-01-30  Gerald Pfeifer  <gerald@pfeifer.com>
+
+	* doc/xml/manual/codecvt.xml: Fix link to The Austin Common
+	Standards Revision Group.
+	* doc/xml/manual/locale.xml: Ditto.
+	* doc/xml/manual/messages.xml: Ditto.
+	* doc/xml/manual/using_exceptions.xml: Ditto.
+
+2011-01-19  Graham Reed  <greed@pobox.com>
+
+	PR libstdc++/47354
+	* src/bitmap_allocator.cc (free_list::_M_get): Lock mutex.
+
+2010-12-17  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	Backport from mainline:
+	2010-12-10  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* testsuite/lib/libstdc++.exp (v3-build_support): Delete
+	libtestc++.a before creation.
+
 2010-12-16  Release Manager
 
 	* GCC 4.5.2 released.
Index: libstdc++-v3/testsuite/lib/libstdc++.exp
===================================================================
--- libstdc++-v3/testsuite/lib/libstdc++.exp	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ libstdc++-v3/testsuite/lib/libstdc++.exp	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -586,6 +586,15 @@
     }
 
     # Collect into libtestc++.a
+    # Delete libtestc++.a first.  Mixed 32 and 64-bit archives cannot be
+    # linked on IRIX 6.
+    # Use same procedure as gcc-dg.exp (remove-build-file).
+    if [is_remote host] {
+	# Ensure the host knows the file is gone by deleting there
+	# first.
+	remote_file host delete "./libtestc++.a"
+	}
+    remote_file build delete "./libtestc++.a"
     if  [info exists env(AR)] {
 	set ar $env(AR)
     } else {
Index: configure.ac
===================================================================
--- configure.ac	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ configure.ac	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1510,8 +1510,6 @@
 AC_SUBST(poststage1_ldflags)
 
 # Check for PPL
-ppl_major_version=0
-ppl_minor_version=10
 ppllibs=" -lppl_c -lppl -lgmpxx"
 pplinc=
 
@@ -1552,9 +1550,9 @@
 if test "x$with_ppl" != "xno" -a "${ENABLE_PPL_CHECK}" = "yes"; then
   saved_CFLAGS="$CFLAGS"
   CFLAGS="$CFLAGS $pplinc $gmpinc"
-  AC_MSG_CHECKING([for version $ppl_major_version.$ppl_minor_version of PPL])
+  AC_MSG_CHECKING([for version 0.10 (or later revision) of PPL])
   AC_TRY_COMPILE([#include "ppl_c.h"],[
-  #if PPL_VERSION_MAJOR != $ppl_major_version || PPL_VERSION_MINOR != $ppl_minor_version
+  #if PPL_VERSION_MAJOR != 0 || PPL_VERSION_MINOR < 10
   choke me
   #endif
   ], [AC_MSG_RESULT([yes])], [AC_MSG_RESULT([no]); ppllibs= ; pplinc= ; with_ppl=no ])
Index: ChangeLog
===================================================================
--- ChangeLog	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ ChangeLog	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1,3 +1,11 @@
+2011-01-25  Richard Guenther  <rguenther@suse.de>
+
+	Backport from mainline
+	2010-05-05  Sebastian Pop  <sebastian.pop@amd.com>
+
+	* configure.ac: Allow all the versions greater than 0.10 of PPL.
+	* configure: Regenerated.
+
 2010-12-16  Release Manager
 
 	* GCC 4.5.2 released.
Index: libffi/ChangeLog
===================================================================
--- libffi/ChangeLog	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ libffi/ChangeLog	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1,3 +1,18 @@
+2011-02-09  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	PR libffi/46661
+	* testsuite/libffi.call/cls_pointer.c (main): Cast void * to
+	uintptr_t first.
+	* testsuite/libffi.call/cls_pointer_stack.c (main): Likewise.
+
+2010-12-17  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	Backport from mainline:
+	2010-12-01  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* testsuite/libffi.call/ffitest.h [__sgi] (PRId64, PRIu64): Define.
+	(PRIuPTR): Define.
+
 2010-12-16  Release Manager
 
 	* GCC 4.5.2 released.
Index: libffi/testsuite/libffi.call/cls_pointer.c
===================================================================
--- libffi/testsuite/libffi.call/cls_pointer.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ libffi/testsuite/libffi.call/cls_pointer.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -65,7 +65,7 @@
 
 	CHECK(ffi_prep_closure_loc(pcl, &cif, cls_pointer_gn, NULL, code) == FFI_OK);
 
-	res = (ffi_arg)((void*(*)(void*, void*))(code))(arg1, arg2);
+	res = (ffi_arg)(uintptr_t)((void*(*)(void*, void*))(code))(arg1, arg2);
 	/* { dg-output "\n0x12345678 0x89abcdef: 0x9be02467" } */
 	printf("res: 0x%08x\n", (unsigned int) res);
 	/* { dg-output "\nres: 0x9be02467" } */
Index: libffi/testsuite/libffi.call/cls_pointer_stack.c
===================================================================
--- libffi/testsuite/libffi.call/cls_pointer_stack.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ libffi/testsuite/libffi.call/cls_pointer_stack.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -129,7 +129,7 @@
 
 	CHECK(ffi_prep_closure_loc(pcl, &cif, cls_pointer_gn, NULL, code) == FFI_OK);
 
-	res = (ffi_arg)((void*(*)(void*, void*))(code))(arg1, arg2);
+	res = (ffi_arg)(uintptr_t)((void*(*)(void*, void*))(code))(arg1, arg2);
 
 	printf("res: 0x%08x\n", (unsigned int) res);
 	// { dg-output "\n0x01234567 0x89abcdef: 0x8acf1356" }
Index: libffi/testsuite/libffi.call/ffitest.h
===================================================================
--- libffi/testsuite/libffi.call/ffitest.h	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ libffi/testsuite/libffi.call/ffitest.h	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -77,6 +77,26 @@
 #define PRIuPTR "lu"
 #endif
 
+/* IRIX kludge.  */
+#if defined(__sgi)
+/* IRIX 6.5 <inttypes.h> provides all definitions, but only for C99
+   compilations.  */
+#if (_MIPS_SZLONG == 32)
+#define PRId64 "lld"
+#define PRIu64 "llu"
+#endif
+/* This doesn't match <inttypes.h>, which always has "lld" here, but the
+   arguments are uint64_t, int64_t, which are unsigned long, long for
+   64-bit in <sgidefs.h>.  */
+#if (_MIPS_SZLONG == 64)
+#define PRId64 "ld"
+#define PRIu64 "lu"
+#endif
+/* This doesn't match <inttypes.h>, which has "u" here, but the arguments
+   are uintptr_t, which is always unsigned long.  */
+#define PRIuPTR "lu"
+#endif
+
 /* Solaris < 10 kludge.  */
 #if defined(__sun__) && defined(__svr4__) && !defined(PRIuPTR)
 #if defined(__arch64__) || defined (__x86_64__)
Index: libjava/classpath/lib/java/security/VMAccessController.class
===================================================================
Nie mona wywietli: plik binarny.
svn:mime-type = application/octet-stream
Index: libjava/ChangeLog
===================================================================
--- libjava/ChangeLog	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ libjava/ChangeLog	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1,3 +1,24 @@
+2011-01-07  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	Backport from mainline:
+	2011-01-06  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* testsuite/libjava.jni/jni.exp (gcj_jni_get_cxxflags_invocation):
+	Add -shared-libgcc to cxxflags for *-*-solaris*.
+	Remove -lsocket.
+
+2010-12-13  Andrew John Hughes  <ahughes@redhat.com>
+
+	PR libgcj/46774
+	* libjava/java/security/VMAccessController.java:
+	(DEFAULT_CONTEXT): Create ProtectionDomain with
+	four argument constructor (arguments are the same
+	as those implied by the two argument constructor).
+	(getContext()): Create ProtectionDomain instances
+	with four argument constructor using a null Principal
+	array (as before) but including the classloader, which
+	was always null before.
+
 2010-12-16  Release Manager
 
 	* GCC 4.5.2 released.
Index: libjava/testsuite/libjava.jni/jni.exp
===================================================================
--- libjava/testsuite/libjava.jni/jni.exp	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ libjava/testsuite/libjava.jni/jni.exp	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -274,8 +274,10 @@
     eval lappend cxxflags "-shared-libgcc -lgcj $libiconv"
   }
 
+  # Make sure libgcc unwinder is used on 64-bit Solaris 10+/x86 rather than
+  # the libc one.
   if { [istarget "*-*-solaris*"] } {
-    lappend cxxflags "-lsocket"
+    lappend cxxflags "-shared-libgcc"
   }
 
   return $cxxflags
Index: libjava/java/security/VMAccessController.java
===================================================================
--- libjava/java/security/VMAccessController.java	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ libjava/java/security/VMAccessController.java	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -56,7 +56,7 @@
     Permissions permissions = new Permissions();
     permissions.add(new AllPermission());
     ProtectionDomain[] domain = new ProtectionDomain[] {
-      new ProtectionDomain(source, permissions)
+      new ProtectionDomain(source, permissions, null, null)
     };
     DEFAULT_CONTEXT = new AccessControlContext(domain);
   }
@@ -178,12 +178,13 @@
     for (int i = 3; i < classes.length; i++)
       {
         Class clazz = classes[i];
+        ClassLoader loader = clazz.getClassLoader();
 
         if (DEBUG)
           {
             debug("checking " + clazz);
             // subject to getClassLoader RuntimePermission
-            debug("loader = " + clazz.getClassLoader());
+            debug("loader = " + loader);
           }
 
         if (privileged && i == classes.length - 2)
@@ -208,7 +209,8 @@
         // Create a static snapshot of this domain, which may change over time
         // if the current policy changes.
         domains.add(new ProtectionDomain(domain.getCodeSource(),
-                                         domain.getPermissions()));
+                                         domain.getPermissions(),
+                                         loader, null));
       }
 
     if (DEBUG)
Index: libcpp/directives.c
===================================================================
--- libcpp/directives.c	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ libcpp/directives.c	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -280,16 +280,17 @@
 static void
 end_directive (cpp_reader *pfile, int skip_line)
 {
-  if (pfile->state.in_deferred_pragma)
-    ;
-  else if (CPP_OPTION (pfile, traditional))
+  if (CPP_OPTION (pfile, traditional))
     {
       /* Revert change of prepare_directive_trad.  */
-      pfile->state.prevent_expansion--;
+      if (!pfile->state.in_deferred_pragma)
+	pfile->state.prevent_expansion--;
 
       if (pfile->directive != &dtable[T_DEFINE])
 	_cpp_remove_overlay (pfile);
     }
+  else if (pfile->state.in_deferred_pragma)
+    ;
   /* We don't skip for an assembler #.  */
   else if (skip_line)
     {
Index: libcpp/ChangeLog
===================================================================
--- libcpp/ChangeLog	(.../tags/gcc_4_5_2_release)	(wersja 170084)
+++ libcpp/ChangeLog	(.../branches/gcc-4_5-branch)	(wersja 170084)
@@ -1,3 +1,10 @@
+2011-11-04  Eric Botcazou  <ebotcazou@adacore.com>
+            Jakub Jelinek  <jakub@redhat.com>
+
+	PR preprocessor/39213
+	* directives.c (end_directive): Call _cpp_remove_overlay for deferred
+	pragmas as well in traditional mode.
+
 2010-12-16  Release Manager
 
 	* GCC 4.5.2 released.
