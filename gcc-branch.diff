Index: libgcc/config/libbid/ChangeLog
===================================================================
--- libgcc/config/libbid/ChangeLog	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libgcc/config/libbid/ChangeLog	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,3 +1,7 @@
+2010-01-21  Release Manager
+
+	* GCC 4.4.3 released.
+
 2009-10-15  Release Manager
 
 	* GCC 4.4.2 released.
Index: libgcc/ChangeLog
===================================================================
--- libgcc/ChangeLog	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libgcc/ChangeLog	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,3 +1,7 @@
+2010-01-21  Release Manager
+
+	* GCC 4.4.3 released.
+
 2009-10-15  Release Manager
 
 	* GCC 4.4.2 released.
Index: libgomp/ChangeLog
===================================================================
--- libgomp/ChangeLog	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libgomp/ChangeLog	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,3 +1,22 @@
+2010-01-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/42866
+	* testsuite/libgomp.fortran/allocatable5.f90: New test.
+
+2010-01-21  Release Manager
+
+	* GCC 4.4.3 released.
+
+2009-11-25  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/42162
+	* testsuite/libgomp.fortran/pr42162.f90: New test.
+
+2009-11-13  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/42029
+	* testsuite/libgomp.c/pr42029.c: New test.
+
 2009-10-15  Release Manager
 
 	* GCC 4.4.2 released.
Index: libgomp/testsuite/libgomp.fortran/allocatable5.f90
===================================================================
--- libgomp/testsuite/libgomp.fortran/allocatable5.f90	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ libgomp/testsuite/libgomp.fortran/allocatable5.f90	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,17 @@
+! PR fortran/42866
+! { dg-do run }
+
+program pr42866
+  integer, allocatable :: a(:)
+  allocate (a(16))
+  a = 0
+  !$omp parallel
+    !$omp sections reduction(+:a)
+      a = a + 1
+    !$omp section
+      a = a + 2
+    !$omp end sections
+  !$omp end parallel
+  if (any (a.ne.3)) call abort
+  deallocate (a)
+end
Index: libgomp/testsuite/libgomp.fortran/pr42162.f90
===================================================================
--- libgomp/testsuite/libgomp.fortran/pr42162.f90	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ libgomp/testsuite/libgomp.fortran/pr42162.f90	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,53 @@
+! PR fortran/42162
+! { dg-do run }
+
+subroutine sub1(k, a)
+  implicit none
+  integer :: k, a(3)
+  !$omp do
+    do k=1,3
+      a(k) = a(k) + 1
+    enddo
+  !$omp end do
+end subroutine sub1
+
+subroutine sub2(k, a)
+  implicit none
+  integer :: k, a(3)
+  !$omp do private (k)
+    do k=1,3
+      a(k) = a(k) + 1
+    enddo
+  !$omp end do
+end subroutine sub2
+
+subroutine sub3(k, a)
+  implicit none
+  integer :: k, a(3)
+  !$omp do lastprivate (k)
+    do k=1,3
+      a(k) = a(k) + 1
+    enddo
+  !$omp end do
+end subroutine sub3
+
+program pr42162
+  implicit none
+  integer :: k, a(3), b(3), c(3)
+  a = 1
+  b = 2
+  c = 3
+  k = 3
+  !$omp parallel num_threads(3)
+  call sub1 (k, a)
+  !$omp end parallel
+  k = 4
+  !$omp parallel num_threads(3)
+  call sub2 (k, b)
+  !$omp end parallel
+  k = 10
+  !$omp parallel num_threads(3)
+  call sub3 (k, c)
+  !$omp end parallel
+  if (k.ne.4.or.any(a.ne.2).or.any(b.ne.3).or.any(c.ne.4)) call abort
+end
Index: libgomp/testsuite/libgomp.c/pr42029.c
===================================================================
--- libgomp/testsuite/libgomp.c/pr42029.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ libgomp/testsuite/libgomp.c/pr42029.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,19 @@
+/* PR middle-end/42029 */
+/* { dg-do run } */
+
+extern void abort (void);
+
+int
+main ()
+{
+  int i;
+  _Complex int c = 0;
+
+#pragma omp parallel for private(i) reduction(+:c)
+  for (i = 0; i < 8; ++i)
+    c += 1;
+
+  if (c != 8)
+    abort ();
+  return 0;
+}
Index: config.guess
===================================================================
--- config.guess	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ config.guess	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,10 +1,10 @@
 #! /bin/sh
 # Attempt to guess a canonical system name.
 #   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
-#   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
+#   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
 #   Free Software Foundation, Inc.
 
-timestamp='2008-12-18'
+timestamp='2009-11-19'
 
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
@@ -27,16 +27,16 @@
 # the same distribution terms that you use for the rest of that program.
 
 
-# Originally written by Per Bothner <per@bothner.com>.
-# Please send patches to <config-patches@gnu.org>.  Submit a context
-# diff and a properly formatted ChangeLog entry.
+# Originally written by Per Bothner.  Please send patches (context
+# diff format) to <config-patches@gnu.org> and include a ChangeLog
+# entry.
 #
 # This script attempts to guess a canonical system name similar to
 # config.sub.  If it succeeds, it prints the system name on stdout, and
 # exits with 0.  Otherwise, it exits with 1.
 #
-# The plan is that this can be called by configure scripts if you
-# don't specify an explicit build system type.
+# You can get the latest version of this script from:
+# http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD
 
 me=`echo "$0" | sed -e 's,.*/,,'`
 
@@ -170,7 +170,7 @@
 	    arm*|i386|m68k|ns32k|sh3*|sparc|vax)
 		eval $set_cc_for_build
 		if echo __ELF__ | $CC_FOR_BUILD -E - 2>/dev/null \
-			| grep __ELF__ >/dev/null
+			| grep -q __ELF__
 		then
 		    # Once all utilities can be ECOFF (netbsdecoff) or a.out (netbsdaout).
 		    # Return netbsd for either.  FIX?
@@ -324,6 +324,9 @@
 	case `/usr/bin/uname -p` in
 	    sparc) echo sparc-icl-nx7; exit ;;
 	esac ;;
+    s390x:SunOS:*:*)
+	echo ${UNAME_MACHINE}-ibm-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit ;;
     sun4H:SunOS:5.*:*)
 	echo sparc-hal-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
 	exit ;;
@@ -653,7 +656,7 @@
 	    # => hppa64-hp-hpux11.23
 
 	    if echo __LP64__ | (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) |
-		grep __LP64__ >/dev/null
+		grep -q __LP64__
 	    then
 		HP_ARCH="hppa2.0w"
 	    else
@@ -804,12 +807,12 @@
     i*:PW*:*)
 	echo ${UNAME_MACHINE}-pc-pw32
 	exit ;;
-    *:Interix*:[3456]*)
+    *:Interix*:*)
     	case ${UNAME_MACHINE} in
 	    x86)
 		echo i586-pc-interix${UNAME_RELEASE}
 		exit ;;
-	    EM64T | authenticamd | genuineintel)
+	    authenticamd | genuineintel | EM64T)
 		echo x86_64-unknown-interix${UNAME_RELEASE}
 		exit ;;
 	    IA64)
@@ -819,6 +822,9 @@
     [345]86:Windows_95:* | [345]86:Windows_98:* | [345]86:Windows_NT:*)
 	echo i${UNAME_MACHINE}-pc-mks
 	exit ;;
+    8664:Windows_NT:*)
+	echo x86_64-pc-mks
+	exit ;;
     i*:Windows_NT*:* | Pentium*:Windows_NT*:*)
 	# How do we know it's Interix rather than the generic POSIX subsystem?
 	# It also conflicts with pre-2.0 versions of AT&T UWIN. Should we
@@ -848,6 +854,20 @@
     i*86:Minix:*:*)
 	echo ${UNAME_MACHINE}-pc-minix
 	exit ;;
+    alpha:Linux:*:*)
+	case `sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' < /proc/cpuinfo` in
+	  EV5)   UNAME_MACHINE=alphaev5 ;;
+	  EV56)  UNAME_MACHINE=alphaev56 ;;
+	  PCA56) UNAME_MACHINE=alphapca56 ;;
+	  PCA57) UNAME_MACHINE=alphapca56 ;;
+	  EV6)   UNAME_MACHINE=alphaev6 ;;
+	  EV67)  UNAME_MACHINE=alphaev67 ;;
+	  EV68*) UNAME_MACHINE=alphaev68 ;;
+        esac
+	objdump --private-headers /bin/sh | grep -q ld.so.1
+	if test "$?" = 0 ; then LIBC="libc1" ; else LIBC="" ; fi
+	echo ${UNAME_MACHINE}-unknown-linux-gnu${LIBC}
+	exit ;;
     arm*:Linux:*:*)
 	eval $set_cc_for_build
 	if echo __ARM_EABI__ | $CC_FOR_BUILD -E - 2>/dev/null \
@@ -870,6 +890,17 @@
     frv:Linux:*:*)
     	echo frv-unknown-linux-gnu
 	exit ;;
+    i*86:Linux:*:*)
+	LIBC=gnu
+	eval $set_cc_for_build
+	sed 's/^	//' << EOF >$dummy.c
+	#ifdef __dietlibc__
+	LIBC=dietlibc
+	#endif
+EOF
+	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^LIBC'`
+	echo "${UNAME_MACHINE}-pc-linux-${LIBC}"
+	exit ;;
     ia64:Linux:*:*)
 	echo ${UNAME_MACHINE}-unknown-linux-gnu
 	exit ;;
@@ -879,78 +910,34 @@
     m68*:Linux:*:*)
 	echo ${UNAME_MACHINE}-unknown-linux-gnu
 	exit ;;
-    mips:Linux:*:*)
+    mips:Linux:*:* | mips64:Linux:*:*)
 	eval $set_cc_for_build
 	sed 's/^	//' << EOF >$dummy.c
 	#undef CPU
-	#undef mips
-	#undef mipsel
+	#undef ${UNAME_MACHINE}
+	#undef ${UNAME_MACHINE}el
 	#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)
-	CPU=mipsel
+	CPU=${UNAME_MACHINE}el
 	#else
 	#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)
-	CPU=mips
+	CPU=${UNAME_MACHINE}
 	#else
 	CPU=
 	#endif
 	#endif
 EOF
-	eval "`$CC_FOR_BUILD -E $dummy.c 2>/dev/null | sed -n '
-	    /^CPU/{
-		s: ::g
-		p
-	    }'`"
+	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^CPU'`
 	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-gnu"; exit; }
 	;;
-    mips64:Linux:*:*)
-	eval $set_cc_for_build
-	sed 's/^	//' << EOF >$dummy.c
-	#undef CPU
-	#undef mips64
-	#undef mips64el
-	#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)
-	CPU=mips64el
-	#else
-	#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)
-	CPU=mips64
-	#else
-	CPU=
-	#endif
-	#endif
-EOF
-	eval "`$CC_FOR_BUILD -E $dummy.c 2>/dev/null | sed -n '
-	    /^CPU/{
-		s: ::g
-		p
-	    }'`"
-	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-gnu"; exit; }
-	;;
     or32:Linux:*:*)
 	echo or32-unknown-linux-gnu
 	exit ;;
-    ppc:Linux:*:*)
-	echo powerpc-unknown-linux-gnu
-	exit ;;
-    ppc64:Linux:*:*)
-	echo powerpc64-unknown-linux-gnu
-	exit ;;
-    alpha:Linux:*:*)
-	case `sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' < /proc/cpuinfo` in
-	  EV5)   UNAME_MACHINE=alphaev5 ;;
-	  EV56)  UNAME_MACHINE=alphaev56 ;;
-	  PCA56) UNAME_MACHINE=alphapca56 ;;
-	  PCA57) UNAME_MACHINE=alphapca56 ;;
-	  EV6)   UNAME_MACHINE=alphaev6 ;;
-	  EV67)  UNAME_MACHINE=alphaev67 ;;
-	  EV68*) UNAME_MACHINE=alphaev68 ;;
-        esac
-	objdump --private-headers /bin/sh | grep ld.so.1 >/dev/null
-	if test "$?" = 0 ; then LIBC="libc1" ; else LIBC="" ; fi
-	echo ${UNAME_MACHINE}-unknown-linux-gnu${LIBC}
-	exit ;;
     padre:Linux:*:*)
 	echo sparc-unknown-linux-gnu
 	exit ;;
+    parisc64:Linux:*:* | hppa64:Linux:*:*)
+	echo hppa64-unknown-linux-gnu
+	exit ;;
     parisc:Linux:*:* | hppa:Linux:*:*)
 	# Look for CPU level
 	case `grep '^cpu[^a-z]*:' /proc/cpuinfo 2>/dev/null | cut -d' ' -f2` in
@@ -959,9 +946,12 @@
 	  *)    echo hppa-unknown-linux-gnu ;;
 	esac
 	exit ;;
-    parisc64:Linux:*:* | hppa64:Linux:*:*)
-	echo hppa64-unknown-linux-gnu
+    ppc64:Linux:*:*)
+	echo powerpc64-unknown-linux-gnu
 	exit ;;
+    ppc:Linux:*:*)
+	echo powerpc-unknown-linux-gnu
+	exit ;;
     s390:Linux:*:* | s390x:Linux:*:*)
 	echo ${UNAME_MACHINE}-ibm-linux
 	exit ;;
@@ -983,66 +973,6 @@
     xtensa*:Linux:*:*)
     	echo ${UNAME_MACHINE}-unknown-linux-gnu
 	exit ;;
-    i*86:Linux:*:*)
-	# The BFD linker knows what the default object file format is, so
-	# first see if it will tell us. cd to the root directory to prevent
-	# problems with other programs or directories called `ld' in the path.
-	# Set LC_ALL=C to ensure ld outputs messages in English.
-	ld_supported_targets=`cd /; LC_ALL=C ld --help 2>&1 \
-			 | sed -ne '/supported targets:/!d
-				    s/[ 	][ 	]*/ /g
-				    s/.*supported targets: *//
-				    s/ .*//
-				    p'`
-        case "$ld_supported_targets" in
-	  elf32-i386)
-		TENTATIVE="${UNAME_MACHINE}-pc-linux-gnu"
-		;;
-	  a.out-i386-linux)
-		echo "${UNAME_MACHINE}-pc-linux-gnuaout"
-		exit ;;
-	  "")
-		# Either a pre-BFD a.out linker (linux-gnuoldld) or
-		# one that does not give us useful --help.
-		echo "${UNAME_MACHINE}-pc-linux-gnuoldld"
-		exit ;;
-	esac
-	# Determine whether the default compiler is a.out or elf
-	eval $set_cc_for_build
-	sed 's/^	//' << EOF >$dummy.c
-	#include <features.h>
-	#ifdef __ELF__
-	# ifdef __GLIBC__
-	#  if __GLIBC__ >= 2
-	LIBC=gnu
-	#  else
-	LIBC=gnulibc1
-	#  endif
-	# else
-	LIBC=gnulibc1
-	# endif
-	#else
-	#if defined(__INTEL_COMPILER) || defined(__PGI) || defined(__SUNPRO_C) || defined(__SUNPRO_CC)
-	LIBC=gnu
-	#else
-	LIBC=gnuaout
-	#endif
-	#endif
-	#ifdef __dietlibc__
-	LIBC=dietlibc
-	#endif
-EOF
-	eval "`$CC_FOR_BUILD -E $dummy.c 2>/dev/null | sed -n '
-	    /^LIBC/{
-		s: ::g
-		p
-	    }'`"
-	test x"${LIBC}" != x && {
-		echo "${UNAME_MACHINE}-pc-linux-${LIBC}"
-		exit
-	}
-	test x"${TENTATIVE}" != x && { echo "${TENTATIVE}"; exit; }
-	;;
     i*86:DYNIX/ptx:4*:*)
 	# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.
 	# earlier versions are messed up and put the nodename in both
@@ -1071,7 +1001,7 @@
     i*86:syllable:*:*)
 	echo ${UNAME_MACHINE}-pc-syllable
 	exit ;;
-    i*86:LynxOS:2.*:* | i*86:LynxOS:3.[01]*:* | i*86:LynxOS:4.0*:*)
+    i*86:LynxOS:2.*:* | i*86:LynxOS:3.[01]*:* | i*86:LynxOS:4.[02]*:*)
 	echo i386-unknown-lynxos${UNAME_RELEASE}
 	exit ;;
     i*86:*DOS:*:*)
@@ -1115,8 +1045,11 @@
     pc:*:*:*)
 	# Left here for compatibility:
         # uname -m prints for DJGPP always 'pc', but it prints nothing about
-        # the processor, so we play safe by assuming i386.
-	echo i386-pc-msdosdjgpp
+        # the processor, so we play safe by assuming i586.
+	# Note: whatever this is, it MUST be the same as what config.sub
+	# prints for the "djgpp" host, or else GDB configury will decide that
+	# this is a cross-build.
+	echo i586-pc-msdosdjgpp
         exit ;;
     Intel:Mach:3*:*)
 	echo i386-pc-mach3
@@ -1154,6 +1087,16 @@
     3[34]??:*:4.0:* | 3[34]??,*:*:4.0:*)
         /bin/uname -p 2>/dev/null | grep 86 >/dev/null \
           && { echo i486-ncr-sysv4; exit; } ;;
+    NCR*:*:4.2:* | MPRAS*:*:4.2:*)
+	OS_REL='.3'
+	test -r /etc/.relid \
+	    && OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
+	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
+	    && { echo i486-ncr-sysv4.3${OS_REL}; exit; }
+	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
+	    && { echo i586-ncr-sysv4.3${OS_REL}; exit; }
+	/bin/uname -p 2>/dev/null | /bin/grep pteron >/dev/null \
+	    && { echo i586-ncr-sysv4.3${OS_REL}; exit; } ;;
     m68*:LynxOS:2.*:* | m68*:LynxOS:3.0*:*)
 	echo m68k-unknown-lynxos${UNAME_RELEASE}
 	exit ;;
@@ -1166,7 +1109,7 @@
     rs6000:LynxOS:2.*:*)
 	echo rs6000-unknown-lynxos${UNAME_RELEASE}
 	exit ;;
-    PowerPC:LynxOS:2.*:* | PowerPC:LynxOS:3.[01]*:* | PowerPC:LynxOS:4.0*:*)
+    PowerPC:LynxOS:2.*:* | PowerPC:LynxOS:3.[01]*:* | PowerPC:LynxOS:4.[02]*:*)
 	echo powerpc-unknown-lynxos${UNAME_RELEASE}
 	exit ;;
     SM[BE]S:UNIX_SV:*:*)
@@ -1259,6 +1202,16 @@
     *:Darwin:*:*)
 	UNAME_PROCESSOR=`uname -p` || UNAME_PROCESSOR=unknown
 	case $UNAME_PROCESSOR in
+	    i386)
+		eval $set_cc_for_build
+		if [ "$CC_FOR_BUILD" != 'no_compiler_found' ]; then
+		  if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \
+		      (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) | \
+		      grep IS_64BIT_ARCH >/dev/null
+		  then
+		      UNAME_PROCESSOR="x86_64"
+		  fi
+		fi ;;
 	    unknown) UNAME_PROCESSOR=powerpc ;;
 	esac
 	echo ${UNAME_PROCESSOR}-apple-darwin${UNAME_RELEASE}
@@ -1340,6 +1293,9 @@
     i*86:rdos:*:*)
 	echo ${UNAME_MACHINE}-pc-rdos
 	exit ;;
+    i*86:AROS:*:*)
+	echo ${UNAME_MACHINE}-pc-aros
+	exit ;;
 esac
 
 #echo '(No uname command or uname output not recognized.)' 1>&2
Index: libdecnumber/ChangeLog
===================================================================
--- libdecnumber/ChangeLog	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libdecnumber/ChangeLog	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,3 +1,7 @@
+2010-01-21  Release Manager
+
+	* GCC 4.4.3 released.
+
 2009-10-15  Release Manager
 
 	* GCC 4.4.2 released.
Index: gcc/loop-unswitch.c
===================================================================
--- gcc/loop-unswitch.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/loop-unswitch.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,5 +1,5 @@
 /* Loop unswitching for GNU compiler.
-   Copyright (C) 2002, 2003, 2004, 2005, 2007, 2008
+   Copyright (C) 2002, 2003, 2004, 2005, 2007, 2008, 2010
    Free Software Foundation, Inc.
 
 This file is part of GCC.
@@ -121,7 +121,7 @@
       op0 = force_operand (op0, NULL_RTX);
       op1 = force_operand (op1, NULL_RTX);
       do_compare_rtx_and_jump (op0, op1, comp, 0,
-			       mode, NULL_RTX, NULL_RTX, label);
+			       mode, NULL_RTX, NULL_RTX, label, -1);
       jump = get_last_insn ();
       JUMP_LABEL (jump) = label;
       LABEL_NUSES (label)++;
Index: gcc/tree-loop-linear.c
===================================================================
--- gcc/tree-loop-linear.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/tree-loop-linear.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,5 +1,5 @@
 /* Linear Loop transforms
-   Copyright (C) 2003, 2004, 2005, 2007, 2008, 2009
+   Copyright (C) 2003, 2004, 2005, 2007, 2008, 2009, 2010
    Free Software Foundation, Inc.
    Contributed by Daniel Berlin <dberlin@dberlin.org>.
 
@@ -246,9 +246,10 @@
 	res = cmp < 0 ?
 	  estimated_loop_iterations (loop_j, false, &nb_iter):
 	  estimated_loop_iterations (loop_i, false, &nb_iter);
-	large = double_int_mul (large, nb_iter);
 
-	if (res && double_int_ucmp (large, l1_cache_size) < 0)
+	if (res
+	    && double_int_ucmp (double_int_mul (large, nb_iter),
+				l1_cache_size) < 0)
 	  continue;
 
 	if (dependence_steps_i < dependence_steps_j 
Index: gcc/doc/tm.texi
===================================================================
--- gcc/doc/tm.texi	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/doc/tm.texi	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -10149,18 +10149,6 @@
 @samp{#pragma pack()} (that is, a small power of two).
 @end defmac
 
-@findex #pragma
-@findex pragma
-@defmac HANDLE_PRAGMA_PUSH_POP_MACRO
-Define this macro if you want to support the Win32 style pragmas
-@samp{#pragma push_macro(macro-name-as-string)} and @samp{#pragma
-pop_macro(macro-name-as-string)}.  The @samp{#pragma push_macro(
-macro-name-as-string)} pragma saves the named macro and via
-@samp{#pragma pop_macro(macro-name-as-string)} it will return to the
-previous value.
-@end defmac
-
-
 @defmac DOLLARS_IN_IDENTIFIERS
 Define this macro to control use of the character @samp{$} in
 identifier names for the C family of languages.  0 means @samp{$} is
Index: gcc/doc/invoke.texi
===================================================================
--- gcc/doc/invoke.texi	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/doc/invoke.texi	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -7817,6 +7817,7 @@
 compilation.
 
 @table @gcctabopt
+@item -Wp,@var{option}
 @opindex Wp
 You can use @option{-Wp,@var{option}} to bypass the compiler driver
 and pass @var{option} directly through to the preprocessor.  If
@@ -7829,7 +7830,7 @@
 options instead.
 
 @item -Xpreprocessor @var{option}
-@opindex preprocessor
+@opindex Xpreprocessor
 Pass @var{option} as an option to the preprocessor.  You can use this to
 supply system-specific preprocessor options which GCC does not know how to
 recognize.
Index: gcc/tree-ssa-loop-im.c
===================================================================
--- gcc/tree-ssa-loop-im.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/tree-ssa-loop-im.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1767,8 +1767,8 @@
       name = get_name (TREE_OPERAND (ref, 1));
       if (!name)
 	name = "F";
-      lsm_tmp_name_add ("_");
       lsm_tmp_name_add (name);
+      break;
 
     case ARRAY_REF:
       gen_lsm_tmp_name (TREE_OPERAND (ref, 0));
Index: gcc/java/jcf-dump.c
===================================================================
--- gcc/java/jcf-dump.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/java/jcf-dump.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -2,7 +2,7 @@
    Functionally similar to Sun's javap.
 
    Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
-   2006, 2007, 2008, 2009 Free Software Foundation, Inc.
+   2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
 
 This file is part of GCC.
 
@@ -1167,7 +1167,7 @@
 version (void)
 {
   printf ("jcf-dump %s%s\n\n", pkgversion_string, version_string);
-  printf ("Copyright %s 2009 Free Software Foundation, Inc.\n", _("(C)"));
+  printf ("Copyright %s 2010 Free Software Foundation, Inc.\n", _("(C)"));
   printf (_("This is free software; see the source for copying conditions.  There is NO\n"
 	    "warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n"));
   exit (0);
Index: gcc/java/ChangeLog
===================================================================
--- gcc/java/ChangeLog	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/java/ChangeLog	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,3 +1,11 @@
+2010-01-21  Release Manager
+
+	* GCC 4.4.3 released.
+
+2010-01-09  Jakub Jelinek  <jakub@redhat.com>
+
+	* jcf-dump.c (version): Update copyright notice dates.
+
 2009-10-15  Release Manager
 
 	* GCC 4.4.2 released.
Index: gcc/optabs.c
===================================================================
--- gcc/optabs.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/optabs.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,6 +1,6 @@
 /* Expand the basic unary and binary arithmetic operations, for GNU compiler.
    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010
    Free Software Foundation, Inc.
 
 This file is part of GCC.
@@ -1149,7 +1149,7 @@
 
   NO_DEFER_POP;
   do_compare_rtx_and_jump (cmp1, cmp2, cmp_code, false, op1_mode,
-			   0, 0, subword_label);
+			   0, 0, subword_label, -1);
   OK_DEFER_POP;
 
   if (!expand_superword_shift (binoptab, outof_input, superword_op1,
@@ -3498,7 +3498,7 @@
   NO_DEFER_POP;
 
   do_compare_rtx_and_jump (target, CONST0_RTX (mode), GE, 0, mode,
-			   NULL_RTX, NULL_RTX, op1);
+			   NULL_RTX, NULL_RTX, op1, -1);
 
   op0 = expand_unop (mode, result_unsignedp ? neg_optab : negv_optab,
                      target, target, 0);
Index: gcc/DATESTAMP
===================================================================
--- gcc/DATESTAMP	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/DATESTAMP	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1 +1 @@
-20091015
+20100311
Index: gcc/tree-tailcall.c
===================================================================
--- gcc/tree-tailcall.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/tree-tailcall.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -920,8 +920,10 @@
 
       if (!phis_constructed)
 	{
-	  /* Ensure that there is only one predecessor of the block.  */
-	  if (!single_pred_p (first))
+	  /* Ensure that there is only one predecessor of the block
+	     or if there are existing degenerate PHI nodes.  */
+	  if (!single_pred_p (first)
+	      || !gimple_seq_empty_p (phi_nodes (first)))
 	    first = split_edge (single_succ_edge (ENTRY_BLOCK_PTR));
 
 	  /* Copy the args if needed.  */
Index: gcc/reload.c
===================================================================
--- gcc/reload.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/reload.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -6096,6 +6096,9 @@
 	      PUT_MODE (tem, GET_MODE (x));
 	      if (MEM_OFFSET (tem))
 		set_mem_offset (tem, plus_constant (MEM_OFFSET (tem), offset));
+	      if (MEM_SIZE (tem)
+		  && INTVAL (MEM_SIZE (tem)) != (HOST_WIDE_INT) outer_size)
+		set_mem_size (tem, GEN_INT (outer_size));
 
 	      /* If this was a paradoxical subreg that we replaced, the
 		 resulting memory must be sufficiently aligned to allow
Index: gcc/ipa-cp.c
===================================================================
--- gcc/ipa-cp.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/ipa-cp.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -191,11 +191,33 @@
 static void
 ipcp_update_cloned_node (struct cgraph_node *new_node)
 {
+  basic_block bb;
+  gimple_stmt_iterator gsi;
+
   /* We might've introduced new direct calls.  */
   push_cfun (DECL_STRUCT_FUNCTION (new_node->decl));
   current_function_decl = new_node->decl;
-  rebuild_cgraph_edges ();
 
+  FOR_EACH_BB (bb)
+    for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))
+      {
+	gimple stmt = gsi_stmt (gsi);
+	tree decl;
+
+	if (is_gimple_call (stmt)
+	    && (decl = gimple_call_fndecl (stmt))
+	    && !cgraph_edge (new_node, stmt))
+	  {
+	    struct cgraph_edge *new_edge;
+
+	    new_edge = cgraph_create_edge (new_node, cgraph_node (decl), stmt,
+					   bb->count,
+					   compute_call_stmt_bb_frequency (bb),
+					   bb->loop_depth);
+	    new_edge->indirect_call = 1;
+	  }
+      }
+
   /* Indirect inlinng rely on fact that we've already analyzed
      the body..  */
   if (flag_indirect_inlining)
@@ -960,7 +982,9 @@
 	for (cs = node->callers; cs; cs = next)
 	  {
 	    next = cs->next_caller;
-	    if (ipcp_node_is_clone (cs->caller) || !ipcp_need_redirect_p (cs))
+	    if (!cs->indirect_call
+		&& (ipcp_node_is_clone (cs->caller)
+		    || !ipcp_need_redirect_p (cs)))
 	      {
 		gimple new_stmt;
 		gimple_stmt_iterator gsi;
Index: gcc/tree-scalar-evolution.c
===================================================================
--- gcc/tree-scalar-evolution.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/tree-scalar-evolution.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -2186,8 +2186,19 @@
       if (CHREC_LEFT (chrec) != op0
 	  || CHREC_RIGHT (chrec) != op1)
 	{
+	  unsigned var = CHREC_VARIABLE (chrec);
+
+	  /* When the instantiated stride or base has an evolution in an
+	     innermost loop, return chrec_dont_know, as this is not a
+	     valid SCEV representation.  In the reduced testcase for
+	     PR40281 we would have {0, +, {1, +, 1}_2}_1 that has no
+	     meaning.  */
+	  if ((tree_is_chrec (op0) && CHREC_VARIABLE (op0) > var)
+	      || (tree_is_chrec (op1) && CHREC_VARIABLE (op1) > var))
+	    return chrec_dont_know;
+
 	  op1 = chrec_convert_rhs (chrec_type (op0), op1, NULL);
-	  chrec = build_polynomial_chrec (CHREC_VARIABLE (chrec), op0, op1);
+	  chrec = build_polynomial_chrec (var, op0, op1);
 	}
       return chrec;
 
Index: gcc/rtlanal.c
===================================================================
--- gcc/rtlanal.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/rtlanal.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -4508,8 +4508,16 @@
 					   known_x, known_mode, known_ret);
 
     case UMOD:
-      /* The result must be <= the second operand.  */
-      return cached_num_sign_bit_copies (XEXP (x, 1), mode,
+      /* The result must be <= the second operand.  If the second operand
+	 has (or just might have) the high bit set, we know nothing about
+	 the number of sign bit copies.  */
+      if (bitwidth > HOST_BITS_PER_WIDE_INT)
+	return 1;
+      else if ((nonzero_bits (XEXP (x, 1), mode)
+		& ((HOST_WIDE_INT) 1 << (bitwidth - 1))) != 0)
+	return 1;
+      else
+	return cached_num_sign_bit_copies (XEXP (x, 1), mode,
 					   known_x, known_mode, known_ret);
 
     case DIV:
Index: gcc/mips-tdump.c
===================================================================
--- gcc/mips-tdump.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/mips-tdump.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,6 +1,6 @@
 /* Read and manage MIPS symbol tables from object modules.
    Copyright (C) 1991, 1994, 1995, 1997, 1998, 1999, 2000, 2001, 2003, 2004,
-   2006, 2007, 2008, 2009 Free Software Foundation, Inc.
+   2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
    Contributed by hartzell@boulder.colorado.edu,
    Rewritten by meissner@osf.org.
 
@@ -1414,7 +1414,7 @@
   if (version)
     {
       printf ("mips-tdump %s%s\n", pkgversion_string, version_string);
-      fputs ("Copyright (C) 2009 Free Software Foundation, Inc.\n", stdout);
+      fputs ("Copyright (C) 2010 Free Software Foundation, Inc.\n", stdout);
       fputs ("This is free software; see the source for copying conditions.  There is NO\n\
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n",
              stdout);
Index: gcc/configure
===================================================================
--- gcc/configure	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/configure	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -21680,6 +21680,42 @@
 _ACEOF
 
 
+echo "$as_me:$LINENO: checking assembler for cfi sections directive" >&5
+echo $ECHO_N "checking assembler for cfi sections directive... $ECHO_C" >&6
+if test "${gcc_cv_as_cfi_sections_directive+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  gcc_cv_as_cfi_sections_directive=no
+  if test x$gcc_cv_as != x; then
+    echo '	.text
+	.cfi_sections .debug_frame, .eh_frame
+	.cfi_startproc
+	.cfi_endproc' > conftest.s
+    if { ac_try='$gcc_cv_as  -o conftest.o conftest.s >&5'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }
+    then
+	gcc_cv_as_cfi_sections_directive=yes
+    else
+      echo "configure: failed program was" >&5
+      cat conftest.s >&5
+    fi
+    rm -f conftest.o conftest.s
+  fi
+fi
+echo "$as_me:$LINENO: result: $gcc_cv_as_cfi_sections_directive" >&5
+echo "${ECHO_T}$gcc_cv_as_cfi_sections_directive" >&6
+
+
+cat >>confdefs.h <<_ACEOF
+#define HAVE_GAS_CFI_SECTIONS_DIRECTIVE `if test $gcc_cv_as_cfi_sections_directive = yes;
+    then echo 1; else echo 0; fi`
+_ACEOF
+
+
 # GAS versions up to and including 2.11.0 may mis-optimize
 # .eh_frame data.
 echo "$as_me:$LINENO: checking assembler for eh_frame optimization" >&5
Index: gcc/mips-tfile.c
===================================================================
--- gcc/mips-tfile.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/mips-tfile.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -3,7 +3,7 @@
    in the form of comments (the mips assembler does not support
    assembly access to debug information).
    Copyright (C) 1991, 1993, 1994, 1995, 1997, 1998, 1999, 2000, 2001,
-   2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
+   2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
    Free Software Foundation, Inc.
    Contributed by Michael Meissner (meissner@cygnus.com).
 
@@ -4781,7 +4781,7 @@
   if (version)
     {
       printf (_("mips-tfile %s%s\n"), pkgversion_string, version_string);
-      fputs ("Copyright (C) 2009 Free Software Foundation, Inc.\n", stdout);
+      fputs ("Copyright (C) 2010 Free Software Foundation, Inc.\n", stdout);
       fputs (_("This is free software; see the source for copying conditions.  There is NO\n\
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n"),
 	     stdout);
Index: gcc/builtins.c
===================================================================
--- gcc/builtins.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/builtins.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -151,7 +151,7 @@
 static tree fold_builtin_constant_p (tree);
 static tree fold_builtin_expect (tree, tree);
 static tree fold_builtin_classify_type (tree);
-static tree fold_builtin_strlen (tree);
+static tree fold_builtin_strlen (tree, tree);
 static tree fold_builtin_inf (tree, int);
 static tree fold_builtin_nan (tree, tree, int);
 static tree rewrite_call_expr (tree, int, tree, int, ...);
@@ -3712,7 +3712,15 @@
 {
   tree result = fold_builtin_strcpy (fndecl, dest, src, 0);
   if (result)
-    return expand_expr (result, target, mode, EXPAND_NORMAL);
+    {
+      while (TREE_CODE (result) == COMPOUND_EXPR)
+	{
+	  expand_expr (TREE_OPERAND (result, 0), const0_rtx, VOIDmode,
+		       EXPAND_NORMAL);
+	  result = TREE_OPERAND (result, 1);
+	}
+      return expand_expr (result, target, mode, EXPAND_NORMAL);
+    }
   return expand_movstr (dest, src, target, /*endp=*/0);
 
 }
@@ -7351,7 +7359,7 @@
 /* Fold a call to __builtin_strlen with argument ARG.  */
 
 static tree
-fold_builtin_strlen (tree arg)
+fold_builtin_strlen (tree type, tree arg)
 {
   if (!validate_arg (arg, POINTER_TYPE))
     return NULL_TREE;
@@ -7360,12 +7368,7 @@
       tree len = c_strlen (arg, 0);
 
       if (len)
-	{
-	  /* Convert from the internal "sizetype" type to "size_t".  */
-	  if (size_type_node)
-	    len = fold_convert (size_type_node, len);
-	  return len;
-	}
+	return fold_convert (type, len);
 
       return NULL_TREE;
     }
@@ -10126,7 +10129,7 @@
       return fold_builtin_classify_type (arg0);
 
     case BUILT_IN_STRLEN:
-      return fold_builtin_strlen (arg0);
+      return fold_builtin_strlen (type, arg0);
 
     CASE_FLT_FN (BUILT_IN_FABS):
       return fold_builtin_fabs (arg0, type);
Index: gcc/gcc.c
===================================================================
--- gcc/gcc.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/gcc.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -3642,7 +3642,7 @@
 	  /* translate_options () has turned --version into -fversion.  */
 	  printf (_("%s %s%s\n"), programname, pkgversion_string,
 		  version_string);
-	  printf ("Copyright %s 2009 Free Software Foundation, Inc.\n",
+	  printf ("Copyright %s 2010 Free Software Foundation, Inc.\n",
 		  _("(C)"));
 	  fputs (_("This is free software; see the source for copying conditions.  There is NO\n\
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n"),
Index: gcc/fold-const.c
===================================================================
--- gcc/fold-const.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/fold-const.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -328,13 +328,17 @@
   HOST_WIDE_INT h;
 
   l = l1 + l2;
-  h = h1 + h2 + (l < l1);
+  h = (HOST_WIDE_INT) ((unsigned HOST_WIDE_INT) h1
+		       + (unsigned HOST_WIDE_INT) h2
+		       + (l < l1));
 
   *lv = l;
   *hv = h;
 
   if (unsigned_p)
-    return (unsigned HOST_WIDE_INT) h < (unsigned HOST_WIDE_INT) h1;
+    return ((unsigned HOST_WIDE_INT) h < (unsigned HOST_WIDE_INT) h1
+	    || (h == h1
+		&& l < l1));
   else
     return OVERFLOW_SUM_SIGN (h1, h2, h);
 }
Index: gcc/omp-low.c
===================================================================
--- gcc/omp-low.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/omp-low.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -4606,7 +4606,7 @@
   l2_bb = region->exit;
   if (exit_reachable)
     {
-      if (single_pred (l2_bb) == l0_bb)
+      if (single_pred_p (l2_bb) && single_pred (l2_bb) == l0_bb)
 	l2 = gimple_block_label (l2_bb);
       else
 	{
@@ -6790,6 +6790,27 @@
       wi->info = context;
       break;
 
+    case GIMPLE_COND:
+	{
+	  tree lab = gimple_cond_true_label (stmt);
+	  if (lab)
+	    {
+	      n = splay_tree_lookup (all_labels,
+				     (splay_tree_key) lab);
+	      diagnose_sb_0 (gsi_p, context,
+			     n ? (gimple) n->value : NULL);
+	    }
+	  lab = gimple_cond_false_label (stmt);
+	  if (lab)
+	    {
+	      n = splay_tree_lookup (all_labels,
+				     (splay_tree_key) lab);
+	      diagnose_sb_0 (gsi_p, context,
+			     n ? (gimple) n->value : NULL);
+	    }
+	}
+      break;
+
     case GIMPLE_GOTO:
       {
 	tree lab = gimple_goto_dest (stmt);
Index: gcc/objc/ChangeLog
===================================================================
--- gcc/objc/ChangeLog	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/objc/ChangeLog	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,3 +1,7 @@
+2010-01-21  Release Manager
+
+	* GCC 4.4.3 released.
+
 2009-10-15  Release Manager
 
 	* GCC 4.4.2 released.
Index: gcc/gcov.c
===================================================================
--- gcc/gcov.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/gcov.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,7 +1,7 @@
 /* Gcov.c: prepend line execution counts and branch probabilities to a
    source file.
    Copyright (C) 1990, 1991, 1992, 1993, 1994, 1996, 1997, 1998, 1999,
-   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
+   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
    Free Software Foundation, Inc.
    Contributed by James E. Wilson of Cygnus Support.
    Mangled by Bob Manson of Cygnus Support.
@@ -426,7 +426,7 @@
 print_version (void)
 {
   fnotice (stdout, "gcov %s%s\n", pkgversion_string, version_string);
-  fprintf (stdout, "Copyright %s 2009 Free Software Foundation, Inc.\n",
+  fprintf (stdout, "Copyright %s 2010 Free Software Foundation, Inc.\n",
 	   _("(C)"));
   fnotice (stdout,
 	   _("This is free software; see the source for copying conditions.\n"
Index: gcc/vmsdbgout.c
===================================================================
--- gcc/vmsdbgout.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/vmsdbgout.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -166,6 +166,7 @@
 
 static void vmsdbgout_init (const char *);
 static void vmsdbgout_finish (const char *);
+static void vmsdbgout_assembly_start (void);
 static void vmsdbgout_define (unsigned int, const char *);
 static void vmsdbgout_undef (unsigned int, const char *);
 static void vmsdbgout_start_source_file (unsigned int, const char *);
@@ -188,6 +189,7 @@
 const struct gcc_debug_hooks vmsdbg_debug_hooks
 = {vmsdbgout_init,
    vmsdbgout_finish,
+   vmsdbgout_assembly_start,
    vmsdbgout_define,
    vmsdbgout_undef,
    vmsdbgout_start_source_file,
@@ -1636,6 +1638,15 @@
 /* Not implemented in VMS Debug.  */
 
 static void
+vmsdbgout_assembly_start (void)
+{
+  if (write_symbols == VMS_AND_DWARF2_DEBUG)
+    (*dwarf2_debug_hooks.assembly_start) ();
+}
+
+/* Not implemented in VMS Debug.  */
+
+static void
 vmsdbgout_define (unsigned int lineno, const char *buffer)
 {
   if (write_symbols == VMS_AND_DWARF2_DEBUG)
Index: gcc/debug.c
===================================================================
--- gcc/debug.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/debug.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -27,6 +27,7 @@
 {
   debug_nothing_charstar,
   debug_nothing_charstar,
+  debug_nothing_void,
   debug_nothing_int_charstar,
   debug_nothing_int_charstar,
   debug_nothing_int_charstar,
Index: gcc/DEV-PHASE
===================================================================
--- gcc/DEV-PHASE	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/DEV-PHASE	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1 @@
+prerelease
Index: gcc/debug.h
===================================================================
--- gcc/debug.h	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/debug.h	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -31,6 +31,10 @@
   /* Output debug symbols.  */
   void (* finish) (const char *main_filename);
 
+  /* Called from cgraph_optimize before starting to assemble
+     functions/variables/toplevel asms.  */
+  void (* assembly_start) (void);
+
   /* Macro defined on line LINE with name and expansion TEXT.  */
   void (* define) (unsigned int line, const char *text);
 
Index: gcc/cgraphunit.c
===================================================================
--- gcc/cgraphunit.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/cgraphunit.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1293,6 +1293,7 @@
   timevar_pop (TV_CGRAPHOPT);
 
   /* Output everything.  */
+  (*debug_hooks->assembly_start) ();
   if (!quiet_flag)
     fprintf (stderr, "Assembling functions:\n");
 #ifdef ENABLE_CHECKING
Index: gcc/ChangeLog
===================================================================
--- gcc/ChangeLog	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/ChangeLog	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,3 +1,1038 @@
+2010-03-08  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline:
+	2010-03-04  Andrew Pinski  <andrew_pinski@caviumnetworks.com>
+
+	PR c/43248
+	* c-decl.c (build_compound_literal): Return early if init is
+	an error_mark_node.
+
+2010-03-08  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline:
+	2010-02-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/42233
+	* dojump.c (do_jump) <case TRUTH_NOT_EXPR>: Invert priority.
+
+	PR bootstrap/43121
+	* except.c (sjlj_emit_function_enter): Don't call
+	add_reg_br_prob_note, instead add REG_BR_PROB note to the last insn
+	directly.
+	* rtl.h (add_reg_br_prob_note): Remove prototype.
+
+	PR middle-end/42233
+	* loop-doloop.c (add_test): Adjust do_compare_rtx_and_jump caller.
+
+	PR middle-end/42233
+	* expr.h (jumpifnot, jumpifnot_1, jumpif, jumpif_1, do_jump,
+	do_jump_1, do_compare_rtx_and_jump): Add PROB argument.
+	* dojump.c: Include output.h.
+	(inv): New inline function.
+	(jumpifnot, jumpifnot_1, jumpif, jumpif_1, do_jump_1, do_jump,
+	do_jump_by_parts_greater_rtx, do_jump_by_parts_greater,
+	do_jump_by_parts_zero_rtx, do_jump_by_parts_equality_rtx,
+	do_jump_by_parts_equality, do_compare_and_jump): Add PROB
+	argument, pass it down to other calls.
+	(do_compare_rtx_and_jump): Likewise.  If PROB is not -1,
+	add REG_BR_PROB note to the conditional jump.
+	* cfgexpand.c (add_reg_br_prob_note): Removed.
+	(expand_gimple_cond): Don't call it, add the probability
+	as last argument to jumpif_1/jumpifnot_1.
+	* Makefile.in (dojump.o): Depend on output.h.
+	* builtins.c (expand_errno_check): Adjust do_compare_rtx_and_jump
+	callers.
+	* expmed.c (emit_store_flag_force, do_cmp_and_jump): Likewise.
+	* stmt.c (do_jump_if_equal): Likewise.
+	* cfgrtl.c (rtl_lv_add_condition_to_bb): Likewise.
+	* loop-unswitch.c (compare_and_jump_seq): Likewise.
+	* config/rs6000/rs6000.c (rs6000_aix_emit_builtin_unwind_init):
+	Likewise.
+	* optabs.c (expand_doubleword_shift, expand_abs): Likewise.
+	* expr.c (expand_expr_real_1): Adjust do_jump, jumpifnot and
+	jumpifnot_1 callers.
+	(expand_expr_real_2): Adjust jumpifnot_1 and do_compare_rtx_and_jump
+	callers.
+	(store_expr): Adjust jumpifnot caller.
+	(store_constructor): Adjust jumpif caller.
+
+	PR middle-end/42233
+	* gimplify.c (gimple_boolify): For __builtin_expect call
+	gimple_boolify also on its first argument.
+
+2010-03-02  Uros Bizjak  <ubizjak@gmail.com>
+
+	* config/alpha/alpha.c (override_options): Fix -mtune error message.
+
+2010-03-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline:
+	2010-03-01  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/43220
+	* tree-ssa-ccp.c (optimize_stack_restore): Do not optimize
+	BUILT_IN_STACK_{SAVE,RESTORE} around alloca.
+
+2010-02-24  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	Backport from trunk
+	2009-07-10  Mark Mitchell  <mark@codesourcery.com>
+
+	* config/arm/thumb2.md (thumb2_cbz): Correct computation of length
+	attribute.
+	(thumb2_cbnz): Likewise.
+
+2010-02-22  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>
+
+	* config/s390/s390.md ("movqi"): Re-add the mem->mem alternative.
+	(QI to BLKmode splitter): New splitter.
+
+2010-02-18  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	* config/spu/spu-c.c (spu_resolve_overloaded_builtin): Call
+	lang_hooks.types_compatible_p instead of comptypes.
+
+2010-02-18  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	PR target/40887
+	Backport from trunk.
+	2009-12-24  Julian Brown  <julian@codesourcery.com>
+		    Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	* config/arm/arm.c (output_call_mem): Remove armv5 support.
+	* config/arm/arm.md (*call_mem): Disable for armv5. Add note.
+	(*call_value_mem): Likewise.
+
+2010-02-17  Mikael Pettersson  <mikpe@it.uu.se>
+
+	* config/sparc/gas.h: New file.  Restore
+	TARGET_ASM_NAMED_SECTION to its ELF default.
+	* config/sparc/sysv4.h (TARGET_ASM_NAMED_SECTION): Do not
+	check !HAVE_GNU_AS.
+	* config/sparc/sparc.c (sparc_elf_asm_named_section):
+	Likewise.  Add ATTRIBUTE_UNUSED to prototype.
+	* config.gcc (sparc*-*-linux*): Include sparc/gas.h
+	after sparc/sysv4.h.
+
+2010-02-17  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	Backport from trunk.
+	2009-12-07  Julian Brown  <julian@codesourcery.com>
+
+	* config/arm/constraints.md (Ps, Pt): New constraint letters.
+	* config/arm/thumb2.md (*thumb2_addsi_short): Tighten constraints.
+
+2010-02-16  Ira Rosen <irar@il.ibm.com>
+
+	PR tree-optimization/43074
+	* tree-vect-analyze.c (vect_detect_hybrid_slp_stmts): Add
+	vectorizable cycles in hybrid SLP check.
+
+2010-02-14  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>
+
+	* config/s390/s390.c (s390_sched_init): New function.
+	(TARGET_SCHED_INIT): Target hook defined.
+
+2010-02-13  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/42871
+	* tree-ssa-pre.c (phi_translate_set): Make sure to retain
+	leaders.
+
+2010-02-10  Daniel Gutson  <dgutson@codesourcery.com>
+
+	* config/arm/lib1funcs.asm (__ARM_ARCH__): __ARM_ARCH_7EM__
+	added to the preprocessor condition.
+
+2010-02-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/43010
+	* dwarf2out.c (retry_incomplete_types): Don't call gen_type_die
+	if no debug info should be emitted for it.
+
+2010-02-09  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline:
+	2010-01-13  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/42705
+	* tree-ssa-reassoc.c (build_and_add_sum): Insert stmts after
+	labels.
+
+2010-02-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/42890
+	* tree-inline.c (delete_unreachable_blocks_update_callgraph): New
+	function backported from the trunk.
+	(tree_function_versioning): Call it instead of
+	delete_unreachable_blocks.
+
+	PR tree-optimization/42931
+	* tree-loop-linear.c (try_interchange_loops): Don't call
+	double_int_mul if estimated_loop_iterations failed.
+
+2010-02-08  Richard Guenther  <rguenther@suse.de>
+
+	PR middle-end/42995
+	* tree-inline.c (estimate_move_cost): Assert we are not called
+	with a void type.
+	(estimate_num_insns): Do not count the terminating void_type_node
+	of a function argument type list.
+
+	Backport from mainline:
+	2010-01-06  Richard Guenther  <rguenther@suse.de>
+
+	* ipa-inline.c (cgraph_decide_inlining_incrementally): Do
+	not inline regular functions into always-inline functions.
+
+	2010-01-05  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/42462
+	* ipa-inline.c (compute_inline_parameters): Pass node->decl instead of
+	current_function_decl to helper functions and macros.
+
+2010-02-04  Richard Guenther  <rguenther@suse.de>
+
+	PR rtl-optimization/42952
+	* dse.c (const_or_frame_p): Remove MEM handling.
+
+2010-01-31  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR middle-end/42898
+	Backport from mainline:
+	2009-04-23  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gimplify.c (gimplify_modify_expr_rhs) <VAR_DECL>: Do not do a direct
+	assignment from the constructor either if the target is volatile.
+
+2010-01-31  Richard Guenther  <rguenther@suse.de>
+
+	PR middle-end/42898
+	* gimplify.c (gimplify_init_constructor): For volatile LHS
+	initialize a temporary.
+
+2010-01-26  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* config/sparc/sparc.c (sparc_elf_asm_named_section): Test for
+	HAVE_GNU_AS value.
+	* config/sparc/sysv4.h [HAVE_GNU_AS] (TARGET_ASM_NAMED_SECTION):
+	Test for HAVE_GNU_AS value.
+
+2010-01-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/42866
+	* omp-low.c (expand_omp_sections): Only use single_pred if
+	l2_bb is single_pred_p.
+
+2010-01-25  Christian Bruel  <christian.bruel@st.com>
+
+	PR target/42841
+	* config/sh/sh.c (find_barrier): Increase length for non delayed
+	conditional branches.
+	(sh_insn_length_adjustment): Use JUMP_TABLE_DATA_P.
+
+2010-01-25  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	Backport from trunk.
+	2010-01-19  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	PR target/38697
+	* config/arm/neon-testgen.m (emit_automatics): New parameter
+	features. Adjust for Fixed_return_reg feature.
+	(test_intrinsic): Call emit_automatics with new feature.
+	* config/arm/neon.ml: Update copyright years.
+	(features): New Fixed_return_reg feature.
+	(ops): Update feature for Vget_low.
+
+2010-01-24  David S. Miller  <davem@davemloft.net>
+
+	* config/sparc/sysv4.h (TARGET_ASM_NAMED_SECTION): Only
+	define if not using GAS.
+	* config/sparc/sparc.c (sparc_elf_asm_named_section):
+	Likewise.  Delete SECTION_MERGE code, which is only applicable
+	when using GAS.
+
+2010-01-21  Felyza Wishbringer  <fwishbringer@gmail.com>
+
+	PR bootstrap/42786
+	* config.gcc (i[34567]86-*-*): Fix handling of athlon64 and athlon-fx
+	cpu types.  Add support for *-sse3 cpu types.
+	(x86_64-*-*): Ditto.
+
+2010-01-21  Jakub Jelinek  <jakub@redhat.com>
+
+	* BASE-VER: Set to 4.4.4.
+	* DEV-PHASE: Set to prerelease.
+
+2010-01-21  Release Manager
+
+	* GCC 4.4.3 released.
+
+2010-01-20  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/41826
+	* tree-ssa-structalias.c (get_constraint_for_ptr_offset): Avoid
+	access to re-allocated vector fields.
+
+2010-01-20  Jakub Jelinek  <jakub@redhat.com>
+
+	* dwarf2out.c (loc_descriptor_from_tree_1): Don't handle unsigned
+	division.  Handle signed modulo using DW_OP_{over,over,div,mul,minus}.
+	* unwind-dw2.c (execute_stack_op): Handle DW_OP_mod using unsigned
+	modulo instead of signed.
+
+	PR middle-end/42803
+	* varasm.c (narrowing_initializer_constant_valid_p): Add CACHE
+	argument, call initializer_constant_valid_p_1 instead of
+	initializer_constant_valid_p, pass CACHE to it, return NULL
+	immediately if first call returns NULL.
+	(initializer_constant_valid_p_1): New function.
+	(initializer_constant_valid_p): Use it.
+
+2010-01-18  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/42774
+	* config/alpha/predicates.md (aligned_memory_operand): Return 0 for
+	memory references with unaligned offsets.  Remove CQImode handling.
+	(unaligned_memory_operand): Return 1 for memory references with
+	unaligned offsets.  Remove CQImode handling.
+
+2010-01-17  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline:
+	2010-01-13  Steve Ellcey  <sje@cup.hp.com>
+
+	PR target/42542
+	* config/ia64/ia64.c (ia64_expand_vecint_compare): Convert GTU to GT
+	for V2SI by subtracting (-(INT MAX) - 1) from both operands to make
+	them signed.
+
+2010-01-17  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/42773
+	* tree-ssa-pre.c (phi_translate_set): Fix check for PHI node existence.
+	(compute_antic_aux): Likewise.
+	(compute_partial_antic_aux): Likewise.
+
+2010-01-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/42760
+	Backport from trunk
+	2009-06-17  Steve Ellcey  <sje@cup.hp.com>
+
+	* expr.c (expand_assignment): Change complex type check.
+
+2010-01-15  Jing Yu  <jingyu@google.com>
+
+	PR rtl-optimization/42691
+	* combine.c (try_combine): Set changed_i3_dest to 1 when I2 and I3 set
+	a pseudo to a constant and are merged, and adjust comments.
+
+2010-01-15  Richard Guenther  <rguenther@suse.de>
+
+	* tree-ssa-loop-im.c (gen_lsm_tmp_name): Fix bogus fallthru.
+
+2010-01-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/42674
+	* c-decl.c (finish_function): Don't emit -Wreturn-type warnings in
+	functions with noreturn attribute.
+
+	PR c++/42608
+	* varasm.c (declare_weak): Add weak attribute to decl if it
+	doesn't have one already.
+	(assemble_external): Only add decls to weak_decls if they also
+	have weak attribute.
+
+2010-01-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/42721
+	Port from no-undefined-overflow branch
+	2009-03-09  Richard Guenther  <rguenther@suse.de>
+
+	* fold-const.c (add_double_with_sign): Fix unsigned overflow
+	detection.
+
+2010-01-14  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline
+	2010-01-10  Richard Guenther  <rguenther@suse.de>
+
+	PR middle-end/42667
+	* builtins.c (fold_builtin_strlen): Add type argument and
+	convert the resulting length to it.
+	(fold_builtin_1): Adjust.
+
+2010-01-13  Sebastian Pop  <sebastian.pop@amd.com>
+
+	PR middle-end/40281
+	* tree-scalar-evolution.c (instantiate_scev_1): Base and stride
+	evolutions should not variate in inner loops.
+
+2010-01-12  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	* Backport from mainline
+	2010-01-12  Julian Brown  <julian@codesourcery.com>
+
+	* config/arm/neon-schedgen.ml (Utils): Don't try to
+	open missing module.
+	(find_with_result): New.
+
+2010-01-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/42662
+	* simplify-rtx.c (simplify_relational_operation_1): Avoid invalid rtx
+	sharing when canonicalizing ({lt,ge}u (plus a b) b).
+
+2010-01-09  Jakub Jelinek  <jakub@redhat.com>
+
+	* gcc.c (process_command): Update copyright notice dates.
+	* gcov.c (print_version): Likewise.
+	* gcov-dump.c (print_version): Likewise.
+	* mips-tfile.c (main): Likewise.
+	* mips-tdump.c (main): Likewise.
+
+2010-01-07  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2010-01-05  Paolo Bonzini  <bonzini@gnu.org>
+		    H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/42542
+	* config/i386/i386.c (ix86_expand_int_vcond): Convert GTU to GT
+	for V4SI and V2DI by subtracting (-(INT MAX) - 1) from both
+	operands to make them signed.
+
+2010-01-07  Uros Bizjak  <ubizjak@gmail.com>
+
+	* ifcvt.c (if_convert): Output slim multiple dumps with TDF_SLIM.
+
+	PR target/42511
+	* ifcvt.c (dead_or_predicable): Also remove REG_EQUAL note when
+	note itself is not function_invariant_p.
+
+2010-01-05  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/42564
+	* config/sparc/sparc.h (SPARC_SYMBOL_REF_TLS_P): Delete.
+	* config/sparc/sparc-protos.h (legitimize_pic_address): Likewise.
+	(legitimize_tls_address): Likewise.
+	(sparc_tls_referenced_p): Likewise.
+	* config/sparc/sparc.c (sparc_expand_move): Use legitimize_tls_address
+	and adjust calls to legitimize_pic_address.
+	(legitimate_constant_p) Use sparc_tls_referenced_p.
+	(legitimate_pic_operand_p): Likewise.
+	(sparc_legitimate_address_p): Do not use SPARC_SYMBOL_REF_TLS_P.
+	(sparc_tls_symbol_ref_1): Delete.
+	(sparc_tls_referenced_p): Make static, recognize specific patterns.
+	(legitimize_tls_address): Make static, handle CONST patterns.
+	(legitimize_pic_address): Make static, remove unused parameter and
+	adjust recursive calls.
+	(sparc_legitimize_address): Make static, use sparc_tls_referenced_p
+	and adjust call to legitimize_pic_address.
+	(sparc_output_mi_thunk): Likewise.
+
+2010-01-05  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/42614
+	* tree-ssa-alias.c (compute_flow_insensitive_aliasing):
+	Compute SMT aliases before symbol aliases.
+
+2010-01-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR other/42611
+	* cfgexpand.c (expand_one_var): Diagnose too large variables.
+
+2010-01-04  Mikael Pettersson  <mikpe@it.uu.se>
+
+	PR target/42503
+
+	Backport from mainline:
+
+	2009-09-09  Jakub Jelinek  <jakub@redhat.com>
+
+	* config/t-slibgcc-elf-ver (SHLIB_MAKE_SOLINK, SHLIB_INSTALL_SOLINK):
+	New variables.
+	(SHLIB_LINK, SHLIB_INSTALL): Use them.
+	* config/t-slibgcc-libgcc: New file.
+
+	2009-10-19  Matthias Klose  <doko@ubuntu.com>
+
+	PR target/40134
+	* config.gcc (arm*-*-linux-*eabi): Use config/t-slibgcc-libgcc.
+
+2010-01-04  Ira Rosen  <irar@il.ibm.com>
+
+	PR tree-optimization/41956
+	* tree-vect-analyze.c (vect_supported_load_permutation_p): Add check
+	that the load indices differ.
+
+2010-01-02  Richard Guenther  <rguenther@suse.de>
+
+	Backport from mainline
+	2009-12-10  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/42337
+	* tree-ssa-pre.c (seen_during_translate): Remove.
+	(phi_translate_1): Collapse into ...
+	(phi_translate): ... this.  Remove seen parameter and
+	adjust recursive calls.
+
+2010-01-02  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/42448
+	* config/alpha/predicates.md (aligned_memory_operand): Return false
+	for CQImode.
+	(unaligned_memory_operand): Return true for CQImode.
+	* config/alpha/alpha.c (get_aligned_mem): Assert that location
+	doesn not cross aligned SImode word boundary.
+
+2009-12-30  Ian Lance Taylor  <iant@google.com>
+
+	PR middle-end/42099
+	* expmed.c (expand_divmod): Don't shift HOST_WIDE_INT value more
+	than HOST_BITS_PER_WIDE_INT.
+
+2009-12-30  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/42549
+	* config/i386/mmx.md (*mmx_subv2sf3): Fix insn operand number for
+	alternative 1.
+
+2009-12-28  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline:
+	2009-12-28  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR middle-end/41344
+	* omp-low.c (diagnose_sb_2): Handle GIMPLE_COND.
+
+2009-12-27  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/42231
+	* ipa-cp.c (ipcp_update_cloned_node): Add missing edges manually
+	instead of relying on rebuild_cgraph_edges and mark them as
+	indirect calls.
+	(ipcp_update_callgraph): Always redirect indirect edges.
+
+2009-12-23  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/42475
+	* combine.c (make_compound_operation) <case SUBREG>: Use mode of
+	SUBREG_REG (x) instead of tem's mode.
+
+2009-12-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/42429
+	* reload.c (find_reloads_subreg_address): When adjusting mode of
+	MEM, update also MEM_SIZE if it is set.
+
+2009-12-17  Dave Korn  <dave.korn.cygwin@gmail.com>
+
+	* config/i386/cygwin.h (LINK_SPEC): Add -tsaware flag if !mno-cygwin.
+
+2009-12-11  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	PR target/42263
+	Backport from mainline
+
+	2009-12-03  Richard Earnshaw  <rearnsha@arm.com>
+
+	* arm/linux-atomic.c (SYNC_LOCK_RELEASE): Place memory barrier
+	before the lock release.
+
+2009-12-11  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	PR target/42263
+	2009-08-11  Andrew Haley  <aph@redhat.com>
+	* config/arm/arm.c (arm_init_libfuncs): Add __sync_synchronize.
+
+2009-12-11  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	PR target/41196
+	2009-10-14  Daniel Gutson  <dgutson@codesourcery.com>
+
+	* config/arm/neon.md (neon_vshll_n<mode>): Checking Bounds fixed.
+
+2009-12-11  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	2009-10-05  Doug Kwan  <dougkwan@google.com>
+
+	PR rtl-optimization/41574
+	* combine.c (distribute_and_simplify_rtx): Quit if RTX mode is
+	floating point and we are not doing unsafe math optimizations.
+
+2009-12-11  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	PR target/41939
+	Backport from mainline:
+	2009-06-05  Julian Brown  <julian@codesourcery.com>
+
+	* config/arm/ieee754-df.S (cmpdf2): Avoid writing below SP.
+	* config/arm/ieee754-sf.S (cmpsf2): Likewise.
+
+2009-12-09  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>
+
+	* config/s390/s390.md ("copysign<mode>3"): Pattern removed.
+
+2009-12-07  Uros Bizjak  <ubizjak@gmail.com>
+
+	* config/i386/i386.md (*iorqi_ext_2): Fix insn mnemonic typo.
+
+2009-12-06  Richard Henderson  <rth@redhat.com>
+
+	* tree-ssa-dom.c (degenerate_phi_result): Check for NULL phi
+	argument earlier.
+
+2009-12-04  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	Backport from mainline:
+
+	2009-05-22  Trevor Smigiel <Trevor_Smigiel@playstation.sony.com>
+
+	* config/spu/spu-protos.h (aligned_mem_p, spu_valid_mov): Remove.
+	(spu_split_load, spu_split_store): Change return type to int.
+	(spu_split_convert): Declare.
+	* config/spu/predicates.md (spu_mem_operand): Remove.
+	(spu_mov_operand): Update.
+	(spu_dest_operand, shiftrt_operator, extend_operator): Define.
+	* config/spu/spu.c (regno_aligned_for_load): Remove.
+	(reg_aligned_for_addr, spu_expand_load): Define.
+	(spu_expand_extv): Reimplement and handle MEM.
+	(spu_expand_insv): Handle MEM.
+	(spu_sched_reorder): Handle insn's with length 0.
+	(spu_legitimate_address): Reimplement.
+	(store_with_one_insn_p): Return TRUE for any mode with size
+	larger than 16 bytes.
+	(address_needs_split): Define.
+	(spu_expand_mov): Call spu_split_load and spu_split_store for MEM
+	operands.
+	(spu_convert_move): Define.
+	(spu_split_load): Use spu_expand_load and change all MEM's to
+	TImode.
+	(spu_split_store): Change all MEM's to TImode.
+	(spu_init_expanders): Preallocate registers that correspond to
+	LAST_VIRTUAL_REG+1 and LAST_VIRTUAL_REG+2 and set them with
+	mark_reg_pointer.
+	(spu_split_convert): Define.
+	* config/spu/spu.md (QHSI, QHSDI): New mode iterators.
+	(_move<mode>, _movdi, _movti): Update predicate and condition.
+	(load, store): Change to define_split.
+	(extendqiti2, extendhiti2, extendsiti2, extendditi2): Simplify to
+	extend<mode>ti2.
+	(zero_extendqiti2, zero_extendhiti2, <v>lshr<mode>3_imm): Define.
+	(lshr<mode>3, lshr<mode>3_imm, lshr<mode>3_re): Simplify to one
+	define_insn_and_split of lshr<mode>3.
+	(shrqbybi_<mode>, shrqby_<mode>): Simplify to define_expand.
+	(<v>ashr<mode>3_imm): Define.
+	(extv, extzv, insv): Allow MEM operands.
+	(trunc_shr_ti<mode>, trunc_shr_tidi, shl_ext_<mode>ti,
+	shl_ext_diti, sext_trunc_lshr_tiqisi, zext_trunc_lshr_tiqisi,
+	sext_trunc_lshr_tihisi, zext_trunc_lshr_tihisi): Define for combine.
+	(_spu_convert2): Change to define_insn_and_split and remove the
+	corresponding define_peephole2.
+	(stack_protect_set, stack_protect_test, stack_protect_test_si):
+	Change predicates to memory_operand.
+
+	2009-04-27  Trevor Smigiel <trevor_smigiel@playstation.sony.com>
+
+	* spu.c (spu_machine_dependent_reorg): Make sure branch label on hint
+	instruction is correct.
+
+	2009-04-27  Trevor Smigiel <trevor_smigiel@playstation.sony.com>
+
+	Allow non-constant arguments to conversion intrinsics.
+	* spu-protos.h (exp2_immediate_p, spu_gen_exp2): Declare.
+	* predicates.md (spu_inv_exp2_operand, spu_exp2_operand): New.
+	* spu.c (print_operand): Handle 'v' and 'w'.
+	(exp2_immediate_p, spu_gen_exp2): Define.
+	* spu-builtins.def (spu_convts, spu_convtu, spu_convtf_0,
+	spu_convtf_1): Update parameter descriptions.
+	* spu-builtins.md (spu_csflt, spu_cuflt, spu_cflts, spu_cfltu):
+	Update.
+	* constraints.md ('v', 'w'): New.
+	* spu.md (UNSPEC_CSFLT, UNSPEC_CFLTS, UNSPEC_CUFLT, UNSPEC_CFLTU):
+	Remove.
+	(i2f, I2F): New define_mode_attr.
+	(floatsisf2, floatv4siv4sf2, fix_truncsfsi2, fix_truncv4sfv4si2,
+	floatunssisf2, floatunsv4siv4sf2, fixuns_truncsfsi2,
+	fixuns_truncv4sfv4si2):  Update to use mode attribute.
+	(float<mode><i2f>2_mul, float<mode><i2f>2_div,
+	fix_trunc<mode><f2i>2_mul, floatuns<mode><i2f>2_mul,
+	floatuns<mode><i2f>2_div, fixuns_trunc<mode><f2i>2_mul): New
+	patterns for combine.
+
+2009-12-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/42049
+	* builtins.c (expand_builtin_strcpy_args): Handle COMPOUND_EXPRs
+	potentially returned from folding strcpy.
+
+2009-12-02  Chao-ying Fu  <fu@mips.com>
+
+	Backport from mainline
+	2009-11-30  Chao-ying Fu  <fu@mips.com>
+
+	* config/mips/mips-dsp.md (mips_lhx_<mode>): Use sign_extend.
+
+2009-12-02  Richard Earnshaw  <rearnsha@arm.com>
+
+	* arm/thumb2.md (thumb_andsi_not_shiftsi_si): Final condition should
+	be TARGET_THUMB2.
+
+2009-12-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/42234
+	* tree-cfgcleanup.c (cleanup_omp_return): Don't ICE if control_bb
+	contains no statements.
+
+2009-11-27  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>
+
+	* config/s390/s390.c (last_scheduled_insn): New variable.
+	(s390_fpload_toreg, s390_z10_prevent_earlyload_conflicts): New
+	functions.
+	(s390_sched_reorder, s390_sched_variable_issue): New functions.
+	(TARGET_SCHED_VARIABLE_ISSUE, TARGET_SCHED_REORDER): Target hooks
+	defined.
+
+2009-11-27  Jakub Jelinek  <jakub@redhat.com>
+
+	* opts.c (decode_options): If optimize is bigger than 255,
+	set it to 255.
+
+2009-11-25  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/42165
+	* config/i386/i386.c (print_operand): For 32-byte memory use
+	YMMWORD in -masm=intel mode.  Use TBYTE instead of XWORD.
+	* config/i386/i386.md (crc32modesuffix): Expand to nothing
+	in -masm=intel mode.
+	(sse4_2_crc32di): Print just crc32 instead of crc32q in
+	-masm=intel mode.
+	* config/i386/mmx.md (*mmx_pinsrw): Print correct size of
+	memory operand in -masm=intel mode.
+	* config/i386/sse.md (*avx_pinsr<ssevecsize>, *sse4_1_pinsrb,
+	*sse2_pinsrw): Likewise.
+	(sse_cvtss2siq, sse_cvtss2siq_2, sse_cvttss2siq): Don't print
+	q suffix in -masm=intel mode.
+
+2009-11-24  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	* pa.c (output_call): Only use sr4 for long interspace calls if
+	call binds local and generating non PIC code.
+	(attr_length_call): Adjust length calculation for above.
+
+2009-11-24  Wolfgang Gellerich  <gellerich@de.ibm.com>
+
+	* config/s390/s390.md: Added agen condition to operand
+	forwarding bypasses.
+	Added bypass for early address generation use of int results.
+	Updated comments.
+
+2009-11-23  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/42113
+	* config/alpha/alpha.md (*cmp_sadd_si): Change mode
+	of scratch register to SImode.
+	(*cmp_sadd_sidi): Ditto.
+	(*cmp_ssub_si): Ditto.
+	(*cmp_ssub_sidi): Ditto.
+
+2009-11-18  Matthias Klose  <doko@ubuntu.com>
+
+	* config.gcc: Update ARM --with-fpu option list.
+
+2009-11-17  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	* config/spu/spu.c (get_pic_reg): Use LAST_ARG_REGNUM as PIC
+	registers in leaf functions if possible.
+
+2009-11-14  Uros Bizjak  <ubizjak@gmail.com>
+
+	* config/i386/predicates.md (call_register_no_elim_operand):
+	New predicate.  Reject stack register as valid call operand
+	for 32bit targets.
+	(call_insn_operand): Use call_register_no_elim_operand.
+
+2009-11-13  Richard Henderson  <rth@redhat.com>
+
+	* function.c (stack_protect_prologue): Don't bypass expand_expr
+	for stack_protect_guard and guard_decl.
+	(stack_protect_epilogue): Likewise.
+
+2009-11-13  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/41900
+	(*call_pop_1, *call_1, *call_value_pop_1, *call_value_1): Use "lsm"
+	as operand 1 constraint.
+	* config/i386/predicates.md (call_insn_operand): Depend on
+	index_register_operand to avoid %esp register.
+
+2009-11-13  Uros Bizjak  <ubizjak@gmail.com>
+
+	Revert:
+	2009-11-04  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/41900
+	* config/i386/i386.h (ix86_arch_indices) <X86_ARCH_CALL_ESP>: New.
+	(TARGET_CALL_ESP): New define.
+	* config/i386/i386.c (initial_ix86_tune_features): Initialize
+	X86_ARCH_CALL_ESP.
+	* config/i386/i386.md (*call_pop_1_esp, *call_1_esp,
+	*call_value_pop_1_esp, *call_value_1_esp): Rename from *call_pop_1,
+	*call_1, *call_value_pop_1 and *call_value_1.  Depend on
+	TARGET_CALL_ESP.
+	(*call_pop_1, *call_1, *call_value_pop_1, *call_value_1):
+	New patterns, use "lsm" as operand 1 constraint.
+	* config/i386/predicates.md (call_insn_operand): Depend on
+	index_register_operand for !TARGET_CALL_ESP to avoid %esp register.
+
+2009-11-13  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/42029
+	* gimplify.c (gimplify_omp_atomic): Set DECL_GIMPLE_REG_P on
+	tmp_load if needed.
+
+2009-11-11  Kai Tietz  <kai.tietz@onevision.com>
+
+	Backported from trunk
+	* config/i386/cygming.h (HANDLE_PRAGMA_PUSH_POP_MACRO): Removed.
+	* c-pragma.c (def_pragma_macro_value): Likewise.
+	(def_pragma_macro): Likewise.
+	(pushed_macro_table): Likewise.
+	(HANDLE_PRAGMA_PUSH_POP_MACRO): Remove guarded code.
+	* doc/tm.texi (HANDLE_PRAGMA_PUSH_POP_MACRO): Removed.
+
+2009-11-10  Chao-ying Fu  <fu@mips.com>
+
+	Backport from mainline
+	2009-10-29  Chao-ying Fu  <fu@mips.com>
+
+	* config/mips/mips.c (mips_emit_unary, mips_force_unary): New
+	functions.
+	(mips_expand_synci_loop):  Use the length rtx to control the
+	synci loop from the begin rtx that points to the first byte of
+	the cache line.
+
+2009-11-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/40946
+	Backport from mainline
+	2009-09-09  Richard Guenther  <rguenther@suse.de>
+
+	PR middle-end/41317
+	* tree-ssa-ccp.c (maybe_fold_offset_to_component_ref): Remove
+	code dealing with plain pointer bases.
+	(maybe_fold_offset_to_reference): Likewise.
+	(maybe_fold_stmt_addition): Adjust.
+
+2009-11-08  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline:
+	2009-11-06  Michael Matz  <matz@suse.de>
+
+	PR middle-end/41963
+	* tree-ssa-math-opts.c (execute_cse_reciprocals): Check all uses
+	of a potential reciprocal to really be reciprocals.
+
+2009-11-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/41643
+	Backport from mainline
+	2009-04-03  Richard Guenther  <rguenther@suse.de>
+
+	* tree-tailcall.c (tree_optimize_tail_calls_1): Also split the
+	edge from the entry block if we have degenerate PHI nodes in
+	the first basic block.
+
+2009-11-05  Jakub Jelinek  <jakub@redhat.com>
+
+	* c-common.c (fold_offsetof_1): Revert the recently added
+	-Warray-bounds checking of offsetof arguments.
+
+2009-11-04  Jason Merrill  <jason@redhat.com>
+
+	PR c++/36912
+	* varasm.c (initializer_constant_valid_p): A PLUS_EXPR
+	or MINUS_EXPR of REAL_TYPE is not a valid constant initializer.
+	(output_constant): Avoid crash after error.
+
+2009-11-04  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/41900
+	* config/i386/i386.h (ix86_arch_indices) <X86_ARCH_CALL_ESP>: New.
+	(TARGET_CALL_ESP): New define.
+	* config/i386/i386.c (initial_ix86_tune_features): Initialize
+	X86_ARCH_CALL_ESP.
+	* config/i386/i386.md (*call_pop_1_esp, *call_1_esp,
+	*call_value_pop_1_esp, *call_value_1_esp): Rename from *call_pop_1,
+	*call_1, *call_value_pop_1 and *call_value_1.  Depend on
+	TARGET_CALL_ESP.
+	(*call_pop_1, *call_1, *call_value_pop_1, *call_value_1):
+	New patterns, use "lsm" as operand 1 constraint.
+	* config/i386/predicates.md (call_insn_operand): Depend on
+	index_register_operand for !TARGET_CALL_ESP to avoid %esp register.
+
+2009-11-04  Jakub Jelinek  <jakub@redhat.com>
+
+	* c-common.c (fold_offsetof_1): Use %wd instead of
+	HOST_WIDE_INT_PRINT_DEC.
+
+2009-11-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/41917
+	* rtlanal.c (num_sign_bit_copies1) <case UMOD>: If sign bit of second
+	operand isn't known to be 0, return 1.
+
+2009-11-03  Dodji Seketeli  <dodji@redhat.com>
+
+	* c-common.c (fold_offsetof_1): Use HOST_WIDE_INT_PRINT_DEC.
+
+2009-11-03  Dodji Seketeli  <dodji@redhat.com>
+
+	PR c++/38699
+	* c-common.c (fold_offsetof_1): Issue errors when the member
+	designator of the offsetof expression is not legitimate.
+
+2009-10-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/41762
+	* config/i386/i386.c (ix86_pic_register_p): Don't call
+	rtx_equal_for_cselib_p for VALUEs discarded as useless.
+
+2009-10-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/41842
+	* c-typeck.c (convert_arguments): Return -1 if any of the arguments is
+	error_mark_node.
+
+2009-10-27  Kai Tietz  <kai.tietz@onevision.com>
+
+	Backport from mainline:
+	2009-10-20  Pascal Obry  <obry@adacore.com>
+		    Eric Botcazou  <ebotcazou@adacore.com>
+
+	* config/i386/cygming.h (DWARF_FRAME_REGNUM): Add enclosing parens.
+
+2009-10-23  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	Backport from mainline:
+	2009-08-19  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	* pa.md (reload_inhi, reload_outhi, reload_inqi, reload_outqi): New
+	patterns.
+	* pa.c (emit_move_sequence): Check if address of operand1 is valid
+	for mode mode of operand0 when doing secondary reload for SAR.
+
+2009-10-21  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline:
+	2009-06-13  Joerg Sonnenberger  <joerg@britannica.bec.de>
+
+	* doc/invoke.texi: Add missing option -Wp,OPTION in list,
+	fix index entry for -Xpreprocessor.
+
+2009-10-20  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	Backport from mainline:
+	2009-10-15  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	PR target/41702
+	* pa.md (casesi): Use sign extended index in call to gen_casesi64p.
+	(casesi64p): Update pattern to reflect above.
+
+2009-10-20  Joseph Myers  <joseph@codesourcery.com>
+
+	* config/arm/arm.c (output_move_neon): Use DImode in call to
+	adjust_address.
+
+2009-10-19  Jakub Jelinek  <jakub@redhat.com>
+
+	* unwind-dw2.c (execute_stack_op): Fix operand order for
+	DW_OP_le, DW_OP_ge, DW_OP_lt and DW_OP_gt.
+
+2009-10-19  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>
+
+	* config/s390/s390.c (s390_z10_optimize_cmp): Don't touch FP compares.
+
+2009-10-19  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>
+
+	* config/s390/s390.c (s390_z10_optimize_cmp): Skip notes and debug
+	insns when investigating previous or next insns.
+
+2009-10-19  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline:
+	2009-10-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/40521
+	* debug.h (struct gcc_debug_hooks): Add assembly_start hook.
+	* cgraphunit.c (cgraph_optimize): Call it.
+	* dwarf2out.c (dwarf2out_init): Move .cfi_sections printing into...
+	(dwarf2out_assembly_start): ... here.  New hook.
+	(dwarf2out_debug_hooks): Add dwarf2out_assembly_start.
+	* debug.c (do_nothing_debug_hooks): Do nothing for assembly_start
+	hook.
+	* dbxout.c (dbx_debug_hooks, xcoff_debug_hooks): Likewise.
+	* sdbout.c (sdb_debug_hooks): Likewise.
+	* vmsdbgout.c (vmsdbg_debug_hooks): Add vmsdbgout_assembly_start.
+	(vmsdbgout_assembly_start): New hook.
+
+	2009-10-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/40521
+	* dwarf2out.c (dwarf2out_init): Test whether
+	HAVE_GAS_CFI_SECTIONS_DIRECTIVE is non-zero instead of checking
+	it is defined.
+
+	2009-10-02  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/40521
+	* configure.ac (HAVE_GAS_CFI_SECTIONS_DIRECTIVE): New test.
+	* configure: Regenerated.
+	* config.in: Regenerated.
+	* dwarf2out.c (dwarf2out_do_cfi_asm): Return false if
+	!HAVE_GAS_CFI_SECTIONS_DIRECTIVE and not emitting .eh_frame.
+	(dwarf2out_init): If HAVE_GAS_CFI_SECTIONS_DIRECTIVE and
+	not emitting .eh_frame, emit .cfi_sections .debug_frame
+	directive.
+
+2009-10-15  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	Backport from mainline
+	2009-09-17  Michael Haubenwallner  <michael.haubenwallner@salomon.at>
+
+	PR target/40913
+	* config/pa/t-hpux-shlib: Set soname in libgcc_s.sl.
+
+	Backport from mainline
+	2009-05-05  Ben Elliston  <bje@au.ibm.com>
+
+	* config/pa/linux-atomic.c: Eliminate conditional include of
+	errno.h on non-LP64 systems to simplify build requirements.
+
+2009-10-15  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline:
+	2009-10-07  Vladimir Makarov  <vmakarov@redhat.com>
+
+	PR middle-end/22072
+	* ira-lives.c (check_and_make_def_conflict): Process all operands.
+
+2009-10-15  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline:
+	2009-10-11  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/41665
+	* config/i386/i386.md (addsi_1_zext): Get the proper second
+	operand for lea.
+
+2009-10-15  Jakub Jelinek  <jakub@redhat.com>
+
+	* BASE-VER: Set to 4.4.3.
+	* DEV-PHASE: Set to prerelease.
+
 2009-10-15  Release Manager
 
 	* GCC 4.4.2 released.
@@ -43,12 +1078,12 @@
 2009-10-05  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
 
 	Backport from mainline.
-        * config/arm/arm.c (arm_override_options): Really initialize
-        flag_dwarf2_cfi_asm to 0.
+	* config/arm/arm.c (arm_override_options): Really initialize
+	flag_dwarf2_cfi_asm to 0.
 
 2009-10-02  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
 
-	Backport from mainline.	
+	Backport from mainline.
 	2009-10-01  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
 	* config/arm/arm.c (arm_override_options): Turn off
 	flag_dwarf2_cfi_asm for AAPCS variants.
@@ -113,7 +1148,7 @@
 	premark_types_used_by_global_vars): New functions.
 	(prune_unused_types): Do not prune types used by global variables.
 
-2009-09-23 Uros Bizjak <ubizjak@gmail.com>
+2009-09-23  Uros Bizjak  <ubizjak@gmail.com>
 
 	PR c/39779
 	* c-typeck.c (build_binary_op) <short_shift>: Check that integer
Index: gcc/testsuite/gcc.c-torture/execute/pr42614.c
===================================================================
--- gcc/testsuite/gcc.c-torture/execute/pr42614.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/execute/pr42614.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,68 @@
+extern void *malloc(__SIZE_TYPE__);
+extern void abort(void);
+extern void free(void *);
+
+typedef struct SEntry
+{
+  unsigned char num;
+} TEntry;
+
+typedef struct STable
+{
+  TEntry data[2];
+} TTable;
+
+TTable *init ()
+{
+  return malloc(sizeof(TTable));
+}
+
+void
+expect_func (int a, unsigned char *b) __attribute__ ((noinline));
+
+static inline void
+inlined_wrong (TEntry *entry_p, int flag);
+
+void
+inlined_wrong (TEntry *entry_p, int flag)
+{
+  unsigned char index;
+  entry_p->num = 0;
+
+  if (flag == 0)
+    abort();
+
+  for (index = 0; index < 1; index++)
+    entry_p->num++;
+
+  if (!entry_p->num)
+    {
+      abort();
+    }
+}
+
+void
+expect_func (int a, unsigned char *b)
+{
+  if (abs ((a == 0)))
+    abort ();
+  if (abs ((b == 0)))
+    abort ();
+}
+
+int
+main ()
+{
+  unsigned char index = 0;
+  TTable *table_p = init();
+  TEntry work;
+
+  inlined_wrong (&(table_p->data[1]), 1);
+  expect_func (1, &index);
+  inlined_wrong (&work, 1);
+
+  free (table_p);
+
+  return 0;
+}
+
Index: gcc/testsuite/gcc.c-torture/execute/pr42721.c
===================================================================
--- gcc/testsuite/gcc.c-torture/execute/pr42721.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/execute/pr42721.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,21 @@
+/* PR c/42721 */
+
+extern void abort (void);
+
+static unsigned long long
+foo (unsigned long long x, unsigned long long y)
+{
+  return x / y;
+}
+
+static int a, b;
+
+int
+main (void)
+{
+  unsigned long long c = 1;
+  b ^= c && (foo (a, -1ULL) != 1L);
+  if (b != 1)
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr41750.c
===================================================================
--- gcc/testsuite/gcc.c-torture/execute/pr41750.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/execute/pr41750.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,68 @@
+/* PR 41750 - IPA-SRA used to pass hash->sgot by value rather than by
+   reference.  */
+
+struct bfd_link_hash_table
+{
+  int hash;
+};
+
+struct foo_link_hash_table
+{
+  struct bfd_link_hash_table root;
+  int *dynobj;
+  int *sgot;
+};
+
+struct foo_link_info
+{
+  struct foo_link_hash_table *hash;
+};
+
+extern void abort (void);
+
+int __attribute__((noinline))
+foo_create_got_section (int *abfd, struct foo_link_info *info)
+{
+  info->hash->sgot = abfd;
+  return 1;
+}
+
+static int *
+get_got (int *abfd, struct foo_link_info *info,
+	 struct foo_link_hash_table *hash)
+{
+  int *got;
+  int *dynobj;
+
+  got = hash->sgot;
+  if (!got)
+    {
+      dynobj = hash->dynobj;
+      if (!dynobj)
+	hash->dynobj = dynobj = abfd;
+      if (!foo_create_got_section (dynobj, info))
+	return 0;
+      got = hash->sgot;
+    }
+  return got;
+}
+
+int * __attribute__((noinline,noclone))
+elf64_ia64_check_relocs (int *abfd, struct foo_link_info *info)
+{
+  return get_got (abfd, info, info->hash);
+}
+
+struct foo_link_info link_info;
+struct foo_link_hash_table hash;
+int abfd;
+
+int
+main ()
+{
+  link_info.hash = &hash;
+  if (elf64_ia64_check_relocs (&abfd, &link_info) != &abfd)
+    abort ();
+  return 0;
+}
+
Index: gcc/testsuite/gcc.c-torture/execute/pr42570.c
===================================================================
--- gcc/testsuite/gcc.c-torture/execute/pr42570.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/execute/pr42570.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,9 @@
+typedef unsigned char uint8_t;
+uint8_t foo[1][0];
+extern void abort (void);
+int main()
+{
+  if (sizeof (foo) != 0)
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr42006.c
===================================================================
--- gcc/testsuite/gcc.c-torture/execute/pr42006.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/execute/pr42006.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,33 @@
+extern void abort (void);
+
+static unsigned int
+my_add(unsigned int si1, unsigned int si2)
+{
+  return (si1 > (50-si2)) ? si1 : (si1 + si2);
+}
+
+static unsigned int
+my_shift(unsigned int left, unsigned int right)
+{
+  return  (right > 100) ? left : (left >> right);
+}
+
+static int func_4(unsigned int p_6)
+{
+  int count = 0;
+  for (p_6 = 1; p_6 < 3; p_6 = my_add(p_6, 1))
+    {
+      if (count++ > 1)
+	abort ();
+
+      if (my_shift(p_6, p_6))
+	return 0;
+    }
+  return 0;
+}
+
+int main(void)
+{
+  func_4(0);
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr42269-2.c
===================================================================
--- gcc/testsuite/gcc.c-torture/execute/pr42269-2.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/execute/pr42269-2.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,15 @@
+/* Make sure that language + abi extensions in passing S interoperate.  */
+
+static long long __attribute__((noinline))
+foo (unsigned short s)
+{
+  return (short) s;
+}
+
+unsigned short s = 0xFFFF;
+
+int
+main (void)
+{
+  return foo (s) + 1 != 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr43220.c
===================================================================
--- gcc/testsuite/gcc.c-torture/execute/pr43220.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/execute/pr43220.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,28 @@
+void *volatile p;
+
+int
+main (void)
+{
+  int n = 0;
+lab:;
+    {
+      int x[n % 1000 + 1];
+      x[0] = 1;
+      x[n % 1000] = 2;
+      p = x;
+      n++;
+    }
+
+    {
+      int x[n % 1000 + 1];
+      x[0] = 1;
+      x[n % 1000] = 2;
+      p = x;
+      n++;
+    }
+
+  if (n < 1000000)
+    goto lab;
+
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr42231.c
===================================================================
--- gcc/testsuite/gcc.c-torture/execute/pr42231.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/execute/pr42231.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,35 @@
+extern void abort (void);
+
+static max;
+
+static void __attribute__((noinline)) storemax (int i)
+{
+  if (i > max)
+    max = i;
+}
+
+static int CallFunctionRec(int (*fun)(int depth), int depth) {
+  if (!fun(depth)) {
+    return 0;
+  }
+  if (depth < 10) {
+    CallFunctionRec(fun, depth + 1);
+  }
+  return 1;
+}
+
+static int CallFunction(int (*fun)(int depth)) {
+  return CallFunctionRec(fun, 1) && !fun(0);
+}
+
+static int callback(int depth) {
+  storemax (depth);
+  return depth != 0;
+}
+
+int main() {
+  CallFunction(callback);
+  if (max != 10)
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr42142.c
===================================================================
--- gcc/testsuite/gcc.c-torture/execute/pr42142.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/execute/pr42142.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,26 @@
+int __attribute__((noinline,noclone))
+sort(int L)
+{
+  int end[2] = { 10, 10, }, i=0, R;
+  while (i<2)
+    {
+      R = end[i];
+      if (L<R)
+        {
+          end[i+1] = 1;
+          end[i] = 10;
+          ++i;
+        }
+      else
+        break;
+    }
+  return i;
+}
+extern void abort (void);
+int main()
+{
+  if (sort (5) != 1)
+    abort ();
+  return 0;
+}
+
Index: gcc/testsuite/gcc.c-torture/execute/pr43008.c
===================================================================
--- gcc/testsuite/gcc.c-torture/execute/pr43008.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/execute/pr43008.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,23 @@
+int i;
+struct X {
+  int *p;
+};
+struct X * __attribute__((malloc))
+my_alloc (void)
+{
+  struct X *p = __builtin_malloc (sizeof (struct X));
+  p->p = &i;
+  return p;
+}
+extern void abort (void);
+int main()
+{
+  struct X *p, *q;
+  p = my_alloc ();
+  q = my_alloc ();
+  *(p->p) = 1;
+  *(q->p) = 0;
+  if (*(p->p) != 0)
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr41317.c
===================================================================
--- gcc/testsuite/gcc.c-torture/execute/pr41317.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/execute/pr41317.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,28 @@
+extern void abort (void);
+
+struct A
+{
+  int i;
+};
+struct B
+{
+  struct A a;
+  int j;
+};
+
+static void
+foo (struct B *p)
+{
+  ((struct A *)p)->i = 1;
+}
+
+int main()
+{
+  struct A a;
+  a.i = 0;
+  foo ((struct B *)&a);
+  if (a.i != 1)
+    abort ();
+  return 0;
+}
+
Index: gcc/testsuite/gcc.c-torture/execute/pr42248.c
===================================================================
--- gcc/testsuite/gcc.c-torture/execute/pr42248.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/execute/pr42248.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,27 @@
+typedef struct {
+  _Complex double a;
+  _Complex double b;
+} Scf10;
+
+Scf10 g1s;
+
+void
+check (Scf10 x, _Complex double y)
+{
+  if (x.a != y) __builtin_abort ();
+}
+
+void
+init (Scf10 *p, _Complex double y)
+{
+  p->a = y;
+}
+
+int
+main ()
+{
+  init (&g1s, (_Complex double)1);
+  check (g1s, (_Complex double)1);
+
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/20091229-1.c
===================================================================
--- gcc/testsuite/gcc.c-torture/execute/20091229-1.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/execute/20091229-1.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,2 @@
+long long foo(long long v) { return v / -0x080000000LL; }
+void main() { if (foo(0x080000000LL) != -1) abort(); exit (0); }
Index: gcc/testsuite/gcc.c-torture/execute/pr41917.c
===================================================================
--- gcc/testsuite/gcc.c-torture/execute/pr41917.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/execute/pr41917.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,21 @@
+/* PR rtl-optimization/41917 */
+
+extern void abort (void);
+unsigned int a = 1;
+
+int
+main (void)
+{
+  unsigned int b, c, d;
+
+  if (sizeof (int) != 4 || (int) 0xc7d24b5e > 0)
+    return 0;
+
+  c = 0xc7d24b5e;
+  d = a | -2;
+  b = (d == 0) ? c : (c % d);
+  if (b != c)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr41935.c
===================================================================
--- gcc/testsuite/gcc.c-torture/execute/pr41935.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/execute/pr41935.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,25 @@
+/* PR middle-end/41935 */
+
+extern void abort (void);
+
+long int
+foo (int n, int i, int j)
+{
+  typedef int T[n];
+  struct S { int a; T b[n]; };
+  return __builtin_offsetof (struct S, b[i][j]);
+}
+
+int
+main (void)
+{
+  typedef int T[5];
+  struct S { int a; T b[5]; };
+  if (foo (5, 2, 3)
+      != __builtin_offsetof (struct S, b) + (5 * 2 + 3) * sizeof (int))
+    abort ();
+  if (foo (5, 5, 5)
+      != __builtin_offsetof (struct S, b) + (5 * 5 + 5) * sizeof (int))
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr41919.c
===================================================================
--- gcc/testsuite/gcc.c-torture/execute/pr41919.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/execute/pr41919.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,39 @@
+extern void abort (void);
+
+#define assert(x) if(!(x)) abort()
+
+struct S1
+{
+  signed char f0;
+};
+
+int g_23 = 0;
+
+static struct S1
+foo (void)
+{
+  int *l_100 = &g_23;
+  int **l_110 = &l_100;
+  struct S1 l_128 = { 1 };
+  assert (l_100 == &g_23);
+  assert (l_100 == &g_23);
+  assert (l_100 == &g_23);
+  assert (l_100 == &g_23);
+  assert (l_100 == &g_23);
+  assert (l_100 == &g_23);
+  assert (l_100 == &g_23);
+  return l_128;
+}
+
+static signed char bar(signed char si1, signed char si2)
+{
+  return (si1 <= 0) ? si1 : (si2 * 2);
+}
+int main (void)
+{
+  struct S1 s = foo();
+  if (bar(0x99 ^ (s.f0 && 1), 1) != -104)
+    abort ();
+  return 0;
+}
+
Index: gcc/testsuite/gcc.c-torture/execute/pr42691.c
===================================================================
--- gcc/testsuite/gcc.c-torture/execute/pr42691.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/execute/pr42691.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,41 @@
+extern void abort (void);
+
+union _D_rep
+{
+  unsigned short rep[4];
+  double val;
+};
+
+int add(double* key, double* table)
+{
+  unsigned i = 0;
+  double* deletedEntry = 0;
+  while (1) {
+    double* entry = table + i;
+
+    if (*entry == *key)
+      break;
+
+    union _D_rep _D_inf = {{ 0, 0, 0, 0x7ff0 }};
+    if (*entry != _D_inf.val)
+      abort ();
+
+    union _D_rep _D_inf2 = {{ 0, 0, 0, 0x7ff0 }};
+    if (!_D_inf2.val)
+      deletedEntry = entry;
+
+    i++;
+  }
+  if (deletedEntry)
+    *deletedEntry = 0.0;
+  return 0;
+}
+
+int main ()
+{
+  union _D_rep infinit = {{ 0, 0, 0, 0x7ff0 }};
+  double table[2] = { infinit.val, 23 };
+  double key = 23;
+  int ret = add (&key, table);
+  return ret;
+}
Index: gcc/testsuite/gcc.c-torture/execute/20100209-1.c
===================================================================
--- gcc/testsuite/gcc.c-torture/execute/20100209-1.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/execute/20100209-1.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,12 @@
+int bar(int foo)
+{
+  return (int)(((unsigned long long)(long long)foo) / 8);
+}
+extern void abort (void);
+int main()
+{
+  if (sizeof (long long) > sizeof (int)
+      && bar(-1) != -1)
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr42512.c
===================================================================
--- gcc/testsuite/gcc.c-torture/execute/pr42512.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/execute/pr42512.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,13 @@
+extern void abort (void);
+
+short g_3;
+
+int main (void)
+{
+    int l_2;
+    for (l_2 = -1; l_2 != 0; l_2 = (unsigned char)(l_2 - 1))
+      g_3 |= l_2;
+    if (g_3 != -1)
+      abort ();
+    return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr42154.c
===================================================================
--- gcc/testsuite/gcc.c-torture/execute/pr42154.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/execute/pr42154.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,18 @@
+struct A { char x[1]; };
+extern void abort (void);
+void __attribute__((noinline,noclone))
+foo (struct A a)
+{
+  if (a.x[0] != 'a')
+    abort ();
+}
+int main ()
+{
+  struct A a;
+  int i;
+  for (i = 0; i < 1; ++i)
+    a.x[i] = 'a';
+  foo (a);
+  return 0;
+}
+
Index: gcc/testsuite/gcc.c-torture/execute/pushpop_macro.c
===================================================================
--- gcc/testsuite/gcc.c-torture/execute/pushpop_macro.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/execute/pushpop_macro.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,15 @@
+extern void abort ();
+
+#define _ 2
+#pragma push_macro("_")
+#undef _
+#define _ 1
+#pragma pop_macro("_")
+
+int main ()
+{
+  if (_ != 2)
+    abort ();
+  return 0;
+}
+

Zmiany atrybutów dla: gcc/testsuite/gcc.c-torture/execute/pushpop_macro.c
___________________________________________________________________
Dodane: svn:mime-type
   + text/plain
Dodane: svn:eol-style
   + native

Index: gcc/testsuite/gcc.c-torture/compile/pr33009.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr33009.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/gcc.c-torture/compile/pr33009.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,41 +0,0 @@
-/* { dg-do compile } */
-/* Currently ICEs for Alpha, IA64, HPPA, MIPS, CRIS, Xtensa, PowerPC, SH and SPARC; see PR33642.  */
-/* { dg-xfail-if "PR33642" { alpha*-*-* hppa*-*-* mips*-*-* powerpc*-*-* cris-*-* crisv32-*-* ia64-*-* xtensa*-*-* sh*-*-* sparc*-*-* s390*-*-* } { "*" } { "" } } */
-/* Currently ICEs for (x86 && ilp32 && pic).  */
-/* { dg-xfail-if "PR33642/36240" { { i?86-*-* x86_64-*-* } && { ilp32 && { ! nonpic } } } { "*" } { "" } } */
-/* { dg-prune-output ".*internal compiler error.*" }
-/* { dg-options "-frtl-abstract-sequences" } */
-
-char *progName;
-int bar0 (char *, ...);
-void bar1 (char *);
-void exit (int);
-
-
-#define SAME \
- bar0 ("%s: Bad flag `%s'\n", argv[i], argv[i] );\
- bar1 ( progName ); \
- exit ( 1 );
-
-
-int foo ( int argc, char *argv[] )
-{
-    int i;
-    for (i = 0; i < argc; i++) {
-	switch (argv[i][0]) {
-	case 'c':
-	    break;
-	default: 
-	
-	    SAME
-	    
-	    break;
-	}
-    }
-    for (i = 0; i < argc; i++) {
-    
-	SAME
-	
-    }
-    return 0;
-}
Index: gcc/testsuite/gcc.c-torture/compile/pr11832.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr11832.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/gcc.c-torture/compile/pr11832.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,35 +0,0 @@
-/* { dg-do compile } */
-/* Currently ICEs for Alpha, IA64, HPPA, MIPS, CRIS, Xtensa, PowerPC, SH and SPARC; see PR33642.  */
-/* { dg-xfail-if "PR33642" { alpha*-*-* hppa*-*-* mips*-*-* powerpc*-*-* cris-*-* crisv32-*-* ia64-*-* xtensa*-*-* sh*-*-* sparc*-*-* s390*-*-* } { "*" } { "" } } */
-/* Currently ICEs for (x86 && ilp32 && pic).  */
-/* { dg-xfail-if "PR33642/36240" { { i?86-*-* x86_64-*-* } && { ilp32 && { ! nonpic } } } { "*" } { "" } } */
-/* { dg-prune-output ".*internal compiler error.*" }
-/* { dg-options "-frtl-abstract-sequences" } */
-
-int a, b, e;
-unsigned char *c;
-void foo()
-{
-  int d = 13;
-  b = -1;   
-  switch (e) {
-    case 1:
-      b++; c[b] = (unsigned char)d;
-      break;
-    case 2:
-      b++; c[b] = (unsigned char)d;
-      b++; c[b] = (unsigned char)d;
-      break;
-    case 3:
-      b++; c[b] = (unsigned char)d;
-      b++; c[b] = (unsigned char)d;
-      b++; c[b] = (unsigned char)d;
-      break;
-    default:
-      a = 1;
-      b++; c[b] = (unsigned char)d;
-      b++; c[b] = (unsigned char)d;
-      b++; c[b] = (unsigned char)d;
-      b++; c[b] = (unsigned char)d;
-  }
-}
Index: gcc/testsuite/gcc.c-torture/compile/20000804-1.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/20000804-1.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/gcc.c-torture/compile/20000804-1.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,8 +1,7 @@
 /* This does not work on m68hc11 or h8300 due to the use of an asm
    statement to force a 'long long' (64-bits) to go in a register.  */
 /* { dg-do assemble } */
-/* { dg-skip-if "" { { i?86-*-* x86_64-*-* } && ilp32 } { "-fpic" "-fPIC" } { "" } } */
-/* { dg-skip-if "PIC default" { { i?86-*-darwin*  x86_64-*-darwin* } && ilp32 } { "*" } { "" } } */
+/* { dg-skip-if "" { { i?86-*-* x86_64-*-* } && { ilp32 && { ! nonpic } } } { "*" } { "" } } */
 /* { dg-skip-if "No 64-bit registers" { m32c-*-* } { "*" } { "" } } */
 /* { dg-xfail-if "" { m6811-*-* m6812-*-* h8300-*-* } { "*" } { "" } } */
 
Index: gcc/testsuite/gcc.c-torture/compile/pr42703.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr42703.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr42703.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,12 @@
+__extension__ typedef unsigned long long int uint64_t;
+typedef uint64_t ScmUInt64;
+void swapb64(ScmUInt64 *loc) 
+{
+    union {
+        ScmUInt64 l;
+        unsigned char c[4];
+    } dd;
+    unsigned char t;
+    dd.l = *loc;
+    (t = dd.c[3], dd.c[3] = dd.c[4], dd.c[4] = t);
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr41634.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr41634.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr41634.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,19 @@
+extern int _xgetw();
+extern int foo(char*);
+
+void test_readmode( int ascii_mode )
+{
+  static const char outbuffer[]
+    = "0,1,2,3,4,5,6,7,8,9\r\n\r\nA,B,C,D,E\r\nX,Y,Z";
+  char buffer[2*512 +256];
+  int i, j, ao;
+  unsigned int fp;
+
+  foo(buffer);
+
+  for (i=0, j=0; i<6; i++) {
+      if (ao==0 || outbuffer[fp-3+i] != '\r')
+	buffer[j++] = outbuffer[fp-3+i];
+  }
+  _xgetw();
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr42730.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr42730.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr42730.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,14 @@
+union bzz
+{
+  unsigned *pa;
+  void *pv;
+};
+
+void foo (void)
+{
+  union bzz u;
+  void **x;
+  void *y = 0;
+  x = &u.pv;
+  *x = y;
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr42632.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr42632.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr42632.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,16 @@
+static inline __attribute__((always_inline)) int
+__pskb_trim(void)
+{
+  return ___pskb_trim();
+}
+static inline __attribute__((always_inline))
+int pskb_trim(void)
+{
+  return __pskb_trim();
+}
+int ___pskb_trim(void)
+{
+  pskb_trim();
+  return 0;
+}
+
Index: gcc/testsuite/gcc.c-torture/compile/pr42705.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr42705.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr42705.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,58 @@
+typedef int GLint;
+typedef unsigned char GLubyte;
+typedef unsigned int uint32_t;
+struct radeon_bo {
+    void *ptr;
+    uint32_t flags;
+};
+struct radeon_renderbuffer {
+    struct radeon_bo *bo;
+    unsigned int cpp;
+    int has_surface;
+};
+static inline
+GLint r600_1d_tile_helper(const struct radeon_renderbuffer * rrb,
+			  GLint x, GLint y, GLint is_depth, GLint is_stencil)
+{
+  GLint element_bytes = rrb->cpp;
+  GLint num_samples = 1;
+  GLint tile_width = 8;
+  GLint tile_height = 8;
+  GLint tile_thickness = 1;
+  GLint tile_bytes;
+  GLint tiles_per_row;
+  GLint slice_offset;
+  GLint tile_row_index;
+  GLint tile_column_index;
+  GLint tile_offset;
+  GLint pixel_number = 0;
+  GLint element_offset;
+  GLint offset = 0;
+  tile_bytes = tile_width * tile_height * tile_thickness
+      * element_bytes * num_samples;
+  tile_column_index = x / tile_width;
+  tile_offset = ((tile_row_index * tiles_per_row)
+		 + tile_column_index) * tile_bytes;
+  if (is_depth) {
+  }
+  else {
+      GLint sample_offset;
+      switch (element_bytes) {
+	  case 1:       pixel_number |= ((x >> 0) & 1) << 0;
+      }
+      element_offset = sample_offset + (pixel_number * element_bytes);
+  }
+  offset = slice_offset + tile_offset + element_offset;
+  return offset;
+}
+GLubyte *r600_ptr_color(const struct radeon_renderbuffer * rrb,
+			GLint x, GLint y)
+{
+  GLubyte *ptr = rrb->bo->ptr;
+  uint32_t mask = 1 | 2;
+  GLint offset;
+  if (rrb->has_surface || !(rrb->bo->flags & mask)) {
+      offset = r600_1d_tile_helper(rrb, x, y, 0, 0);
+  }
+  return &ptr[offset];
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr42708-1.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr42708-1.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr42708-1.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,10 @@
+typedef __SIZE_TYPE__ size_t;
+void *malloc(size_t);
+typedef union YYSTYPE {
+    char *id;
+}  YYSTYPE;
+extern YYSTYPE yylval;
+void yylex (int b)
+{
+  yylval = (YYSTYPE) (b ? 0 : (char *) malloc (4));
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr41661.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr41661.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr41661.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,20 @@
+/* PR tree-optimization/41661 */
+/* { dg-do compile } */
+/* { dg-options "-fno-early-inlining" } */
+
+int g;
+
+void foo (int x)
+{
+  g = x;
+}
+
+void bar (double d)
+{
+  foo (d == 1);
+}
+
+void baz (int a)
+{
+  bar (1);
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr42196-1.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr42196-1.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr42196-1.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,28 @@
+union U
+{
+  double d;
+  __complex__ int c;
+};
+
+double gd;
+extern double bar (union U);
+
+double foo (int b, double d, int c1, int c2)
+{
+  union U u;
+  double r;
+
+  if (b)
+    {
+      u.d = d;
+      r = u.d;
+    }
+  else
+    {
+      __real__ u.c = c1;
+      __imag__ u.c = c2;
+      r = bar (u);
+    }
+
+  return r;
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr41182-1.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr41182-1.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr41182-1.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,6 @@
+typedef long unsigned int size_t;
+int _lae_process_opts(char *pr, char *pe)
+{ 
+  return (strlen ("on") < ((size_t) ((pe-&pr[2])>(strlen("on"))                
+                                     ? (pe-&pr[2]) : (strlen("on")))));
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr42716.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr42716.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr42716.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,18 @@
+static short foo (long long si1, short si2)
+{
+  return si1 > 0 && si2 > 0 || si1 < 0
+      && si2 < 0 && si1 < 1 - si2 ? : si1 + si2;
+}
+
+int g_13;
+unsigned g_17;
+
+int safe (int, int);
+
+void bar (short p_51, short * p_52)
+{
+  int *const l_55 = &g_13;
+  if (safe (*p_52, g_13 != foo (*p_52 & *l_55 == g_13 && g_17 >= 1, 0)))
+    {
+    }
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr42196-3.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr42196-3.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr42196-3.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,27 @@
+union U
+{
+  __complex__ int ci;
+  __complex__ float cf;
+};
+
+float gd;
+extern float bar (float, float);
+
+float foo (int b, union U u)
+{
+  float f1, f2, r;
+
+  if (b)
+    {
+      f1 = __real__ u.cf;
+      f1 = __imag__ u.cf;
+    }
+  else
+    {
+      f1 = __real__ u.ci;
+      f1 = __imag__ u.ci;
+    }
+
+  r = bar (f1, f2);
+  return r;
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr42398.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr42398.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr42398.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,6 @@
+int ptrace_setregs(void)
+{
+  union { unsigned int l; int t; } __gu_tmp;
+  __asm__ __volatile__("" : "=r" (__gu_tmp.l));
+  return __gu_tmp.t;
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr42927.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr42927.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr42927.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,32 @@
+typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
+typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
+typedef enum { READ_SHARED = 0, WRITE_EXCLUSIVE = 1,
+    READ_EXCLUSIVE = 2, EXCLUSIVE_ACCESS = 3 } scsires_access_mode;
+struct scsires_extent_elem {
+    scsires_access_mode mode;
+    unsigned relative_address;
+    u_int32_t first_block;
+    u_int32_t length;
+};
+typedef struct scsires_extent_elem scsires_extent_elem_t;
+struct scsires_extent {
+    u_int8_t num_elements;
+    scsires_extent_elem_t *elements;
+};
+typedef struct scsires_extent scsires_extent_t;
+unsigned char buf[512];
+void scsires_issue_reservation(scsires_extent_t * new_extent)
+{
+  int i;
+  for (i = 0; i < new_extent->num_elements; i++)
+    {
+      buf[(i * 8)] = new_extent->elements[i].mode;
+      buf[(i * 8) + 1] = ((new_extent->elements[i].length >> 16) & 0xff); 
+      buf[(i * 8) + 2] = ((new_extent->elements[i].length >> 8) & 0xff);
+      buf[(i * 8) + 3] = (new_extent->elements[i].length & 0xff);
+      buf[(i * 8) + 4] = ((new_extent->elements[i].first_block >> 24) & 0xff); 
+      buf[(i * 8) + 5] = ((new_extent->elements[i].first_block >> 16) & 0xff);
+      buf[(i * 8) + 6] = ((new_extent->elements[i].first_block >> 8) & 0xff);
+      buf[(i * 8) + 7] = (new_extent->elements[i].first_block & 0xff);
+    }
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr42749.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr42749.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr42749.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,5 @@
+struct pdf_object { int val; };
+int pdf_count_size_object (struct pdf_object * p_obj)
+{
+    return pdf_count_size_object(p_obj) + 2 * sizeof(struct pdf_object);
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr42025-2.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr42025-2.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr42025-2.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,32 @@
+typedef struct
+{
+  void *p;
+} Ptr;
+
+struct A
+{
+  int i;
+  union
+  {
+    Ptr p;
+    char *q;
+  } u;
+};
+
+extern Ptr get_stuff (void);
+extern void use_stuff (char *);
+
+static void foo(struct A p, char *q)
+{
+  if (p.i)
+    p.u.p = get_stuff ();
+  else
+    p.u.q = q;
+
+  use_stuff (p.u.q);
+}
+
+void bar(struct A *p, char *q)
+{
+  foo(*p, q);
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr42164.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr42164.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr42164.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,25 @@
+typedef struct
+{
+  unsigned long long pte;
+} pte_t;
+pte_t mk_swap_pte (unsigned long offset)
+{
+  pte_t pte;
+  pte.pte = (offset << 40);
+  return pte;
+}
+int pte_file (pte_t pte)
+{
+  return pte.pte & (1 << 4);
+}
+typedef struct
+{
+  unsigned long val;
+} swp_entry_t;
+pte_t swp_entry_to_pte (swp_entry_t entry)
+{
+  swp_entry_t arch_entry;
+  arch_entry = (swp_entry_t){mk_swap_pte (swp_offset (entry)).pte};
+  __BUG_ON ((unsigned long) pte_file ((pte_t) {arch_entry.val}));
+  return (pte_t) {arch_entry.val};
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr42237.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr42237.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr42237.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,32 @@
+struct A
+{
+  int p;
+};
+
+struct B
+{
+  struct A n;
+  struct A m;
+  int x;
+  int y;
+  int z;
+};
+
+extern int g1, g2;
+
+static void __attribute__((noinline)) foo (struct B *b)
+{
+  int t;
+
+  t = b->n.p;
+  g1 = t;
+  b->n.p = t+1;
+  g2 = b->m.p;
+
+  b->m = b->n;
+}
+
+void bar (struct B *b)
+{
+  foo (b);
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr43066.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr43066.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr43066.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,14 @@
+struct S {
+  struct { } empty[1];
+  int i;
+};
+
+int foo(int i, ...)
+{
+  struct S s;
+  __builtin_va_list va;
+  __builtin_va_start(va, i);
+  s = __builtin_va_arg(va, struct S);
+  __builtin_va_end(va);
+  return s.i;
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr42196-2.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr42196-2.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr42196-2.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,28 @@
+union U
+{
+  __complex__ int ci;
+  __complex__ float cf;
+};
+
+float gd;
+extern float bar (union U);
+
+float foo (int b, double f1, double f2, int c1, int c2)
+{
+  union U u;
+  double r;
+
+  if (b)
+    {
+      __real__ u.cf = f1;
+      __imag__ u.cf = f2;
+    }
+  else
+    {
+      __real__ u.ci = c1;
+      __imag__ u.ci = c2;
+    }
+
+  r = bar (u);
+  return r;
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr42717.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr42717.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr42717.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,30 @@
+static signed char
+foo (signed char si1, unsigned char si2)
+{
+  return (si1 ^ si2) & (-si2 ^ si2) ? : si1 - si2;
+}
+
+struct S0
+{
+};
+
+unsigned char g_21;
+
+struct S0 g_34;
+
+void
+bar (unsigned char p_20)
+{
+  unsigned char *l_22 = &g_21;
+  unsigned char l_23 = 0;
+  struct S0 *l = &g_34;
+  goto lbl_42;
+  for (; l_23; l_23 = foo (l_23, 1))
+    {
+      for (p_20 = 0; 0; p_20 = foo (p_20, 1))
+	lbl_42:;
+      (l == &g_34) ? 0 : "";
+lbl_85:*l_22 = p_20;
+    }
+  goto lbl_85;
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr41728.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr41728.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr41728.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,12 @@
+int a[8];
+int s244(void)
+{
+  int lrc, j;
+  lrc = 0;
+  for (j=0; j<7; j++)
+    if(a[j] != a[j+1])
+      lrc = 1;
+  if (lrc != 0)
+    return 0;
+  return 1;
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr42998.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr42998.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr42998.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,15 @@
+void foo(void *);
+void bar(void *);
+void ndisc_fill_addr_option(unsigned char *opt, int data_len,
+			    unsigned short addr_type) 
+{
+  int pad;
+  if (addr_type == 32)
+    pad = 2;
+  else
+    pad = 0;
+  __builtin_memset(opt + 2, 0, pad);
+  opt += pad;
+  __builtin_constant_p(data_len) ? foo (opt+2) : bar (opt+2);
+}
+
Index: gcc/testsuite/gcc.c-torture/compile/pr42559.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr42559.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr42559.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,8 @@
+void jumpfunc(int copy, void *p)
+{
+  void *l = &&jumplabel;
+  if (copy)
+    __builtin___memcpy_chk (p, l, 128, __builtin_object_size (p, 0));
+jumplabel:
+  return;
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr42299.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr42299.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr42299.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,23 @@
+/* { dg-options "-g" } */
+
+static int
+foo (int x, int y)
+{
+  if (y)
+    goto lab;
+  if (x)
+    y = 0;
+  if (y)
+    goto lab;
+  y = 0;
+lab:
+  return y;
+}
+
+void
+baz (int x, int y)
+{
+  y = foo (x, y);
+  if (y != 0)
+    bar ();
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr42234.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr42234.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr42234.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,14 @@
+/* { dg-options "-g" } */
+
+void
+foo (int x)
+{
+  struct S { int s; } d = { 1 };
+  unsigned int e = 1;
+  if (x)
+    e = x && d.s;
+  else
+    for (e = 0; e <= 3; e--)
+      ;
+  e++;
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr42025-1.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr42025-1.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr42025-1.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,24 @@
+typedef void* Ptr;
+
+struct A
+{
+  int i;
+  union
+  {
+    Ptr p;
+    char *q;
+  } u;
+};
+
+static void foo(struct A *p, char *q)
+{
+  if (p->i)
+    p->u.p = 0;
+  else
+    p->u.q = q;
+}
+
+void bar(struct A *p, char *q)
+{
+  foo(p, q);
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr42049.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr42049.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr42049.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,27 @@
+/* PR middle-end/42049 */
+
+extern char *strcpy (char *s1, const char *s2);
+struct S { char s[4]; };
+
+int
+foo (int x, char **y)
+{
+  char const *a;
+  char const *b;
+  struct S s[9];
+  long i;
+  if (x > 1)
+    a = y[1];
+  else
+    a = "abc";
+  if (x > 2)
+    b = y[2];
+  else
+    b = "def";
+  strcpy (s[0].s, a);
+  strcpy (s[1].s, b);
+  for (i = 2; i < x - 2 && i < 8; i++)
+    strcpy (s[i].s, y[i + 1]);
+  s[i].s[0] = '\0';
+  return 0;
+}
Index: gcc/testsuite/gcc.target/arm/synchronize.c
===================================================================
--- gcc/testsuite/gcc.target/arm/synchronize.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/arm/synchronize.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,6 @@
+/* { dg-final { scan-assembler "__sync_synchronize" { target arm*-*-linux-*eabi } } } */
+
+void *foo (void)
+{
+  __sync_synchronize();
+}
Index: gcc/testsuite/gcc.target/arm/neon/vget_lowp8.c
===================================================================
--- gcc/testsuite/gcc.target/arm/neon/vget_lowp8.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/gcc.target/arm/neon/vget_lowp8.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -9,7 +9,7 @@
 
 void test_vget_lowp8 (void)
 {
-  poly8x8_t out_poly8x8_t;
+  register poly8x8_t out_poly8x8_t asm ("d18");
   poly8x16_t arg0_poly8x16_t;
 
   out_poly8x8_t = vget_low_p8 (arg0_poly8x16_t);
Index: gcc/testsuite/gcc.target/arm/neon/vget_lows64.c
===================================================================
--- gcc/testsuite/gcc.target/arm/neon/vget_lows64.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/gcc.target/arm/neon/vget_lows64.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -15,5 +15,4 @@
   out_int64x1_t = vget_low_s64 (arg0_int64x2_t);
 }
 
-/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
Index: gcc/testsuite/gcc.target/arm/neon/vget_lowu64.c
===================================================================
--- gcc/testsuite/gcc.target/arm/neon/vget_lowu64.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/gcc.target/arm/neon/vget_lowu64.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -15,5 +15,4 @@
   out_uint64x1_t = vget_low_u64 (arg0_uint64x2_t);
 }
 
-/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
Index: gcc/testsuite/gcc.target/arm/neon/vget_lowp16.c
===================================================================
--- gcc/testsuite/gcc.target/arm/neon/vget_lowp16.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/gcc.target/arm/neon/vget_lowp16.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -9,7 +9,7 @@
 
 void test_vget_lowp16 (void)
 {
-  poly16x4_t out_poly16x4_t;
+  register poly16x4_t out_poly16x4_t asm ("d18");
   poly16x8_t arg0_poly16x8_t;
 
   out_poly16x4_t = vget_low_p16 (arg0_poly16x8_t);
Index: gcc/testsuite/gcc.target/arm/neon/vget_lows8.c
===================================================================
--- gcc/testsuite/gcc.target/arm/neon/vget_lows8.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/gcc.target/arm/neon/vget_lows8.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -9,7 +9,7 @@
 
 void test_vget_lows8 (void)
 {
-  int8x8_t out_int8x8_t;
+  register int8x8_t out_int8x8_t asm ("d18");
   int8x16_t arg0_int8x16_t;
 
   out_int8x8_t = vget_low_s8 (arg0_int8x16_t);
Index: gcc/testsuite/gcc.target/arm/neon/vget_lowu8.c
===================================================================
--- gcc/testsuite/gcc.target/arm/neon/vget_lowu8.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/gcc.target/arm/neon/vget_lowu8.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -9,7 +9,7 @@
 
 void test_vget_lowu8 (void)
 {
-  uint8x8_t out_uint8x8_t;
+  register uint8x8_t out_uint8x8_t asm ("d18");
   uint8x16_t arg0_uint8x16_t;
 
   out_uint8x8_t = vget_low_u8 (arg0_uint8x16_t);
Index: gcc/testsuite/gcc.target/arm/neon/vget_lows32.c
===================================================================
--- gcc/testsuite/gcc.target/arm/neon/vget_lows32.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/gcc.target/arm/neon/vget_lows32.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -9,7 +9,7 @@
 
 void test_vget_lows32 (void)
 {
-  int32x2_t out_int32x2_t;
+  register int32x2_t out_int32x2_t asm ("d18");
   int32x4_t arg0_int32x4_t;
 
   out_int32x2_t = vget_low_s32 (arg0_int32x4_t);
Index: gcc/testsuite/gcc.target/arm/neon/vget_lows16.c
===================================================================
--- gcc/testsuite/gcc.target/arm/neon/vget_lows16.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/gcc.target/arm/neon/vget_lows16.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -9,7 +9,7 @@
 
 void test_vget_lows16 (void)
 {
-  int16x4_t out_int16x4_t;
+  register int16x4_t out_int16x4_t asm ("d18");
   int16x8_t arg0_int16x8_t;
 
   out_int16x4_t = vget_low_s16 (arg0_int16x8_t);
Index: gcc/testsuite/gcc.target/arm/neon/vget_lowu32.c
===================================================================
--- gcc/testsuite/gcc.target/arm/neon/vget_lowu32.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/gcc.target/arm/neon/vget_lowu32.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -9,7 +9,7 @@
 
 void test_vget_lowu32 (void)
 {
-  uint32x2_t out_uint32x2_t;
+  register uint32x2_t out_uint32x2_t asm ("d18");
   uint32x4_t arg0_uint32x4_t;
 
   out_uint32x2_t = vget_low_u32 (arg0_uint32x4_t);
Index: gcc/testsuite/gcc.target/arm/neon/vget_lowu16.c
===================================================================
--- gcc/testsuite/gcc.target/arm/neon/vget_lowu16.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/gcc.target/arm/neon/vget_lowu16.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -9,7 +9,7 @@
 
 void test_vget_lowu16 (void)
 {
-  uint16x4_t out_uint16x4_t;
+  register uint16x4_t out_uint16x4_t asm ("d18");
   uint16x8_t arg0_uint16x8_t;
 
   out_uint16x4_t = vget_low_u16 (arg0_uint16x8_t);
Index: gcc/testsuite/gcc.target/arm/neon/vget_lowf32.c
===================================================================
--- gcc/testsuite/gcc.target/arm/neon/vget_lowf32.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/gcc.target/arm/neon/vget_lowf32.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -9,7 +9,7 @@
 
 void test_vget_lowf32 (void)
 {
-  float32x2_t out_float32x2_t;
+  register float32x2_t out_float32x2_t asm ("d18");
   float32x4_t arg0_float32x4_t;
 
   out_float32x2_t = vget_low_f32 (arg0_float32x4_t);
Index: gcc/testsuite/gcc.target/arm/neon-thumb2-move.c
===================================================================
--- gcc/testsuite/gcc.target/arm/neon-thumb2-move.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/arm/neon-thumb2-move.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,98 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_neon_ok } */
+/* { dg-options "-O2 -mthumb -march=armv7-a -mfloat-abi=softfp -mfpu=neon" } */
+
+#include <arm_neon.h>
+#include <stddef.h>
+
+void *
+memset (DST, C, LENGTH)
+     void *DST;
+     int C;
+     size_t LENGTH;
+{
+  void* DST0 = DST;
+  unsigned char C_BYTE = C;
+
+
+  if (__builtin_expect(LENGTH < 4, 1)) {
+    size_t i = 0;
+    while (i < LENGTH) {
+      ((char*)DST)[i] = C_BYTE;
+      i++;
+    }
+    return DST;
+  }
+
+  const char* DST_end = (char*)DST + LENGTH;
+
+
+  while ((uintptr_t)DST % 4 != 0) {
+    *(char*) (DST++) = C_BYTE;
+  }
+
+
+  uint32_t C_SHORTWORD = (uint32_t)(unsigned char)(C_BYTE) * 0x01010101;
+
+
+  if (__builtin_expect(DST_end - (char*)DST >= 16, 0)) {
+    while ((uintptr_t)DST % 16 != 0) {
+      *((uint32_t*)((char*)(DST) + (0))) = C_SHORTWORD;
+      DST += 4;
+    }
+
+
+    uint8x16_t C_WORD = vdupq_n_u8(C_BYTE);
+
+
+
+
+
+    size_t i = 0;
+    LENGTH = DST_end - (char*)DST;
+    while (i + 16 * 16 <= LENGTH) {
+      *((uint8x16_t*)((char*)(DST) + (i))) = C_WORD;
+      *((uint8x16_t*)((char*)(DST) + (i + 16 * 1))) = C_WORD;
+      *((uint8x16_t*)((char*)(DST) + (i + 16 * 2))) = C_WORD;
+      *((uint8x16_t*)((char*)(DST) + (i + 16 * 3))) = C_WORD;
+      *((uint8x16_t*)((char*)(DST) + (i + 16 * 4))) = C_WORD;
+      *((uint8x16_t*)((char*)(DST) + (i + 16 * 5))) = C_WORD;
+      *((uint8x16_t*)((char*)(DST) + (i + 16 * 6))) = C_WORD;
+      *((uint8x16_t*)((char*)(DST) + (i + 16 * 7))) = C_WORD;
+      *((uint8x16_t*)((char*)(DST) + (i + 16 * 8))) = C_WORD;
+      *((uint8x16_t*)((char*)(DST) + (i + 16 * 9))) = C_WORD;
+      *((uint8x16_t*)((char*)(DST) + (i + 16 * 10))) = C_WORD;
+      *((uint8x16_t*)((char*)(DST) + (i + 16 * 11))) = C_WORD;
+      *((uint8x16_t*)((char*)(DST) + (i + 16 * 12))) = C_WORD;
+      *((uint8x16_t*)((char*)(DST) + (i + 16 * 13))) = C_WORD;
+      *((uint8x16_t*)((char*)(DST) + (i + 16 * 14))) = C_WORD;
+      *((uint8x16_t*)((char*)(DST) + (i + 16 * 15))) = C_WORD;
+      i += 16 * 16;
+    }
+    while (i + 16 * 4 <= LENGTH) {
+      *((uint8x16_t*)((char*)(DST) + (i))) = C_WORD;
+      *((uint8x16_t*)((char*)(DST) + (i + 16 * 1))) = C_WORD;
+      *((uint8x16_t*)((char*)(DST) + (i + 16 * 2))) = C_WORD;
+      *((uint8x16_t*)((char*)(DST) + (i + 16 * 3))) = C_WORD;
+      i += 16 * 4;
+    }
+    while (i + 16 <= LENGTH) {
+      *((uint8x16_t*)((char*)(DST) + (i))) = C_WORD;
+      i += 16;
+    }
+    DST += i;
+  }
+
+  while (4 <= DST_end - (char*)DST) {
+    *((uint32_t*)((char*)(DST) + (0))) = C_SHORTWORD;
+    DST += 4;
+  }
+
+
+  while ((char*)DST < DST_end) {
+    *((char*)DST) = C_BYTE;
+    DST++;
+  }
+
+  return DST0;
+}
Index: gcc/testsuite/gcc.target/arm/thumb2-cbnz.c
===================================================================
--- gcc/testsuite/gcc.target/arm/thumb2-cbnz.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/arm/thumb2-cbnz.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,110 @@
+/* { dg-do assemble } */
+/* { dg-options "-O1 -mthumb -march=armv7-a" } */
+
+typedef short int int16_t;
+typedef unsigned char uint8_t;
+struct component
+{
+  float *Q_table;
+};
+static inline unsigned char descale_and_clamp(int x, int shift)
+{
+  x += (1UL<<(shift-1));
+  if (x<0)
+    x = (x >> shift) | ((~(0UL)) << (32-(shift)));
+    x >>= shift;
+  x += 128;
+  if (x>255)
+    return 255;
+  else if (x<0)
+    return 0;
+    return x;
+}
+void
+tinyjpeg_idct_float (struct component *compptr, uint8_t *output_buf, int stride)
+{
+  float tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;
+  float tmp10, tmp11, tmp12, tmp13;
+  float z5, z10, z11, z12, z13;
+  int16_t *inptr;
+  float *quantptr;
+  float *wsptr;
+  uint8_t *outptr;
+  int ctr;
+  float workspace[(8*8)];
+  quantptr = compptr->Q_table;
+  wsptr = workspace;
+  for (ctr = 8; ctr > 0; ctr--) {
+    if (inptr[8*1] == 0 && inptr[8*2] == 0 &&
+ inptr[8*3] == 0 && inptr[8*4] == 0 &&
+ inptr[8*5] == 0 && inptr[8*6] == 0 &&
+ inptr[8*7] == 0) {
+      float dcval = (((float) (inptr[8*0])) * (quantptr[8*0]));
+      wsptr[8*0] = dcval;
+      wsptr[8*1] = dcval;
+      wsptr[8*2] = dcval;
+      wsptr[8*3] = dcval;
+      wsptr[8*4] = dcval;
+      wsptr[8*5] = dcval;
+      wsptr[8*6] = dcval;
+      wsptr[8*7] = dcval;
+      inptr++;
+      quantptr++;
+      wsptr++;
+      continue;
+    }
+    tmp0 = (((float) (inptr[8*0])) * (quantptr[8*0]));
+    tmp1 = (((float) (inptr[8*2])) * (quantptr[8*2]));
+    tmp2 = (((float) (inptr[8*4])) * (quantptr[8*4]));
+    tmp3 = (((float) (inptr[8*6])) * (quantptr[8*6]));
+    tmp10 = tmp0 + tmp2;
+    tmp11 = tmp0 - tmp2;
+    tmp13 = tmp1 + tmp3;
+    tmp12 = (tmp1 - tmp3) * ((float) 1.414213562) - tmp13;
+    tmp0 = tmp10 + tmp13;
+    tmp3 = tmp10 - tmp13;
+    tmp1 = tmp11 + tmp12;
+    tmp2 = tmp11 - tmp12;
+    tmp4 = (((float) (inptr[8*1])) * (quantptr[8*1]));
+    tmp5 = (((float) (inptr[8*3])) * (quantptr[8*3]));
+    tmp6 = (((float) (inptr[8*5])) * (quantptr[8*5]));
+    tmp7 = (((float) (inptr[8*7])) * (quantptr[8*7]));
+    z13 = tmp6 + tmp5;
+    z10 = tmp6 - tmp5;
+    z11 = tmp4 + tmp7;
+    z12 = tmp4 - tmp7;
+    tmp7 = z11 + z13;
+    tmp11 = (z11 - z13) * ((float) 1.414213562);
+    z5 = (z10 + z12) * ((float) 1.847759065);
+    tmp10 = ((float) 1.082392200) * z12 - z5;
+    tmp12 = ((float) -2.613125930) * z10 + z5;
+    tmp6 = tmp12 - tmp7;
+    tmp5 = tmp11 - tmp6;
+    tmp4 = tmp10 + tmp5;
+    wsptr[8*0] = tmp0 + tmp7;
+    wsptr[8*7] = tmp0 - tmp7;
+    wsptr[8*1] = tmp1 + tmp6;
+    wsptr[8*2] = tmp2 + tmp5;
+    wsptr[8*5] = tmp2 - tmp5;
+    wsptr[8*4] = tmp3 + tmp4;
+    wsptr[8*3] = tmp3 - tmp4;
+    inptr++;
+    quantptr++;
+    wsptr++;
+  }
+  for (ctr = 0; ctr < 8; ctr++) {
+    tmp11 = wsptr[0] - wsptr[4];
+    tmp12 = (wsptr[2] - wsptr[6]) * ((float) 1.414213562) - tmp13;
+    tmp0 = tmp10 + tmp13;
+    tmp1 = tmp11 + tmp12;
+    z10 = wsptr[5] - wsptr[3];
+    tmp12 = ((float) -2.613125930) * z10 + z5;
+    tmp6 = tmp12 - tmp7;
+    outptr[0] = descale_and_clamp((int)(tmp0 + tmp7), 3);
+    outptr[7] = descale_and_clamp((int)(tmp0 - tmp7), 3);
+    outptr[1] = descale_and_clamp((int)(tmp1 + tmp6), 3);
+    outptr[6] = descale_and_clamp((int)(tmp1 - tmp6), 3);
+    outptr[2] = descale_and_clamp((int)(tmp2 + tmp5), 3);
+    outptr += stride;
+  }
+}
Index: gcc/testsuite/gcc.target/arm/pr40887.c
===================================================================
--- gcc/testsuite/gcc.target/arm/pr40887.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/arm/pr40887.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,9 @@
+/* { dg-options "-O2 -march=armv5te" }  */
+/* { dg-final { scan-assembler "blx" } } */
+
+int (*indirect_func)();
+
+int indirect_call()
+{
+    return indirect_func();
+}
Index: gcc/testsuite/gcc.target/alpha/pr42113.c
===================================================================
--- gcc/testsuite/gcc.target/alpha/pr42113.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/alpha/pr42113.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+int foo (int a, int b)
+{
+  int bar = a * sizeof (int);
+
+  if (b)
+    bar += sizeof (int);
+
+  return bar;
+}
Index: gcc/testsuite/gcc.target/alpha/pr42448-1.c
===================================================================
--- gcc/testsuite/gcc.target/alpha/pr42448-1.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/alpha/pr42448-1.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,27 @@
+/* { dg-do run } */
+/* { dg-options "-mcpu=21064 -O0" } */
+
+extern void abort (void);
+
+struct S2180
+{
+  char t;
+  _Complex char u[2];
+};
+
+struct S2180 s2180;
+
+int
+main (void)
+{
+  volatile struct S2180 x;
+
+  s2180.u[1] = 3 + 4i;
+
+  x.u[1] = s2180.u[1];
+
+  if (x.u[1] != s2180.u[1])
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/alpha/pr42448-2.c
===================================================================
--- gcc/testsuite/gcc.target/alpha/pr42448-2.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/alpha/pr42448-2.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,27 @@
+/* { dg-do run } */
+/* { dg-options "-mcpu=21064 -O0" } */
+
+extern void abort (void);
+
+struct S2180
+{
+  char t;
+  _Complex char u[4];
+};
+
+struct S2180 s2180;
+
+int
+main (void)
+{
+  volatile struct S2180 x;
+
+  s2180.u[3] = 3 + 4i;
+
+  x.u[3] = s2180.u[3];
+
+  if (x.u[3] != s2180.u[3])
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/alpha/pr42774.c
===================================================================
--- gcc/testsuite/gcc.target/alpha/pr42774.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/alpha/pr42774.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -mcpu=ev4" } */
+
+unsigned int ntfs_getinfo(void *p)
+{
+    char bootsect[8];
+
+    __builtin_memcpy(bootsect, p, sizeof bootsect);
+    return *(unsigned short *)(bootsect + 3);
+}
Index: gcc/testsuite/gcc.target/i386/pr42542-2b.c
===================================================================
--- gcc/testsuite/gcc.target/i386/pr42542-2b.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/i386/pr42542-2b.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-O1 -msse4.1 -ftree-vectorize" } */
+
+#define CHECK_H "sse4_1-check.h"
+#define TEST sse4_1_test
+
+#include "pr42542-2.c"
+
+/* { dg-final { scan-assembler "pmaxuw" } } */
+/* { dg-final { scan-assembler "pminuw" } } */
Index: gcc/testsuite/gcc.target/i386/pr42542-3a.c
===================================================================
--- gcc/testsuite/gcc.target/i386/pr42542-3a.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/i386/pr42542-3a.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,7 @@
+/* { dg-do compile } */
+/* { dg-options "-O1 -msse2 -ftree-vectorize" } */
+
+#include "pr42542-3.c"
+
+/* { dg-final { scan-assembler "pmaxub" } } */
+/* { dg-final { scan-assembler "pminub" } } */
Index: gcc/testsuite/gcc.target/i386/mmx-3dnow-check.h
===================================================================
--- gcc/testsuite/gcc.target/i386/mmx-3dnow-check.h	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/i386/mmx-3dnow-check.h	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,21 @@
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "cpuid.h"
+
+static void mmx_3dnow_test (void);
+
+int
+main ()
+{
+  unsigned int eax, ebx, ecx, edx;
+ 
+  if (!__get_cpuid (0x80000001, &eax, &ebx, &ecx, &edx))
+    return 0;
+
+  /* Run 3DNow! test only if host has 3DNow! support.  */
+  if (edx & bit_3DNOW)
+    mmx_3dnow_test ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/i386/pr42549.c
===================================================================
--- gcc/testsuite/gcc.target/i386/pr42549.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/i386/pr42549.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,37 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -m3dnow" } */
+
+#include "mmx-3dnow-check.h"
+
+#include <mm3dnow.h>
+
+typedef union {
+  float f[2];
+  __m64 v;
+} vec_t;
+
+void __attribute__ ((noinline))
+Butterfly_3 (__m64 * D, __m64 SC)
+{
+  __m64 T, T1;
+
+  T = _m_pfmul (D[1], SC);
+  T1 = D[0];
+  D[0] = _m_pfadd (T1, T);
+  D[1] = _m_pfsub (T1, T);
+}
+
+static void
+mmx_3dnow_test (void)
+{
+  vec_t D[2] = { { .f = { 2.0f, 3.0f } },
+		 { .f = { 4.0f, 5.0f } } };
+
+  const vec_t SC = { .f = { 1.0f, 1.0f } };
+
+  Butterfly_3 (&D[0].v, SC.v);
+  _m_femms ();
+
+  if (D[1].f[0] != -2.0f || D[1].f[1] != -2.0f)
+    abort ();
+}
Index: gcc/testsuite/gcc.target/i386/pr41963.c
===================================================================
--- gcc/testsuite/gcc.target/i386/pr41963.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/i386/pr41963.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,36 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -ffast-math -mrecip" } */
+#include <math.h>
+
+extern float sqrtf(float);
+
+static __attribute__((noinline)) void f (float *dst, float *src)
+{
+  int i, j;
+  for (i = 0; i < 2; i++)
+    {
+      float len;
+      dst[0] = src[0];
+      dst[1] = src[1];
+      len = sqrtf (dst[0] * dst[0] + dst[1] * dst[1]);
+      if (len > 0.5f)
+	{
+	  len = 1.0f / len;
+	  dst[0] *= len;
+	  dst[1] *= len;
+	}
+    }
+}
+
+extern void abort (void);
+
+int main()
+{
+  float dst[2], src[2];
+  src[0] = 2.0f;
+  src[1] = 5.0f;
+  f (dst, src);
+  if (fabsf (dst[0] * dst[0] + dst[1] * dst[1] - 1.0f) > 0.01f)
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.target/i386/pr42542-2.c
===================================================================
--- gcc/testsuite/gcc.target/i386/pr42542-2.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/i386/pr42542-2.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,77 @@
+/* { dg-do run } */
+/* { dg-options "-O1 -msse2 -ftree-vectorize" } */
+
+#ifndef CHECK_H
+#define CHECK_H "sse2-check.h"
+#endif
+
+#ifndef TEST
+#define TEST sse2_test
+#endif
+
+#include CHECK_H
+
+unsigned short v1[] __attribute__ ((aligned(16))) =
+{
+  0x8000, 0x9000, 1, 10, 0xa000, 0xb000, 2, 20,
+  3, 30, 0xd000, 0xe000, 0xf000, 0xe000, 25, 30
+};
+unsigned short v2[] __attribute__ ((aligned(16))) =
+{
+  4, 40, 0xb000, 0x8000, 5, 50, 0xc000, 0xf000,
+  0xd000, 0xa000, 6, 65, 7, 75, 0xe000, 0xc000
+};
+
+unsigned short max[] =
+{
+  0x8000, 0x9000, 0xb000, 0x8000, 0xa000, 0xb000, 0xc000, 0xf000,
+  0xd000, 0xa000, 0xd000, 0xe000, 0xf000, 0xe000, 0xe000, 0xc000
+};
+
+unsigned short min[] =
+{
+  4, 40, 1, 10, 5, 50, 2, 20,
+  3, 30, 6, 65, 7, 75, 25, 30
+};
+
+unsigned short res[16] __attribute__ ((aligned(16)));
+
+extern void abort (void);
+
+void
+find_max (void)
+{
+  int i;
+
+  for (i = 0; i < 16; i++)
+    res[i] = v1[i] < v2[i] ? v2[i] : v1[i];
+}
+
+void
+find_min (void)
+{
+  int i;
+
+  for (i = 0; i < 16; i++)
+    res[i] = v1[i] > v2[i] ? v2[i] : v1[i];
+}
+
+static void
+TEST (void)
+{
+  int i;
+  int err = 0;
+
+  find_max ();
+  for (i = 0; i < 16; i++)
+    if (res[i] != max[i])
+      err++;
+
+  find_min ();
+  for (i = 0; i < 16; i++)
+    if (res[i] != min[i])
+      err++;
+
+  if (err)
+    abort ();
+}
Index: gcc/testsuite/gcc.target/i386/pr42881.c
===================================================================
--- gcc/testsuite/gcc.target/i386/pr42881.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/i386/pr42881.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,13 @@
+/* PR target/42881 */
+/* { dg-do run } */
+/* { dg-options "-O0 -msse2" } */
+#include "sse2-check.h"
+static void
+sse2_test (void)
+{
+  double a[2];
+  __m128d x = _mm_set1_pd(3);
+  _mm_storeu_pd(a,x);
+  if (a[0] != 3.0 || a[1] != 3.0)
+    __builtin_abort ();
+}
Index: gcc/testsuite/gcc.target/i386/pr42542-1b.c
===================================================================
--- gcc/testsuite/gcc.target/i386/pr42542-1b.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/i386/pr42542-1b.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-O1 -msse4.1 -ftree-vectorize" } */
+
+#define CHECK_H "sse4_1-check.h"
+#define TEST sse4_1_test
+
+#include "pr42542-1.c"
+
+/* { dg-final { scan-assembler "pmaxud" } } */
+/* { dg-final { scan-assembler "pminud" } } */
Index: gcc/testsuite/gcc.target/i386/pr41900.c
===================================================================
--- gcc/testsuite/gcc.target/i386/pr41900.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/i386/pr41900.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target ilp32 } */
+/* { dg-options "-O2 -fomit-frame-pointer -mpreferred-stack-boundary=2" } */
+
+int main ()
+{
+  volatile unsigned code = 0xc3;
+
+  ((void (*)(void)) &code) ();
+  return 0;
+}
+
+/* { dg-final { scan-assembler-not "call\[ \\t\]+\\*%esp" } } */
Index: gcc/testsuite/gcc.target/i386/pr42542-2a.c
===================================================================
--- gcc/testsuite/gcc.target/i386/pr42542-2a.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/i386/pr42542-2a.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,8 @@
+/* { dg-do run } */
+/* { dg-require-effective-target sse4 } */
+/* { dg-options "-O1 -msse4.1 -ftree-vectorize" } */
+
+#define CHECK_H "sse4_1-check.h"
+#define TEST sse4_1_test
+
+#include "pr42542-2.c"
Index: gcc/testsuite/gcc.target/i386/clobbers.c
===================================================================
--- gcc/testsuite/gcc.target/i386/clobbers.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/gcc.target/i386/clobbers.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,7 +1,6 @@
 /* Test asm clobbers on x86. */
 
 /* { dg-do run } */
-/* { dg-skip-if "" { ilp32 } { "-fpic" "-fPIC" } { "" } } */
 
 extern void abort (void);
 
@@ -13,11 +12,15 @@
                 abort ();
 	/* On darwin you can't call external functions from non-pic code,
 	   however, clobbering ebx isn't valid in pic code. Instead of
-	   disabling the whole test, just disable the ebx clobbering part.  */
+	   disabling the whole test, just disable the ebx clobbering part.
+	   Ditto for any x86 system that is ilp32 && pic.
+	*/
 #if !(defined (__MACH__))
+#if ! defined (__PIC__) || defined (__LP64__)
         __asm__ ("movl $1,%0\n\txorl %%ebx,%%ebx" : "=r" (i) : : "ebx");
         if (i != 1)
                 abort ();
+#endif /* ! pic || lp64 */
 #endif
         __asm__ ("movl $1,%0\n\txorl %%ecx,%%ecx" : "=r" (i) : : "ecx");
         if (i != 1)
Index: gcc/testsuite/gcc.target/i386/pr42542-1.c
===================================================================
--- gcc/testsuite/gcc.target/i386/pr42542-1.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/i386/pr42542-1.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,77 @@
+/* { dg-do run } */
+/* { dg-options "-O1 -msse2 -ftree-vectorize" } */
+
+#ifndef CHECK_H
+#define CHECK_H "sse2-check.h"
+#endif
+
+#ifndef TEST
+#define TEST sse2_test
+#endif
+
+#include CHECK_H
+
+unsigned int v1[] __attribute__ ((aligned(16))) =
+{
+  0x80000000, 1, 0xa0000000, 2,
+  3, 0xd0000000, 0xf0000000, 0xe0000000
+};
+unsigned int v2[] __attribute__ ((aligned(16))) =
+{
+  4, 0xb0000000, 5, 0xc0000000,
+  0xd0000000, 6, 7, 8
+};
+
+unsigned int max[] =
+{
+  0x80000000, 0xb0000000, 0xa0000000, 0xc0000000,
+  0xd0000000, 0xd0000000, 0xf0000000, 0xe0000000
+};
+
+unsigned int min[] =
+{
+  4, 1, 5, 2,
+  3, 6, 7, 8
+};
+
+unsigned int res[8] __attribute__ ((aligned(16)));
+
+extern void abort (void);
+
+void
+find_max (void)
+{
+  int i;
+
+  for (i = 0; i < 8; i++)
+    res[i] = v1[i] < v2[i] ? v2[i] : v1[i];
+}
+
+void
+find_min (void)
+{
+  int i;
+
+  for (i = 0; i < 8; i++)
+    res[i] = v1[i] > v2[i] ? v2[i] : v1[i];
+}
+
+static void
+TEST (void)
+{
+  int i;
+  int err = 0;
+
+  find_max ();
+  for (i = 0; i < 8; i++)
+    if (res[i] != max[i])
+      err++;
+
+  find_min ();
+  for (i = 0; i < 8; i++)
+    if (res[i] != min[i])
+      err++;
+
+  if (err)
+    abort ();
+}
Index: gcc/testsuite/gcc.target/i386/pr42542-3.c
===================================================================
--- gcc/testsuite/gcc.target/i386/pr42542-3.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/i386/pr42542-3.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,85 @@
+/* { dg-do run } */
+/* { dg-options "-O1 -msse2 -ftree-vectorize" } */
+
+#ifndef CHECK_H
+#define CHECK_H "sse2-check.h"
+#endif
+
+#ifndef TEST
+#define TEST sse2_test
+#endif
+
+#include CHECK_H
+
+unsigned char v1[] __attribute__ ((aligned(16))) =
+{
+  0x80, 0xd0, 0x90, 0xa0, 1, 15, 10, 15,
+  0xa0, 0xc0, 0xb0, 0xf0, 2, 25, 20, 35,
+  3, 34, 30, 36, 0xd0, 0x80, 0xe0, 0xb0,
+  0xf0, 0xe0, 0xe0, 0x80, 25, 34, 30, 40
+};
+unsigned char v2[] __attribute__ ((aligned(16))) =
+{
+  4, 44, 40, 48, 0xb0, 0x80, 0x80, 0x90,
+  5, 55, 50, 51, 0xc0, 0xb0, 0xf0, 0xd0,
+  0xd0, 0x80, 0xa0, 0xf0, 6, 61, 65, 68,
+  7, 76, 75, 81, 0xe0, 0xf0, 0xc0, 0x90
+};
+
+unsigned char max[] =
+{
+  0x80, 0xd0, 0x90, 0xa0, 0xb0, 0x80, 0x80, 0x90,
+  0xa0, 0xc0, 0xb0, 0xf0, 0xc0, 0xb0, 0xf0, 0xd0,
+  0xd0, 0x80, 0xa0, 0xf0, 0xd0, 0x80, 0xe0, 0xb0,
+  0xf0, 0xe0, 0xe0, 0x80, 0xe0, 0xf0, 0xc0, 0x90
+};
+
+unsigned char min[] =
+{
+  4, 44, 40, 48, 1, 15, 10, 15,
+  5, 55, 50, 51, 2, 25, 20, 35,
+  3, 34, 30, 36, 6, 61, 65, 68,
+  7, 76, 75, 81, 25, 34, 30, 40
+};
+
+unsigned char res[32] __attribute__ ((aligned(16)));
+
+extern void abort (void);
+
+void
+find_max (void)
+{
+  int i;
+
+  for (i = 0; i < 32; i++)
+    res[i] = v1[i] < v2[i] ? v2[i] : v1[i];
+}
+
+void
+find_min (void)
+{
+  int i;
+
+  for (i = 0; i < 32; i++)
+    res[i] = v1[i] > v2[i] ? v2[i] : v1[i];
+}
+
+static void
+TEST (void)
+{
+  int i;
+  int err = 0;
+
+  find_max ();
+  for (i = 0; i < 32; i++)
+    if (res[i] != max[i])
+      err++;
+
+  find_min ();
+  for (i = 0; i < 32; i++)
+    if (res[i] != min[i])
+      err++;
+
+  if (err)
+    abort ();
+}
Index: gcc/testsuite/gcc.target/i386/pr42542-1a.c
===================================================================
--- gcc/testsuite/gcc.target/i386/pr42542-1a.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/i386/pr42542-1a.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,8 @@
+/* { dg-do run } */
+/* { dg-require-effective-target sse4 } */
+/* { dg-options "-O1 -msse4.1 -ftree-vectorize" } */
+
+#define CHECK_H "sse4_1-check.h"
+#define TEST sse4_1_test
+
+#include "pr42542-1.c"
Index: gcc/testsuite/gcc.target/i386/pr42891.c
===================================================================
--- gcc/testsuite/gcc.target/i386/pr42891.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/i386/pr42891.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+union B { int i; float f; };
+
+extern void bar (void);
+
+void
+foo (union B x, union B y)
+{
+  if (!(y.f > x.i))
+    bar ();
+}
Index: gcc/testsuite/gcc.target/x86_64/abi/avx/asm-support.S
===================================================================
--- gcc/testsuite/gcc.target/x86_64/abi/avx/asm-support.S	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/gcc.target/x86_64/abi/avx/asm-support.S	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -46,7 +46,9 @@
 	.type	snapshot_ret, @function
 snapshot_ret:
 	movq	%rdi, rdi(%rip)
+	subq	$8, %rsp
 	call	*callthis(%rip)
+	addq	$8, %rsp
 	movq	%rax, rax(%rip)
 	movq	%rdx, rdx(%rip)
 	vmovdqu	%ymm0, ymm_regs+0(%rip)
Index: gcc/testsuite/gcc.target/ia64/pr42542-1.c
===================================================================
--- gcc/testsuite/gcc.target/ia64/pr42542-1.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/ia64/pr42542-1.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,68 @@
+/* { dg-do run } */
+/* { dg-options "-O1 -ftree-vectorize" } */
+
+unsigned int v1[] __attribute__ ((aligned(16))) =
+{
+  0x80000000, 1, 0xa0000000, 2,
+  3, 0xd0000000, 0xf0000000, 0xe0000000
+};
+unsigned int v2[] __attribute__ ((aligned(16))) =
+{
+  4, 0xb0000000, 5, 0xc0000000,
+  0xd0000000, 6, 7, 8
+};
+
+unsigned int max[] =
+{
+  0x80000000, 0xb0000000, 0xa0000000, 0xc0000000,
+  0xd0000000, 0xd0000000, 0xf0000000, 0xe0000000
+};
+
+unsigned int min[] =
+{
+  4, 1, 5, 2,
+  3, 6, 7, 8
+};
+
+unsigned int res[8] __attribute__ ((aligned(16)));
+
+extern void abort (void);
+
+void
+find_max (void)
+{
+  int i;
+
+  for (i = 0; i < 8; i++)
+    res[i] = v1[i] < v2[i] ? v2[i] : v1[i];
+}
+
+void
+find_min (void)
+{
+  int i;
+
+  for (i = 0; i < 8; i++)
+    res[i] = v1[i] > v2[i] ? v2[i] : v1[i];
+}
+
+int main (void)
+{
+  int i;
+  int err = 0;
+
+  find_max ();
+  for (i = 0; i < 8; i++)
+    if (res[i] != max[i])
+      err++;
+
+  find_min ();
+  for (i = 0; i < 8; i++)
+    if (res[i] != min[i])
+      err++;
+
+  if (err)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/ia64/pr42542-2.c
===================================================================
--- gcc/testsuite/gcc.target/ia64/pr42542-2.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/ia64/pr42542-2.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,68 @@
+/* { dg-do run } */
+/* { dg-options "-O1 -ftree-vectorize" } */
+
+unsigned short v1[] __attribute__ ((aligned(16))) =
+{
+  0x8000, 0x9000, 1, 10, 0xa000, 0xb000, 2, 20,
+  3, 30, 0xd000, 0xe000, 0xf000, 0xe000, 25, 30
+};
+unsigned short v2[] __attribute__ ((aligned(16))) =
+{
+  4, 40, 0xb000, 0x8000, 5, 50, 0xc000, 0xf000,
+  0xd000, 0xa000, 6, 65, 7, 75, 0xe000, 0xc000
+};
+
+unsigned short max[] =
+{
+  0x8000, 0x9000, 0xb000, 0x8000, 0xa000, 0xb000, 0xc000, 0xf000,
+  0xd000, 0xa000, 0xd000, 0xe000, 0xf000, 0xe000, 0xe000, 0xc000
+};
+
+unsigned short min[] =
+{
+  4, 40, 1, 10, 5, 50, 2, 20,
+  3, 30, 6, 65, 7, 75, 25, 30
+};
+
+unsigned short res[16] __attribute__ ((aligned(16)));
+
+extern void abort (void);
+
+void
+find_max (void)
+{
+  int i;
+
+  for (i = 0; i < 16; i++)
+    res[i] = v1[i] < v2[i] ? v2[i] : v1[i];
+}
+
+void
+find_min (void)
+{
+  int i;
+
+  for (i = 0; i < 16; i++)
+    res[i] = v1[i] > v2[i] ? v2[i] : v1[i];
+}
+
+int main (void)
+{
+  int i;
+  int err = 0;
+
+  find_max ();
+  for (i = 0; i < 16; i++)
+    if (res[i] != max[i])
+      err++;
+
+  find_min ();
+  for (i = 0; i < 16; i++)
+    if (res[i] != min[i])
+      err++;
+
+  if (err)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/ia64/pr42542-3.c
===================================================================
--- gcc/testsuite/gcc.target/ia64/pr42542-3.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/ia64/pr42542-3.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,76 @@
+/* { dg-do run } */
+/* { dg-options "-O1 -ftree-vectorize" } */
+
+unsigned char v1[] __attribute__ ((aligned(16))) =
+{
+  0x80, 0xd0, 0x90, 0xa0, 1, 15, 10, 15,
+  0xa0, 0xc0, 0xb0, 0xf0, 2, 25, 20, 35,
+  3, 34, 30, 36, 0xd0, 0x80, 0xe0, 0xb0,
+  0xf0, 0xe0, 0xe0, 0x80, 25, 34, 30, 40
+};
+unsigned char v2[] __attribute__ ((aligned(16))) =
+{
+  4, 44, 40, 48, 0xb0, 0x80, 0x80, 0x90,
+  5, 55, 50, 51, 0xc0, 0xb0, 0xf0, 0xd0,
+  0xd0, 0x80, 0xa0, 0xf0, 6, 61, 65, 68,
+  7, 76, 75, 81, 0xe0, 0xf0, 0xc0, 0x90
+};
+
+unsigned char max[] =
+{
+  0x80, 0xd0, 0x90, 0xa0, 0xb0, 0x80, 0x80, 0x90,
+  0xa0, 0xc0, 0xb0, 0xf0, 0xc0, 0xb0, 0xf0, 0xd0,
+  0xd0, 0x80, 0xa0, 0xf0, 0xd0, 0x80, 0xe0, 0xb0,
+  0xf0, 0xe0, 0xe0, 0x80, 0xe0, 0xf0, 0xc0, 0x90
+};
+
+unsigned char min[] =
+{
+  4, 44, 40, 48, 1, 15, 10, 15,
+  5, 55, 50, 51, 2, 25, 20, 35,
+  3, 34, 30, 36, 6, 61, 65, 68,
+  7, 76, 75, 81, 25, 34, 30, 40
+};
+
+unsigned char res[32] __attribute__ ((aligned(16)));
+
+extern void abort (void);
+
+void
+find_max (void)
+{
+  int i;
+
+  for (i = 0; i < 32; i++)
+    res[i] = v1[i] < v2[i] ? v2[i] : v1[i];
+}
+
+void
+find_min (void)
+{
+  int i;
+
+  for (i = 0; i < 32; i++)
+    res[i] = v1[i] > v2[i] ? v2[i] : v1[i];
+}
+
+int main (void)
+{
+  int i;
+  int err = 0;
+
+  find_max ();
+  for (i = 0; i < 32; i++)
+    if (res[i] != max[i])
+      err++;
+
+  find_min ();
+  for (i = 0; i < 32; i++)
+    if (res[i] != min[i])
+      err++;
+
+  if (err)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/spu/intrinsics-3.c
===================================================================
--- gcc/testsuite/gcc.target/spu/intrinsics-3.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/gcc.target/spu/intrinsics-3.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -19,3 +19,24 @@
 {
   vec_uint4 out = spu_convtu (in[0], 128); /* { dg-error "expects an integer literal in the range" "0, 127"  }*/
 }
+
+/* Test that these intrinsics accept non-literal arguments */
+void f4 (vec_uint4 *in, int n)
+{
+  vec_float4 out = spu_convtf (in[0], n);
+}
+
+void f5 (vec_int4 *in, int n)
+{
+  vec_float4 out = spu_convtf (in[0], n);
+}
+
+void f6 (vec_float4 *in, int n)
+{
+  vec_int4 out = spu_convts (in[0], n);
+}
+
+void f7 (vec_float4 *in, int n)
+{
+  vec_uint4 out = spu_convtu (in[0], n);
+}
Index: gcc/testsuite/gcc.target/mips/dsp-lhx.c
===================================================================
--- gcc/testsuite/gcc.target/mips/dsp-lhx.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/mips/dsp-lhx.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,10 @@
+/* Test MIPS32 DSP LHX instruction */
+/* { dg-do compile } */
+/* { dg-options "-mgp32 -mdsp -O2" } */
+
+/* { dg-final { scan-assembler "\tlhx\t" } } */
+
+NOMIPS16 signed short test (signed short *a, int index)
+{
+  return a[index];
+}
Index: gcc/testsuite/gcc.target/mips/dsp-no-lhx.c
===================================================================
--- gcc/testsuite/gcc.target/mips/dsp-no-lhx.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/mips/dsp-no-lhx.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,10 @@
+/* Test MIPS32 DSP LHX instruction */
+/* { dg-do compile } */
+/* { dg-options "-mgp32 -mdsp -O2" } */
+
+/* { dg-final { scan-assembler-not "\tlhx\t" } } */
+
+NOMIPS16 unsigned short test (unsigned short *a, int index)
+{
+  return a[index];
+}
Index: gcc/testsuite/gnat.dg/thin_pointer.adb
===================================================================
--- gcc/testsuite/gnat.dg/thin_pointer.adb	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/gnat.dg/thin_pointer.adb	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,11 +0,0 @@
--- { dg-do compile }
--- { dg-options "-O" }
-
-package body Thin_Pointer is
-
-   procedure Set_Buffer (AD : Buf_Ptr; Buffer : Stream_ptr) is
-   begin
-      AD.B.A := Buffer (Buffer'First)'Address;
-   end Set_Buffer;
-
-end Thin_Pointer;
Index: gcc/testsuite/gnat.dg/thin_pointer.ads
===================================================================
--- gcc/testsuite/gnat.dg/thin_pointer.ads	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/gnat.dg/thin_pointer.ads	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,22 +0,0 @@
-with System;
-
-package Thin_Pointer is
-
-   type Stream is array (Integer range <>) of Character;
-
-   type Stream_Ptr is access Stream;
-   for Stream_Ptr'Size use Standard'Address_Size;
-
-   type Buf is record
-      A : System.Address;
-   end record;
-
-   type Buf_Wrapper is record
-      B : Buf;
-   end record;
-
-   type Buf_Ptr is access Buf_Wrapper;
-
-   procedure Set_Buffer (AD : Buf_Ptr; Buffer : Stream_ptr);
-
-end Thin_Pointer;
Index: gcc/testsuite/gnat.dg/thin_pointer1.adb
===================================================================
--- gcc/testsuite/gnat.dg/thin_pointer1.adb	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gnat.dg/thin_pointer1.adb	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,11 @@
+-- { dg-do compile }
+-- { dg-options "-O" }
+
+package body Thin_Pointer1 is
+
+   procedure Set_Buffer (AD : Buf_Ptr; Buffer : Stream_ptr) is
+   begin
+      AD.B.A := Buffer (Buffer'First)'Address;
+   end Set_Buffer;
+
+end Thin_Pointer1;
Index: gcc/testsuite/gnat.dg/thin_pointer1.ads
===================================================================
--- gcc/testsuite/gnat.dg/thin_pointer1.ads	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gnat.dg/thin_pointer1.ads	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,22 @@
+with System;
+
+package Thin_Pointer1 is
+
+   type Stream is array (Integer range <>) of Character;
+
+   type Stream_Ptr is access Stream;
+   for Stream_Ptr'Size use Standard'Address_Size;
+
+   type Buf is record
+      A : System.Address;
+   end record;
+
+   type Buf_Wrapper is record
+      B : Buf;
+   end record;
+
+   type Buf_Ptr is access Buf_Wrapper;
+
+   procedure Set_Buffer (AD : Buf_Ptr; Buffer : Stream_ptr);
+
+end Thin_Pointer1;
Index: gcc/testsuite/gnat.dg/thin_pointer2_pkg.adb
===================================================================
--- gcc/testsuite/gnat.dg/thin_pointer2_pkg.adb	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gnat.dg/thin_pointer2_pkg.adb	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,18 @@
+package body Thin_Pointer2_Pkg is
+
+   type SB is access constant String;
+
+   function Inner (S : SB) return Character is
+   begin
+      if S /= null and then S'Length > 0 then
+         return S (S'First);
+      end if;
+      return '*';
+   end;
+
+   function F return Character is
+   begin
+      return Inner (SB (S));
+   end;
+
+end Thin_Pointer2_Pkg;
Index: gcc/testsuite/gnat.dg/thin_pointer2_pkg.ads
===================================================================
--- gcc/testsuite/gnat.dg/thin_pointer2_pkg.ads	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gnat.dg/thin_pointer2_pkg.ads	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,9 @@
+package Thin_Pointer2_Pkg is
+
+   type SA is access String;
+   for SA'Size use Standard'Address_Size;
+   S : SA;
+
+   function F return Character;
+
+end Thin_Pointer2_Pkg;
Index: gcc/testsuite/gnat.dg/thin_pointer2.adb
===================================================================
--- gcc/testsuite/gnat.dg/thin_pointer2.adb	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gnat.dg/thin_pointer2.adb	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,13 @@
+-- PR ada/42253
+-- Testcase by Duncan Sands <baldrick@gcc.gnu.org>
+
+-- { dg-do run }
+
+with Thin_Pointer2_Pkg; use Thin_Pointer2_Pkg;
+
+procedure Thin_Pointer2 is
+begin
+   if F /= '*' then
+      raise Program_Error;
+   end if;
+end;
Index: gcc/testsuite/ada/acats/run_all.sh
===================================================================
--- gcc/testsuite/ada/acats/run_all.sh	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/ada/acats/run_all.sh	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -129,6 +129,7 @@
 
 cp $testdir/tests/cd/*.c $dir/support
 cp $testdir/tests/cxb/*.c $dir/support
+grep -v '^#' $testdir/norun.lst | sort > $dir/support/norun.lst
 
 rm -rf $dir/run
 mv $dir/tests $dir/tests.$$ 2> /dev/null
@@ -206,7 +207,7 @@
 
    cd $dir/tests/$chapter
    ls *.a *.ada *.adt *.am *.dep 2> /dev/null | sed -e 's/\(.*\)\..*/\1/g' | \
-   cut -c1-7 | sort | uniq | comm -23 - $testdir/norun.lst \
+   cut -c1-7 | sort | uniq | comm -23 - $dir/support/norun.lst \
      > $dir/tests/$chapter/${chapter}.lst 
    countn=`wc -l < $dir/tests/$chapter/${chapter}.lst`
    glob_countn=`expr $glob_countn + $countn`
Index: gcc/testsuite/gcc.dg/Wunreachable-2.c
===================================================================
--- gcc/testsuite/gcc.dg/Wunreachable-2.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/gcc.dg/Wunreachable-2.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,19 +0,0 @@
-/* { dg-do compile } */
-/* { dg-options "-O2 -Wunreachable-code" } */
-
-extern int foo (const char *);
-extern void baz (void);
-const char *a[] = { "one", "two" };
-
-void bar (void)
-{
-  int i;
-
-  for (i = 0; i < 2; i++)
-    if (! foo (a[i]))
-      return;
-
-  baz ();	/* { dg-bogus "will never be executed" } */
-  baz ();
-  baz ();
-}
Index: gcc/testsuite/gcc.dg/inline-33.c
===================================================================
--- gcc/testsuite/gcc.dg/inline-33.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/gcc.dg/inline-33.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,6 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-O3 -fdump-tree-optimized"  } */
-/* { dg-options "-O3 -fdump-tree-optimized -fpie" { target { ! nonpic } } } */
+/* { dg-add-options bind_pic_locally } */
 
 int i;
 
Index: gcc/testsuite/gcc.dg/errno-1.c
===================================================================
--- gcc/testsuite/gcc.dg/errno-1.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/errno-1.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,17 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+#include <errno.h>
+#include <stdlib.h>
+
+int main()
+{
+  void *p;
+  errno = 0;
+  p = malloc (-1);
+  if (errno != 0)
+    do_not_optimize_away ();
+  return 0;
+}
+
+/* { dg-final { scan-assembler "do_not_optimize_away" } } */
Index: gcc/testsuite/gcc.dg/pr41643.c
===================================================================
--- gcc/testsuite/gcc.dg/pr41643.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/pr41643.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,15 @@
+/* PR tree-optimization/41643 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -fno-tree-dce" } */
+
+struct S { int a; };
+
+int
+f (struct S *x)
+{
+  int a = x->a;
+  if (a)
+    return f (x) + a;
+  else
+    return f (x);
+}
Index: gcc/testsuite/gcc.dg/pr42078.c
===================================================================
--- gcc/testsuite/gcc.dg/pr42078.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/pr42078.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,22 @@
+/* PR tree-optimization/42078 */
+/* { dg-do compile } */
+/* { dg-options "-g -O -ffast-math" } */
+
+double sqrt (double x);
+
+float
+foo (float x)
+{
+  float y = sqrt (x);
+  return x / y;
+}
+
+inline float
+bar (float x)
+{
+  float y = sqrt (x);
+  float a = y;
+  float b = y;
+  float c = y;
+  return x / y;
+}
Index: gcc/testsuite/gcc.dg/pr41841.c
===================================================================
--- gcc/testsuite/gcc.dg/pr41841.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/pr41841.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,22 @@
+/* PR tree-optimization/41841 */
+/* { dg-do compile } */
+/* { dg-options "-O -fipa-struct-reorg -fwhole-program -fipa-cp" } */
+
+typedef struct S *T;
+typedef struct { } *U;
+extern int f1 (void);
+
+static void
+f3 (U x, int y)
+{
+  T a = (T) x;
+  y && f1 ();
+}
+
+static void
+f2 (T x)
+{
+  f3 ((U) x, 1);
+}
+
+void *volatile a __attribute__((used)) = f2;
Index: gcc/testsuite/gcc.dg/pch/pushpop-1.hs
===================================================================
--- gcc/testsuite/gcc.dg/pch/pushpop-1.hs	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/pch/pushpop-1.hs	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,5 @@
+#define FOO 1
+#pragma push_macro ("FOO")
+#undef FOO
+#define FOO 2
+
Index: gcc/testsuite/gcc.dg/pch/pushpop-1.c
===================================================================
--- gcc/testsuite/gcc.dg/pch/pushpop-1.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/pch/pushpop-1.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,11 @@
+#include "pushpop-1.hs"
+
+#if FOO != 2
+#error FOO != 2
+#endif
+#pragma pop_macro("FOO")
+
+#if FOO != 1
+#error FOR != 1
+#endif
+

Zmiany atrybutów dla: gcc/testsuite/gcc.dg/pch/pushpop-1.c
___________________________________________________________________
Dodane: svn:mime-type
   + text/plain
Dodane: svn:eol-style
   + native

Index: gcc/testsuite/gcc.dg/pr41574.c
===================================================================
--- gcc/testsuite/gcc.dg/pr41574.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/pr41574.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -march=armv7-a -mfloat-abi=softfp -mfpu=neon -fno-unsafe-math-optimizations -fdump-rtl-combine" { target { arm*-*-* } } } */
+/* { dg-options "-O2 -fno-unsafe-math-optimizations -fdump-rtl-combine" { target { ! arm*-*-* } } } */
+
+
+static const double one=1.0;
+
+double
+f(double x)
+{
+  return x*(one+x);
+}
+
+/* { dg-final { scan-rtl-dump-not "\\(plus:DF \\(mult:DF" "combine" } } */
+/* { dg-final { cleanup-rtl-dump "combine*" } } */
Index: gcc/testsuite/gcc.dg/dg.exp
===================================================================
--- gcc/testsuite/gcc.dg/dg.exp	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/gcc.dg/dg.exp	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -32,5 +32,9 @@
 dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.\[cSi\]]] \
 	"" $DEFAULT_CFLAGS
 
+# C/C++ common tests.
+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/*.\[cSi\]]] \
+	" -Wc++-compat " ""
+
 # All done.
 dg-finish
Index: gcc/testsuite/gcc.dg/vla-22.c
===================================================================
--- gcc/testsuite/gcc.dg/vla-22.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/vla-22.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,22 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+extern void bar (int *);
+
+static inline __attribute__((always_inline))
+int
+foo (int i)
+{
+  struct S {
+    int ar[1][i];
+  } s;
+
+  s.ar[0][0] = 0;
+  bar (&s.ar[0][0]);
+}
+
+void
+baz (int i)
+{
+  foo (i + 2);
+}
Index: gcc/testsuite/gcc.dg/pr42215.c
===================================================================
--- gcc/testsuite/gcc.dg/pr42215.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/pr42215.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -ftree-loop-distribution" } */
+
+extern int A[];
+extern int B[];
+
+void f(int i)
+{
+   while (i-- > 0) {
+     A[i] = 0;
+     B[i] = 0;
+   }
+}
Index: gcc/testsuite/gcc.dg/fold-div-3.c
===================================================================
--- gcc/testsuite/gcc.dg/fold-div-3.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/fold-div-3.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+/* { dg-options "-O -fdump-tree-original" } */
+
+unsigned int
+apply_frontend_param (unsigned int spi_bias)
+{
+  static const int ppm = 8000;
+  spi_bias /= 1000ULL + ppm/1000;
+  return spi_bias;
+}
+
+/* Make sure we perform the division in the narrower type.  */
+
+/* { dg-final { scan-tree-dump "spi_bias = spi_bias / 1008;" "original" } } */
+/* { dg-final { cleanup-tree-dump "original" } } */
Index: gcc/testsuite/gcc.dg/torture/pr42952.c
===================================================================
--- gcc/testsuite/gcc.dg/torture/pr42952.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/torture/pr42952.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,19 @@
+/* { dg-do run } */
+/* { dg-options "-fno-tree-ccp -fno-tree-fre" } */
+
+extern void abort (void);
+
+static int g[1];
+
+static int * const p = &g[0];
+static int * const q = &g[0];
+
+int main(void)
+{
+  g[0] = 1;
+  *p = 0;
+  *p = *q;
+  if (g[0] != 0)
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/torture/pr41555.c
===================================================================
--- gcc/testsuite/gcc.dg/torture/pr41555.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/torture/pr41555.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,119 @@
+/* { dg-do run } */
+/* { dg-options "-std=c99" } */
+
+#include <stdint.h>
+#include <limits.h>
+
+extern void abort (void);
+
+static uint64_t safe_div_func_uint64_t_u_u (uint64_t _ui1, uint64_t _ui2)
+{
+  if (_ui2==0) return _ui1;
+  return _ui1 / _ui2;
+}
+
+static int64_t safe_div_func_int64_t_s_s (int64_t _si1, int64_t _si2)
+{
+  if (_si2==0 || (_si1==INT64_MIN && _si2==-1)) return _si1;
+  return _si1 / _si2;
+}
+
+#define safe_add_macro_int8_t_s_s(si1,si2) \
+                ((((((int8_t)(si1))>((int8_t)0)) && (((int8_t)(si2))>((int8_t)0)) && (((int8_t)(si1)) > ((INT8_MAX)-((int8_t)(si2))))) \
+                  || ((((int8_t)(si1))<((int8_t)0)) && (((int8_t)(si2))<((int8_t)0)) && (((int8_t)(si1)) < ((INT8_MIN)-((int8_t)(si2)))))) \
+                 ? ((int8_t)(si1)) \
+                 : (((int8_t)(si1)) + ((int8_t)(si2))) \
+                 ) 
+
+static int8_t
+safe_add_func_int8_t_s_s(int8_t _si1, int8_t _si2)
+{
+  return safe_add_macro_int8_t_s_s(_si1,_si2);
+}
+
+#define safe_rshift_macro_uint64_t_u_s(left,right) \
+        (((((int)(right)) < ((uint64_t)0)) \
+                         || (((int)(right)) >= sizeof(uint64_t)*CHAR_BIT)) \
+                        ? ((uint64_t)(left)) \
+                        : (((uint64_t)(left)) >> ((int)(right))))
+
+static uint64_t
+safe_rshift_func_uint64_t_u_s(uint64_t _left, int _right)
+{
+  return safe_rshift_macro_uint64_t_u_s(_left,_right);
+}
+
+#define safe_mul_macro_int32_t_s_s(si1,si2) \
+  ((((((int32_t)(si1)) > ((int32_t)0)) && (((int32_t)(si2)) > ((int32_t)0)) && (((int32_t)(si1)) > ((INT32_MAX) / ((int32_t)(si2))))) || \
+  ((((int32_t)(si1)) > ((int32_t)0)) && (((int32_t)(si2)) <= ((int32_t)0)) && (((int32_t)(si2)) < ((INT32_MIN) / ((int32_t)(si1))))) || \
+  ((((int32_t)(si1)) <= ((int32_t)0)) && (((int32_t)(si2)) > ((int32_t)0)) && (((int32_t)(si1)) < ((INT32_MIN) / ((int32_t)(si2))))) || \
+  ((((int32_t)(si1)) <= ((int32_t)0)) && (((int32_t)(si2)) <= ((int32_t)0)) && (((int32_t)(si1)) != ((int32_t)0)) && (((int32_t)(si2)) < ((INT32_MAX) / ((int32_t)(si1)))))) \
+  ? ((int32_t)(si1)) \
+  : ((int32_t)(si1)) * ((int32_t)(si2)))
+
+static int32_t
+safe_mul_func_int32_t_s_s (int32_t _si1, int32_t _si2)
+{
+  return safe_mul_macro_int32_t_s_s(_si1,_si2);
+}
+
+static int8_t g_39;
+static volatile uint8_t g_46;
+static uint8_t g_47;
+static uint8_t *g_62;
+static uint8_t g_79;
+static int8_t g_101 = -1L;
+static uint8_t *g_114;
+static uint8_t *g_126;
+static uint8_t g_133;
+
+static uint16_t func_35 (int32_t * p_36, uint64_t p_37, uint32_t p_38);
+static uint16_t func_35 (int32_t * p_36, uint64_t p_37, uint32_t p_38)
+{
+  if (g_62 != 0)
+    abort ();
+  for (g_39 = 1; g_39 < 0; g_39 = 1)
+    {
+    }
+  return 1;
+}
+
+static int32_t func_19 (int32_t p_20);
+static int32_t func_19 (int32_t p_20)
+{
+  if (1 !=
+      safe_div_func_uint64_t_u_u ((safe_div_func_int64_t_s_s (p_20, 1)),
+                                  g_101))
+    {
+      func_35 (0, 1 <= (safe_add_func_int8_t_s_s (g_47, g_46)) > p_20 < 1, 1);
+      g_133 = 1;
+      if (g_114 != 0)
+	abort ();
+      if (g_126 != 0)
+	abort ();
+    }
+  return 1;
+}
+
+static uint8_t func_2 (int32_t p_6);
+static uint8_t func_2 (int32_t p_6)
+{
+  for (1; p_6 > 1; 1)
+    return 0;
+  func_19 (g_79);
+  if (safe_mul_func_int32_t_s_s
+      ((0, 1 < (safe_rshift_func_uint64_t_u_s (1 ^ p_6, 1))),
+       (func_35 (&p_6, 1, 1) < 1)))
+    {
+    }
+  return 1;
+}
+
+int main (void)
+{
+  func_2 (1);
+  if (g_133 != 1)
+    abort ();
+  return 0;
+}
+
Index: gcc/testsuite/gcc.dg/torture/pr42667.c
===================================================================
--- gcc/testsuite/gcc.dg/torture/pr42667.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/torture/pr42667.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-options "-w" } */
+
+extern int strlen(const char *);
+void WriteTextDots(int len);
+
+void OnDisplay(char * string)
+{
+  if (!string)
+    string = "(none)";
+  WriteTextDots(strlen(string));
+}
+
Index: gcc/testsuite/gcc.dg/torture/pr43002.c
===================================================================
--- gcc/testsuite/gcc.dg/torture/pr43002.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/torture/pr43002.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+/* { dg-options "-Wall -fwrapv" } */
+
+long A[4], B[100];
+
+void foo(void)
+{
+  int i, j, k = 3;
+  while (A[k] && k > 0) k--; /* k = {0, 1, 2, 3} */
+  for (i = 3 - k; i >= 0; i--) /* i = {0..3-k} */
+    for (j = 0; j <= k; j++) { /* line 8; j = {0..k} */
+	B[i + j] = 0; /* line 9; i + j = {0..3-k+k} = {0..3} */
+	for (j = 0; j <= k; j++); /* only one iteration is done, with j == 0 */
+    }
+}
+
Index: gcc/testsuite/gcc.dg/torture/pr42898-2.c
===================================================================
--- gcc/testsuite/gcc.dg/torture/pr42898-2.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/torture/pr42898-2.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,25 @@
+/* { dg-do compile } */
+/* { dg-options "-fdump-tree-optimized" } */
+
+struct hardware {
+  int parm1:8;
+  int :4;
+  int parm2:4;
+  int parm3:15;
+  int parm4:1;
+};
+
+const struct hardware h = {
+  .parm1=42,
+  .parm2=13,
+  .parm3=11850,
+  .parm4=1,
+};
+
+void f1(volatile struct hardware *ptr)
+{
+  *ptr = h;
+}
+
+/* { dg-final { scan-tree-dump-times "\\*ptr" 1 "optimized" } } */
+/* { dg-final { cleanup-tree-dump "optimized" } } */
Index: gcc/testsuite/gcc.dg/torture/pr42898.c
===================================================================
--- gcc/testsuite/gcc.dg/torture/pr42898.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/torture/pr42898.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,23 @@
+/* { dg-do compile } */
+/* { dg-options "-fdump-tree-optimized" } */
+
+struct hardware {
+  int parm1:8;
+  int :4;
+  int parm2:4;
+  int parm3:15;
+  int parm4:1;
+};
+
+void f1(volatile struct hardware *ptr)
+{
+  *ptr=(struct hardware) {
+    .parm1=42,
+    .parm2=13,
+    .parm3=11850,
+    .parm4=1,
+  };
+}
+
+/* { dg-final { scan-tree-dump-times "\\*ptr" 1 "optimized" } } */
+/* { dg-final { cleanup-tree-dump "optimized" } } */
Index: gcc/testsuite/gcc.dg/torture/pr42363.c
===================================================================
--- gcc/testsuite/gcc.dg/torture/pr42363.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/torture/pr42363.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,84 @@
+/* PR middle-end/pr42363, extended from the test for PR middle-end/37913.  */
+/* { dg-do compile } */
+/* { dg-options "-g" } */
+
+void foo (void) __attribute__ ((noreturn));
+
+static int __attribute__ ((noreturn))
+bar (void)
+{
+  foo ();
+}
+
+int
+baz (void)
+{
+  int i = bar ();
+  return i + 1;
+}
+
+int fooz (void) __attribute__ ((noreturn));
+
+static int __attribute__ ((noreturn))
+bart (void)
+{
+  return fooz (); /* { dg-warning "noreturn" } */
+}
+
+int bazr (void)
+{
+  int i = bart ();
+  return i + 1;
+}
+
+static inline int
+bard (void)
+{
+  return fooz ();
+}
+
+int bizr (void)
+{
+  int i, j;
+
+  i = j = bard ();
+
+  return i + 1;
+}
+
+/* This might be regarded as pure and folded, rather than inlined.
+   It's pure evil.  */
+static int __attribute__ ((pure, const, noreturn))
+barf (void)
+{
+} /* { dg-warning "does return" } */
+
+static int __attribute__ ((pure, const))
+bark (void)
+{
+  barf ();
+}
+
+int buzr (void)
+{
+  int i, j;
+
+  i = j = bark () + bark ();
+
+  return i + 1;
+}
+
+int buzt (void)
+{
+  int i, j;
+
+  i = j = barf () + barf ();
+
+  return i + 1;
+}
+
+void bust (void)
+{
+  while (barf ())
+    ;
+}
Index: gcc/testsuite/gcc.dg/torture/pr43000.c
===================================================================
--- gcc/testsuite/gcc.dg/torture/pr43000.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/torture/pr43000.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,24 @@
+/* { dg-do run } */
+/* { dg-options "-fwrapv" } */
+
+int __attribute__((noinline))
+foo (long i, long j)
+{
+  if (i >= 1)
+    if (j > -(long)(((unsigned long)(long)-1)>>1))
+      {
+        long x;
+	j--;
+	x = i + j;
+	if (x >= 0)
+	  return 1;
+      }
+  return 0;
+}
+extern void abort (void);
+int main()
+{
+  if (foo (1, 1) != 1)
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/tree-ssa/pr41497.c
===================================================================
--- gcc/testsuite/gcc.dg/tree-ssa/pr41497.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/tree-ssa/pr41497.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,27 @@
+/* { dg-do run } */
+/* { dg-options "-Os" } */
+
+extern void abort (void);
+
+unsigned int a;
+int b, c;
+
+void
+foo (void)
+{
+  b = 0;
+  do {
+    for (a = -13; a == 0; a = (unsigned short)a)
+      c = 1;
+    b++;
+  } while (b == 0);
+}
+
+int
+main ()
+{
+  foo ();
+  if (a != -13)
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/tree-ssa/pr42585.c
===================================================================
--- gcc/testsuite/gcc.dg/tree-ssa/pr42585.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/tree-ssa/pr42585.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,37 @@
+/* { dg-do compile } */
+/* { dg-options "-O1 -fdump-tree-optimized" } */
+
+struct _fat_ptr
+{
+  unsigned char *curr;
+  unsigned char *base;
+  unsigned char *last_plus_one;
+};
+int Cyc_string_ungetc (int ignore, struct _fat_ptr *sptr);
+int
+Cyc_string_ungetc (int ignore, struct _fat_ptr *sptr)
+{
+  struct _fat_ptr *_T0;
+  struct _fat_ptr *_T1;
+  struct _fat_ptr _T2;
+  int _T3;
+  struct _fat_ptr _ans;
+  int _change;
+
+  {
+    _T0 = sptr;
+    _T1 = sptr;
+    _T2 = *sptr;
+    _T3 = -1;
+    _ans = _T2;
+    _change = -1;
+    _ans.curr += 4294967295U;
+    *sptr = _ans;
+    return (0);
+  }
+}
+
+/* The local aggregates . */
+/* { dg-final { scan-tree-dump-times "struct _fat_ptr _ans" 0 "optimized"} } */
+/* { dg-final { scan-tree-dump-times "struct _fat_ptr _T2" 0 "optimized"} } */
+/* { dg-final { cleanup-tree-dump "optimized" } } */
Index: gcc/testsuite/gcc.dg/tree-ssa/inline-4.c
===================================================================
--- gcc/testsuite/gcc.dg/tree-ssa/inline-4.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/tree-ssa/inline-4.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,27 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-einline2" } */
+/* { dg-add-options bind_pic_locally } */
+
+extern int rand(void);
+
+int get_data_for (int id)
+{
+  return rand();
+}
+
+int my_id;
+
+int main()
+{
+  int res = get_data_for (my_id);
+  switch (res)
+    {
+      case 0:
+	  return 666;
+      default:
+	  return -1;
+    }
+}
+
+/* { dg-final { scan-tree-dump "Inlining get_data_for into main" "einline2" } } */
+/* { dg-final { cleanup-tree-dump "einline2" } } */
Index: gcc/testsuite/gcc.dg/pr42611.c
===================================================================
--- gcc/testsuite/gcc.dg/pr42611.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/pr42611.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,19 @@
+/* PR other/42611 */
+/* { dg-do compile } */
+/* { dg-options "" } */
+
+#define L \
+  (sizeof (__SIZE_TYPE__) == 1 ? __SCHAR_MAX__				\
+  : sizeof (__SIZE_TYPE__) == sizeof (short) ? __SHRT_MAX__		\
+  : sizeof (__SIZE_TYPE__) == sizeof (int) ? __INT_MAX__		\
+  : sizeof (__SIZE_TYPE__) == sizeof (long) ? __LONG_MAX__		\
+  : sizeof (__SIZE_TYPE__) == sizeof (long long) ? __LONG_LONG_MAX__	\
+  : __INTMAX_MAX__)
+struct S { int a; char b[L]; };
+
+void
+foo (void)
+{
+  struct S s;				/* { dg-error "is too large" } */
+  asm volatile ("" : : "r" (&s));
+}
Index: gcc/testsuite/gcc.dg/tls/opt-15.c
===================================================================
--- gcc/testsuite/gcc.dg/tls/opt-15.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/tls/opt-15.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,24 @@
+/* PR target/42564 */
+/* This used to ICE on the SPARC because of an unrecognized TLS pattern.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O -fPIC" } */
+/* { dg-require-effective-target tls_native } */
+/* { dg-require-effective-target fpic } */
+
+extern void *memset(void *s, int c, __SIZE_TYPE__ n);
+
+struct S1 { int i; };
+
+struct S2
+{
+  int ver;
+  struct S1 s;
+};
+
+static __thread struct S2 m;
+
+void init(void)
+{
+  memset(&m.s, 0, sizeof(m.s));
+}
Index: gcc/testsuite/gcc.dg/compound-literal-1.c
===================================================================
--- gcc/testsuite/gcc.dg/compound-literal-1.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/compound-literal-1.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+
+/* PR c/43248 */
+
+int foo(__SIZE_TYPE__ i)
+{
+  i ? : (void *){}; /* { dg-error "" } */
+}
+
Index: gcc/testsuite/gcc.dg/cpp/pragma-pop_macro-1.c
===================================================================
--- gcc/testsuite/gcc.dg/cpp/pragma-pop_macro-1.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/gcc.dg/cpp/pragma-pop_macro-1.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,7 +1,7 @@
 /* PR preprocessor/35061 */
 /* Do nothing if there is nothing on the macro stack to pop.  */
 
-/* { dg-do preprocess { target *-*-mingw* *-*-cygwin* } } */
+/* { dg-do preprocess } */
 
 #define X  1
 /* # pragma push_macro("X") */
Index: gcc/testsuite/gcc.dg/pr42084.c
===================================================================
--- gcc/testsuite/gcc.dg/pr42084.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/pr42084.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,22 @@
+/* { dg-do run } */
+/* { dg-options "-O1 -fno-delete-null-pointer-checks" } */
+extern void abort (void);
+int g = 0;
+static int __attribute__((noinline)) f (long long a, long long b)
+{
+  int cmp;
+  cmp = a > b;
+  if (&g == 0)
+    cmp-=2;
+  else
+    cmp++;
+  return cmp;
+}
+
+int main (void)
+{
+  int ret = f (2, 1);
+  if (ret != 2)
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/debug/pr42244.c
===================================================================
--- gcc/testsuite/gcc.dg/debug/pr42244.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/debug/pr42244.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,13 @@
+/* PR debug/42444 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -g -fmodulo-sched -ffloat-store" } */
+
+extern int a, b;
+
+double
+foo (double x)
+{
+  for (; a > b; a--)
+    x *= (double) a;
+  return x;
+}
Index: gcc/testsuite/gcc.dg/debug/pr41717.c
===================================================================
--- gcc/testsuite/gcc.dg/debug/pr41717.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/debug/pr41717.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,10 @@
+/* PR debug/41717 */
+/* { dg-do compile } */
+
+void
+foo (void)
+{
+  _Complex float v[1], w;
+  v[1] = 0.0f + 0.8fi;
+  w = __builtin_conjf (v[1] * v[1]);
+}
Index: gcc/testsuite/gcc.dg/Wstrict-aliasing-bogus-vla-1.c
===================================================================
--- gcc/testsuite/gcc.dg/Wstrict-aliasing-bogus-vla-1.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/Wstrict-aliasing-bogus-vla-1.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,10 @@
+/* PR 41673: bogus -Wstrict-aliasing warning from VLA dereference.  */
+/* { dg-do compile } */
+/* { dg-options "-std=gnu99 -O2 -Wall" } */
+
+int main(int argc, char *argv[])
+{
+    float x[argc];
+    float y[argc];
+    return 0 == __builtin_memcpy(y, x, argc * sizeof(*x));
+}
Index: gcc/testsuite/gcc.dg/pr42715.c
===================================================================
--- gcc/testsuite/gcc.dg/pr42715.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/pr42715.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,59 @@
+/* { dg-do compile { target fpic } } */
+/* { dg-options "-fPIC -g -O2 -w" } */
+/* var-tracking failed to clobber the reg holding v at the asm insn,
+   so v ended up bound to an intermediate PIC expression.  */
+
+struct A { unsigned a1; char a2[15]; };
+struct B { long b1; unsigned char b2; long b3; };
+struct C { void *c1; unsigned c2; unsigned c3; };
+
+static struct A v1;
+struct A *const v2 = &v1;
+
+static inline
+int foo (void)
+{
+  int *v;
+  __asm__ __volatile__ ("" : "=r" (v));
+  return v[1];
+}
+
+static void
+bar (struct C *x)
+{
+  if (x->c2 == x->c3 && x->c1)
+    f1 (foo (), x->c1, x->c3 * sizeof (x->c1[0]));
+}
+
+void
+baz (struct B *y)
+{
+  int i;
+  const char *j;
+  char *k;
+  char x[64];
+  for (i = 0; i < sizeof (struct B); i++, y)
+    {
+      switch (y->b2)
+        {
+        case 0x20:
+          if (__builtin_strchr (j, '='))
+            continue;
+        }
+      switch (y->b2)
+        {
+        case 0x80:
+          bar (&x);
+          f2 (y->b3);
+        case 0x2e:
+        case 0x4e:
+          break;
+        default:
+          if (v2->a1)
+            f2 (y->b2);
+        }
+      k[0] = '\0';
+      if (v2->a1)
+        f2 (y->b1);
+    }
+}
Index: gcc/testsuite/gcc.dg/pr41573.c
===================================================================
--- gcc/testsuite/gcc.dg/pr41573.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/pr41573.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+__inline __attribute__ ((__always_inline__)) char *
+strcpy (char *__dest, __const char *__src)
+{
+  return __builtin___strcpy_chk (__dest, __src, __builtin_object_size (__dest, 2 > 1));
+}
+
+const char* get_attr(unsigned attr)
+{
+    static char tmp[256];
+
+    strcpy(tmp, "");
+    return tmp;
+}
Index: gcc/testsuite/gcc.dg/ipa/ipacost-2.c
===================================================================
--- gcc/testsuite/gcc.dg/ipa/ipacost-2.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/gcc.dg/ipa/ipacost-2.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,6 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-O3 -fipa-cp -fipa-cp-clone -fdump-ipa-cp -fno-early-inlining -fdump-tree-optimized"  } */
-/* { dg-options "-O3 -fipa-cp -fipa-cp-clone -fdump-ipa-cp -fno-early-inlining -fdump-tree-optimized -fpie" { target { ! nonpic } } } */
+/* { dg-add-options bind_pic_locally } */
 
 int array[100];
 
Index: gcc/testsuite/gcc.dg/ipa/ipa-1.c
===================================================================
--- gcc/testsuite/gcc.dg/ipa/ipa-1.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/gcc.dg/ipa/ipa-1.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,6 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-O3 -fipa-cp -fipa-cp-clone -fdump-ipa-cp -fno-early-inlining"  } */
-/* { dg-skip-if "PR 25442" { "*-*-*" } { "-fpic" "-fPIC" } { "" } } */
+/* { dg-add-options bind_pic_locally } */
 
 #include <stdio.h>
 int g (int b, int c)
Index: gcc/testsuite/gcc.dg/ipa/ipa-2.c
===================================================================
--- gcc/testsuite/gcc.dg/ipa/ipa-2.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/gcc.dg/ipa/ipa-2.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,6 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-O3 -fipa-cp -fipa-cp-clone -fdump-ipa-cp -fno-early-inlining"  } */
-/* { dg-skip-if "PR 25442" { "*-*-*" } { "-fpic" "-fPIC" } { "" } } */
+/* { dg-add-options bind_pic_locally } */
 
 #include <stdio.h>
 int g (int b, int c)
Index: gcc/testsuite/gcc.dg/ipa/ipa-3.c
===================================================================
--- gcc/testsuite/gcc.dg/ipa/ipa-3.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/gcc.dg/ipa/ipa-3.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,6 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-O3 -fipa-cp -fipa-cp-clone -fdump-ipa-cp -fno-early-inlining"  } */
-/* { dg-skip-if "PR 25442" { "*-*-*" } { "-fpic" "-fPIC" } { "" } } */
+/* { dg-add-options bind_pic_locally } */
 
 
 /* Double constants.  */
Index: gcc/testsuite/gcc.dg/ipa/ipa-4.c
===================================================================
--- gcc/testsuite/gcc.dg/ipa/ipa-4.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/gcc.dg/ipa/ipa-4.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,6 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-O3 -fipa-cp -fipa-cp-clone -fdump-ipa-cp"  } */
-/* { dg-skip-if "PR 25442" { "*-*-*" } { "-fpic" "-fPIC" } { "" } } */
+/* { dg-add-options bind_pic_locally } */
 
 #include <stdio.h>
 int g (int b, int c)
Index: gcc/testsuite/gcc.dg/ipa/ipa-5.c
===================================================================
--- gcc/testsuite/gcc.dg/ipa/ipa-5.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/gcc.dg/ipa/ipa-5.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,6 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-O3 -fipa-cp -fipa-cp-clone -fdump-ipa-cp -fno-early-inlining"  } */
-/* { dg-skip-if "PR 25442" { "*-*-*" } { "-fpic" "-fPIC" } { "" } } */
+/* { dg-add-options bind_pic_locally } */
 
 /* Float & short constants.  */
 
Index: gcc/testsuite/gcc.dg/ipa/ipa-7.c
===================================================================
--- gcc/testsuite/gcc.dg/ipa/ipa-7.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/gcc.dg/ipa/ipa-7.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,6 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-O3 -fipa-cp -fipa-cp-clone -fdump-ipa-cp -fno-early-inlining"  } */
-/* { dg-skip-if "PR 25442" { "*-*-*" } { "-fpic" "-fPIC" } { "" } } */
+/* { dg-add-options bind_pic_locally } */
 
 #include <stdio.h>
 void send_addr (int *);
Index: gcc/testsuite/gcc.dg/pr41842.c
===================================================================
--- gcc/testsuite/gcc.dg/pr41842.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/pr41842.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,8 @@
+/* PR c/41842 */
+/* { dg-do compile } */
+
+void
+f ()
+{
+  char x[g (h)];	/* { dg-error "undeclared|for each function" } */
+}
Index: gcc/testsuite/gcc.dg/pr41762.c
===================================================================
--- gcc/testsuite/gcc.dg/pr41762.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/pr41762.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,31 @@
+/* PR target/41762 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -ftracer -fsched2-use-superblocks" } */
+/* { dg-options "-O2 -ftracer -fsched2-use-superblocks -fpic" { target fpic } } */
+
+extern __SIZE_TYPE__ strlen (const char *);
+extern int f1 (void *);
+extern char *f2 (void);
+extern void f3 (int, int);
+static char *a;
+char *b, *c, *d, *e;
+
+void
+foo (void)
+{
+  int f, g, h;
+  f = (a ? strlen (a) : strlen ("abcde"));
+  f += (b ? strlen (b) : 0);
+  f += (c ? strlen (c) : 0);
+  f += (d ? strlen (d) : 0);
+  f += (e ? strlen (e) : 0);
+  h = f1 (strlen);
+  g = strlen (a);
+  f3 (g, f);
+}
+
+void
+bar (void)
+{
+  a = f2 ();
+}
Index: gcc/testsuite/gcc.dg/bitfld-19.c
===================================================================
--- gcc/testsuite/gcc.dg/bitfld-19.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/bitfld-19.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,11 @@
+/* Test for bit-field widths not integer constant expressions but
+   folding to integer constants: PR 42439.  */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+void
+f (void)
+{
+  const int m = 1;
+  ((void)(sizeof(struct { int i:!!m; })));
+}
Index: gcc/testsuite/gcc.dg/pr42662.c
===================================================================
--- gcc/testsuite/gcc.dg/pr42662.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/pr42662.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,48 @@
+/* PR debug/42662 */
+/* { dg-do compile } */
+/* { dg-options "-g -O2" } */
+
+struct S { unsigned long s[17]; };
+
+static inline void
+foo (struct S *r, struct S *a, unsigned n)
+{
+  unsigned b = n / 8;
+  r->s[0] = (b >= 1 ? : a->s[1 - b]);
+}
+
+static inline void
+bar (struct S *r, struct S *a)
+{
+  r->s[0] = a->s[0] << 1;
+}
+
+static inline void
+baz (struct S *r, struct S *a, struct S *b)
+{
+  unsigned c = 0;
+  int i;
+  for (i = 0; i < 3; ++i)
+    {
+      unsigned long d = a->s[i];
+      long e = d + b->s[i];
+      if (c)
+	++e == 0;
+      c = e < d;
+      r->s[i] = e;
+    }
+}
+
+void
+test (struct S *r, int s, int d)
+{
+  struct S u;
+  if (s)
+    {
+      bar (&u, r);
+      foo (r, r, 3);
+      baz (r, r, &u);
+    }
+  u.s[0] = d;
+  baz (r, r, &u);
+}
Index: gcc/testsuite/gcc.dg/pr42475.c
===================================================================
--- gcc/testsuite/gcc.dg/pr42475.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/pr42475.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,28 @@
+/* PR rtl-optimization/42475 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+typedef struct { float x, y; } B;
+typedef struct { float z; } C;
+typedef struct { B b; C c; } D;
+
+B
+foo (float x, float y)
+{
+  B b = { .x = x, .y = y };
+  return b;
+}
+
+B
+bar (B b, B y)
+{
+  return foo (y.x + b.x, b.y);
+}
+
+B
+baz (D p)
+{
+  D d = { };
+  B y = bar (foo (0, (p.c.z) / 2), d.b);
+  return y;
+}
Index: gcc/testsuite/gcc.dg/pr41935.c
===================================================================
--- gcc/testsuite/gcc.dg/pr41935.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/pr41935.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,25 @@
+/* PR middle-end/41935 */
+/* { dg-do run } */
+/* { dg-options "-O2" } */
+
+extern void abort (void);
+struct A { int a; int b[10]; };
+
+int
+foo (struct A *p)
+{
+  return __builtin_offsetof (struct A, b[p->a]);
+}
+
+int
+main ()
+{
+  struct A a;
+  a.a = 7;
+  if (foo (&a) != 7 * sizeof (int) + __builtin_offsetof (struct A, b))
+    abort ();
+  a.a = 2;
+  if (foo (&a) != 2 * sizeof (int) + __builtin_offsetof (struct A, b))
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/pr40946.c
===================================================================
--- gcc/testsuite/gcc.dg/pr40946.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/pr40946.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,33 @@
+/* PR middle-end/40946 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -Wall" } */
+
+struct A
+{
+  unsigned char a1[8];
+  unsigned short a2, a3, a4, a5, a6, a7;
+};
+
+int bar (void *, const char *, int);
+char *foo (void *, int);
+
+char *
+baz (const char *x, const char *y)
+{
+  int a = sizeof (struct A) + 2 * (__builtin_strlen (y)
+				   + __builtin_strlen (x) + 24) + 16;
+  struct A *b = __builtin_malloc (a);
+  char *c;
+  int d;
+
+  b->a4 = sizeof (struct A);
+  c = ((char *) b) + b->a4;
+  d = ((char *) b) + a - c;
+  b->a2 = b->a3 = (unsigned short) bar (c, y, d); /* { dg-bogus "array subscript is above array bounds" } */
+  c += b->a2;
+  d = ((char *) b) + a - c;
+  b->a7 = b->a4 + b->a2;
+  b->a5 = b->a6 = (unsigned short) bar (c, x, d);
+  c = foo (b, a);
+  return c;
+}
Index: gcc/testsuite/gcc.dg/pr42388.c
===================================================================
--- gcc/testsuite/gcc.dg/pr42388.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/pr42388.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,67 @@
+/* { dg-do compile { target powerpc*-*-* ia64-*-* x86_64-*-* } } */
+/* { dg-options "-O2 -fselective-scheduling -fmodulo-sched" } */
+
+enum rtx_code
+{
+  INSN, ADDR_VEC, ADDR_DIFF_VEC, CALL_INSN, CODE_LABEL, BARRIER, NOTE
+};
+typedef union rtunion_def
+{
+  int rtint;
+  char *rtstr;
+  struct rtx_def *rtx;
+  struct rtvec_def *rtvec;
+}
+rtunion;
+typedef struct rtx_def
+{
+  unsigned short code;
+  rtunion fld[1];
+}
+ *rtx;
+typedef struct rtvec_def
+{
+  unsigned num_elem;
+  rtunion elem[1];
+}
+ *rtvec;
+extern rtx emit_barrier (void);
+extern rtx emit_note (char *);
+
+static void
+copy_loop_body (rtx *map)
+{
+  int i;
+  rtx insn, copy;
+  rtx pat = copy->fld[3].rtx;
+
+  switch (insn->code)
+    {
+    case INSN:
+      if (insn->fld[7].rtx)
+	{
+	}
+      else if (pat->code == ADDR_VEC || pat->code == ADDR_DIFF_VEC)
+	{
+	  int diff_vec_p = pat->code == ADDR_DIFF_VEC;
+	  int len = pat->fld[diff_vec_p].rtvec->num_elem;
+	  for (i = 0; i < len; i++)
+	    pat->fld[diff_vec_p].rtvec->elem[i].rtx->fld[5].rtint++;
+	}
+    case CALL_INSN:
+      for (i = 0; i < 64; i++)
+	map[i] = 0;
+    case CODE_LABEL:
+    case BARRIER:
+      copy = emit_barrier ();
+    case NOTE:
+      copy = emit_note ("x");
+    }
+}
+void
+unroll_loop (int insn_count, rtx *map)
+{
+  if (insn_count > 50)
+    copy_loop_body (map);
+}
+
Index: gcc/testsuite/gcc.dg/O16384.c
===================================================================
--- gcc/testsuite/gcc.dg/O16384.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/O16384.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,15 @@
+/* Test insane -O argument.  */
+/* { dg-do compile } */
+/* { dg-options "-O16384" } */
+
+__attribute__((__optimize__(16396), __noinline__)) void
+foo (void)
+{
+}
+
+int
+main (void)
+{
+  foo ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/dfp/dfp.exp
===================================================================
--- gcc/testsuite/gcc.dg/dfp/dfp.exp	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/gcc.dg/dfp/dfp.exp	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -46,10 +46,14 @@
 # Initialize `dg'.
 dg-init
 
-# Main loop.
+# Main loop; run the C-only tests.
 dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.\[cS\]]] \
         "" $DEFAULT_CFLAGS
 
+# Run the tests that are shared with C++ testing.
+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/dfp/*c]] \
+        "" $DEFAULT_CFLAGS
+
 # All done.
 dg-finish
 
Index: gcc/testsuite/gcc.dg/pr42250.c
===================================================================
--- gcc/testsuite/gcc.dg/pr42250.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/pr42250.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,68 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fipa-type-escape" } */
+
+extern double log10 (double __x);
+extern double ceil (double __x);
+extern double floor (double __x);
+extern void free (void *__ptr);
+extern void *my_malloc (unsigned int);
+extern int num_rr_nodes;
+static float get_cblock_trans (int *num_inputs_to_cblock,
+			       int max_inputs_to_cblock,
+			       float trans_cblock_to_lblock_buf,
+			       float trans_sram_bit);
+static float trans_per_mux (int num_inputs, float trans_sram_bit);
+void
+count_routing_transistors (int num_switch, float R_minW_nmos,
+			   float R_minW_pmos)
+{
+  int *num_inputs_to_cblock;
+  int iswitch, i, j, iseg, max_inputs_to_cblock;
+  float input_cblock_trans;
+  const float trans_sram_bit = 6.;
+  float trans_cblock_to_lblock_buf;
+  input_cblock_trans =
+    get_cblock_trans (num_inputs_to_cblock, max_inputs_to_cblock,
+		      trans_cblock_to_lblock_buf, trans_sram_bit);
+}
+
+static float
+get_cblock_trans (int *num_inputs_to_cblock, int max_inputs_to_cblock,
+		  float trans_cblock_to_lblock_buf, float trans_sram_bit)
+{
+  float *trans_per_cblock;
+  float trans_count;
+  int i, num_inputs;
+
+  trans_per_cblock =
+    (float *) my_malloc ((max_inputs_to_cblock + 1) * sizeof (float));
+  for (i = 1; i <= max_inputs_to_cblock; i++)
+    trans_per_cblock[i] =
+      trans_per_mux (i, trans_sram_bit) + trans_cblock_to_lblock_buf;
+  for (i = 0; i < num_rr_nodes; i++)
+    {
+      num_inputs = num_inputs_to_cblock[i];
+      trans_count += trans_per_cblock[num_inputs];
+    }
+  free (trans_per_cblock);
+  return (trans_count);
+}
+
+static float
+trans_per_mux (int num_inputs, float trans_sram_bit)
+{
+  int nlevels, ilevel, current_inps;
+  float ntrans = 0;
+
+  if (num_inputs <= 1)
+    return (0);
+  nlevels = ceil (log10 (num_inputs) / log10 (2.) - 0.00001);
+  current_inps = num_inputs;
+  for (ilevel = 1; ilevel <= nlevels; ilevel++)
+    {
+      ntrans += 2 * floor (current_inps / 2.);
+      current_inps = ceil (current_inps / 2.);
+    }
+  ntrans += trans_sram_bit * nlevels;
+  return (ntrans);
+}
Index: gcc/testsuite/gcc.dg/noncompile/pr40033-1.c
===================================================================
--- gcc/testsuite/gcc.dg/noncompile/pr40033-1.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/noncompile/pr40033-1.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,7 @@
+/* ICE from error_mark_node being wrapped in a C_MAYBE_CONST_EXPR.  PR
+   40033.  */
+
+void foo()
+{
+  ({ 0,; }); /* { dg-error "expected" } */
+}
Index: gcc/testsuite/gcc.dg/cleanup-13.c
===================================================================
--- gcc/testsuite/gcc.dg/cleanup-13.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/cleanup-13.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,332 @@
+/* HP-UX libunwind.so doesn't provide _UA_END_OF_STACK */
+/* { dg-do run } */
+/* { dg-options "-fexceptions" } */
+/* { dg-skip-if "" { "ia64-*-hpux11.*" }  { "*" } { "" } } */
+/* Verify DW_OP_* handling in the unwinder.  */
+
+#include <unwind.h>
+#include <stdlib.h>
+#include <string.h>
+
+/* #define OP_addr(x) 0x06, ... */
+#define OP_deref 0x06,
+#define SLEB128(x) (x)&0x7f	/* Assume here the value is -0x40 ... 0x3f.  */
+#define ULEB128(x) (x)&0x7f	/* Assume here the value is 0 ... 0x7f.  */
+#define VAL1(x) (x)&0xff
+#if defined (__BIG_ENDIAN__)
+#define VAL2(x) ((x)>>8)&0xff,(x)&0xff
+#define VAL4(x) ((x)>>24)&0xff,((x)>>16)&0xff,((x)>>8)&0xff,(x)&0xff
+#define VAL8(x) ((x)>>56)&0xff,((x)>>48)&0xff,((x)>>40)&0xff,((x)>>32)&0xff,((x)>>24)&0xff,((x)>>16)&0xff,((x)>>8)&0xff,(x)&0xff
+#elif defined(__LITTLE_ENDIAN__) || defined(__x86_64__) || defined(__i386__)
+#define VAL2(x) (x)&0xff,((x)>>8)&0xff
+#define VAL4(x) (x)&0xff,((x)>>8)&0xff,((x)>>16)&0xff,((x)>>24)&0xff
+#define VAL8(x) (x)&0xff,((x)>>8)&0xff,((x)>>16)&0xff,((x)>>24)&0xff,((x)>>32)&0xff,((x)>>40)&0xff,((x)>>48)&0xff,((x)>>56)&0xff
+#endif
+#define OP_const1u(x) 0x08,VAL1(x),
+#define OP_const1s(x) 0x09,VAL1(x),
+#define OP_const2u(x) 0x0a,VAL2(x),
+#define OP_const2s(x) 0x0b,VAL2(x),
+#define OP_const4u(x) 0x0c,VAL4(x),
+#define OP_const4s(x) 0x0d,VAL4(x),
+#define OP_const8u(x) 0x0e,VAL8(x),
+#define OP_const8s(x) 0x0f,VAL8(x),
+#define OP_constu(x) 0x10,ULEB128(x),
+#define OP_consts(x) 0x11,SLEB128(x),
+#define OP_dup 0x12,
+#define OP_drop 0x13,
+#define OP_over 0x14,
+#define OP_pick(x) 0x15,VAL1(x),
+#define OP_swap 0x16,
+#define OP_rot 0x17,
+#define OP_xderef 0x18,
+#define OP_abs 0x19,
+#define OP_and 0x1a,
+#define OP_div 0x1b,
+#define OP_minus 0x1c,
+#define OP_mod 0x1d,
+#define OP_mul 0x1e,
+#define OP_neg 0x1f,
+#define OP_not 0x20,
+#define OP_or 0x21,
+#define OP_plus 0x22,
+#define OP_plus_uconst(x) 0x23,ULEB128(x),
+#define OP_shl 0x24,
+#define OP_shr 0x25,
+#define OP_shra 0x26,
+#define OP_xor 0x27,
+#define OP_bra(x) 0x28,VAL2(x),
+#define OP_eq 0x29,
+#define OP_ge 0x2a,
+#define OP_gt 0x2b,
+#define OP_le 0x2c,
+#define OP_lt 0x2d,
+#define OP_ne 0x2e,
+#define OP_skip(x) 0x2f,VAL2(x),
+#define OP_lit0 0x30,
+#define OP_lit1 0x31,
+#define OP_lit2 0x32,
+#define OP_lit3 0x33,
+#define OP_lit4 0x34,
+#define OP_lit5 0x35,
+#define OP_lit6 0x36,
+#define OP_lit7 0x37,
+#define OP_lit8 0x38,
+#define OP_lit9 0x39,
+#define OP_lit10 0x3a,
+#define OP_lit11 0x3b,
+#define OP_lit12 0x3c,
+#define OP_lit13 0x3d,
+#define OP_lit14 0x3e,
+#define OP_lit15 0x3f,
+#define OP_lit16 0x40,
+#define OP_lit17 0x41,
+#define OP_lit18 0x42,
+#define OP_lit19 0x43,
+#define OP_lit20 0x44,
+#define OP_lit21 0x45,
+#define OP_lit22 0x46,
+#define OP_lit23 0x47,
+#define OP_lit24 0x48,
+#define OP_lit25 0x49,
+#define OP_lit26 0x4a,
+#define OP_lit27 0x4b,
+#define OP_lit28 0x4c,
+#define OP_lit29 0x4d,
+#define OP_lit30 0x4e,
+#define OP_lit31 0x4f,
+#define OP_reg0 0x50,
+#define OP_reg1 0x51,
+#define OP_reg2 0x52,
+#define OP_reg3 0x53,
+#define OP_reg4 0x54,
+#define OP_reg5 0x55,
+#define OP_reg6 0x56,
+#define OP_reg7 0x57,
+#define OP_reg8 0x58,
+#define OP_reg9 0x59,
+#define OP_reg10 0x5a,
+#define OP_reg11 0x5b,
+#define OP_reg12 0x5c,
+#define OP_reg13 0x5d,
+#define OP_reg14 0x5e,
+#define OP_reg15 0x5f,
+#define OP_reg16 0x60,
+#define OP_reg17 0x61,
+#define OP_reg18 0x62,
+#define OP_reg19 0x63,
+#define OP_reg20 0x64,
+#define OP_reg21 0x65,
+#define OP_reg22 0x66,
+#define OP_reg23 0x67,
+#define OP_reg24 0x68,
+#define OP_reg25 0x69,
+#define OP_reg26 0x6a,
+#define OP_reg27 0x6b,
+#define OP_reg28 0x6c,
+#define OP_reg29 0x6d,
+#define OP_reg30 0x6e,
+#define OP_reg31 0x6f,
+#define OP_breg0(x) 0x70,SLEB128(x),
+#define OP_breg1(x) 0x71,SLEB128(x),
+#define OP_breg2(x) 0x72,SLEB128(x),
+#define OP_breg3(x) 0x73,SLEB128(x),
+#define OP_breg4(x) 0x74,SLEB128(x),
+#define OP_breg5(x) 0x75,SLEB128(x),
+#define OP_breg6(x) 0x76,SLEB128(x),
+#define OP_breg7(x) 0x77,SLEB128(x),
+#define OP_breg8(x) 0x78,SLEB128(x),
+#define OP_breg9(x) 0x79,SLEB128(x),
+#define OP_breg10(x) 0x7a,SLEB128(x),
+#define OP_breg11(x) 0x7b,SLEB128(x),
+#define OP_breg12(x) 0x7c,SLEB128(x),
+#define OP_breg13(x) 0x7d,SLEB128(x),
+#define OP_breg14(x) 0x7e,SLEB128(x),
+#define OP_breg15(x) 0x7f,SLEB128(x),
+#define OP_breg16(x) 0x80,SLEB128(x),
+#define OP_breg17(x) 0x81,SLEB128(x),
+#define OP_breg18(x) 0x82,SLEB128(x),
+#define OP_breg19(x) 0x83,SLEB128(x),
+#define OP_breg20(x) 0x84,SLEB128(x),
+#define OP_breg21(x) 0x85,SLEB128(x),
+#define OP_breg22(x) 0x86,SLEB128(x),
+#define OP_breg23(x) 0x87,SLEB128(x),
+#define OP_breg24(x) 0x88,SLEB128(x),
+#define OP_breg25(x) 0x89,SLEB128(x),
+#define OP_breg26(x) 0x8a,SLEB128(x),
+#define OP_breg27(x) 0x8b,SLEB128(x),
+#define OP_breg28(x) 0x8c,SLEB128(x),
+#define OP_breg29(x) 0x8d,SLEB128(x),
+#define OP_breg30(x) 0x8e,SLEB128(x),
+#define OP_breg31(x) 0x8f,SLEB128(x),
+#define OP_regx(x) 0x90,SLEB128(x),
+#define OP_fbreg(x) 0x91,SLEB128(x),
+#define OP_bregx(x,y) 0x92,ULEB128(x),SLEB128(y),
+#define OP_piece(x) 0x93,ULEB128(x),
+#define OP_deref_size(x) 0x94,VAL1(x),
+#define OP_xderef_size(x) 0x95,VAL1(x),
+#define OP_nop 0x96,
+#define OP_nop_termination 0x96
+#define OP_push_object_address 0x97,
+#define OP_call2(x) 0x98,VAL2(x),
+#define OP_call4(x) 0x99,VAL4(x),
+/* #define OP_call_ref(x) 0x9a,... */
+#define OP_form_tls_address(x) 0x9b,
+#define OP_call_frame_cfa 0x9c,
+#define OP_bit_piece(x) 0x9d,ULEB128(x),
+/* #define OP_implicit_value(x...) 0x9e,... */
+#define OP_stack_value 0x9f,
+#define OP_GNU_push_tls_address 0xe0,
+/* #define OP_GNU_encoded_addr(x...) 0xf1, */
+
+#define ASSERT_TOS_NON0 OP_bra(3) OP_skip(-3)
+#define ASSERT_TOS_0 OP_lit0 OP_eq ASSERT_TOS_NON0
+
+/* Initially there is CFA value on the stack, we want to
+   keep it there at the end.  */
+#define CFI_PROGRAM \
+OP_lit0 OP_nop ASSERT_TOS_0						\
+OP_lit1 ASSERT_TOS_NON0							\
+OP_lit1 OP_const1u(1) OP_eq ASSERT_TOS_NON0				\
+OP_lit16 OP_const2u(16) OP_eq ASSERT_TOS_NON0				\
+OP_lit31 OP_const4u(31) OP_ne ASSERT_TOS_0				\
+OP_lit1 OP_neg OP_const1s(-1) OP_eq ASSERT_TOS_NON0			\
+OP_lit16 OP_neg OP_const2s(-16) OP_ne ASSERT_TOS_0			\
+OP_lit31 OP_const4s(-31) OP_neg OP_ne ASSERT_TOS_0			\
+OP_lit7 OP_dup OP_plus_uconst(2) OP_lit9 OP_eq ASSERT_TOS_NON0		\
+  OP_lit7 OP_eq ASSERT_TOS_NON0						\
+OP_lit20 OP_lit1 OP_drop OP_lit20 OP_eq ASSERT_TOS_NON0			\
+OP_lit17 OP_lit19 OP_over OP_lit17 OP_eq ASSERT_TOS_NON0		\
+  OP_lit19 OP_eq ASSERT_TOS_NON0 OP_lit17 OP_eq ASSERT_TOS_NON0		\
+OP_lit1 OP_lit2 OP_lit3 OP_lit4 OP_pick(2) OP_lit2 OP_eq ASSERT_TOS_NON0\
+  OP_lit4 OP_eq ASSERT_TOS_NON0 OP_lit3 OP_eq ASSERT_TOS_NON0		\
+  OP_pick(0) OP_lit2 OP_eq ASSERT_TOS_NON0				\
+  OP_lit2 OP_eq ASSERT_TOS_NON0 OP_lit1 OP_eq ASSERT_TOS_NON0		\
+OP_lit6 OP_lit12 OP_swap OP_lit6 OP_eq ASSERT_TOS_NON0			\
+  OP_lit12 OP_eq ASSERT_TOS_NON0					\
+OP_lit7 OP_lit8 OP_lit9 OP_rot OP_lit8 OP_eq ASSERT_TOS_NON0		\
+  OP_lit7 OP_eq ASSERT_TOS_NON0 OP_lit9 OP_eq ASSERT_TOS_NON0		\
+OP_lit7 OP_abs OP_lit7 OP_eq ASSERT_TOS_NON0				\
+OP_const1s(-123) OP_abs OP_const1u(123) OP_eq ASSERT_TOS_NON0		\
+OP_lit3 OP_lit6 OP_and OP_lit2 OP_eq ASSERT_TOS_NON0			\
+OP_lit3 OP_lit6 OP_or OP_lit7 OP_eq ASSERT_TOS_NON0			\
+OP_lit17 OP_lit2 OP_minus OP_lit15 OP_eq ASSERT_TOS_NON0		\
+/* Divide is signed truncating toward zero.  */				\
+OP_const1s(-6) OP_const1s(-2) OP_div OP_lit3 OP_eq ASSERT_TOS_NON0	\
+OP_const1s(-7) OP_const1s(3) OP_div OP_const1s(-2)			\
+  OP_eq ASSERT_TOS_NON0							\
+/* Modulo is unsigned.  */						\
+OP_const1s(-6) OP_const1s(-4) OP_mod OP_const1s(-6)			\
+  OP_eq ASSERT_TOS_NON0							\
+OP_const1s(-6) OP_lit4 OP_mod OP_lit2 OP_eq ASSERT_TOS_NON0		\
+OP_lit6 OP_const1s(-4) OP_mod OP_lit6 OP_eq ASSERT_TOS_NON0		\
+/* Signed modulo can be implemented using "over over div mul minus".  */\
+OP_const1s(-6) OP_const1s(-4) OP_over OP_over OP_div OP_mul OP_minus	\
+  OP_const1s(-2) OP_eq ASSERT_TOS_NON0					\
+OP_const1s(-7) OP_lit3 OP_over OP_over OP_div OP_mul OP_minus		\
+  OP_const1s(-1) OP_eq ASSERT_TOS_NON0					\
+OP_lit7 OP_const1s(-3) OP_over OP_over OP_div OP_mul OP_minus		\
+  OP_lit1 OP_eq ASSERT_TOS_NON0						\
+OP_lit16 OP_lit31 OP_plus_uconst(1) OP_mul OP_const2u(512)		\
+  OP_eq ASSERT_TOS_NON0							\
+OP_lit5 OP_not OP_lit31 OP_and OP_lit26 OP_eq ASSERT_TOS_NON0		\
+OP_lit12 OP_lit31 OP_plus OP_const1u(43) OP_eq ASSERT_TOS_NON0		\
+OP_const1s(-6) OP_lit2 OP_plus OP_const1s(-4) OP_eq ASSERT_TOS_NON0	\
+OP_const1s(-6) OP_plus_uconst(3) OP_const1s(-3) OP_eq ASSERT_TOS_NON0	\
+OP_lit16 OP_lit4 OP_shl OP_const2u(256) OP_eq ASSERT_TOS_NON0		\
+OP_lit16 OP_lit3 OP_shr OP_lit2 OP_eq ASSERT_TOS_NON0			\
+OP_const1s(-16) OP_lit3 OP_shra OP_const1s(-2) OP_eq ASSERT_TOS_NON0	\
+OP_lit3 OP_lit6 OP_xor OP_lit5 OP_eq ASSERT_TOS_NON0			\
+OP_lit3 OP_lit6 OP_le ASSERT_TOS_NON0					\
+OP_lit3 OP_lit3 OP_le ASSERT_TOS_NON0					\
+OP_lit6 OP_lit3 OP_le ASSERT_TOS_0					\
+OP_lit3 OP_lit6 OP_lt ASSERT_TOS_NON0					\
+OP_lit3 OP_lit3 OP_lt ASSERT_TOS_0					\
+OP_lit6 OP_lit3 OP_lt ASSERT_TOS_0					\
+OP_lit3 OP_lit6 OP_ge ASSERT_TOS_0					\
+OP_lit3 OP_lit3 OP_ge ASSERT_TOS_NON0					\
+OP_lit6 OP_lit3 OP_ge ASSERT_TOS_NON0					\
+OP_lit3 OP_lit6 OP_gt ASSERT_TOS_0					\
+OP_lit3 OP_lit3 OP_gt ASSERT_TOS_0					\
+OP_lit6 OP_lit3 OP_gt ASSERT_TOS_NON0					\
+OP_const1s(-6) OP_lit1 OP_shr OP_lit0 OP_gt ASSERT_TOS_NON0		\
+OP_const1s(-6) OP_lit1 OP_shra OP_lit0 OP_lt ASSERT_TOS_NON0
+
+#define CFI_ESCAPE_VAL_2(VALUES...) #VALUES
+#define CFI_ESCAPE_VAL_1(VALUES...) CFI_ESCAPE_VAL_2(VALUES)
+#define CFI_ESCAPE_VAL(VALUES...) CFI_ESCAPE_VAL_1(VALUES)
+#define CFI_ESCAPE do { } while (0)
+#define CFI_ARCH_PROGRAM OP_nop_termination
+#ifdef __GCC_HAVE_DWARF2_CFI_ASM
+#if defined (__x86_64__)
+#undef CFI_ESCAPE
+#undef CFI_ARCH_PROGRAM
+#define CFI_ARCH_PROGRAM CFI_PROGRAM OP_lit8 OP_minus OP_nop_termination
+unsigned char cfi_arch_program[] = { CFI_ARCH_PROGRAM };
+extern char verify_it[sizeof (cfi_arch_program) - 0x80 < 0x3f80 ? 1 : -1];
+/* DW_CFA_expression %rip, uleb128(l2-l1), l1: program DW_OP_lit8 DW_OP_minus DW_OP_nop l2: */
+#define CFI_ESCAPE \
+  asm volatile (".cfi_escape 0x10, 0x10, (%P0&0x7f)+0x80, %P0>>7, " \
+		CFI_ESCAPE_VAL (CFI_ARCH_PROGRAM) \
+		: : "i" (sizeof (cfi_arch_program)))
+#elif defined (__i386__)
+#undef CFI_ESCAPE
+#undef CFI_ARCH_PROGRAM
+#define CFI_ARCH_PROGRAM CFI_PROGRAM OP_lit4 OP_minus OP_nop_termination
+unsigned char cfi_arch_program[] = { CFI_ARCH_PROGRAM };
+extern char verify_it[sizeof (cfi_arch_program) - 0x80 < 0x3f80 ? 1 : -1];
+/* DW_CFA_expression %eip, uleb128(l2-l1), l1: program DW_OP_lit4 DW_OP_minus DW_OP_nop l2: */
+#define CFI_ESCAPE \
+  asm volatile (".cfi_escape 0x10, 8, (%P0&0x7f)+0x80, %P0>>7, " \
+		CFI_ESCAPE_VAL (CFI_ARCH_PROGRAM) \
+		: : "i" (sizeof (cfi_arch_program)))
+#endif
+#endif
+static _Unwind_Reason_Code
+force_unwind_stop (int version, _Unwind_Action actions,
+		   _Unwind_Exception_Class exc_class,
+		   struct _Unwind_Exception *exc_obj,
+		   struct _Unwind_Context *context,
+		   void *stop_parameter)
+{
+  if (actions & _UA_END_OF_STACK)
+    abort ();
+  return _URC_NO_REASON;
+}
+
+static void force_unwind ()
+{
+  struct _Unwind_Exception *exc = malloc (sizeof (*exc));
+  memset (&exc->exception_class, 0, sizeof (exc->exception_class));
+  exc->exception_cleanup = 0;
+
+#ifndef __USING_SJLJ_EXCEPTIONS__
+  _Unwind_ForcedUnwind (exc, force_unwind_stop, 0);
+#else
+  _Unwind_SjLj_ForcedUnwind (exc, force_unwind_stop, 0);
+#endif
+
+  abort ();
+}
+
+static void handler (void *p __attribute__((unused)))
+{
+  exit (0);
+}
+
+__attribute__((noinline)) static void callme ()
+{
+  CFI_ESCAPE;
+  force_unwind ();
+}
+
+__attribute__((noinline)) static void doit ()
+{
+  char dummy __attribute__((cleanup (handler)));
+  callme ();
+}
+
+int main()
+{ 
+  doit ();
+  abort ();
+}
Index: gcc/testsuite/gcc.dg/graphite/pr40281.c
===================================================================
--- gcc/testsuite/gcc.dg/graphite/pr40281.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/graphite/pr40281.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-options "-O -fprefetch-loop-arrays -w" } */
+/* { dg-options "-O -fprefetch-loop-arrays -march=i686 -msse -w" { target { { i?86-*-* x86_64-*-* } && ilp32 } } } */
+
+void foo(int);
+void bar(int n)
+{
+ int a[2], i, j = 0;
+
+ for (i = 0; i < 2; i += j+1)
+   for (j = 0; j < (n ? 1 : 2); ++j)
+     foo(a[i] + a[j]);
+}
Index: gcc/testsuite/gcc.dg/vect/slp-multitypes-3.c
===================================================================
--- gcc/testsuite/gcc.dg/vect/slp-multitypes-3.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/gcc.dg/vect/slp-multitypes-3.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -88,7 +88,7 @@
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  } } */
-/* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 2 "vect" } } */
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail { sparc*-*-* && ilp32 } } } } */
+/* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 2 "vect" { xfail { sparc*-*-* && ilp32 } }} } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
   
Index: gcc/testsuite/gcc.dg/vect/vect-multitypes-5.c
===================================================================
--- gcc/testsuite/gcc.dg/vect/vect-multitypes-5.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/gcc.dg/vect/vect-multitypes-5.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -48,6 +48,6 @@
   return main1 ();
 }
 
-/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail { sparc*-*-* && ilp32 } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
 
Index: gcc/testsuite/gcc.dg/vect/pr42604.c
===================================================================
--- gcc/testsuite/gcc.dg/vect/pr42604.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/vect/pr42604.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,35 @@
+/* PR debug/42604 */
+/* { dg-do compile } */
+/* { dg-options "-O3 -ftree-vectorize -g -ffast-math" } */
+
+unsigned *d;
+unsigned short e;
+int f;
+float h[3][4];
+
+void
+test (unsigned short *b)
+{
+  int a, c, i;
+  float g[3];
+  unsigned j[32] = { 10, 0x63707274 };
+  for (i = 0; i < (int) j[0]; i++)
+    {
+      j[i * 3 + 2] = d[0];
+      d[0] += (j[i * 3 + 3] + 3) & -4;
+    }
+  for (a = 0; a < e; a++)
+    {
+      g[0] = g[1] = g[2] = 0;
+      for (c = 0; c < f; c++)
+	{
+	  g[0] += h[0][c] * b[c];
+	  g[1] += h[1][c] * b[c];
+	}
+      for (c = 0; c < 3; c++)
+	b[c] = 0 > ((int) g[c] < 65535 ? ((int) g[c]) : 65535)
+	  ? 0 : ((int) g[c]) < 65535 ? (int) g[c] : 65535;
+    }
+}
+
+/* { dg-final { cleanup-tree-dump "vect" } } */
Index: gcc/testsuite/gcc.dg/vect/pr42395.c
===================================================================
--- gcc/testsuite/gcc.dg/vect/pr42395.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/vect/pr42395.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,10 @@
+/* PR debug/42395 */
+/* { dg-do compile } */
+/* { dg-options "-O3 -ftree-vectorize -g" } */
+
+void foo(int j, int *A)
+{
+  int i;
+  for (i = 0; i < j; i ++) A[i] = i;
+  for (; i < 4096; i ++) A[i] = 0;
+}
Index: gcc/testsuite/gcc.dg/vect/vect-multitypes-6.c
===================================================================
--- gcc/testsuite/gcc.dg/vect/vect-multitypes-6.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/gcc.dg/vect/vect-multitypes-6.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -59,7 +59,7 @@
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail { sparc*-*-* && ilp32 } }} } */
 /*  { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 6 "vect" { target vect_no_align } } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 6 "vect" {xfail vect_no_align } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
Index: gcc/testsuite/gcc.dg/vect/fast-math-pr43074.c
===================================================================
--- gcc/testsuite/gcc.dg/vect/fast-math-pr43074.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/vect/fast-math-pr43074.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+
+float
+pvslockprocess(float *fout, float *fin, int framesize)
+{
+  int i;
+  float mag=0.0f, diff;
+  for (i = 0; i < framesize; i += 2) {
+      mag += fin[i];
+      fout[i] = fin[i];
+      fout[i+1] = fin[i+1];
+  }
+  return mag;
+}
+
+/* { dg-final { cleanup-tree-dump "vect" } } */
Index: gcc/testsuite/gcc.dg/vect/pr42193.c
===================================================================
--- gcc/testsuite/gcc.dg/vect/pr42193.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/vect/pr42193.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,28 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target vect_long } */
+
+#include <stdarg.h>
+
+unsigned long in[6], out[6];
+
+void foo ()
+{
+  unsigned long a, b, c, d, e, f;
+
+  a = in[0];
+  b = in[1];
+  c = in[2];
+  d = in[3];
+  e = in[4];
+  f = in[5];
+
+  out[0] = 2 * a + 7 * b + 8  * c + 31 * d + 10 * e + 21 * f;
+  out[1] = 3 * a + 6 * b + 12 * c + 13 * d + 15 * e + 28 * f;
+  out[2] = 4 * a + 5 * b + 72  * c + 23 * d + 14 * e + 24 * f;
+  out[3] = 8 * a + 71 * b + 18  * c + 33 * d + 13 * e + 25 * f;
+  out[4] = 12 * a + 16 * b + 19 * c + 41 * d + 22 * e + 26 * f;
+  out[5] = 17 * a + 15 * b + 13  * c + 14 * d + 11 * e + 9 * f;
+}
+
+/* { dg-final { cleanup-tree-dump "vect" } } */
+
Index: gcc/testsuite/gcc.dg/vect/vect-debug-pr41926.c
===================================================================
--- gcc/testsuite/gcc.dg/vect/vect-debug-pr41926.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/vect/vect-debug-pr41926.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,20 @@
+/* PR debug/41926 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -g -ffast-math -funroll-loops -ftree-vectorize -msse2" { target { i?86-*-* x86_64-*-* } } } */
+
+void
+foo (double (*__restrict p)[4], double (*__restrict q)[4],
+     double *__restrict prim, double scale, double pp, double pq)
+{
+  int md, mc, mb, ma, p_index = 0;
+
+  for (md = 0; md < 1; md++)
+    for (mc = 0; mc < 1; mc++)
+      for (mb = 0; mb < 1; mb++)
+	for (ma = 0; ma < 4; ma++)
+	  {
+	    double tmp = scale * prim[p_index++];
+	    p[md][ma] = p[md][ma] - tmp * pp;
+	    q[mc][ma] = q[mc][ma] - tmp * pq;
+	  }
+}
Index: gcc/testsuite/gcc.dg/vect/pr41956.c
===================================================================
--- gcc/testsuite/gcc.dg/vect/pr41956.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/vect/pr41956.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target vect_int } */
+
+void K (int *gpwgts, int *badminpwgt, int *badmaxpwgt)
+{
+  int i;
+  for (i = 0; i < 10; i += 2) {
+    badminpwgt[i] = badminpwgt[i+1] = gpwgts[i]+gpwgts[i];
+    badmaxpwgt[i] = badmaxpwgt[i+1] = gpwgts[i]+gpwgts[i];
+  }
+}
+
+/* { dg-final { cleanup-tree-dump "vect" } } */
+
Index: gcc/testsuite/gcc.dg/vect/vect-multitypes-12.c
===================================================================
--- gcc/testsuite/gcc.dg/vect/vect-multitypes-12.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/gcc.dg/vect/vect-multitypes-12.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -39,6 +39,6 @@
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 2 "vect" { target vect_unpack } } } */
-/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { ! vect_unpack } } } } */
+/* { dg-final { if [ istarget sparc*-*-* ] { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail ilp32 } } else { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { ! vect_unpack } } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
 
Index: gcc/testsuite/gcc.dg/vect/pr42709.c
===================================================================
--- gcc/testsuite/gcc.dg/vect/pr42709.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/vect/pr42709.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,28 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target vect_int } */
+
+#include <stdarg.h>
+#include "tree-vect.h"
+
+#define N 128 
+
+int *res[N];
+
+int
+main1 (int *a, int *b, int *c, int *d, int dummy)
+{
+  int i;
+
+  for (i = 0; i < N/2; i+=4)
+    {
+      res[i] = a + 16;
+      res[i+1] = b + 16;
+      res[i+2] = c + 16;
+      res[i+3] = d + 16;
+      if (dummy == 32)
+        abort ();
+    } 
+}
+
+/* { dg-final { cleanup-tree-dump "vect" } } */
+  
Index: gcc/testsuite/ChangeLog
===================================================================
--- gcc/testsuite/ChangeLog	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/ChangeLog	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,3 +1,1417 @@
+2010-03-11  Janis Johnson  <janis187@us.ibm.com>
+
+	* lib/target-supports-dg.exp (check-flags): Provide defaults for
+	include-opts and exclude-opts; skip checking the flags if arguments
+	are the same as the defaults.
+	(dg-xfail-if): Verify the number of arguments, supply defaults
+	for unspecified optional arguments.
+	(dg-skip-if, dg-xfail-run-if): Verify the number of arguments.
+
+2010-03-11  Tobias Burnus  <burnus@net-b.de
+
+	PR fortran/43303
+	* gfortran.dg/c_assoc_3.f90: New test.
+
+2010-03-10  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
+
+	* g++.old-deja/g++.pt/asm1.C: Don't detect pic via looking for the
+	-fpic/-fPIC flags.
+	* g++.old-deja/g++.pt/asm2.C: Likewise.
+	* gcc.c-torture/compile/20000804-1.c: Likewise.
+	* gcc.target/i386/clobbers.c: Likewise.
+
+2010-03-08  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline:
+	2010-03-04  Andrew Pinski  <andrew_pinski@caviumnetworks.com>
+
+	PR c/43248
+	* gcc.dg/compound-literal-1.c: New testcase.
+
+2010-03-05  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
+
+	Backport:
+	2009-10-15  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
+	* lib/target-supports.exp (add_options_for_bind_pic_locally): New.
+	
+	2009-10-16  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
+	* g++.dg/ipa/iinline-1.C: Use dg-add-options bind_pic_locally.
+	* g++.dg/other/first-global.C: Likewise.
+	* g++.dg/parse/attr-externally-visible-1.C: Likewise.
+	* g++.dg/tree-ssa/nothrow-1.C: Likewise.
+	* gcc.dg/inline-33.c: Likewise.
+	* gcc.dg/ipa/ipa-1.c: Likewise.
+	* gcc.dg/ipa/ipa-2.c: Likewise.
+	* gcc.dg/ipa/ipa-3.c: Likewise.
+	* gcc.dg/ipa/ipa-4.c: Likewise.
+	* gcc.dg/ipa/ipa-5.c: Likewise.
+	* gcc.dg/ipa/ipa-7.c: Likewise.
+	* gcc.dg/ipa/ipacost-2.c: Likewise.
+	
+	2010-02-09  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
+	* gcc.dg/tree-ssa/inline-4.c: Bind pic locally.
+
+2010-03-05  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* lib/gnat.exp (gnat_init): Remove GNAT_UNDER_TEST_ORIG.
+	(gnat_target_compile): Likewise.
+	Reinitialize GNAT_UNDER_TEST if target changes.
+	Set ADA_INCLUDE_PATH, ADA_OBJECTS_PATH in environment.
+	(local_find_gnatmake): Pass full --GCC to gnatlink.
+	Remove --LINK.
+
+2010-03-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline:
+	2010-03-01  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/43220
+	* gcc.c-torture/execute/pr43220.c: New testcase.
+
+2010-02-27  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/thin_pointer.ad[sb]: Rename into...
+	* gnat.dg/thin_pointer1.ad[sb]: ...this.
+	* gnat.dg/thin_pointer2.adb: New test.
+	* gnat.dg/thin_pointer2_pkg.ad[sb]: New helper.
+
+2010-02-24  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	* gcc.target/arm/thumb2-cbnz.c: New test.
+
+2010-02-23  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline:
+	2010-02-22  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/42749
+	* gcc.c-torture/compile/pr42749.c: New testcase.
+
+	2010-02-21  Dodji Seketeli  <dodji@redhat.com>
+
+	PR c++/42824
+	* g++.dg/template/memclass4.C: New test.
+
+	2010-02-20  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/43111
+	* gfortran.dg/internal_pack_8.f90: New test.
+
+	2010-02-18  Jason Merrill  <jason@redhat.com>
+
+	PR c++/43109
+	* g++.dg/parse/namespace12.C: New.
+
+	2010-02-18  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/43066
+	* gcc.c-torture/compile/pr43066.c: New test.
+
+	2010-02-17  Jason Merrill  <jason@redhat.com>
+
+	PR c++/43069
+	* g++.dg/parse/namespace11.C: New.
+
+	PR c++/43093
+	* g++.dg/ext/attrib37.C: New.
+
+	PR c++/43079
+	* g++.dg/template/ptrmem20.C: New.
+
+	2010-02-16  Jason Merrill  <jason@redhat.com>
+
+	PR c++/43031
+	* g++.dg/ext/attrib36.C: New.
+
+	2010-02-15  Richard Guenther  <rguenther@suse.de>
+
+	PR middle-end/43068
+	* g++.dg/torture/pr43068.C: New testcase.
+
+	2010-02-11  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/42998
+	* gcc.c-torture/compile/pr42998.c: New testcase.
+
+	2010-02-10  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/43017
+	* gcc.dg/torture/pr43017.c: New testcase.
+
+	2010-02-10  Richard Guenther  <rguenther@suse.de>
+
+	PR c/43007
+	* gcc.c-torture/execute/20100209-1.c: New testcase.
+	* gcc.dg/fold-div-3.c: Likewise.
+
+	2010-02-09  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR fortran/42999
+	* gfortran.dg/array_constructor_35.f90: New test.
+
+	2010-02-09  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/43008
+	* gcc.c-torture/execute/pr43008.c: New testcase.
+
+	2010-02-09  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/43000
+	* gcc.dg/torture/pr43000.c: New testcase.
+	* gcc.dg/torture/pr43002.c: Likewise.
+
+	2010-02-06  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR libfortran/42742
+	* gfortran.dg/fmt_cache_2.f: New test.
+
+	2010-02-03  Jason Merrill  <jason@redhat.com>
+
+	PR c++/42870
+	* g++.dg/ext/dllexport3.C: New.
+
+2010-02-18  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	PR target/40887
+	Backport from trunk.
+	2009-12-24  Julian Brown  <julian@codesourcery.com>
+		    Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	* gcc.target/arm/pr40887.c: New test.
+
+2010-02-16  Ira Rosen <irar@il.ibm.com>
+
+	PR tree-optimization/43074
+	* gcc.dg/vect/fast-math-pr43074.c: New test.
+
+2010-02-16  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/41869
+	* gfortran.dg/module_write_1.f90: New test.
+
+2010-02-13  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/42871
+	* g++.dg/torture/pr42871.C: New testcase.
+
+2010-02-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/43033
+	* g++.dg/other/default3.C: Xfail g4 test.
+
+2010-02-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/43010
+	* g++.dg/debug/pr43010.C: New test.
+
+2010-02-09  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
+
+	* gcc.dg/tree-ssa/inline-4.c: Bind pic locally.
+
+2010-02-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/42890
+	* g++.dg/torture/pr42890.C: New test.
+
+2010-02-08  Richard Guenther  <rguenther@suse.de>
+
+	Backport from mainline:
+	2010-01-05  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/42462
+	* gcc.dg/tree-ssa/inline-4.c: New testcase.
+	* gcc.dg/Wunreachable-2.c: Remove.
+
+2010-02-08  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* gcc.dg/ipa/pr42706.c: Removed.
+
+2010-02-06  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline:
+	2010-02-05  Dodji Seketeli  <dodji@redhat.com>
+
+	PR c++/42915
+	* g++.dg/other/crash-9.C: New test.
+
+	2010-02-03  Jason Merrill  <jason@redhat.com>
+
+	PR c++/40138
+	* g++.dg/ext/builtin11.C: New.
+
+	2010-02-03  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/42944
+	* gcc.dg/errno-1.c: New testcase.
+
+	2010-02-03  Richard Guenther  <rguenther@suse.de>
+
+	PR middle-end/42927
+	* gcc.c-torture/compile/pr42927.c: New testcase.
+
+	2010-01-29  Dodji Seketeli  <dodji@redhat.com>
+
+	PR c++/42758
+	PR c++/42634
+	PR c++/42336
+	PR c++/42797
+	PR c++/42880
+	* g++.dg/other/crash-5.C: New test.
+	* g++.dg/other/crash-7.C: New test.
+	* g++.dg/other/crash-8.C: New test.
+
+	2010-01-28  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/42891
+	* gcc.target/i386/pr42891.c: New test.
+
+	2010-01-28  Richard Guenther  <rguenther@suse.de>
+
+	PR middle-end/42883
+	* g++.dg/torture/pr42883.C: New testcase.
+
+	2010-01-28  Michael Matz  <matz@suse.de>
+
+	* gcc.target/i386/pr42881.c: New test.
+
+	2010-01-28  Dodji Seketeli  <dodji@redhat.com>
+
+	PR c++/42713
+	PR c++/42820
+	* g++.dg/template/typedef27.C: New test case.
+	* g++.dg/template/typedef28.C: New test case.
+
+	2010-01-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/42874
+	* gcc.dg/vla-22.c: New test.
+
+	2010-01-26  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/42250
+	* gcc.dg/pr42250.c: New testcase.
+
+	2010-01-25  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/42858
+	* gfortran.dg/generic_21.f90: New test.
+
+	2010-01-21  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/42585
+	* gcc.dg/tree-ssa/pr42585.c: New test.
+
+	2010-01-20  Alexandre Oliva  <aoliva@redhat.com>
+
+	PR debug/42715
+	* gcc.dg/pr42715.c: New.
+
+	2010-01-20  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/42717
+	* gcc.c-torture/compile/pr42717.c: New testcase.
+
+	2010-01-19  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/42783
+	* gfortran.dg/bounds_check_15.f90 : New test.
+
+	2010-01-18  Dodji Seketeli  <dodji@redhat.com>
+
+	PR c++/42766
+	* g++.dg/conversion/op6.C: New test.
+
+	2010-01-18  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/42781
+	* gfortran.fortran-torture/compile/pr42781.f90: New testcase.
+
+	2010-01-17  Richard Guenther  <rguenther@suse.de>
+
+	PR middle-end/42248
+	* gcc.c-torture/execute/pr42248.c: New testcase.
+
+	2010-01-17  Janus Weil  <janus@gcc.gnu.org>
+
+	PR fortran/42677
+	* gfortran.dg/interface_assignment_5.f90: New test.
+
+	2010-01-15  Richard Guenther  <rguenther@suse.de>
+
+	PR middle-end/42739
+	* g++.dg/torture/pr42739.C: New testcase.
+
+	2010-01-14 Jerry DeLisle <jvdelisle@gcc.gnu.org>
+
+	PR fortran/42684
+	* gfortran.dg/interface_31.f90: New test.
+
+	2010-01-14  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/42706
+	* gcc.dg/ipa/pr42706.c: New testcase.
+
+	2010-01-14  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/42714
+	* g++.dg/torture/pr42714.C: New test.
+
+	2010-01-14  Alexander Monakov  <amonakov@ispras.ru>
+
+	PR rtl-optimization/42388
+	* gcc.dg/pr42388.c: New.
+
+	2010-01-14  Alexander Monakov <amonakov@ispras.ru>
+
+	PR rtl-optimization/42294
+	* gfortran.dg/pr42294.f: New.
+
+	2010-01-14  Ira Rosen  <irar@il.ibm.com>
+
+	PR tree-optimization/42709
+	* gcc.dg/vect/pr42709.c: New test.
+
+	2010-01-13  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/42730
+	* gcc.c-torture/compile/pr42730.c: New testcase.
+
+	2010-01-13  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/42704
+	* g++.dg/torture/pr42704.C: New test.
+
+	2010-01-13  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/42703
+	* gcc.c-torture/compile/pr42703.c: New test.
+
+	2010-01-13  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/42705
+	* gcc.c-torture/compile/pr42705.c: New testcase.
+
+	2010-01-13  Richard Guenther  <rguenther@suse.de>
+
+	PR middle-end/42716
+	* gcc.c-torture/compile/pr42716.c: New testcase.
+
+	2010-01-12  Joseph Myers  <joseph@codesourcery.com>
+
+	PR c/42708
+	* gcc.c-torture/compile/pr42708-1.c: New test.
+
+	2010-01-09  Alexandre Oliva  <aoliva@redhat.com>
+
+	PR middle-end/42363
+	* gcc.dg/torture/pr42363.c: New.
+
+	2010-01-09  Alexandre Oliva  <aoliva@redhat.com>
+
+	PR debug/42604
+	PR debug/42395
+	* gcc.dg/vect/pr42604.c: New.
+	* gcc.dg/vect/pr42395.c: New.
+
+	2010-01-09  Richard Guenther  <rguenther@suse.de>
+
+	PR middle-end/42512
+	* gcc.c-torture/execute/pr42512.c: New testcase.
+
+2010-02-06  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/42309
+	* gfortran.dg/subref_array_pointer_4.f90 : New test.
+
+2010-02-04  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR libfortran/42901
+	*gfortran.dg/namelist_60.f90: New test.
+	*gfortran.dg/namelist_59.f90: New test.
+
+2010-02-04  Richard Guenther  <rguenther@suse.de>
+
+	PR rtl-optimization/42952
+	* gcc.dg/torture/pr42952.c: New testcase.
+
+2010-02-02  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/42650
+	* gfortran.dg/func_result_5.f90: New test.
+
+2010-02-01  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline:
+	2009-12-17  Uros Bizjak  <ubizjak@gmail.com>
+
+	* objc/execute/forward-1.x: XFAIL for -fgnu-runtime on
+	x86_64-*-darwin*, powerpc*-*-darwin* and alpha*-*-linux* targets.
+
+2010-01-31  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR middle-end/42898
+	* gcc.dg/torture/pr42898-2.c: New test.
+
+2010-01-31  Richard Guenther  <rguenther@suse.de>
+
+	PR middle-end/42898
+	* gcc.dg/torture/pr42898.c: New testcase.
+
+2010-01-31  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/38324
+	* gfortran.dg/alloc_comp_basics_1.f90: Remove option -O2.
+	* gfortran.dg/alloc_comp_bounds_1.f90: New test.
+
+2010-01-30  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/41044
+	* gfortran.dg/parameter_array_ref_2.f90 : New test.
+
+	PR fortran/41167
+	* gfortran.dg/char_array_arg_1.f90 : New test.
+
+2010-01-27  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/42736
+	* gfortran.dg/dependency_25.f90 : New test.
+
+2010-01-26  Jakub Jelinek  <jakub@redhat.com>
+
+	* ada/acats/run_all.sh: Make sure norun.lst is sorted using the
+	current collation.
+
+	Backport from mainline:
+	2009-12-17  Arnaud Charlet  <charlet@adacore.com>
+
+	* ada/acats/run_all.sh: Strip comments from norun.lst.
+
+2010-01-25  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	Backport from mainline.
+	2010-01-19  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	PR target/38697.
+	* gcc.target/arm/neon/vget_lowf32.c: Regenerate.
+	* gcc.target/arm/neon/vget_lowp16.c: Likewise.
+	* gcc.target/arm/neon/vget_lowp8.c:  Likewise.
+	* gcc.target/arm/neon/vget_lows16.c: Likewise.
+	* gcc.target/arm/neon/vget_lows32.c: Likewise.
+	* gcc.target/arm/neon/vget_lows64.c: Likewise.
+	* gcc.target/arm/neon/vget_lows8.c: Likewise.
+	* gcc.target/arm/neon/vget_lowu16.c: Likewise.
+	* gcc.target/arm/neon/vget_lowu32.c: Likewise.
+	* gcc.target/arm/neon/vget_lowu64.c: Likewise.
+	* gcc.target/arm/neon/vget_lowu8.c: Likewise.
+
+2010-01-21  Release Manager
+
+	* GCC 4.4.3 released.
+
+2010-01-20  Jakub Jelinek  <jakub@redhat.com>
+
+	* gcc.dg/cleanup-13.c: Expect DW_OP_mod to do unsigned modulo instead
+	of signed, add a few new tests.
+
+	PR middle-end/42803
+	* g++.dg/parse/limits-initializer1.C: New test.
+
+2010-01-18  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/42774
+	* gcc.target/alpha/pr42774.c: New test.
+
+2010-01-17  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline:
+	2010-01-13  Steve Ellcey  <sje@cup.hp.com>
+
+	PR target/42542
+	* gcc.target/ia64/pr42542-1.c: New.
+	* gcc.target/ia64/pr42542-2.c: New.
+	* gcc.target/ia64/pr42542-3.c: New.
+
+2010-01-17  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/42773
+	* g++.dg/torture/pr42773.C: New testcase.
+
+2010-01-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/42760
+	* g++.dg/torture/pr42760.C: New test.
+
+2010-01-15  Jing Yu  <jingyu@google.com>
+
+	PR rtl-optimization/42691
+	* gcc.c-torture/execute/pr42691.c: New.
+
+2010-01-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/42674
+	* c-c++-common/pr42674.c: New test.
+
+	PR c++/42608
+	* g++.dg/template/instantiate11.C: New test.
+
+2010-01-14  Jason Merrill  <jason@redhat.com>
+
+	PR c++/42655
+	* g++.dg/overload/rvalue1.C: New.
+
+2010-01-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/42721
+	* gcc.c-torture/execute/pr42721.c: New test.
+
+2010-01-14  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline
+	2010-01-10  Richard Guenther  <rguenther@suse.de>
+
+	PR middle-end/42667
+	* gcc.dg/torture/pr42667.c: New testcase.
+
+2010-01-13  Sebastian Pop  <sebastian.pop@amd.com>
+
+	PR middle-end/40281
+	* gcc.dg/graphite/pr40281.c: New.
+
+2010-01-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/42662
+	* gcc.dg/pr42662.c: New test.
+
+2010-01-11  Uros Bizjak  <ubizjak@gmail.com>
+
+	* gcc.target/x86_64/abi/avx/asm-support.S (snapshot_ret): Preserve
+	stack alignment.
+
+2010-01-07  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* g++.dg/opt/pr42508.C: Removed.
+
+2010-01-07  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline:
+	2010-01-06  Richard Guenther  <rguenther@suse.de>
+
+	* gcc.c-torture/compile/pr42632.c: New testcase.
+
+	2010-01-05  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/42462
+	* g++.dg/torture/pr42462.C: New test.
+
+	2010-01-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/42508
+	* g++.dg/opt/pr42508.C: New test.
+
+	2010-01-04  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/42398
+	* gcc.c-torture/compile/pr42398.c: New test.
+
+	2010-01-04  Jason Merrill  <jason@redhat.com>
+
+	PR c++/42555
+	* g++.dg/ext/attrib35.C: New.
+
+	2010-01-01  Richard Guenther  <rguenther@suse.de>
+
+	PR c/42570
+	* gcc.c-torture/execute/pr42570.c: New testcase.
+
+	2010-01-01  Richard Guenther  <rguenther@suse.de>
+
+	PR middle-end/42559
+	* gcc.c-torture/compile/pr42559.c: New testcase.
+
+	2009-12-30  Joseph Myers  <joseph@codesourcery.com>
+
+	PR c/42439
+	* gcc.dg/bitfld-19.c: New test.
+
+	2009-12-28  Jason Merrill  <jason@redhat.com>
+
+	PR c++/42447
+	* g++.dg/template/array21.C: New.
+
+2010-01-07  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2010-01-05  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/42542
+	* gcc.target/i386/pr42542-1.c: New.
+	* gcc.target/i386/pr42542-1a.c: Likewise.
+	* gcc.target/i386/pr42542-1b.c: Likewise.
+	* gcc.target/i386/pr42542-2.c: Likewise.
+	* gcc.target/i386/pr42542-2a.c: Likewise.
+	* gcc.target/i386/pr42542-2b.c: Likewise.
+	* gcc.target/i386/pr42542-3.c: Likewise.
+	* gcc.target/i386/pr42542-3a.c: Likewise.
+
+2010-01-05  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.dg/tls/opt-15.c: New test.
+
+2010-01-05  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/42614
+	* gcc.c-torture/execute/pr42614.c: New testcase.
+
+2010-01-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR other/42611
+	* gcc.dg/pr42611.c: New test.
+
+2010-01-04  Ira Rosen  <irar@il.ibm.com>
+
+	PR tree-optimization/41956
+	* gcc.dg/vect/pr41956.c: New test.
+
+2010-01-02  Richard Guenther  <rguenther@suse.de>
+
+	Backport from mainline
+	2009-12-09  Xinliang David Li  <davidxl@google.com>
+
+	PR tree-optimization/42337
+	* g++.dg/tree-ssa/pr42337.C: New test.
+
+2010-01-02  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/42448
+	* gcc.target/alpha/pr42448-1.c: New test.
+	* gcc.target/alpha/pr42448-2.c: Ditto.
+
+2009-12-30  Ian Lance Taylor  <iant@google.com>
+
+	PR middle-end/42099
+	* gcc.c-torture/execute/20091229-1.c: New test.
+
+2009-12-30  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/42549
+	* gcc.target/i386/mmx-3dnow-check.h: New file.
+	* gcc.target/i386/pr42549.c: New test.
+
+2009-12-28  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline:
+	2009-12-24  Jason Merrill  <jason@redhat.com>
+
+	PR c++/41305
+	* g++.dg/lookup/koenig10.C: New test.
+	* g++.dg/lookup/koenig11.C: New test.
+	* g++.dg/lookup/koenig12.C: New test.
+
+2009-12-28  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline:
+	2009-12-28  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR middle-end/41344
+	* gfortran.dg/gomp/pr41344.f: New.
+
+2009-12-27  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/42231
+	* gcc.c-torture/execute/pr42231.c: New test.
+
+2009-12-22  Jason Merrill  <jason@redhat.com>
+
+	PR c++/42331
+	* g++.dg/cpp0x/initlist29.C: New.
+
+2009-12-23  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/42475
+	* gcc.dg/pr42475.c: New test.
+
+2009-12-22  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline:
+	2009-12-19  Dodji Seketeli  <dodji@redhat.com>
+
+	PR c++/42225
+	* g++.dg/template/typedef26.C: New test.
+
+	2009-12-17  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/42386
+	* g++.dg/opt/dtor3.C: New test.
+
+	2009-12-15  Jason Merrill  <jason@redhat.com>
+
+	PR c++/42358
+	* g++.dg/cpp0x/variadic98.C: New.
+
+	2009-12-13  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/42357
+	* g++.dg/torture/pr42357.C: New testcase.
+
+2009-12-21  Jason Merrill  <jason@redhat.com>
+
+	* g++.dg/abi/mangle14.C: Add expected mangling.
+
+2009-12-21  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR libfortran/PR42422
+	* gfortran.dg/list_read_10.f90:  New test.
+
+2009-12-15  Jason Merrill  <jason@redhat.com>
+
+	PR c++/42387
+	* g++.dg/ext/vla8.C: New.
+
+2009-12-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/41183
+	* g++.dg/torture/pr41183.C: New test.
+
+2009-12-11  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	Backport from mainline:
+	2009-08-11  Andrew Haley  <aph@redhat.com>
+	* gcc.target/arm/synchronize.c: New file.
+
+2009-12-11  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline:
+	2009-12-07  Richard Henderson  <rth@redhat.com>
+
+	PR rtl-opt/42269
+	* gcc.c-torture/execute/pr42269-2.c: New.
+
+	2009-12-07  Richard Henderson  <rth@redhat.com>
+
+	PR debug/42299
+	PR debug/42166
+	* gcc.c-torture/compile/pr42299.c: New.
+	* gfortran.dg/pr42166.f90: Likewise.
+
+	2009-12-06  Richard Henderson  <rth@redhat.com>
+
+	PR debug/42234
+	* gcc.c-torture/compile/pr42234.c: New.
+
+	2009-12-02  Richard Henderson  <rth@redhat.com>
+
+	PR tree-opt/42215
+	* gcc.dg/pr42215.c: New.
+
+2009-12-11  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline:
+	2009-12-11  Dodji Seketeli  <dodji@redhat.com>
+
+	PR c++/42225
+	* g++.dg/template/typedef24.C: New test.
+	* g++.dg/template/typedef25.C: New test.
+
+	2009-12-11  Dodji Seketeli  <dodji@redhat.com>
+
+	PR c++/42251
+	* g++.dg/template/const3.C: New test.
+
+	2009-12-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/42317
+	* g++.dg/opt/dtor2.C: New test.
+	* g++.dg/opt/dtor2.h: New file.
+	* g++.dg/opt/dtor2-aux.cc: New file.
+
+	2009-12-10  Jan Hubicka  <jh@suse.cz>
+
+	PR middle-end/42110
+	* g++.dg/torture/pr42110.C: new file.
+
+	2009-12-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/42244
+	* gcc.dg/debug/pr42244.c: New test.
+
+	2009-12-04  David Daney  <ddaney@caviumnetworks.com>
+
+	PR rtl-optimization/42164
+	* gcc.c-torture/compile/pr42164.c: New test.
+
+	2009-12-03  Jason Merrill  <jason@redhat.com>
+
+	PR c++/41611
+	* g++.dg/abi/guard2.C: New.
+
+	2009-12-03  Dodji Seketeli  <dodji@redhat.com>
+
+	PR c++/42217
+	* g++.dg/other/bitfield4.C: New test.
+
+	2009-12-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/42256
+	* g++.dg/inherit/thunk11.C: New test.
+	* g++.dg/inherit/thunk11.h: New file.
+	* g++.dg/inherit/thunk11-aux.cc: New file.
+
+	2009-12-01  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/42237
+	* gcc.c-torture/compile/pr42237.c: New test.
+
+	2009-12-01  Paolo Carlini  <paolo.carlini@oracle.com>
+
+	PR c++/42057
+	* g++.dg/parse/crash54.C: New.
+
+	2009-11-30  Martin Jambor  <mjambor@suse.cz>
+
+	PR middle-end/42196
+	* gcc.c-torture/compile/pr42196-1.c: New test.
+	* gcc.c-torture/compile/pr42196-2.c: New test.
+	* gcc.c-torture/compile/pr42196-3.c: New test.
+
+	2009-11-30  Dodji Seketeli  <dodji@redhat.com>
+
+	PR c++/42069
+	* g++.dg/template/typedef23.C: New test.
+
+	2009-11-29  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR tree-optimization/41961
+	* g++.dg/tree-ssa/pr41961.C: New.
+
+	2009-11-29  Ira Rosen  <irar@il.ibm.com>
+
+	PR tree-optimization/42193
+	* gcc.dg/vect/pr42193.c: New test.
+
+	2009-11-28  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/42183
+	* g++.dg/torture/pr42183.C: New testcase.
+
+	2009-11-27  Martin Jambor  <mjambor@suse.cz>
+
+	PR middle-end/42006
+	* gcc.c-torture/execute/pr42006.c: New test.
+
+	2009-11-27  Michael Matz  <matz@suse.de>
+
+	PR rtl-optimization/42084
+	* gcc.dg/pr42084.c: New test.
+
+	2009-11-27  Michael Matz  <matz@suse.de>
+
+	PR c++/41906
+	* g++.dg/tree-ssa/pr41906.C: New testcase.
+
+	2009-11-26  Michael Matz  <matz@suse.de>
+
+	PR tree-optimization/41905
+	* g++.dg/tree-ssa/pr41905.C: New testcase.
+
+	2009-11-24  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/42142
+	* gcc.c-torture/execute/pr42142.c: New testcase.
+
+	2009-11-24  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/42154
+	* gcc.c-torture/execute/pr42154.c: New test.
+
+	2009-11-21  Martin Jambor  <mjambor@suse.cz>
+
+	PR middle-end/42025
+	* gcc.c-torture/compile/pr42025-1.c: New test.
+	* gcc.c-torture/compile/pr42025-2.c: New test.
+
+	2009-11-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/42078
+	* gcc.dg/pr42078.c: New test.
+
+2009-12-11  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	PR target/41196
+	2009-10-14  Daniel Gutson  <dgutson@codesourcery.com>
+	* testsuite/gcc.target/arm/neon/vfp-shift-a2t2.c: New test case.
+
+2009-12-11  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	2009-10-08  Doug Kwan  <dougkwan@google.com>
+
+	PR rtl-optimization/41574
+	* gcc.dg/pr41574.c: New test.
+
+2009-11-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/27425
+	PR c++/34274
+	* g++.dg/template/arg7.C: New.
+
+2009-12-10  Janus Weil  <janus@gcc.gnu.org>
+
+	PR fortran/42268
+	* gfortran.dg/intrinsic_pack_5.f90: New test.
+
+2009-12-04  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	Backport from mainline:
+
+	2009-04-27  Trevor Smigiel <trevor_smigiel@playstation.sony.com>
+
+	Allow non-constant arguments to conversion intrinsics.
+	* gcc.target/spu/intrinsics-3.c: Update tests.
+
+2009-12-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/42049
+	* gcc.c-torture/compile/pr42049.c: New test.
+
+2009-12-02  Chao-ying Fu  <fu@mips.com>
+
+	Backport from mainline
+	2009-11-30  Chao-ying Fu  <fu@mips.com>
+
+	* gcc.target/mips/dsp-lhx.c: New test.
+	* gcc.target/mips/dsp-no-lhx.c: New test.
+
+2009-12-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/42234
+	* g++.dg/gomp/pr42234.C: New test.
+
+2009-11-30  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR fortran/41278
+	* gfortran.dg/array_function_5.f90: New test.
+
+2009-11-27  Jakub Jelinek  <jakub@redhat.com>
+
+	* gcc.dg/O16384.c: New test.
+
+2009-11-26  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR fortran/41807
+	* gfortran.dg/data_value_1.f90: Update test.
+	* gfortran.dg/array_constructor_32.f90: New test.
+
+2009-11-23  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/42113
+	* gcc.target/alpha/pr42113.c: New test.
+
+2009-11-20  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* c-c++-common/pr41935.c: Removed.
+	* g++.dg/template/crash92.C: Likewise.
+	* gfortran.dg/missing_optional_dummy_6.f90: Likewise.
+
+2009-11-20  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline:
+	2009-11-18  Alexandre Oliva  <aoliva@redhat.com>
+
+	PR debug/41926
+	* gcc.dg/vect/vect-debug-pr41926.c: New.
+
+	2009-11-16  Paolo Carlini  <paolo.carlini@oracle.com>
+
+	PR c++/42055
+	* g++.dg/template/crash92.C: New.
+
+	2009-11-08  Richard Guenther  <rguenther@suse.de>
+
+	PR rtl-optimization/41928
+	* gfortran.dg/pr41928.f90: New testcase.
+
+	2009-11-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/41935
+	* gcc.dg/pr41935.c: New test.
+	* c-c++-common/pr41935.c: New test.
+	* gcc.c-torture/execute/pr41935.c: New test.
+
+	2009-11-04  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/41919
+	* gcc.c-torture/execute/pr41919.c: New testcase.
+
+	2009-11-03  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/41907
+	* gfortran.dg/missing_optional_dummy_6.f90: New test.
+
+	2009-11-02  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/41750
+	* gcc.c-torture/execute/pr41750.c: New test.
+
+	2009-11-02  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/41841
+	* gcc.dg/pr41841.c: New test.
+
+2009-11-19  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR libgfortran/42090
+	* gfortran.dg/direct_io_11.f90: New test.
+
+2009-11-17  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/42061
+	* g++.dg/cpp0x/initlist27.C: New test.
+
+	PR c++/42059
+	* g++.dg/cpp0x/initlist26.C: New test.
+
+2009-11-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/21008, DR 515
+	* g++.dg/template/inherit4.C: New.
+	* g++.dg/lookup/scoped8.C: Adjust.
+
+2009-11-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/37037
+	* g++.dg/template/typedef21.C: New.
+
+2009-11-11  Kai Tietz  <kai.tietz@onevision.com>
+
+	Backported from trunk
+	* g++.dg/torture/pushpop_macro.C: New testcase.
+	* gcc.c-torture/execute/pushpop_macro.c: New testcase.
+	* gcc.dg/cpp/pragma-pop_macro-1.c: Allow test for all
+	targets.
+
+2009-11-10  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.dg/vect/vect-multitypes-5.c: XFAIL on SPARC 32-bit.
+	* gcc.dg/vect/vect-multitypes-6.c: Likewise.
+	* gcc.dg/vect/vect-multitypes-12.c: Likewise.
+	* gcc.dg/vect/slp-multitypes-3.c: Likewise.
+
+2009-11-09  Jason Merrill  <jason@redhat.com>
+
+	PR c++/41972
+	* g++.dg/template/ref4.C: New.
+
+2009-11-09  Jason Merrill  <jason@redhat.com>
+
+	PR c++/41994
+	* g++.dg/template/conv10.C: New.
+
+2009-11-07  Jason Merrill  <jason@redhat.com>
+
+	* g++.dg/abi/regparm1.C: Fix execute test.
+
+2009-11-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/40946
+	* gcc.dg/pr40946.c: New test.
+
+	Backport from mainline
+	2009-09-09  Richard Guenther  <rguenther@suse.de>
+
+	PR middle-end/41317
+	* gcc.c-torture/execute/pr41317.c: New testcase.
+
+2009-11-08  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline:
+	2009-11-06  Michael Matz  <matz@suse.de>
+
+	PR middle-end/41963
+	* gcc.target/i386/pr41963.c: New test.
+
+2009-11-06  Jason Merrill  <jason@redhat.com>
+
+	PR c++/9381
+	* g++.dg/abi/regparm1.C: New.
+
+2009-11-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/41643
+	* gcc.dg/pr41643.c: New test.
+
+2009-11-06  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR fortran/41909
+	* gfortran.dg/recursive_check_15.f90: New test.
+
+2009-11-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/41967
+	* g++.dg/gomp/pr41967.C: New test.
+
+2009-11-05  Jakub Jelinek  <jakub@redhat.com>
+
+	* c-c++-common/builtin-offset.c: Renamed to ...
+	* c-c++-common/builtin-offsetof.c: ... this.  Don't expect a warning
+	on offsetof (struct B, p[10]).
+
+2009-11-04  Jason Merrill  <jason@redhat.com>
+
+	PR c++/36912
+	* g++.dg/init/static-init2.C: New.
+
+2009-11-04  Jason Merrill  <jason@redhat.com>
+
+	PR c++/35067
+	* g++.dg/abi/thunk5.C: New.
+
+2009-11-04  Uros Bizjak  <ubizjak@gmail.com>
+
+	* gcc.target/i386/pr41900.c: New test.
+
+2009-11-03  Jason Merrill  <jason@redhat.com>
+
+	PR c++/36959
+	* g++.dg/opt/inline16.C: New.
+
+2009-11-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/41917
+	* gcc.c-torture/execute/pr41917.c: New test.
+
+2009-10-28  Jason Merrill  <jason@redhat.com>
+
+	* g++.dg/cpp0x/inline-ns3.C: New.
+
+	PR c++/39786
+	* g++.dg/lookup/using22.C: New.
+
+	PR c++/41876
+	* g++.dg/parse/eh-decl.C: New.
+
+2009-11-03  Dodji Seketeli  <dodji@redhat.com>
+
+	* g++.dg/dg.exp: Port c-c++-common support from 4.5.
+	* gcc.dg/dfp/dfp.exp: Likewise.
+	* gcc.dg/dg.exp: Likewise.
+	* lib/target-supports.exp: Likewise.
+
+2009-11-03  Dodji Seketeli  <dodji@redhat.com>
+
+	PR c++/41856
+	* g++.dg/lookup/extern-c-redecl3.C: Make the test x86 only.
+	* g++.dg/lookup/extern-c-redecl4.C: Likewise.
+
+2009-11-03  Dodji Seketeli  <dodji@redhat.com>
+
+	* c-c++-common/dfp/builtin-offsetof.c: Moved this ...
+	* c-c++-common/builtin-offsetof.c: ... here.
+
+2009-11-03  Dodji Seketeli  <dodji@redhat.com>
+
+	PR c++/38699
+	* c-c++-common/dfp/builtin-offsetof.c: New test.
+	* g++.dg/other/offsetof6.C: Likewise.
+
+2009-11-02  Dodji Seketeli  <dodji@redhat.com>
+
+	PR c++/37093
+	* g++.dg/other/ptrmem10.C: New test.
+	* g++.dg/other/ptrmem11.C: Likewise.
+
+2009-11-02  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/41772
+	* gfortran.dg/transfer_intrinsic_3.f90.
+
+2009-11-01  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/41850
+	* gfortran.dg/intent_out_6.f90: New testcase.
+
+2009-10-31  Jason Merrill  <jason@redhat.com>
+
+	PR c++/41754
+	* g++.dg/cpp0x/initlist25.C: New.
+
+2009-10-31  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* gcc.dg/pr41345.c: Removed.
+
+2009-10-30  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline:
+	2009-10-30  Dodji Seketeli  <dodji@redhat.com>
+
+	PR c++/41863
+	* g++.dg/template/sizeof12.C: New test.
+
+	2009-10-29  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/41775
+	* g++.dg/torture/pr41775.C: New testcase.
+
+	2009-10-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/41801
+	* g++.dg/ext/sync-3.C: New test.
+
+	2009-10-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/41020
+	* g++.dg/lookup/extern-c-redecl5.C: Fix up regexp.
+
+	2009-10-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR bootstrap/41345
+	* gcc.dg/pr41345.c: New test.
+
+	2009-10-26  Dodji Seketeli  <dodji@redhat.com>
+
+	PR c++/41785
+	* g++.dg/cpp0x/variadic96.C: New test.
+
+	2009-10-26  Dodji Seketeli  <dodji@redhat.com>
+
+	PR c++/41020
+	* g++.dg/lookup/extern-c-redecl2.C: New test.
+	* g++.dg/lookup/extern-c-redecl3.C: Likewise.
+	* g++.dg/lookup/extern-c-redecl4.C: Likewise.
+	* g++.dg/lookup/extern-c-redecl5.C: Likewise.
+
+	2009-10-23  Joseph Myers  <joseph@codesourcery.com>
+
+	PR c/40033
+	* gcc.dg/noncompile/pr40033-1.c: New test.
+
+	2009-10-23  Joseph Myers  <joseph@codesourcery.com>
+
+	PR c/41673
+	* gcc.dg/Wstrict-aliasing-bogus-vla-1.c: New test.
+
+	2009-10-21  Sebastian Pop  <sebastian.pop@amd.com>
+
+	PR tree-optimization/41497
+	* gcc.dg/tree-ssa/pr41497.c: New.
+
+2009-10-30  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/41777
+	gfortran.dg/associated_target_3.f90: New testcase.
+
+2009-10-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/41762
+	* gcc.dg/pr41762.c: New test.
+
+2009-10-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/41842
+	* gcc.dg/pr41842.c: New test.
+
+2009-10-23  Dodji Seketeli  <dodji@redhat.com>
+
+	PR c++/40808
+	* g++.dg/abi/mangle33.C: New test
+
+2009-10-23  Mikael Pettersson  <mikpe@it.uu.se>
+
+	* gcc.c-torture/compile/pr11832.c: Delete.
+	* gcc.c-torture/compile/pr33009.c: Likewise.
+
+2009-10-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline:
+	2009-10-16  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/41728
+	* gcc.c-torture/compile/pr41728.c: New testcase.
+
+	2009-10-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/41717
+	* gcc.dg/debug/pr41717.c: New test.
+
+2009-10-21  Jakub Jelinek  <jakub@redhat.com>
+
+	* g++.dg/abi/mangle33.C: New test.
+
+2009-10-20  Joseph Myers  <joseph@codesourcery.com>
+
+	* gcc.target/arm/neon-thumb2-move.c: New test.
+
+2009-10-19  Jakub Jelinek  <jakub@redhat.com>
+
+	* gcc.dg/cleanup-13.c: New test.
+
+2009-10-19  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/41755
+	* gfortran.dg/equiv_8.f90: New test.
+
+2009-10-15  Jason Merrill  <jason@redhat.com>
+
+	PR c++/38798
+	* g++.dg/cpp0x/trailing5.C: New.
+
+2009-10-14  Larry Evans  <cppljevans@suddenlink.net>
+
+	* g++.dg/cpp0x/vt-40092.C: New.
+
+2009-10-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/37875
+	* g++.dg/cpp0x/decltype18.C: New.
+
+	PR c++/37766
+	* g++.dg/cpp0x/fntmpdefarg1.C: New.
+
+2009-10-11  Jason Merrill  <jason@redhat.com>
+
+	PR c++/37204
+	* g++.dg/cpp0x/rv-reinterpret.C: New.
+
+2009-10-16  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* g++.dg/debug/dwarf2/template-params-7.C: Removed.
+	* gfortran.dg/fmt_error_9.f: Likewise.
+
+2009-10-15  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline:
+	2009-10-13  Martin Jambor  <mjambor@suse.cz>
+
+	* gcc.c-torture/compile/pr41661.c: New test.
+
+	2009-10-12  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR libgfortran/41683
+	* gfortran.dg/fmt_error_9.f: Add check for repeat count after P.
+
+	2009-10-12  Dodji Seketeli  <dodji@redhat.com>
+
+	PR c++/41570
+	* g++.dg/debug/dwarf2/template-params-7.C: New test.
+
+	2009-10-11  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/41555
+	* gcc.dg/torture/pr41555.c: New testcase.
+
+	2009-10-09  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/41634
+	* gcc.c-torture/compile/pr41634.c: New testcase.
+
+	2009-10-08  Michael Matz  <matz@suse.de>
+
+	PR middle-end/41573
+	* gcc.dg/pr41573.c: New test.
+
+	2009-10-07  Joseph Myers  <joseph@codesourcery.com>
+
+	PR c/41182
+	* gcc.c-torture/compile/pr41182-1.c: New.
+
 2009-10-15  Release Manager
 
 	* GCC 4.4.2 released.
@@ -449,9 +1863,9 @@
 2009-08-16  Dodji Seketeli  <dodji@redhat.com>
 
 	PR debug/37801
-	* gcc/testsuite/gcc.dg/debug/20020224-1.c: Adjust the comment.
+	* gcc.dg/debug/20020224-1.c: Adjust the comment.
 	Make sure to trigger inlining optimizations.
-	* gcc/testsuite/gcc.dg/debug/dwarf2/inline2.c: New test.
+	* gcc.dg/debug/dwarf2/inline2.c: New test.
 
 2009-08-12  Richard Guenther  <rguenther@suse.de>
 
@@ -769,7 +2183,7 @@
 
 2009-07-14  Jack Howarth  <howarth@bromo.med.uc.edu>
 
-	* testsuite/gcc.c-torture/compile/20000804-1.c: skip for ilp32 on
+	* gcc.c-torture/compile/20000804-1.c: skip for ilp32 on
 	both i?86-*-darwin* and x86_64-*-darwin*.
 
 2009-07-12  Jason Merrill  <jason@redhat.com>
@@ -2151,7 +3565,7 @@
 2009-03-13  Jack Howarth  <howarth@bromo.med.uc.edu>
 
 	PR target/39137
-	* testsuite/gcc.target/i386/stackalign/longlong-2.c: Skip on darwin.
+	* gcc.target/i386/stackalign/longlong-2.c: Skip on darwin.
 
 2009-03-13  H.J. Lu  <hongjiu.lu@intel.com>
 
@@ -2346,8 +3760,8 @@
 2009-03-02  Sebastian Pop  <sebastian.pop@amd.com>
 
 	PR middle-end/39335
-	* testsuite/gcc.dg/graphite/pr39335_1.c: New.
-	* testsuite/gcc.dg/graphite/pr39335.c: New.
+	* gcc.dg/graphite/pr39335_1.c: New.
+	* gcc.dg/graphite/pr39335.c: New.
 
 2009-03-02  H.J. Lu  <hongjiu.lu@intel.com>
 
@@ -3727,7 +5141,7 @@
 	    Jan Sjodin  <jan.sjodin@amd.com>
 
 	PR tree-optimization/38559
-	* testsuite/gcc.dg/graphite/pr38559.c: New.
+	* gcc.dg/graphite/pr38559.c: New.
 
 2009-01-08  Ira Rosen  <irar@il.ibm.com>
 
@@ -3789,15 +5203,15 @@
 
 	PR tree-optimization/38492
 	PR tree-optimization/38498
-	* testsuite/gcc.dg/graphite/pr38500.c: Fixed warning as committed
+	* gcc.dg/graphite/pr38500.c: Fixed warning as committed
 	in trunk.
-	* testsuite/gcc.dg/graphite/block-0.c: Update test.
-	* testsuite/gcc.dg/graphite/block-1.c: Same.
-	* testsuite/gcc.dg/graphite/block-2.c: Remove xfail and test
+	* gcc.dg/graphite/block-0.c: Update test.
+	* gcc.dg/graphite/block-1.c: Same.
+	* gcc.dg/graphite/block-2.c: Remove xfail and test
 	for blocking.
-	* testsuite/gcc.dg/graphite/block-4.c: Remove test for strip mine.
-	* testsuite/gcc.dg/graphite/block-3.c: New.
-	* testsuite/gcc.dg/graphite/pr38498.c: New.
+	* gcc.dg/graphite/block-4.c: Remove test for strip mine.
+	* gcc.dg/graphite/block-3.c: New.
+	* gcc.dg/graphite/pr38498.c: New.
 
 2009-01-07  H.J. Lu  <hongjiu.lu@intel.com>
 
Index: gcc/testsuite/g++.old-deja/g++.oliva/ChangeLog
===================================================================
--- gcc/testsuite/g++.old-deja/g++.oliva/ChangeLog	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/g++.old-deja/g++.oliva/ChangeLog	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,3 +1,7 @@
+2010-01-21  Release Manager
+
+	* GCC 4.4.3 released.
+
 2009-10-15  Release Manager
 
 	* GCC 4.4.2 released.
Index: gcc/testsuite/g++.old-deja/g++.pt/asm1.C
===================================================================
--- gcc/testsuite/g++.old-deja/g++.pt/asm1.C	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/g++.old-deja/g++.pt/asm1.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,6 +1,6 @@
 // { dg-do assemble { target i?86-*-linux* x86_64-*-linux* } }
-// We'd use ebx with -fpic/-fPIC, so skip.
-// { dg-skip-if "" { ilp32 } { "-fpic" "-fPIC" } { "" } }
+// We'd use ebx with 32-bit pic code, so skip.
+// { dg-skip-if "" { ilp32 && { ! nonpic } } { "*" } { "" } }
 // Origin: "Weidmann, Nicholas" <nicholas.weidmann@swx.ch>
 
 template<int i> int foo(int v)
Index: gcc/testsuite/g++.old-deja/g++.pt/asm2.C
===================================================================
--- gcc/testsuite/g++.old-deja/g++.pt/asm2.C	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/g++.old-deja/g++.pt/asm2.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,7 +1,7 @@
 // { dg-do assemble { target i?86-*-linux* x86_64-*-linux* } }
 // { dg-require-effective-target ilp32 }
-// We'd use ebx with -fpic/-fPIC, so skip.
-// { dg-skip-if "" { *-*-* } { "-fpic" "-fPIC" } { "" } }
+// We'd use ebx with 32-bit pic code, so require nonpic.
+// { dg-require-effective-target nonpic }
 // Origin: "Weidmann, Nicholas" <nicholas.weidmann@swx.ch>
 
 typedef void (function_ptr)(int);
Index: gcc/testsuite/gfortran.fortran-torture/compile/pr42781.f90
===================================================================
--- gcc/testsuite/gfortran.fortran-torture/compile/pr42781.f90	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.fortran-torture/compile/pr42781.f90	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,59 @@
+! ICE with gfortran 4.5 at -O1:
+!gfcbug98.f90: In function ‘convert_cof’:
+!gfcbug98.f90:36:0: internal compiler error: in pt_solutions_same_restrict_base,
+!at tree-ssa-structalias.c:5072
+module foo
+  implicit none
+  type t_time
+     integer :: secs = 0
+  end type t_time
+contains
+  elemental function time_cyyyymmddhh (cyyyymmddhh) result (time)
+    type (t_time)                :: time
+    character(len=10),intent(in) :: cyyyymmddhh
+  end function time_cyyyymmddhh
+
+  function nf90_open(path, mode, ncid)
+    character(len = *), intent(in) :: path
+    integer, intent(in)  :: mode
+    integer, intent(out) :: ncid
+    integer              :: nf90_open
+  end function nf90_open
+end module foo
+!==============================================================================
+module gfcbug98
+  use foo
+  implicit none
+
+  type t_fileinfo
+     character(len=10) :: atime = ' '
+  end type t_fileinfo
+
+  type t_body
+     real         :: bg(10)
+  end type t_body
+contains
+  subroutine convert_cof (ifile)
+    character(len=*) ,intent(in) :: ifile
+
+    character(len=5)         :: version
+    type(t_fileinfo)         :: gattr
+    type(t_time)             :: atime
+    type(t_body),allocatable :: tmp_dat(:)
+    real        ,allocatable :: BDA(:, :, :)
+
+    call open_input
+    call convert_data
+  contains
+    subroutine open_input
+      integer             :: i,j
+      version = ''
+      j = nf90_open(ifile, 1, i)
+    end subroutine open_input
+    !--------------------------------------------------------------------------
+    subroutine convert_data
+      BDA(1,:,1) = tmp_dat(1)% bg(:)
+      atime = time_cyyyymmddhh (gattr% atime)
+    end subroutine convert_data
+  end subroutine convert_cof
+end module gfcbug98
Index: gcc/testsuite/g++.dg/other/first-global.C
===================================================================
--- gcc/testsuite/g++.dg/other/first-global.C	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/g++.dg/other/first-global.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-fpie" { target { ! nonpic } } } */
+/* { dg-add-options bind_pic_locally } */
 /* { dg-final { scan-assembler "_GLOBAL__I(_|_65535_0_)foobar" } } */
 
 struct foo { foo (); };
Index: gcc/testsuite/g++.dg/other/crash-5.C
===================================================================
--- gcc/testsuite/g++.dg/other/crash-5.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/other/crash-5.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,16 @@
+// Origin: PR c++/42758
+// { dg-do compile }
+
+template<class T> struct less {};
+
+template<class T, typename U = less<T> > struct set {};
+
+struct int_less_than {};
+
+void assert_fail (const char*);
+
+int f(const set<int, int_less_than>&)
+{
+    assert_fail (__PRETTY_FUNCTION__);
+
+}
Index: gcc/testsuite/g++.dg/other/crash-9.C
===================================================================
--- gcc/testsuite/g++.dg/other/crash-9.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/other/crash-9.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,15 @@
+// Origin: PR c++/42915
+// { dg-do compile }
+
+template <typename T>
+class A
+{
+  template <typename U>
+  class B
+  {
+    B foo();
+  };
+};
+template <typename T> template <typename U>
+A<T>::B<U> A<T>::B<U>::foo() {}
+
Index: gcc/testsuite/g++.dg/other/default3.C
===================================================================
--- gcc/testsuite/g++.dg/other/default3.C	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/g++.dg/other/default3.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -25,7 +25,7 @@
 template<typename> void g3(int = 0, int);    // { dg-error "default" }
 
 template<typename> void g4(int, int);
-template<typename> void g4(int = 0, int) {}  // { dg-error "default" }
+template<typename> void g4(int = 0, int) {}  // { dg-error "default" "" { xfail *-*-* } }
 
 template<typename> void g5();
 template<typename> void g5(int = 0, int);    // { dg-error "default" }
Index: gcc/testsuite/g++.dg/other/offsetof6.C
===================================================================
--- gcc/testsuite/g++.dg/other/offsetof6.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/other/offsetof6.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,26 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin PR c++/38699
+// { dg-do compile }
+
+template<class T>
+struct A
+{
+  const T *p;
+};
+
+struct B
+{
+  A<int> a;
+};
+
+template class A<char>;
+
+void
+f0 ()
+{
+  __builtin_offsetof(A<char>, p); // OK
+  __builtin_offsetof(A<char>, p[1]); // { dg-error "non constant address" }
+  __builtin_offsetof(B, a.p); // OK
+  __builtin_offsetof(B, a.p[1]); // { dg-error "non constant address" }
+}
+
Index: gcc/testsuite/g++.dg/other/crash-7.C
===================================================================
--- gcc/testsuite/g++.dg/other/crash-7.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/other/crash-7.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,19 @@
+// Origin: PR c++/42336
+// { dg-options "-std=c++0x -O2 -g" }
+// { dg-do compile }
+
+struct X {
+      void func() {}
+};
+
+template<typename T, void (X::*P)() = &T::func>
+void b(T) {}
+
+int main() {
+      b(X()); /* line 9 */
+        X().func();
+
+          return 0;
+}
+
+
Index: gcc/testsuite/g++.dg/other/ptrmem10.C
===================================================================
--- gcc/testsuite/g++.dg/other/ptrmem10.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/other/ptrmem10.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,29 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin PR c++/37093
+
+template <class C, void (C::*M) ()>
+static
+void foo(void *obj)
+{
+  C *p = static_cast<C*>(obj);
+  (p->*M)();
+}
+
+template <class C>
+static void
+bar(C *c, void (C::*m) ())
+{
+  foo<C,m>((void *)c);// { dg-error "(not a valid template arg|pointer-to-member|no matching fun)" }
+}
+
+struct S
+{
+  void baz () {}
+};
+
+int
+main ()
+{
+  S a;
+  bar(&a, &S::baz);
+}
Index: gcc/testsuite/g++.dg/other/crash-8.C
===================================================================
--- gcc/testsuite/g++.dg/other/crash-8.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/other/crash-8.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,109 @@
+// Origin: PR c++/42797
+// { dg-options "-g -O2 -std=c++0x" }
+
+template<typename _Tp, _Tp __v>     struct integral_constant     {
+    static const _Tp value = __v;
+};
+
+template<typename _Tp>     _Tp declval();
+
+template<typename _Tp, typename... _Args>
+class __is_constructible_helper  {
+};
+
+template<typename _Tp, typename _Arg>
+class __is_constructible_helper<_Tp, _Arg>  {
+
+    template<typename _Tp1, typename _Arg1>
+    static decltype(static_cast<_Tp1>(declval<_Arg1>()), char())  __test(int);
+public:
+    static const bool __value = sizeof(__test<_Tp, _Arg>(0)) == 1;
+};
+
+template<typename _Tp, typename... _Args>
+struct is_constructible     : public integral_constant<bool,__is_constructible_helper<_Tp, _Args...>::__value>     { };
+
+template<bool, typename _Tp = void>
+struct enable_if  { };
+
+template<typename _Tp>
+struct enable_if<true, _Tp>     {
+    typedef _Tp type;
+};
+
+template<class _T1, class _T2>     struct pair     {
+    _T1 first;
+    _T2 second;
+
+    template<class _U2, class = typename  enable_if<is_constructible<_T2, _U2&&>::value>::type>
+    pair(const _T1& __x, _U2&& __y)  : first(__x),
+                                       second(__y) { }
+};
+
+namespace __gnu_cxx {
+template<typename _Tp>
+class new_allocator     {
+public:
+    new_allocator() throw() { }
+    new_allocator(const new_allocator&) throw() { }
+};
+}
+
+template<typename _Tp>
+class allocator: public __gnu_cxx::new_allocator<_Tp>     {
+public:
+
+    template<typename _Tp1>
+    struct rebind  {
+        typedef allocator<_Tp1> other;
+    };
+};
+
+
+template<typename _Tp, typename _Alloc>     struct _Vector_base     {
+    typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;
+
+    struct _Vector_impl       : public _Tp_alloc_type   {
+        _Vector_impl()
+        { }
+    };
+public:
+
+    _Vector_impl _M_impl;
+};
+
+template<typename _Tp, typename _Alloc = allocator<_Tp> >
+class vector : protected _Vector_base<_Tp, _Alloc> {
+    typedef _Alloc allocator_type;
+public:
+    vector()       { }
+    explicit       vector(int, const allocator_type& __a = allocator_type())
+    {
+    }
+};
+
+
+template <typename _Key, typename _Tp>
+class map {
+    typedef _Key key_type;
+    typedef _Tp mapped_type;
+    typedef pair<const _Key, _Tp> value_type;
+public:
+
+    void insert(const value_type& __x)
+    {
+    }
+
+    mapped_type&       operator[](const key_type& __k)       {
+        insert(value_type(__k, mapped_type()));
+    }
+
+};
+
+struct Foo {
+    Foo() {}      template<typename Tp>     Foo(Tp *p) {} };
+void foo() {
+    map <int, vector<Foo>> the_map;
+    the_map[1] = vector<Foo>();
+}
+
Index: gcc/testsuite/g++.dg/other/bitfield4.C
===================================================================
--- gcc/testsuite/g++.dg/other/bitfield4.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/other/bitfield4.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,10 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin PR c++/42217
+// { dg-do compile }
+
+struct A
+{
+ int : 0;
+};
+A a = A();
+
Index: gcc/testsuite/g++.dg/other/ptrmem11.C
===================================================================
--- gcc/testsuite/g++.dg/other/ptrmem11.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/other/ptrmem11.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,21 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin PR c++/37093
+
+struct A {};
+
+template <int A::* p>
+int
+foo(A* q)
+{
+  return q->*p;
+}
+
+template <typename T>
+int
+bar(int T::* p)
+{
+  return foo<p>(0);// { dg-error "(not a valid template arg|no matching func|pointer-to-member)" }
+}
+
+int i = bar<A>(0);
+
Index: gcc/testsuite/g++.dg/tree-ssa/nothrow-1.C
===================================================================
--- gcc/testsuite/g++.dg/tree-ssa/nothrow-1.C	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/g++.dg/tree-ssa/nothrow-1.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,6 +1,7 @@
 /* { dg-do compile } */
 /* { dg-options "-O1 -fdump-tree-cfg" } */
-/* { dg-skip-if "" { "*-*-*" } { "-fpic" "-fPIC" } { "" } } */
+/* { dg-add-options bind_pic_locally } */
+
 double a;
 void t()
 {
Index: gcc/testsuite/g++.dg/tree-ssa/pr41905.C
===================================================================
--- gcc/testsuite/g++.dg/tree-ssa/pr41905.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/tree-ssa/pr41905.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,4 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+int foo() __attribute__((noreturn));
+int bar() { return foo(); }
Index: gcc/testsuite/g++.dg/tree-ssa/pr42337.C
===================================================================
--- gcc/testsuite/g++.dg/tree-ssa/pr42337.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/tree-ssa/pr42337.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,173 @@
+// PR tree-optimize/42337
+// { dg-do compile }
+// { dg-options "-O2" }
+
+template<class _T1, class _T2> struct pair {
+  _T2 second;
+};
+template<typename _Tp>
+inline const _Tp& max(const _Tp& __a, const _Tp& __b) { }
+
+template<typename _ForwardIterator, typename _Tp, typename _Compare> _ForwardIterator
+lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __val, _Compare __comp) { }
+template<class _CharT> struct char_traits {};
+
+template<typename _Iterator, typename _Container> class __normal_iterator {
+ public: typedef _Iterator iterator_type;
+  __normal_iterator& operator++() {
+  }
+};
+template<typename _IteratorL, typename _IteratorR, typename _Container>
+inline bool operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs, const __normal_iterator<_IteratorR, _Container>& __rhs) { }
+template<typename _Tp> class new_allocator {
+ public:
+  typedef _Tp* pointer;
+  typedef const _Tp* const_pointer;
+};
+
+template<typename _Tp>
+class allocator: public new_allocator<_Tp> {
+ public:
+  template<typename _Tp1> struct rebind {
+    typedef allocator<_Tp1> other;
+  };
+};
+
+template<typename _Arg, typename _Result> struct unary_function { };
+template<typename _Arg1, typename _Arg2, typename _Result> struct binary_function { };
+template<typename _Tp> struct less : public binary_function<_Tp, _Tp, bool> { };
+template<typename _Pair> struct _Select1st : public unary_function<_Pair, typename _Pair::first_type> { };
+template<typename _Tp> struct _Rb_tree_iterator {
+  typedef _Tp* pointer;
+  pointer operator->() const {
+  }
+};
+template<typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc = allocator<_Val> >
+class _Rb_tree {
+  typedef _Val value_type;
+ public: typedef _Rb_tree_iterator<value_type> iterator;
+};
+template <typename _Key, typename _Tp, typename _Compare = less<_Key>, typename _Alloc = allocator<pair<const _Key, _Tp> > >
+class map {
+ public: typedef _Key key_type;
+  typedef pair<const _Key, _Tp> value_type;
+  typedef _Compare key_compare;
+ private: typedef typename _Alloc::template rebind<value_type>::other _Pair_alloc_type;
+  typedef _Rb_tree<key_type, value_type, _Select1st<value_type>, key_compare, _Pair_alloc_type> _Rep_type;
+ public: typedef typename _Pair_alloc_type::pointer pointer;
+  typedef typename _Rep_type::iterator iterator;
+  iterator find(const key_type& __x) { }
+};
+
+template<typename _Tp, typename _Alloc> struct _Vector_base {
+  typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;
+};
+template<typename _Tp, typename _Alloc = allocator<_Tp> >
+class vector : protected _Vector_base<_Tp, _Alloc> {
+  typedef _Vector_base<_Tp, _Alloc> _Base;
+  typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
+ public:
+  typedef typename _Tp_alloc_type::pointer pointer;
+  typedef typename _Tp_alloc_type::const_pointer const_pointer;
+  typedef __normal_iterator<pointer, vector> iterator;
+  typedef __normal_iterator<const_pointer, vector> const_iterator;
+  iterator begin() { }
+  const_iterator begin() const { }
+  const_iterator end() const { }
+  unsigned long size() const { }
+};
+
+class SSC {
+ public:
+  SSC () {}
+  SSC (const int& cs);
+};
+extern int flag;
+
+struct TP {
+   const int cl_;
+   const vector<int> &its_;
+   int max_s_;
+ };
+
+double foo(TP *p);
+map<int, int> cs_;
+
+template <typename T> class vector32 {
+ public:
+  typedef T& reference;
+  typedef T* iterator;
+  typedef const T* const_iterator;
+  iterator begin() { return data_; }
+  iterator end() { return data_ + size_; }
+  long unsigned int size() const { return size_; }
+  T* data_;
+  unsigned size_;
+};
+
+struct SF : public pair<unsigned long long, double> { };
+
+template<typename KEY, typename VALUE> class SFVT {
+ private: typedef vector32<SF> Container;
+  typedef typename Container::const_iterator CI;
+  mutable Container v_;
+  mutable bool sorted_;
+  struct Cmp : public binary_function<SF, SF, bool> {
+  };
+  __attribute__((always_inline)) VALUE IS(const SFVT &sfv) const {
+    if (sfv.v_.size() < v_.size()) {
+      return sfv.IS(*this);
+    }
+    else {
+      VALUE sum = 0.0;
+      CI beg = sfv.v_.begin();
+      CI end = sfv.v_.end();
+      for (CI i = v_.begin();
+           i != v_.end();
+           ++i) { beg = lower_bound(beg, end, *i, Cmp()); if (beg == end) { return sum; } }
+    }
+  }
+ public: explicit SFVT(const int capacity = 0) : sorted_(true) { }
+  long unsigned int size() const { }
+  __attribute__((always_inline)) VALUE DP(const SFVT &sfv) const {
+    return IS(sfv);
+  }
+};
+class SFV : public SFVT<unsigned long long, double> { };
+
+class Edge;
+extern int flag2;
+
+double foo(TP *p) {
+  int nbests_requested = max(p->max_s_, flag);
+  map<int, int>::iterator it = cs_.find(p->cl_);
+  int* c = &it->second;
+  for (vector<int>::const_iterator iter = p->its_.begin();
+       iter != p->its_.end();
+       ++iter) {
+  }
+  vector<int*> fb;
+  vector<double> w;
+  int *hg = 0;
+  if (flag2 == 10) {
+    hg = &flag2;
+  }
+  int nr = 0;
+  for (vector<int*>::iterator iter = fb.begin();
+       (iter != fb.end() && nr < nbests_requested);
+       ++iter) {
+  }
+  if (hg) {
+    SFV s_weights;
+    for (int i = 0;
+         i < w.size();
+         ++i) {
+    }
+    SFV uw;
+    for (int i = 0, j = 0;
+         i < uw.size() && j < s_weights.size();
+         ) {
+    }
+    const double tc = uw.DP(s_weights);
+  }
+}
Index: gcc/testsuite/g++.dg/tree-ssa/pr41906.C
===================================================================
--- gcc/testsuite/g++.dg/tree-ssa/pr41906.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/tree-ssa/pr41906.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-options "-fpermissive -w" } */
+/* We aren't interested in the warning, but in the ICE.  */
+void foo();
+extern void abort (void);
+
+void bar()
+{
+  try { foo(); }
+  catch (...) {}
+  catch (int) {abort ();}
+}
Index: gcc/testsuite/g++.dg/tree-ssa/pr41961.C
===================================================================
--- gcc/testsuite/g++.dg/tree-ssa/pr41961.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/tree-ssa/pr41961.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,15 @@
+// { dg-do compile }
+// { dg-require-effective-target pthread }
+// { dg-options "-O3 -ftree-parallelize-loops=2" }
+
+struct A
+{
+    char c[17];
+      void foo();
+};
+
+void A::foo()
+{
+    for (int i = 0; i < 17; ++i)
+          c[i] = 0;
+}
Index: gcc/testsuite/g++.dg/conversion/op6.C
===================================================================
--- gcc/testsuite/g++.dg/conversion/op6.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/conversion/op6.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,18 @@
+// Origin: PR c++/42766
+// { dg-do compile }
+
+template<class T> class smart_pointer {
+public:
+    operator T* () const { }
+    operator bool () const { }
+    operator bool () { }
+};
+class Context { };
+typedef smart_pointer<Context> ContextP;
+class SvnClient  {
+    ~SvnClient();
+    ContextP svnContext;
+};
+SvnClient::~SvnClient() {
+    delete svnContext;
+}
Index: gcc/testsuite/g++.dg/dg.exp
===================================================================
--- gcc/testsuite/g++.dg/dg.exp	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/g++.dg/dg.exp	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -48,5 +48,9 @@
 # Main loop.
 dg-runtest $tests "" $DEFAULT_CXXFLAGS
 
+# C/C++ common tests.
+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/*.\[cSi\]]] \
+       "" ""
+
 # All done.
 dg-finish
Index: gcc/testsuite/g++.dg/debug/pr43010.C
===================================================================
--- gcc/testsuite/g++.dg/debug/pr43010.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/debug/pr43010.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,8 @@
+// PR debug/43010
+// { dg-do compile }
+// { dg-options "-g -femit-struct-debug-baseonly" }
+# 1 "foo.C"
+# 1 "bar.h" 1
+typedef struct { int i; } S __attribute__((aligned));
+typedef struct { struct { int i; } j; } T __attribute__((aligned));
+# 1 "foo.C" 2
Index: gcc/testsuite/g++.dg/ext/attrib35.C
===================================================================
--- gcc/testsuite/g++.dg/ext/attrib35.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/ext/attrib35.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,19 @@
+// { dg-do compile { target i*86-*-* x86_64-*-* } }
+// { dg-options "-O3 -msse2" }
+
+// You can make NON-template typedefs with a large alignment.
+typedef double AlignedDoubleType __attribute__((aligned(16)));
+
+template <typename RealType>
+RealType f(const RealType* p)
+{
+  // But if you use a template parameter it complains.
+  typedef RealType AlignedRealType __attribute__((aligned(16)));
+
+  return p[0];
+}
+
+double f2(const double* p)
+{
+  return f<double>(p);
+}
Index: gcc/testsuite/g++.dg/ext/attrib36.C
===================================================================
--- gcc/testsuite/g++.dg/ext/attrib36.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/ext/attrib36.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,20 @@
+// PR c++/43031
+// { dg-do compile { target { { i?86-*-* x86_64-*-* } && ilp32 } } }
+
+class T;
+class L { };
+class P : public L
+{
+  typedef void (__attribute__((__stdcall__)) T::*F) (L*);
+  void f(bool aAdd);
+};
+class T
+{
+public:
+    virtual void __attribute__((__stdcall__)) A(L *listener) = 0;
+    virtual void __attribute__((__stdcall__)) R(L *listener) = 0;
+};
+void P::f(bool aAdd)
+{
+  F addRemoveEventListener = (aAdd ? &T::A : &T::R);
+}
Index: gcc/testsuite/g++.dg/ext/attrib37.C
===================================================================
--- gcc/testsuite/g++.dg/ext/attrib37.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/ext/attrib37.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,14 @@
+// PR c++/43093
+// { dg-do compile { target { { i?86-*-* x86_64-*-* } && ilp32 } } }
+
+struct S {
+  int x;
+  S(const S &s) {}
+};
+
+S __attribute__((__stdcall__)) getS();
+
+void test()
+{
+  S s = getS();
+}
Index: gcc/testsuite/g++.dg/ext/dllexport3.C
===================================================================
--- gcc/testsuite/g++.dg/ext/dllexport3.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/ext/dllexport3.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,19 @@
+// PR c++/42870
+// { dg-do compile { target i?86-*-cygwin *-*-mingw* } }
+// { dg-final { scan-assembler "-export:_ZN2SaD1Ev" } }
+
+#define ATTRIBUTE __attribute__ ((dllexport))
+class ATTRIBUTE Sa {
+ public:
+  Sa()
+    {}
+  ~Sa();
+};
+ATTRIBUTE Sa::~Sa()
+{return;}
+
+bool DllMain(void *a,void*b,int)
+{
+  Sa s;
+  return true;
+}
Index: gcc/testsuite/g++.dg/ext/builtin11.C
===================================================================
--- gcc/testsuite/g++.dg/ext/builtin11.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/ext/builtin11.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,9 @@
+// PR c++/40138
+// { dg-options "-Wall" }
+
+void foo(int i, ...)
+{
+  V v;				// { dg-error "not declared|expected" }
+  __builtin_va_start(v, i);	// { dg-error "not declared" }
+  i = __builtin_va_arg(v, int);
+}
Index: gcc/testsuite/g++.dg/ext/sync-3.C
===================================================================
--- gcc/testsuite/g++.dg/ext/sync-3.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/ext/sync-3.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,21 @@
+// PR debug/41801
+// { dg-do compile }
+// { dg-options "-O2 -g" }
+
+struct T
+{
+  void
+  foo () volatile
+  {
+    __sync_lock_release (&t);
+    __sync_synchronize ();
+  }
+  bool t;
+};
+
+int
+main ()
+{
+  T t = { false };
+  t.foo ();
+}
Index: gcc/testsuite/g++.dg/ext/vla8.C
===================================================================
--- gcc/testsuite/g++.dg/ext/vla8.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/ext/vla8.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,15 @@
+// PR c++/42387
+// { dg-options "" }
+
+template<class PF>
+struct AvlTreeIter
+{
+  int Num();
+
+  AvlTreeIter()
+  {
+    new (void* [Num()]);
+  }
+};
+
+AvlTreeIter<int> a;
Index: gcc/testsuite/g++.dg/opt/dtor2-aux.cc
===================================================================
--- gcc/testsuite/g++.dg/opt/dtor2-aux.cc	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/opt/dtor2-aux.cc	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,16 @@
+// { dg-do compile }
+// { dg-options "" }
+
+#include "dtor2.h"
+
+A::A () {}
+A::~A () {}
+
+void B::mb () {}
+B::B (int) {}
+B::~B () {}
+
+void C::mc () {}
+C::C (int x) : B (x) {}
+
+D::~D () {}
Index: gcc/testsuite/g++.dg/opt/dtor2.C
===================================================================
--- gcc/testsuite/g++.dg/opt/dtor2.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/opt/dtor2.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,13 @@
+// PR c++/42317
+// { dg-do link }
+// { dg-options "-O0" }
+// { dg-additional-sources "dtor2-aux.cc" }
+
+#include "dtor2.h"
+
+D::D (int x) : C (x) {}
+
+int
+main ()
+{
+}
Index: gcc/testsuite/g++.dg/opt/dtor2.h
===================================================================
--- gcc/testsuite/g++.dg/opt/dtor2.h	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/opt/dtor2.h	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,29 @@
+struct A
+{
+  A ();
+  ~A ();
+};
+
+struct B
+{
+  A b;
+  virtual void mb ();
+  B (int);
+  virtual ~B ();
+};
+
+struct C : public B
+{
+  virtual void mc ();
+  C (int);
+  ~C ();
+};
+
+inline C::~C () {}
+
+struct D : public C
+{
+  A d;
+  D (int);
+  ~D ();
+};
Index: gcc/testsuite/g++.dg/opt/inline16.C
===================================================================
--- gcc/testsuite/g++.dg/opt/inline16.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/opt/inline16.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,19 @@
+// PR c++/36959
+// We shouldn't have to emit fromSlotB just because we need shuf_BZZZ.
+// { dg-options -O }
+// { dg-final { scan-assembler-not "_ZL9fromSlotBv" } }
+
+static inline int *fromSlotB(void)
+{
+  static int shuf_BZZZ = 1;
+  return &shuf_BZZZ;
+}
+
+int *p;
+
+int main(void)
+{
+  p = fromSlotB();
+  return (*p != 1);
+}
+
Index: gcc/testsuite/g++.dg/opt/dtor3.C
===================================================================
--- gcc/testsuite/g++.dg/opt/dtor3.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/opt/dtor3.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,11 @@
+// PR c++/42386
+// { dg-do compile }
+// { dg-options "-O2" }
+# 1 "A.h" 1
+#pragma interface
+struct D { virtual bool d () const; };
+struct E { virtual ~E (); virtual void *e () const = 0; };
+struct A : public D, public E { ~A () {} };
+# 5 "dtor3.C" 1
+struct F : public A { void *f () const; void *e () const; };
+void *F::e () const { return __null; }
Index: gcc/testsuite/g++.dg/lookup/extern-c-redecl4.C
===================================================================
--- gcc/testsuite/g++.dg/lookup/extern-c-redecl4.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/lookup/extern-c-redecl4.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,18 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin: PR c++/41020
+
+// { dg-options "" }
+// { dg-do compile }
+// { dg-final { scan-assembler "call\[\t \]+\[^\$\]*?_Z4forkv" { target i?86-*-* x86_64-*-* } } }
+
+class frok
+{
+  int this_errno;
+  friend int fork (void);
+};
+
+void
+foo ()
+{
+  fork ();
+}
Index: gcc/testsuite/g++.dg/lookup/koenig11.C
===================================================================
--- gcc/testsuite/g++.dg/lookup/koenig11.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/lookup/koenig11.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,12 @@
+// Test that we treat unions like other classes in arg-dep lookup.
+
+union U
+{
+  friend void f (U);
+};
+
+int main()
+{
+  U u;
+  f(u);
+}
Index: gcc/testsuite/g++.dg/lookup/using16.C
===================================================================
--- gcc/testsuite/g++.dg/lookup/using16.C	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/g++.dg/lookup/using16.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -3,7 +3,7 @@
 // { dg-do compile }
 
 namespace M {
-  struct S {}; // { dg-error "candidates are: struct M::S" "candidate 1" }
+  struct S {}; // { dg-error "struct M::S" "candidate 1" }
 }
 
 namespace N {
Index: gcc/testsuite/g++.dg/lookup/extern-c-redecl5.C
===================================================================
--- gcc/testsuite/g++.dg/lookup/extern-c-redecl5.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/lookup/extern-c-redecl5.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,18 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin: PR c++/41020
+// { dg-do compile }
+
+
+class frok
+{
+  int this_errno;
+  friend int fork (void); // { dg-error "previous declaration .*?C\\+\\+. linkage" }
+};
+
+extern "C" int
+fork (void) // { dg-error "conflicts with new declaration .*?C. linkage" }}
+{
+  frok grouped;
+  return grouped.this_errno;
+}
+
Index: gcc/testsuite/g++.dg/lookup/koenig12.C
===================================================================
--- gcc/testsuite/g++.dg/lookup/koenig12.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/lookup/koenig12.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,18 @@
+// PR c++/41305
+// We got into infinite recursion instantiating the B<U> series.
+
+template <class T> struct A { };
+template <class T, class U = A<T> > struct B;
+template <class T> struct C { };
+
+template <class T, class U> struct B: C<B<U> >
+{
+  friend void f(B) { }
+};
+
+B<int> b;
+
+int main()
+{
+  f(b);
+}
Index: gcc/testsuite/g++.dg/lookup/extern-c-redecl2.C
===================================================================
--- gcc/testsuite/g++.dg/lookup/extern-c-redecl2.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/lookup/extern-c-redecl2.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,21 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin PR c++/41020
+// { dg-do compile }
+
+extern "C"
+{
+  int fork (void);
+}
+
+class frok
+{
+  int this_errno;
+  friend int fork (void);
+};
+
+extern "C" int
+fork (void)
+{
+  frok grouped;
+  return grouped.this_errno;
+}
Index: gcc/testsuite/g++.dg/lookup/using22.C
===================================================================
--- gcc/testsuite/g++.dg/lookup/using22.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/lookup/using22.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,17 @@
+// PR c++/39786
+
+namespace A {
+    char (*f(char *p))[13] { return 0; }
+}
+
+namespace B {
+    namespace C {
+        char (*f(int p))[42] { return 0; }
+    }
+    using namespace C;
+}
+
+using namespace B;
+using namespace A;
+
+char x[sizeof *::f(0) == 42 ? 1 : -1];
Index: gcc/testsuite/g++.dg/lookup/extern-c-redecl3.C
===================================================================
--- gcc/testsuite/g++.dg/lookup/extern-c-redecl3.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/lookup/extern-c-redecl3.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,23 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin: PR c++/41020
+// { dg-options "" }
+// { dg-do compile }
+// { dg-final { scan-assembler-not "call\[\t \]+\[^\$\]*?_Z4forkv" { target i?86-*-* x86_64-*-* } } }
+// { dg-final { scan-assembler "call\[\t \]+_?fork" { target i?86-*-* x86_64-*-* } } }
+
+extern "C" int fork (void);
+
+void
+foo ()
+{
+  extern int fork (void);
+  fork ();
+}
+
+extern "C"
+int
+fork (void)
+{
+  return 0;
+}
+
Index: gcc/testsuite/g++.dg/lookup/scoped8.C
===================================================================
--- gcc/testsuite/g++.dg/lookup/scoped8.C	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/g++.dg/lookup/scoped8.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -14,3 +14,5 @@
 {
     int foo() { return A::i; }	// { dg-error "this location" }
 };
+
+template struct B<0>;
Index: gcc/testsuite/g++.dg/lookup/koenig10.C
===================================================================
--- gcc/testsuite/g++.dg/lookup/koenig10.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/lookup/koenig10.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,12 @@
+// Test for proper handling of class-scope enums.
+
+struct A
+{
+  enum E { e };
+  friend void f (E);
+};
+
+int main()
+{
+  f(A::e);
+}
Index: gcc/testsuite/g++.dg/parse/attr-externally-visible-1.C
===================================================================
--- gcc/testsuite/g++.dg/parse/attr-externally-visible-1.C	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/g++.dg/parse/attr-externally-visible-1.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,6 +1,6 @@
 // { dg-do compile }
 // { dg-options "-O3 -fwhole-program" }
-// { dg-options "-O3 -fwhole-program -fpie" { target { ! nonpic } } }
+// { dg-add-options bind_pic_locally }
 // { dg-final { scan-assembler "foo1" } }
 // { dg-final { scan-assembler "foo2" } }
 // { dg-final { scan-assembler "foo3" } }
Index: gcc/testsuite/g++.dg/parse/crash54.C
===================================================================
--- gcc/testsuite/g++.dg/parse/crash54.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/parse/crash54.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,15 @@
+// PR c++/42057
+
+struct A; // { dg-error "forward declaration" }
+
+struct B
+{
+  virtual B* foo(A);
+};
+
+struct C : virtual B
+{
+  virtual C* foo(A) { return 0; } // { dg-error "incomplete type" }
+};
+
+C c;
Index: gcc/testsuite/g++.dg/parse/limits-initializer1.C
===================================================================
--- gcc/testsuite/g++.dg/parse/limits-initializer1.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/parse/limits-initializer1.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,37 @@
+// PR middle-end/42803
+// { dg-do compile }
+// { dg-options "-O0" }
+
+#define X2 (a + a)
+#define X4 (X2 + X2)
+#define X8 (X4 + X4)
+#define X16 (X8 + X8)
+#define X32 (X16 + X16)
+#define X64 (X32 + X32)
+#define X128 (X64 + X64)
+#define X256 (X128 + X128)
+#define X512 (X256 + X256)
+#define X1024 (X512 + X512)
+#define X2048 (X1024 + X1024)
+#define X4096 (X2048 + X2048)
+#define X8192 (X4096 + X4096)
+#define X16384 (X8192 + X8192)
+#define X32768 (X16384 + X16384)
+#define X65536 (X32768 + X32768)
+#define X131072 (X65536 + X65536)
+#define X262144 (X131072 + X131072)
+
+int
+foo (int a)
+{
+  int v = X262144;
+  return v;
+}
+
+// Emit an error to just make sure we don't waste too much time
+// in the middle-end compiling this.
+int
+bar (void)
+{
+  return x;	// { dg-error "was not declared in this scope" }
+}
Index: gcc/testsuite/g++.dg/parse/namespace11.C
===================================================================
--- gcc/testsuite/g++.dg/parse/namespace11.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/parse/namespace11.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,7 @@
+// PR c++/43069
+
+namespace std {
+  template < typename >
+  void swap ();
+}
+template std::swap		// { dg-error "" }
Index: gcc/testsuite/g++.dg/parse/namespace12.C
===================================================================
--- gcc/testsuite/g++.dg/parse/namespace12.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/parse/namespace12.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,7 @@
+// PR c++/43109
+
+namespace std {
+ namespace {
+   struct S {};
+ }
+}
Index: gcc/testsuite/g++.dg/parse/eh-decl.C
===================================================================
--- gcc/testsuite/g++.dg/parse/eh-decl.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/parse/eh-decl.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,8 @@
+// PR c++/41876
+
+struct A;
+
+void foo()
+{
+  try {} catch(int A) {}
+}
Index: gcc/testsuite/g++.dg/cpp0x/auto13.C
===================================================================
--- gcc/testsuite/g++.dg/cpp0x/auto13.C	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/g++.dg/cpp0x/auto13.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,11 +0,0 @@
-// PR c++/38597
-// { dg-options "-std=c++0x" }
-
-template<class T, class U>
-auto f(T,U) -> decltype(T() + U())
-{ return T() + U(); }
-
-template<class T> void g(T){}
-
-int main() { g(f); }		// { dg-error "no matching function" }
-
Index: gcc/testsuite/g++.dg/cpp0x/auto6.C
===================================================================
--- gcc/testsuite/g++.dg/cpp0x/auto6.C	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/g++.dg/cpp0x/auto6.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,118 +0,0 @@
-// Tests for late-specified return type.
-// { dg-options "-std=c++0x" }
-
-auto f() -> int
-{
-  return 0;
-}
-
-template<class T, class U>
-auto add(T t, U u) -> decltype (t+u)
-{
-  return t+u;
-}
-
-template<class T, class U>
-decltype(T()+U()) add2(T t, U u)
-{
-  return t+u;
-}
-
-template <class T, class U>
-U ag (T, U)
-{
-  return U();
-}
-
-template<class T, class U>
-auto add3(T t, U u) -> decltype (ag(t,u))
-{
-  return ag(t,u);
-}
-
-template<class T, class U>
-decltype(*(T*)0+*(U*)0) add4(T t, U u)
-{
-  return t+u;
-}
-
-template <class T>
-struct A
-{
-  T f() {}
-  template <class U>
-  T g() {}
-  template <class V>
-  struct B
-  {
-    int MEM;
-  };
-};
-
-template <class T>
-auto f(T* t) -> decltype (t->f())
-{
-  return t->f();
-}
-
-template <class T>
-auto g(T t) -> decltype (t.f())
-{
-  return t.f();
-}
-
-template <class T, class U>
-auto h(T t, U u) -> decltype (t.template g<U>())
-{
-  return t.template g<U>();
-}
-
-struct D { };
-struct C: public A<int>::B<D>
-{
-};
-
-template <class T, class U, class V>
-auto k(T t, U u, V v) -> decltype (t.U::template B<V>::MEM)
-{
-  return t.U::template B<V>::MEM;
-}
-
-// For these two examples we can elide the 'decltype' and just mangle the type.
-template <class T>
-auto l(T t) -> decltype (t)
-{
-  return t;
-}
-
-template <class T, T u>
-auto m(T t) -> decltype (u)
-{
-  return t;
-}
-
-A<int> a, *p;
-
-int main()
-{
-  // { dg-final { scan-assembler  "_Z3addIidEDTplfp_fp0_ET_T0_" } }
-  auto i = add(1, 2.0);
-  // { dg-final { scan-assembler "_Z4add4IidEDTpldecvPT_Li0EdecvPT0_Li0EES0_S2_" } }
-  auto i4 = add4(1, 2.0);
-  // { dg-final { scan-assembler "_Z4add2IidEDTplcvT__EcvT0__EES0_S1_" } }
-  auto i2 = add2(1, 2.0);
-  // { dg-final { scan-assembler "_Z4add3IidEDTcl2agfp_fp0_EET_T0_" } }
-  auto i3 = add3(1, 2.0);
-  // { dg-final { scan-assembler "_Z1fI1AIiEEDTclptfp_1fEEPT_" } }
-  f(p);
-  // { dg-final { scan-assembler "_Z1gI1AIiEEDTcldtfp_1fEET_" } }
-  g(a);
-  // { dg-final { scan-assembler "_Z1hI1AIiEdEDTcldtfp_1gIT0_EEET_S2_" } }
-  h(a,1.0);
-  // { dg-final { scan-assembler "_Z1kI1C1AIiE1DEDtdtfp_srNT0_1BIT1_EE3MEMET_S4_S6_" } }
-  k( C(), A<int>(), D() );
-  // { dg-final { scan-assembler "_Z1lIiET_S0_" } }
-  l(1);
-  // { dg-final { scan-assembler "_Z1mIiLi1EET_S0_" } }
-  m<int,1>(1);
-}
Index: gcc/testsuite/g++.dg/cpp0x/auto8.C
===================================================================
--- gcc/testsuite/g++.dg/cpp0x/auto8.C	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/g++.dg/cpp0x/auto8.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,16 +0,0 @@
-// PR c++/37967
-// Negative test for auto
-// { dg-options "-std=c++0x" }
-
-auto f1 () -> int;
-auto f2 ();		// { dg-error "without late return type" }
-int f3 () -> int;	// { dg-error "late return type" }
-auto *f4 () -> int;	// { dg-error "late return type" }
-
-struct A
-{
-  auto f5 () const -> int;
-  auto f6 ();		// { dg-error "without late return type" }
-  int f7 () -> int;	// { dg-error "late return type" }
-  auto *f8 () -> int;	// { dg-error "late return type" }
-};
Index: gcc/testsuite/g++.dg/cpp0x/auto12.C
===================================================================
--- gcc/testsuite/g++.dg/cpp0x/auto12.C	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/g++.dg/cpp0x/auto12.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,63 +0,0 @@
-// More auto/decltype mangling tests.
-// { dg-options "-std=c++0x" }
-
-template <class T>
-struct B
-{
-  static int i;
-};
-
-int&& x();
-
-template <class T>
-struct A
-{
-  static int i;
-  static int &ir;
-  static int &&irr;
-  template <class U>
-  auto f(U u) -> decltype (u + i);
-  template <class U>
-  auto fr(U u) -> decltype (u + ir);
-  template <class U>
-  auto frr(U u) -> decltype (u + irr);
-  template <class U>
-  auto g(U u) -> decltype (u + sizeof (i));
-  template <class U>
-  auto h(U u) -> decltype (u + B<U>::i);
-  template <class U>
-  auto j(U u) -> decltype (u + x());
-};
-
-template<class T> template<class U>
-auto A<T>::f(U u) -> decltype (u + i)
-{
-  return u + i;
-}
-
-template <class... Args>
-int f (Args... args);
-
-template <class... Args>
-auto g (Args... args) -> decltype (f ((args+1)...))
-{
-  return (f ((args+1)...));
-}
-
-int main()
-{
-  // { dg-final { scan-assembler  "_ZN1AIiE1fIiEEDTplfp_L_ZNS0_1iEEET_" } }
-  A<int>().f(1);
-  // { dg-final { scan-assembler  "_ZN1AIiE2frIiEEDTplfp_L_ZNS0_2irEEET_" } }
-  A<int>().fr(1);
-  // { dg-final { scan-assembler  "_ZN1AIiE3frrIiEEDTplfp_L_ZNS0_3irrEEET_" } }
-  A<int>().frr(1);
-  // { dg-final { scan-assembler  "_ZN1AIiE1gIiEEDTplfp_szL_ZNS0_1iEEET_" } }
-  A<int>().g(1);
-  // { dg-final { scan-assembler  "_ZN1AIiE1hIiEEDTplfp_sr1BIT_E1iES3_" } }
-  A<int>().h(1);
-  // { dg-final { scan-assembler  "_ZN1AIiE1jIiEEDTplfp_clL_Z1xvEEET_" } }
-  A<int>().j(1);
-  // { dg-final { scan-assembler  "_Z1gIIidEEDTcl1fspplfp_Li1EEEDpT_" } }  
-  g(42, 1.0);
-}
Index: gcc/testsuite/g++.dg/cpp0x/initlist29.C
===================================================================
--- gcc/testsuite/g++.dg/cpp0x/initlist29.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/cpp0x/initlist29.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,14 @@
+// PR c++/42331
+// { dg-options "-std=c++0x" }
+
+class Mesh
+{
+public:
+  Mesh(const char*)
+  { typele={0}; }		// { dg-error "" }
+
+private:
+  int typele[7][2];
+};
+
+Mesh m(0);
Index: gcc/testsuite/g++.dg/cpp0x/decltype18.C
===================================================================
--- gcc/testsuite/g++.dg/cpp0x/decltype18.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/cpp0x/decltype18.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,5 @@
+// PR c++/37875
+// { dg-options "-std=c++0x" }
+
+template <typename> struct X {};
+X<decltype(1 > 2)> x;
Index: gcc/testsuite/g++.dg/cpp0x/trailing1.C
===================================================================
--- gcc/testsuite/g++.dg/cpp0x/trailing1.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/cpp0x/trailing1.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,118 @@
+// Tests for late-specified return type.
+// { dg-options "-std=c++0x" }
+
+auto f() -> int
+{
+  return 0;
+}
+
+template<class T, class U>
+auto add(T t, U u) -> decltype (t+u)
+{
+  return t+u;
+}
+
+template<class T, class U>
+decltype(T()+U()) add2(T t, U u)
+{
+  return t+u;
+}
+
+template <class T, class U>
+U ag (T, U)
+{
+  return U();
+}
+
+template<class T, class U>
+auto add3(T t, U u) -> decltype (ag(t,u))
+{
+  return ag(t,u);
+}
+
+template<class T, class U>
+decltype(*(T*)0+*(U*)0) add4(T t, U u)
+{
+  return t+u;
+}
+
+template <class T>
+struct A
+{
+  T f() {}
+  template <class U>
+  T g() {}
+  template <class V>
+  struct B
+  {
+    int MEM;
+  };
+};
+
+template <class T>
+auto f(T* t) -> decltype (t->f())
+{
+  return t->f();
+}
+
+template <class T>
+auto g(T t) -> decltype (t.f())
+{
+  return t.f();
+}
+
+template <class T, class U>
+auto h(T t, U u) -> decltype (t.template g<U>())
+{
+  return t.template g<U>();
+}
+
+struct D { };
+struct C: public A<int>::B<D>
+{
+};
+
+template <class T, class U, class V>
+auto k(T t, U u, V v) -> decltype (t.U::template B<V>::MEM)
+{
+  return t.U::template B<V>::MEM;
+}
+
+// For these two examples we can elide the 'decltype' and just mangle the type.
+template <class T>
+auto l(T t) -> decltype (t)
+{
+  return t;
+}
+
+template <class T, T u>
+auto m(T t) -> decltype (u)
+{
+  return t;
+}
+
+A<int> a, *p;
+
+int main()
+{
+  // { dg-final { scan-assembler  "_Z3addIidEDTplfp_fp0_ET_T0_" } }
+  auto i = add(1, 2.0);
+  // { dg-final { scan-assembler "_Z4add4IidEDTpldecvPT_Li0EdecvPT0_Li0EES0_S2_" } }
+  auto i4 = add4(1, 2.0);
+  // { dg-final { scan-assembler "_Z4add2IidEDTplcvT__EcvT0__EES0_S1_" } }
+  auto i2 = add2(1, 2.0);
+  // { dg-final { scan-assembler "_Z4add3IidEDTcl2agfp_fp0_EET_T0_" } }
+  auto i3 = add3(1, 2.0);
+  // { dg-final { scan-assembler "_Z1fI1AIiEEDTclptfp_1fEEPT_" } }
+  f(p);
+  // { dg-final { scan-assembler "_Z1gI1AIiEEDTcldtfp_1fEET_" } }
+  g(a);
+  // { dg-final { scan-assembler "_Z1hI1AIiEdEDTcldtfp_1gIT0_EEET_S2_" } }
+  h(a,1.0);
+  // { dg-final { scan-assembler "_Z1kI1C1AIiE1DEDtdtfp_srNT0_1BIT1_EE3MEMET_S4_S6_" } }
+  k( C(), A<int>(), D() );
+  // { dg-final { scan-assembler "_Z1lIiET_S0_" } }
+  l(1);
+  // { dg-final { scan-assembler "_Z1mIiLi1EET_S0_" } }
+  m<int,1>(1);
+}
Index: gcc/testsuite/g++.dg/cpp0x/variadic96.C
===================================================================
--- gcc/testsuite/g++.dg/cpp0x/variadic96.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/cpp0x/variadic96.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,26 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin: PR c++/41785
+// { dg-options -std=c++0x }
+
+struct a {};
+
+template < typename T, typename ENCLOSING >
+struct base;
+
+template < typename... T >
+struct derived
+  : public base< T, derived< T... > >...
+{};
+
+template < typename... T>
+struct base< a, derived< T... > >
+{
+  typedef derived< T... >
+          Derived;
+};
+
+int main()
+{
+  derived< a > instance;
+}
+
Index: gcc/testsuite/g++.dg/cpp0x/trailing2.C
===================================================================
--- gcc/testsuite/g++.dg/cpp0x/trailing2.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/cpp0x/trailing2.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,16 @@
+// PR c++/37967
+// Negative test for auto
+// { dg-options "-std=c++0x" }
+
+auto f1 () -> int;
+auto f2 ();		// { dg-error "without late return type" }
+int f3 () -> int;	// { dg-error "late return type" }
+auto *f4 () -> int;	// { dg-error "late return type" }
+
+struct A
+{
+  auto f5 () const -> int;
+  auto f6 ();		// { dg-error "without late return type" }
+  int f7 () -> int;	// { dg-error "late return type" }
+  auto *f8 () -> int;	// { dg-error "late return type" }
+};
Index: gcc/testsuite/g++.dg/cpp0x/fntmpdefarg1.C
===================================================================
--- gcc/testsuite/g++.dg/cpp0x/fntmpdefarg1.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/cpp0x/fntmpdefarg1.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,7 @@
+// PR c++/37766
+// { dg-options -std=c++0x }
+
+int a = 1;
+template<int& b = a> void f() {
+  f<>();
+}
Index: gcc/testsuite/g++.dg/cpp0x/trailing3.C
===================================================================
--- gcc/testsuite/g++.dg/cpp0x/trailing3.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/cpp0x/trailing3.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,63 @@
+// More auto/decltype mangling tests.
+// { dg-options "-std=c++0x" }
+
+template <class T>
+struct B
+{
+  static int i;
+};
+
+int&& x();
+
+template <class T>
+struct A
+{
+  static int i;
+  static int &ir;
+  static int &&irr;
+  template <class U>
+  auto f(U u) -> decltype (u + i);
+  template <class U>
+  auto fr(U u) -> decltype (u + ir);
+  template <class U>
+  auto frr(U u) -> decltype (u + irr);
+  template <class U>
+  auto g(U u) -> decltype (u + sizeof (i));
+  template <class U>
+  auto h(U u) -> decltype (u + B<U>::i);
+  template <class U>
+  auto j(U u) -> decltype (u + x());
+};
+
+template<class T> template<class U>
+auto A<T>::f(U u) -> decltype (u + i)
+{
+  return u + i;
+}
+
+template <class... Args>
+int f (Args... args);
+
+template <class... Args>
+auto g (Args... args) -> decltype (f ((args+1)...))
+{
+  return (f ((args+1)...));
+}
+
+int main()
+{
+  // { dg-final { scan-assembler  "_ZN1AIiE1fIiEEDTplfp_L_ZNS0_1iEEET_" } }
+  A<int>().f(1);
+  // { dg-final { scan-assembler  "_ZN1AIiE2frIiEEDTplfp_L_ZNS0_2irEEET_" } }
+  A<int>().fr(1);
+  // { dg-final { scan-assembler  "_ZN1AIiE3frrIiEEDTplfp_L_ZNS0_3irrEEET_" } }
+  A<int>().frr(1);
+  // { dg-final { scan-assembler  "_ZN1AIiE1gIiEEDTplfp_szL_ZNS0_1iEEET_" } }
+  A<int>().g(1);
+  // { dg-final { scan-assembler  "_ZN1AIiE1hIiEEDTplfp_sr1BIT_E1iES3_" } }
+  A<int>().h(1);
+  // { dg-final { scan-assembler  "_ZN1AIiE1jIiEEDTplfp_clL_Z1xvEEET_" } }
+  A<int>().j(1);
+  // { dg-final { scan-assembler  "_Z1gIIidEEDTcl1fspplfp_Li1EEEDpT_" } }  
+  g(42, 1.0);
+}
Index: gcc/testsuite/g++.dg/cpp0x/variadic98.C
===================================================================
--- gcc/testsuite/g++.dg/cpp0x/variadic98.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/cpp0x/variadic98.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,411 @@
+// PR c++/42358
+// { dg-do assemble }
+// { dg-options -std=c++0x }
+
+typedef __PTRDIFF_TYPE__ ptrdiff_t;
+typedef __SIZE_TYPE__ size_t;
+namespace std __attribute__ ((__visibility__ ("default"))) {
+    using ::size_t;
+}
+namespace std __attribute__ ((__visibility__ ("default"))) {
+    struct __sfinae_types   {
+	typedef char __one;
+	typedef struct {
+	} __two;
+    };
+    template<typename _Tp, _Tp __v>     struct integral_constant     {
+	static const _Tp value = __v;
+	typedef _Tp value_type;
+	typedef integral_constant<_Tp, __v> type;
+    };
+    typedef integral_constant<bool, false> false_type;
+    template<typename>     struct remove_cv;
+    template<typename>     struct __is_void_helper     : public false_type {
+    };
+    template<typename _Tp>     struct is_void     : public integral_constant<bool, (__is_void_helper<typename           remove_cv<_Tp>::type>::value)>     {
+    };
+    template<typename>     struct is_array     : public false_type {
+    };
+    template<typename>     struct is_function     : public false_type {
+    };
+    template<typename, unsigned _Uint = 0>     struct extent     : public integral_constant<std::size_t, 0> {
+    };
+    template<typename _Tp>     struct remove_const     {
+	typedef _Tp type;
+    };
+    template<typename _Tp>     struct remove_volatile     {
+	typedef _Tp type;
+    };
+    template<typename _Tp>     struct remove_cv     {
+	typedef typename       remove_const<typename remove_volatile<_Tp>::type>::type type;
+    };
+    template<typename>     struct is_lvalue_reference     : public false_type {
+    };
+    template<typename>     struct is_rvalue_reference     : public false_type {
+    };
+    template<typename _Tp>     struct is_reference     : public integral_constant<bool, (is_lvalue_reference<_Tp>::value           || is_rvalue_reference<_Tp>::value)>     {
+    };
+    template<typename _Tp>     struct remove_reference     {
+	typedef _Tp type;
+    };
+    template<typename _Tp,     bool = !is_reference<_Tp>::value && !is_void<_Tp>::value>     struct __add_rvalue_reference_helper     {
+	typedef _Tp type;
+    };
+    template<typename _Tp>     struct add_rvalue_reference     : public __add_rvalue_reference_helper<_Tp>     {
+    };
+    template<typename _Tp>     typename add_rvalue_reference<_Tp>::type declval();
+    template<typename _From, typename _To,     bool = (is_void<_From>::value || is_void<_To>::value      || is_function<_To>::value || is_array<_To>::value)>     struct __is_convertible_helper     {
+    };
+    template<typename _From, typename _To>     struct __is_convertible_helper<_From, _To, false>     : public __sfinae_types     {
+	static __one __test(_To);
+	static __two __test(...);
+	static const bool __value = sizeof(__test(declval<_From>())) == 1;
+    };
+    template<typename _From, typename _To>     struct is_convertible     : public integral_constant<bool,           __is_convertible_helper<_From, _To>::__value>     {
+    };
+    template<bool, typename _Tp = void>     struct enable_if     {
+    };
+    template<typename _Tp>     struct enable_if<true, _Tp>     {
+	typedef _Tp type;
+    };
+    template<typename _Tp>     struct identity     {
+	typedef _Tp type;
+    };
+    template<typename _Tp>     inline typename enable_if<!is_lvalue_reference<_Tp>::value, _Tp&&>::type     forward(typename std::identity<_Tp>::type& __t)     {
+    }
+    template<typename _Tp>     inline typename enable_if<is_lvalue_reference<_Tp>::value, _Tp>::type     forward(typename std::identity<_Tp>::type __t)     {
+    }
+    template<typename _Tp>     inline typename std::remove_reference<_Tp>::type&&     move(_Tp&& __t)     {
+    }
+    template<class _T1, class _T2>     struct pair     {
+	typedef _T1 first_type;
+	typedef _T2 second_type;
+	_T1 first;
+	_T2 second;
+	template<class _U1, class = typename         std::enable_if<std::is_convertible<_U1, _T1>::value>::type>         pair(_U1&& __x, const _T2& __y)  : first(std::forward<_U1>(__x)),    second(__y) {
+	}
+	template<class _U2, class = typename         std::enable_if<std::is_convertible<_U2, _T2>::value>::type>         pair(const _T1& __x, _U2&& __y)  : first(__x),    second(std::forward<_U2>(__y)) {
+	}
+	template<class _U1, class _U2, class = typename         std::enable_if<std::is_convertible<_U1, _T1>::value          && std::is_convertible<_U2, _T2>::value>::type>         pair(_U1&& __x, _U2&& __y)  : first(std::forward<_U1>(__x)),    second(std::forward<_U2>(__y)) {
+	}
+	template<class _U1, class _U2>         pair(pair<_U1, _U2>&& __p)  : first(std::move(__p.first)),    second(std::move(__p.second)) {
+	}
+	template<class _U1, class _U2>         pair&         operator=(pair<_U1, _U2>&& __p)  {
+	}
+    };
+    struct input_iterator_tag {
+    };
+    struct output_iterator_tag {
+    };
+    struct forward_iterator_tag : public input_iterator_tag {
+    };
+    struct bidirectional_iterator_tag : public forward_iterator_tag {
+    };
+    template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,            typename _Pointer = _Tp*, typename _Reference = _Tp&>     struct iterator     {
+	typedef _Category iterator_category;
+	typedef _Tp value_type;
+	typedef _Distance difference_type;
+	typedef _Pointer pointer;
+	typedef _Reference reference;
+    };
+    template<typename _Iterator>     struct iterator_traits     {
+	typedef typename _Iterator::iterator_category iterator_category;
+	typedef typename _Iterator::value_type value_type;
+	typedef typename _Iterator::difference_type difference_type;
+	typedef typename _Iterator::pointer pointer;
+	typedef typename _Iterator::reference reference;
+    };
+    template<typename _Iter>     inline typename iterator_traits<_Iter>::iterator_category     __iterator_category(const _Iter&)     {
+    }
+    template<typename _InputIterator>     inline typename iterator_traits<_InputIterator>::difference_type     __distance(_InputIterator __first, _InputIterator __last,                input_iterator_tag)     {
+    }
+    template<typename _InputIterator>     inline typename iterator_traits<_InputIterator>::difference_type     distance(_InputIterator __first, _InputIterator __last)     {
+	return std::__distance(__first, __last,         std::__iterator_category(__first));
+    }
+    template<typename _Iterator>     class reverse_iterator     : public iterator<typename iterator_traits<_Iterator>::iterator_category,         typename iterator_traits<_Iterator>::value_type,         typename iterator_traits<_Iterator>::difference_type,         typename iterator_traits<_Iterator>::pointer,                       typename iterator_traits<_Iterator>::reference>     {
+    };
+    template<typename _Container>     class back_insert_iterator     : public iterator<output_iterator_tag, void, void, void, void>     {
+    };
+}
+namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {
+    template<typename _Tp>     class new_allocator     {
+    public:
+	typedef size_t size_type;
+	typedef ptrdiff_t difference_type;
+	typedef _Tp* pointer;
+	typedef const _Tp* const_pointer;
+	typedef _Tp& reference;
+	typedef const _Tp& const_reference;
+	typedef _Tp value_type;
+	new_allocator() throw() {
+	}
+	new_allocator(const new_allocator&) throw() {
+	}
+	template<typename _Tp1>         new_allocator(const new_allocator<_Tp1>&) throw() {
+	}
+	template<typename... _Args>         void         construct(pointer __p, _Args&&... __args)  {
+	}
+    };
+}
+namespace std __attribute__ ((__visibility__ ("default"))) {
+    template<typename _Tp>     class allocator: public __gnu_cxx::new_allocator<_Tp>     {
+    public:
+	typedef size_t size_type;
+	typedef ptrdiff_t difference_type;
+	typedef _Tp* pointer;
+	typedef const _Tp* const_pointer;
+	typedef _Tp& reference;
+	typedef const _Tp& const_reference;
+	typedef _Tp value_type;
+	template<typename _Tp1>         struct rebind         {
+	    typedef allocator<_Tp1> other;
+	};
+	allocator() throw() {
+	}
+	template<typename _Tp1>         allocator(const allocator<_Tp1>&) throw() {
+	}
+    };
+    extern template class allocator<char>;
+    extern template class allocator<wchar_t>;
+    template<typename _Arg, typename _Result>     struct unary_function     {
+	typedef _Arg argument_type;
+	typedef _Result result_type;
+    };
+    template<typename _Arg1, typename _Arg2, typename _Result>     struct binary_function     {
+	typedef _Arg1 first_argument_type;
+	typedef _Arg2 second_argument_type;
+	typedef _Result result_type;
+    };
+    template<typename _Tp>     struct less : public binary_function<_Tp, _Tp, bool>     {
+	bool       operator()(const _Tp& __x, const _Tp& __y) const       {
+	}
+    };
+    template<typename _Pair>     struct _Select1st : public unary_function<_Pair,            typename _Pair::first_type>     {
+	const typename _Pair::first_type&       operator()(const _Pair& __x) const       {
+	}
+    };
+    struct _Rb_tree_node_base   {
+	typedef _Rb_tree_node_base* _Base_ptr;
+	typedef const _Rb_tree_node_base* _Const_Base_ptr;
+    };
+    template<typename _Val>     struct _Rb_tree_node : public _Rb_tree_node_base     {
+	typedef _Rb_tree_node<_Val>* _Link_type;
+	_Val _M_value_field;
+	template<typename... _Args>         _Rb_tree_node(_Args&&... __args)  : _Rb_tree_node_base(),    _M_value_field(std::forward<_Args>(__args)...) {
+	}
+    };
+    template<typename _Tp>     struct _Rb_tree_iterator     {
+	typedef _Tp value_type;
+	typedef _Tp& reference;
+	typedef _Tp* pointer;
+	typedef bidirectional_iterator_tag iterator_category;
+	typedef ptrdiff_t difference_type;
+	typedef _Rb_tree_iterator<_Tp> _Self;
+	typedef _Rb_tree_node_base::_Base_ptr _Base_ptr;
+	typedef _Rb_tree_node<_Tp>* _Link_type;
+	_Base_ptr _M_node;
+    };
+    template<typename _Tp>     struct _Rb_tree_const_iterator     {
+	typedef _Tp value_type;
+	typedef const _Tp& reference;
+	typedef const _Tp* pointer;
+	typedef _Rb_tree_iterator<_Tp> iterator;
+	typedef bidirectional_iterator_tag iterator_category;
+	typedef ptrdiff_t difference_type;
+	typedef _Rb_tree_const_iterator<_Tp> _Self;
+	typedef _Rb_tree_node_base::_Const_Base_ptr _Base_ptr;
+	typedef const _Rb_tree_node<_Tp>* _Link_type;
+	explicit       _Rb_tree_const_iterator(_Link_type __x)       : _M_node(__x) {
+	}
+	_Rb_tree_const_iterator(const iterator& __it)       : _M_node(__it._M_node) {
+	}
+	_Base_ptr _M_node;
+    };
+    template<typename _Key, typename _Val, typename _KeyOfValue,            typename _Compare, typename _Alloc = allocator<_Val> >     class _Rb_tree     {
+	typedef typename _Alloc::template rebind<_Rb_tree_node<_Val> >::other               _Node_allocator;
+	typedef _Rb_tree_node_base* _Base_ptr;
+	typedef const _Rb_tree_node_base* _Const_Base_ptr;
+    public:
+	typedef _Key key_type;
+	typedef _Val value_type;
+	typedef value_type* pointer;
+	typedef const value_type* const_pointer;
+	typedef value_type& reference;
+	typedef const value_type& const_reference;
+	typedef _Rb_tree_node<_Val>* _Link_type;
+	typedef const _Rb_tree_node<_Val>* _Const_Link_type;
+	typedef size_t size_type;
+	typedef ptrdiff_t difference_type;
+	typedef _Alloc allocator_type;
+	_Node_allocator&       _M_get_Node_allocator()       {
+	}
+	_Link_type       _M_get_node()       {
+	}
+	template<typename... _Args>         _Link_type         _M_create_node(_Args&&... __args)  {
+	    _Link_type __tmp = _M_get_node();
+	    try      {
+		_M_get_Node_allocator().construct(__tmp,           std::forward<_Args>(__args)...);
+	    }
+	    catch(...)      {
+	    }
+	}
+	template<typename _Key_compare,         bool _Is_pod_comparator = __is_pod(_Key_compare)>         struct _Rb_tree_impl : public _Node_allocator         {
+	    _Key_compare _M_key_compare;
+	    _Rb_tree_node_base _M_header;
+	    size_type _M_node_count;
+	    _Rb_tree_impl(const _Key_compare& __comp, const _Node_allocator& __a)    : _Node_allocator(__a), _M_key_compare(__comp), _M_header(),      _M_node_count(0)    {
+	    }
+	    void    _M_initialize()    {
+	    }
+	};
+	_Rb_tree_impl<_Compare> _M_impl;
+	_Base_ptr&       _M_rightmost()       {
+	}
+	_Link_type       _M_begin()       {
+	}
+	_Link_type       _M_end()       {
+	}
+	_Const_Link_type       _M_end() const       {
+	}
+	static _Link_type       _S_right(_Base_ptr __x)       {
+	}
+	static const_reference       _S_value(_Const_Base_ptr __x)       {
+	}
+	static const _Key&       _S_key(_Const_Base_ptr __x)       {
+	    return _KeyOfValue()(_S_value(__x));
+	}
+	typedef _Rb_tree_iterator<value_type> iterator;
+	typedef _Rb_tree_const_iterator<value_type> const_iterator;
+	typedef std::reverse_iterator<iterator> reverse_iterator;
+	typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
+	iterator       _M_insert_(_Const_Base_ptr __x, _Const_Base_ptr __y,    const value_type& __v);
+	iterator       _M_insert_lower(_Base_ptr __x, _Base_ptr __y, const value_type& __v);
+	iterator       _M_insert_equal_lower(const value_type& __x);
+	iterator       _M_lower_bound(_Link_type __x, _Link_type __y,        const _Key& __k);
+	iterator       _M_upper_bound(_Link_type __x, _Link_type __y,        const _Key& __k);
+	_Rb_tree(const _Compare& __comp,         const allocator_type& __a = allocator_type())       : _M_impl(__comp, __a) {
+	}
+	iterator       end()       {
+	}
+	iterator       _M_insert_equal_(const_iterator __position, const value_type& __x);
+	template<typename _InputIterator>         void         _M_insert_unique(_InputIterator __first, _InputIterator __last);
+	template<typename _InputIterator>         void         _M_insert_equal(_InputIterator __first, _InputIterator __last);
+	size_type       count(const key_type& __k) const;
+	pair<iterator, iterator>       equal_range(const key_type& __k);
+	pair<const_iterator, const_iterator>       equal_range(const key_type& __k) const;
+    };
+    template<typename _Key, typename _Val, typename _KeyOfValue,            typename _Compare, typename _Alloc>     typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::     _M_insert_(_Const_Base_ptr __x, _Const_Base_ptr __p, const _Val& __v)     {
+	_Link_type __z = _M_create_node(__v);
+    }
+    template<typename _Key, typename _Val, typename _KeyOfValue,            typename _Compare, typename _Alloc>     typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::     _M_insert_lower(_Base_ptr __x, _Base_ptr __p, const _Val& __v)     {
+	_Link_type __z = _M_create_node(__v);
+    }
+    template<typename _Key, typename _Val, typename _KeyOfValue,            typename _Compare, typename _Alloc>     typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::     _M_insert_equal_lower(const _Val& __v)     {
+	_Link_type __x = _M_begin();
+	_Link_type __y = _M_end();
+	return _M_insert_lower(__x, __y, __v);
+    }
+    template<typename _Key, typename _Val, typename _KeyOfValue,            typename _Compare, typename _Alloc>     pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,       _Compare, _Alloc>::iterator,   typename _Rb_tree<_Key, _Val, _KeyOfValue,       _Compare, _Alloc>::iterator>     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::     equal_range(const _Key& __k)     {
+	_Link_type __x = _M_begin();
+	_Link_type __y = _M_end();
+	while (__x != 0)  {
+	    if (_M_impl._M_key_compare(_S_key(__x), __k))      __x = _S_right(__x);
+	    else      {
+		_Link_type __xu(__x), __yu(__y);
+		return pair<iterator,             iterator>(_M_lower_bound(__x, __y, __k),         _M_upper_bound(__xu, __yu, __k));
+	    }
+	}
+    }
+    template<typename _Key, typename _Val, typename _KeyOfValue,            typename _Compare, typename _Alloc>     pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,       _Compare, _Alloc>::const_iterator,   typename _Rb_tree<_Key, _Val, _KeyOfValue,       _Compare, _Alloc>::const_iterator>     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::     equal_range(const _Key& __k) const     {
+	_Const_Link_type __y = _M_end();
+	return pair<const_iterator, const_iterator>(const_iterator(__y),         const_iterator(__y));
+    }
+    template<typename _Key, typename _Val, typename _KeyOfValue,            typename _Compare, typename _Alloc>     typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::     _M_insert_equal_(const_iterator __position, const _Val& __v)     {
+	if (__position._M_node == _M_end())  {
+	    if (__position._M_node == _M_rightmost())      return _M_insert_(0, _M_rightmost(), __v);
+	    else      return _M_insert_equal_lower(__v);
+	}
+    }
+    template<typename _Key, typename _Val, typename _KoV,            typename _Cmp, typename _Alloc>     template<class _II>       void       _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::       _M_insert_equal(_II __first, _II __last)       {
+	for (;
+	     __first != __last;
+	     ++__first)    _M_insert_equal_(end(), *__first);
+    }
+    template<typename _Key, typename _Val, typename _KeyOfValue,            typename _Compare, typename _Alloc>     typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::     count(const _Key& __k) const     {
+	pair<const_iterator, const_iterator> __p = equal_range(__k);
+	const size_type __n = std::distance(__p.first, __p.second);
+    }
+    template<class _E>     class initializer_list     {
+    public:
+	typedef _E value_type;
+	typedef const _E& reference;
+	typedef const _E& const_reference;
+	typedef size_t size_type;
+	typedef const _E* iterator;
+	typedef const _E* const_iterator;
+	iterator _M_array;
+	size_type _M_len;
+	initializer_list(const_iterator __a, size_type __l)       : _M_array(__a), _M_len(__l) {
+	}
+	const_iterator       begin() const {
+	}
+	const_iterator       end() const {
+	}
+    };
+    template <typename _Key, typename _Tp,      typename _Compare = std::less<_Key>,      typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >     class multimap     {
+	typedef _Key key_type;
+	typedef _Tp mapped_type;
+	typedef std::pair<const _Key, _Tp> value_type;
+	typedef _Compare key_compare;
+	typedef _Alloc allocator_type;
+	typedef typename _Alloc::value_type _Alloc_value_type;
+	typedef typename _Alloc::template rebind<value_type>::other         _Pair_alloc_type;
+	typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,          key_compare, _Pair_alloc_type> _Rep_type;
+	_Rep_type _M_t;
+    public:
+	typedef typename _Pair_alloc_type::pointer pointer;
+	typedef typename _Pair_alloc_type::const_pointer const_pointer;
+	typedef typename _Pair_alloc_type::reference reference;
+	typedef typename _Pair_alloc_type::const_reference const_reference;
+	typedef typename _Rep_type::iterator iterator;
+	typedef typename _Rep_type::const_iterator const_iterator;
+	typedef typename _Rep_type::size_type size_type;
+	typedef typename _Rep_type::difference_type difference_type;
+	typedef typename _Rep_type::reverse_iterator reverse_iterator;
+	typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
+	multimap(initializer_list<value_type> __l,         const _Compare& __comp = _Compare(),         const allocator_type& __a = allocator_type())       : _M_t(__comp, __a)       {
+	    _M_t._M_insert_equal(__l.begin(), __l.end());
+	}
+	template<typename _InputIterator>         multimap(_InputIterator __first, _InputIterator __last)  : _M_t()         {
+	}
+	template<typename _InputIterator>         multimap(_InputIterator __first, _InputIterator __last,    const _Compare& __comp,    const allocator_type& __a = allocator_type())         : _M_t(__comp, __a)         {
+	}
+	template<typename _InputIterator>         void         insert(_InputIterator __first, _InputIterator __last)         {
+	}
+	size_type       count(const key_type& __x) const       {
+	    return _M_t.count(__x);
+	}
+	std::pair<iterator, iterator>       equal_range(const key_type& __x)       {
+	    return _M_t.equal_range(__x);
+	}
+	template<typename _K1, typename _T1, typename _C1, typename _A1>         friend bool         operator==(const multimap<_K1, _T1, _C1, _A1>&,      const multimap<_K1, _T1, _C1, _A1>&);
+	template<typename _K1, typename _T1, typename _C1, typename _A1>         friend bool         operator<(const multimap<_K1, _T1, _C1, _A1>&,     const multimap<_K1, _T1, _C1, _A1>&);
+    };
+}
+extern "C" {
+    extern void __assert_fail (__const char *__assertion, __const char *__file,       unsigned int __line, __const char *__function)      throw () __attribute__ ((__noreturn__));
+}
+using namespace std;
+int test01() {
+    typedef multimap<int,double> Container;
+    typedef Container::iterator iterator;
+    typedef pair<iterator,iterator> itpair;
+    Container m({
+		{
+		1, 1.0 }
+		}
+	       );
+    itpair ip = m.equal_range(1);
+    ((distance(ip.first, ip.second) == 3) ? static_cast<void> (0) : __assert_fail ("distance(ip.first, ip.second) == 3", "/home/richard/src/trunk/libstdc++-v3/testsuite/23_containers/multimap/init-list.cc", 36, __PRETTY_FUNCTION__));
+    ((m.count(7) == 2) ? static_cast<void> (0) : __assert_fail ("m.count(7) == 2", "/home/richard/src/trunk/libstdc++-v3/testsuite/23_containers/multimap/init-list.cc", 54, __PRETTY_FUNCTION__));
+}
Index: gcc/testsuite/g++.dg/cpp0x/trailing4.C
===================================================================
--- gcc/testsuite/g++.dg/cpp0x/trailing4.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/cpp0x/trailing4.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,11 @@
+// PR c++/38597
+// { dg-options "-std=c++0x" }
+
+template<class T, class U>
+auto f(T,U) -> decltype(T() + U())
+{ return T() + U(); }
+
+template<class T> void g(T){}
+
+int main() { g(f); }		// { dg-error "no matching function" }
+
Index: gcc/testsuite/g++.dg/cpp0x/initlist25.C
===================================================================
--- gcc/testsuite/g++.dg/cpp0x/initlist25.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/cpp0x/initlist25.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,17 @@
+// PR c++/41754
+// { dg-options -std=c++0x }
+// { dg-do run }
+
+#include <map>
+#include <string>
+#include <iostream>
+
+using namespace std;
+
+int main()
+{
+        map<string, string> m;
+        m.insert({{"t", "t"}, {"y", "y"}});
+
+        return 0;
+}
Index: gcc/testsuite/g++.dg/cpp0x/vt-40092.C
===================================================================
--- gcc/testsuite/g++.dg/cpp0x/vt-40092.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/cpp0x/vt-40092.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,21 @@
+// { dg-do "compile" }
+// { dg-options "-std=c++0x" }
+
+template <typename... Types> struct package {};
+
+template <int ArgGen> struct wrapper_gen {};
+
+template <int ArgNest> struct wrapper_nest
+{
+  typedef wrapper_gen<ArgNest> type_nest;
+};
+
+template <int... ArgPack>
+struct wrapper_pack
+{
+  typedef package<wrapper_gen <ArgPack>...> type_pack;
+  // incorrect error: expansion pattern 'wrapper_gen<ArgNest>'
+  //    contains no argument packs
+};
+
+
Index: gcc/testsuite/g++.dg/cpp0x/inline-ns3.C
===================================================================
--- gcc/testsuite/g++.dg/cpp0x/inline-ns3.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/cpp0x/inline-ns3.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,24 @@
+namespace C
+{
+  void f();
+}
+
+namespace B
+{
+  using namespace C;
+
+  inline namespace B1
+  {
+    void f();
+  }
+}
+
+namespace A
+{
+  using namespace B;
+}
+
+int main()
+{
+  A::f();
+}
Index: gcc/testsuite/g++.dg/cpp0x/trailing5.C
===================================================================
--- gcc/testsuite/g++.dg/cpp0x/trailing5.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/cpp0x/trailing5.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,10 @@
+// PR c++/38798, DR 770
+// { dg-options -std=c++0x }
+
+struct A {};
+auto foo() -> struct A {}
+
+enum B {};
+auto bar() -> enum B {}
+
+auto baz() -> struct C {} {}	// { dg-error "" }
Index: gcc/testsuite/g++.dg/cpp0x/initlist26.C
===================================================================
--- gcc/testsuite/g++.dg/cpp0x/initlist26.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/cpp0x/initlist26.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,10 @@
+// PR c++/42059
+// { dg-do compile }
+// { dg-options "-std=gnu++0x" }
+
+void
+foo (int i)
+{
+  int a[i];
+  a = { }; // { dg-error "may not be initialized" }
+}
Index: gcc/testsuite/g++.dg/cpp0x/initlist27.C
===================================================================
--- gcc/testsuite/g++.dg/cpp0x/initlist27.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/cpp0x/initlist27.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,5 @@
+// PR c++/42061
+// { dg-do compile }
+// { dg-options "-std=c++0x" }
+
+int& i = { j };	// { dg-error "invalid initialization|was not declared" }
Index: gcc/testsuite/g++.dg/cpp0x/rv-reinterpret.C
===================================================================
--- gcc/testsuite/g++.dg/cpp0x/rv-reinterpret.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/cpp0x/rv-reinterpret.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,11 @@
+// { dg-options -std=c++0x }
+// { dg-do compile }
+
+void f(int &);
+void f(int &&ir) { ir = 42; }
+int main()
+{
+  int x;
+  f(reinterpret_cast<int&&>(x));
+  return (x != 42);
+}
Index: gcc/testsuite/g++.dg/abi/mangle14.C
===================================================================
--- gcc/testsuite/g++.dg/abi/mangle14.C	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/g++.dg/abi/mangle14.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,5 +1,6 @@
 // { dg-do compile }
 // { dg-options "-Wabi -fabi-version=1" }
+// { dg-final { scan-assembler "_Z1g1SIXadsr1ANS0_1fIiEEivEE" } }
 
 struct A {
   template <typename T> int f ();
Index: gcc/testsuite/g++.dg/abi/mangle33.C
===================================================================
--- gcc/testsuite/g++.dg/abi/mangle33.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/abi/mangle33.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,19 @@
+// Testcase for mangling very long names.
+
+#define N \
+abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklm
+
+namespace N {
+  int i;
+}
+
+#undef N
+#define N \
+abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijk
+
+namespace N {
+  int j;
+}
+
+// { dg-final { scan-assembler "_ZN4043abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklm1iE" } }
+// { dg-final { scan-assembler "_ZN4041abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijk1jE" } }
Index: gcc/testsuite/g++.dg/abi/thunk5.C
===================================================================
--- gcc/testsuite/g++.dg/abi/thunk5.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/abi/thunk5.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,13 @@
+// PR c++/35067
+// The thunks should be weak even on targets without one-only support.
+// { dg-require-weak "" }
+// { dg-final { scan-assembler "weak.*ZTv" } }
+
+struct A
+{
+  virtual ~A() { }
+};
+
+struct B: virtual A { };
+
+B b;
Index: gcc/testsuite/g++.dg/abi/mangle34.C
===================================================================
--- gcc/testsuite/g++.dg/abi/mangle34.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/abi/mangle34.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,42 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin PR c++/40808
+// { dg-do compile }
+// This tests the mangling of empty template argument list in a template
+// id.
+// { dg-final {scan-assembler "_ZNK5DummyclI3GenEENT_3SigIE10ResultTypeERKS2_" } }
+
+
+struct Void {};
+
+template <class R> struct FunType {
+  typedef R ResultType;
+};
+
+struct WrongNumberOfSigArgs {};
+
+template <typename R> struct CFunType {
+  template <class Dummy1=Void, class Dummy2=Void> struct Sig : public
+FunType<WrongNumberOfSigArgs> {};
+  template <class Dummy> struct Sig<Void,Dummy> : public FunType<R> {};
+};
+
+struct Dummy {
+  template <typename F> typename F::template Sig<>::ResultType operator()(F
+const& f) const {
+    return typename F::template Sig<>::ResultType(0);
+  }
+};
+
+struct Gen: public CFunType<int> {
+  int operator()() const {return 0;}
+  Gen() {}
+};
+
+int myfunction() {
+  return Dummy()(Gen());
+}
+
+int main() {
+  myfunction();
+}
+
Index: gcc/testsuite/g++.dg/abi/regparm1.C
===================================================================
--- gcc/testsuite/g++.dg/abi/regparm1.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/abi/regparm1.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,51 @@
+// PR c++/29911 (9381)
+// { dg-options -std=c++0x }
+// { dg-do run { target i?86-*-* x86_64-*-* } }
+
+extern "C" int printf(const char *, ...);
+
+void *save_this;
+int *save_addr1, *save_addr2;
+
+int fail;
+
+struct Base
+{
+  __attribute((regparm(3))) void
+  set(int *addr1, int *addr2)
+  {
+    if (this != save_this)
+      {
+	++fail;
+	printf("error! this == %p, should be %p\n", this, save_this);
+      }
+    if (addr1 != save_addr1)
+      {
+	++fail;
+	printf("error! addr1 == %p, should be %p\n", addr1, save_addr1);
+      }
+    if (addr2 != save_addr2)
+      {
+	++fail;
+	printf("error! addr2 == %p, should be %p\n", addr2, save_addr1);
+      }
+  }
+};
+
+int main()
+{
+  void (__attribute((regparm(3))) Base::* pfm)(int *, int *) = &Base::set;
+  __typeof (&Base::set) pfm2 = &Base::set;
+  decltype (&Base::set) pfm3 = &Base::set;
+  auto pfm4 = &Base::set;
+
+  Base obj; save_this = &obj;
+  int x, y; save_addr1 = &x; save_addr2 = &y;
+
+  (obj.* pfm) (&x, &y);
+  (obj.* pfm2) (&x, &y);
+  (obj.* pfm3) (&x, &y);
+  (obj.* pfm4) (&x, &y);
+
+  return fail;
+}
Index: gcc/testsuite/g++.dg/abi/guard2.C
===================================================================
--- gcc/testsuite/g++.dg/abi/guard2.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/abi/guard2.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,16 @@
+// PR c++/41611
+// Test that the guard gets its own COMDAT group.
+// { dg-final { scan-assembler "_ZGVZN1A1fEvE1i,comdat" { target *-*-linux* } } }
+
+struct A {
+  static int f()
+  {
+    static int &i = *new int();
+    return i;
+  }
+};
+
+int main()
+{
+  return A::f();
+}
Index: gcc/testsuite/g++.dg/gomp/pr42234.C
===================================================================
--- gcc/testsuite/g++.dg/gomp/pr42234.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/gomp/pr42234.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,19 @@
+// PR c++/42234
+// { dg-do compile }
+// { dg-options "-fopenmp" }
+
+extern int foo (void);
+
+void
+bar (int x)
+{
+  #pragma omp critical
+    {
+      int j;
+      for (j = 0; j < foo (); j++)
+	;
+      if (0)
+        if (x >= 4)
+	  ;
+    }
+}
Index: gcc/testsuite/g++.dg/gomp/pr41967.C
===================================================================
--- gcc/testsuite/g++.dg/gomp/pr41967.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/gomp/pr41967.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,17 @@
+// PR c++/41967
+// { dg-do compile }
+// { dg-options "-fopenmp" }
+
+int
+foo ()
+{
+  int sum = 0;
+#pragma omp for collapse(2)
+  for (int i = 0; i < 5; ++i)
+    {
+      for (int j = 0; j < 5; ++j)
+	++sum;
+      ++sum;	// { dg-error "collapsed loops not perfectly nested" }
+    }
+  return sum;
+}
Index: gcc/testsuite/g++.dg/inherit/thunk11.h
===================================================================
--- gcc/testsuite/g++.dg/inherit/thunk11.h	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/inherit/thunk11.h	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,16 @@
+struct A
+{
+  A () {}
+  virtual ~A () {}
+};
+struct B
+{
+  B () {}
+  virtual ~B () {}
+};
+struct C : public A, public B
+{
+  virtual void foo ();
+  virtual ~C () {};
+};
+inline void C::foo () {}
Index: gcc/testsuite/g++.dg/inherit/thunk11-aux.cc
===================================================================
--- gcc/testsuite/g++.dg/inherit/thunk11-aux.cc	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/inherit/thunk11-aux.cc	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,4 @@
+// { dg-do compile }
+// { dg-options "-O2" }
+
+#include "thunk11.h"
Index: gcc/testsuite/g++.dg/inherit/thunk11.C
===================================================================
--- gcc/testsuite/g++.dg/inherit/thunk11.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/inherit/thunk11.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,11 @@
+// PR c++/42256
+// { dg-do link }
+// { dg-additional-sources "thunk11-aux.cc" }
+// { dg-options "-O2" }
+
+#include "thunk11.h"
+
+int
+main ()
+{
+}
Index: gcc/testsuite/g++.dg/init/static-init2.C
===================================================================
--- gcc/testsuite/g++.dg/init/static-init2.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/init/static-init2.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,3 @@
+// PR c++/36912
+// { dg-options -frounding-math }
+const double c = .1, d = c+1;
Index: gcc/testsuite/g++.dg/torture/pr42704.C
===================================================================
--- gcc/testsuite/g++.dg/torture/pr42704.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/torture/pr42704.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,44 @@
+/* { dg-do compile } */
+
+typedef int PRInt32;
+class nsTreeRows {
+    class Subtree { };
+    enum { kMaxDepth = 32 };
+    struct Link {
+        Subtree* mParent;
+        PRInt32 mChildIndex;
+        Link&         operator=(const Link& aLink) {
+            mParent = aLink.mParent;
+            mChildIndex = aLink.mChildIndex;
+        }
+    };
+    class iterator {
+        PRInt32 mTop;
+        PRInt32 mRowIndex;
+        Link mLink[kMaxDepth];
+    public:
+        iterator() : mTop(-1), mRowIndex(-1) { }
+        iterator& operator=(const iterator& aIterator);
+    };
+    Subtree*     EnsureSubtreeFor(Subtree* aParent, PRInt32 aChildIndex);
+    Subtree*     GetSubtreeFor(const Subtree* aParent,
+PRInt32 aChildIndex,                   PRInt32* aSubtreeSize = 0);
+    void     InvalidateCachedRow() {
+        mLastRow = iterator();
+    }
+    iterator mLastRow;
+};
+nsTreeRows::Subtree* nsTreeRows::EnsureSubtreeFor(Subtree* aParent,
+                     PRInt32 aChildIndex) {
+    Subtree* subtree = GetSubtreeFor(aParent, aChildIndex);
+    if (! subtree) {
+        InvalidateCachedRow();
+    }
+}
+nsTreeRows::iterator& nsTreeRows::iterator::operator=(const iterator&
+aIterator) {
+    mTop = aIterator.mTop;
+    for (PRInt32 i = mTop;
+         i >= 0;
+         --i)         mLink[i] = aIterator.mLink[i];
+}
Index: gcc/testsuite/g++.dg/torture/pushpop_macro.C
===================================================================
--- gcc/testsuite/g++.dg/torture/pushpop_macro.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/torture/pushpop_macro.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,19 @@
+/* Do the preprocessor push_macro/pop_macro test.  */
+
+/* { dg-do run } */
+
+extern "C" void abort ();
+
+#define _ 2
+#pragma push_macro("_")
+#undef _
+#define _ 1
+#pragma pop_macro("_")
+
+int main ()
+{
+  if (_ != 2)
+    abort ();
+  return 0;
+}
+

Zmiany atrybutów dla: gcc/testsuite/g++.dg/torture/pushpop_macro.C
___________________________________________________________________
Dodane: svn:mime-type
   + text/plain
Dodane: svn:eol-style
   + native

Index: gcc/testsuite/g++.dg/torture/pr41183.C
===================================================================
--- gcc/testsuite/g++.dg/torture/pr41183.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/torture/pr41183.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,30 @@
+// PR c++/41183
+// { dg-do compile }
+
+void foo (const char *);
+
+template <int *>
+struct A
+{
+  template <typename T> A (const int &, T);
+  int i;
+};
+
+template <int *X>
+template <typename T>
+A<X>::A (const int &j, T) : i(j)
+{
+  foo (0);
+  foo (0);
+  foo (__PRETTY_FUNCTION__);
+}
+
+int N;
+
+struct B
+{
+  B ();
+  A<&N> a;
+};
+
+B::B() : a(N, 0) {}
Index: gcc/testsuite/g++.dg/torture/pr42357.C
===================================================================
--- gcc/testsuite/g++.dg/torture/pr42357.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/torture/pr42357.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,30 @@
+// { dg-do compile }
+typedef unsigned char uint8;
+typedef unsigned int uint32;
+class PixelARGB {
+public:
+    ~PixelARGB() throw() { }
+    PixelARGB (const uint32 argb_) throw() : argb (argb_)     { }
+    inline __attribute__((always_inline)) uint8 getRed() const throw() {
+	return components.r;
+    }
+    union     {
+	uint32 argb;
+	struct         {
+	    uint8 b, g, r, a;
+	} components;
+    };
+};
+class Colour {
+public:
+    Colour() throw() : argb (0) {};
+    uint8 getRed() const throw() {
+	return argb.getRed();
+    }
+    PixelARGB argb;
+};
+uint8 writeImage (void) {
+    Colour pixel;
+    pixel = Colour ();
+    return pixel.getRed();
+}
Index: gcc/testsuite/g++.dg/torture/pr42462.C
===================================================================
--- gcc/testsuite/g++.dg/torture/pr42462.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/torture/pr42462.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,47 @@
+/* { dg-do run } */
+
+#define INLINE inline __attribute__((always_inline))
+extern "C" void abort (void);
+
+template<class> struct Foo {
+        inline bool isFalse() { return false; }
+        template <bool>        void f1() {}
+        template <bool> INLINE void f2() { f1<false>(); }
+        template <bool>        void f3() { f2<false>(); }
+        template <bool> INLINE void f4() { f3<false>(); }
+        int exec2();
+        void execute();
+        inline void unused();
+};
+
+template<class T> inline void Foo<T>::unused() {
+        f4<true>();
+}
+
+static int counter = 0;
+
+template<class T> int Foo<T>::exec2() {
+        static void* table[2] = { &&begin, &&end };	
+	if (counter++ > 10)
+	  return 0;
+        goto *(table[0]);
+begin:
+        if (isFalse()) f1<false>();
+end:
+        return 1;
+}
+
+template<class T> void Foo<T>::execute() {
+        int r = 1;
+        while (r) { r = exec2(); }
+}
+
+template class Foo<int>;
+
+int main() {
+        Foo<int> c;
+        c.execute();
+	if (counter < 10)
+	  abort ();
+	return 0;
+}
Index: gcc/testsuite/g++.dg/torture/pr42183.C
===================================================================
--- gcc/testsuite/g++.dg/torture/pr42183.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/torture/pr42183.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,51 @@
+// { dg-do compile }
+
+class IntSize {
+public:
+    IntSize(int width, int height) : m_width(width), m_height(height) { }
+    int m_width, m_height;
+};
+class IntPoint {
+public:
+    IntPoint(int x, int y) : m_x(x), m_y(y) { }
+    int m_x, m_y;
+};
+class IntRect {
+public:
+    IntRect(int x, int y, int width, int height)
+        : m_location(IntPoint(x, y)), m_size(IntSize(width, height)) { }
+    void intersect(const IntRect&);
+    IntPoint m_location;
+    IntSize m_size;
+};
+inline IntRect intersection(const IntRect& a, const IntRect& b) {
+    IntRect c = a;
+    c.intersect(b);
+    return c;
+}
+class RenderObject  {
+public:
+    int contentWidth() const { }
+    int contentHeight() const { }
+    virtual int xPos() const { }
+    virtual int yPos() const { }
+    virtual int paddingTop() const;
+    virtual int paddingLeft() const;
+    virtual int borderTop() const { }
+    virtual int borderLeft() const { }
+};
+class RenderMenuList : public RenderObject {
+    virtual IntRect controlClipRect(int tx, int ty) const;
+    RenderObject* m_innerBlock;
+};
+IntRect RenderMenuList::controlClipRect(int tx, int ty) const {
+    IntRect outerBox(tx + borderLeft() + paddingLeft(),
+                     ty + borderTop() + paddingTop(),
+                     contentWidth(), contentHeight());
+    IntRect innerBox(tx + m_innerBlock->xPos() + m_innerBlock->paddingLeft(),
+                     ty + m_innerBlock->yPos() + m_innerBlock->paddingTop(),
+                     m_innerBlock->contentWidth(),
+                     m_innerBlock->contentHeight());
+    return intersection(outerBox, innerBox);
+}
+
Index: gcc/testsuite/g++.dg/torture/pr42760.C
===================================================================
--- gcc/testsuite/g++.dg/torture/pr42760.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/torture/pr42760.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,46 @@
+// PR middle-end/42760
+// { dg-do compile }
+
+template <typename T>
+struct A
+{
+  static T b (T it) { return it; }
+};
+
+template <typename T, typename U>
+static U
+baz (T x, T y, U z)
+{
+  for (long n = y - x; n > 0; --n)
+    {
+      *z = *x;
+      ++z;
+    }
+};
+
+template <typename T, typename U>
+U
+bar (T x, T y, U z)
+{
+  baz (A <T>::b (x), A <T>::b (y), A <U>::b (z));
+}
+
+struct C
+{
+  __complex__ float v;
+};
+
+template <class T>
+struct B
+{
+  B (T y[]) { bar (y, y + 1, x); }
+  operator T *() { return x; }
+  T x[1];
+};
+
+B <C>
+foo ()
+{
+  C y[1];
+  return B <C> (y);
+};
Index: gcc/testsuite/g++.dg/torture/pr41775.C
===================================================================
--- gcc/testsuite/g++.dg/torture/pr41775.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/torture/pr41775.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,284 @@
+/* { dg-do compile } */
+/* { dg-require-visibility "" } */
+
+typedef unsigned int size_t;
+namespace std __attribute__ ((__visibility__ ("default")))
+{
+  template < typename _Iterator > struct iterator_traits
+  {
+  };
+  template < typename _Tp > struct iterator_traits <_Tp * >
+  {
+    typedef _Tp & reference;
+  };
+}
+
+namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
+{
+  using std::iterator_traits;
+  template < typename _Iterator, typename _Container > class __normal_iterator
+  {
+  public:typedef _Iterator iterator_type;
+    typedef typename iterator_traits < _Iterator >::reference reference;
+    reference operator* () const
+    {
+    }
+    __normal_iterator operator++ (int)
+    {
+    }
+  };
+  template < typename _IteratorL, typename _IteratorR,
+    typename _Container > inline bool operator!= (const __normal_iterator <
+						  _IteratorL,
+						  _Container > &__lhs,
+						  const __normal_iterator <
+						  _IteratorR,
+						  _Container > &__rhs)
+  {
+  }
+}
+
+extern "C"
+{
+  extern "C"
+  {
+    __extension__ typedef __SIZE_TYPE__ __intptr_t;
+  }
+}
+namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
+{
+  template < typename _Tp > class new_allocator
+  {
+  public:typedef size_t size_type;
+    typedef _Tp *pointer;
+    template < typename _Tp1 > struct rebind
+    {
+      typedef new_allocator < _Tp1 > other;
+    };
+  };
+}
+
+namespace std __attribute__ ((__visibility__ ("default")))
+{
+template < typename _Tp > class allocator:public __gnu_cxx::new_allocator <
+    _Tp >
+  {
+  };
+}
+
+extern "C"
+{
+  typedef __intptr_t intptr_t;
+}
+namespace llvm
+{
+  template < typename NodeTy > class ilist_half_node
+  {
+  };
+template < typename NodeTy > class ilist_node:private ilist_half_node <
+    NodeTy >
+  {
+  };
+  class MachineBasicBlock;
+  class MachineOperand
+  {
+  public:enum MachineOperandType
+    {
+    }
+    Contents;
+    unsigned getReg () const
+    {
+    }
+  };
+  class TargetRegisterInfo;
+}
+
+namespace std __attribute__ ((__visibility__ ("default")))
+{
+  template < typename _Tp, typename _Alloc > struct _Vector_base
+  {
+    typedef typename _Alloc::template rebind < _Tp >::other _Tp_alloc_type;
+  };
+template < typename _Tp, typename _Alloc = std::allocator < _Tp > >class vector:protected _Vector_base < _Tp,
+    _Alloc
+    >
+  {
+    typedef _Vector_base < _Tp, _Alloc > _Base;
+    typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
+  public:typedef _Tp value_type;
+    typedef typename _Tp_alloc_type::pointer pointer;
+    typedef __gnu_cxx::__normal_iterator < pointer, vector > iterator;
+    iterator begin ()
+    {
+    }
+    iterator end ()
+    {
+    }
+  };
+}
+
+namespace llvm
+{
+  class MachineFunction;
+  class MachineInstr:public ilist_node < MachineInstr >
+  {
+  public:const MachineBasicBlock *getParent () const
+    {
+    }
+    const MachineOperand & getOperand (unsigned i) const
+    {
+    }
+    bool registerDefIsDead (unsigned Reg, const TargetRegisterInfo * TRI =
+			    __null) const
+    {
+    }
+  };
+  class AnalysisResolver;
+  class Pass
+  {
+    AnalysisResolver *Resolver;
+    intptr_t PassID;
+  public:  explicit Pass (intptr_t pid):Resolver (0), PassID (pid)
+    {
+    }
+    explicit Pass (const void *pid):Resolver (0), PassID ((intptr_t) pid)
+    {
+    }
+    template < typename AnalysisType > AnalysisType & getAnalysis () const;
+  };
+  class FunctionPass:public Pass
+  {
+  public:explicit FunctionPass (intptr_t pid):Pass (pid)
+    {
+    }
+    explicit FunctionPass (const void *pid):Pass (pid)
+    {
+    }
+  };
+  class PassInfo
+  {
+  public:typedef Pass *(*NormalCtor_t) ();
+  private:const char *const PassName;
+    const char *const PassArgument;
+    const intptr_t PassID;
+    const bool IsCFGOnlyPass;
+    const bool IsAnalysis;
+    const bool IsAnalysisGroup;
+    NormalCtor_t NormalCtor;
+  public:   PassInfo (const char *name, const char *arg, intptr_t pi, NormalCtor_t normal = 0, bool isCFGOnly = false, bool is_analysis = false):PassName (name), PassArgument (arg), PassID (pi),
+      IsCFGOnlyPass (isCFGOnly), IsAnalysis (is_analysis),
+      IsAnalysisGroup (false), NormalCtor (normal)
+    {
+    }
+  };
+  template < typename PassName > Pass * callDefaultCtor ()
+  {
+    return new PassName ();
+  }
+  template < typename passName > struct RegisterPass:public PassInfo
+  {
+  RegisterPass (const char *PassArg, const char *Name, bool CFGOnly = false, bool is_analysis = false):PassInfo (Name, PassArg, intptr_t (&passName::ID),
+	      PassInfo::NormalCtor_t (callDefaultCtor < passName >), CFGOnly,
+	      is_analysis)
+    {
+    }
+  };
+  template < typename T > class SmallVectorImpl
+  {
+  };
+  template < typename T,
+    unsigned N > class SmallVector:public SmallVectorImpl < T >
+  {
+  };
+  class MachineFunctionPass:public FunctionPass
+  {
+  protected:explicit MachineFunctionPass (intptr_t ID):FunctionPass (ID)
+    {
+    }
+    explicit MachineFunctionPass (void *ID):FunctionPass (ID)
+    {
+    }
+    virtual bool runOnMachineFunction (MachineFunction & MF) = 0;
+  };
+  class LiveIndex
+  {
+  private:unsigned index;
+  };
+  class VNInfo
+  {
+  };
+  struct LiveRange
+  {
+    LiveIndex start;
+    LiveIndex end;
+    VNInfo *valno;
+  };
+  class LiveInterval
+  {
+  public:typedef SmallVector < LiveRange, 4 > Ranges;
+    bool containsOneValue () const
+    {
+    }
+    LiveRange *getLiveRangeContaining (LiveIndex Idx)
+    {
+    }
+    void removeRange (LiveIndex Start, LiveIndex End, bool RemoveDeadValNo =
+		      false);
+    void removeRange (LiveRange LR, bool RemoveDeadValNo = false)
+    {
+      removeRange (LR.start, LR.end, RemoveDeadValNo);
+    }
+  };
+  class LiveIntervals:public MachineFunctionPass
+  {
+  public:static char ID;
+    LiveIndex getDefIndex (LiveIndex index)
+    {
+    }
+    LiveInterval & getInterval (unsigned reg)
+    {
+    }
+    LiveIndex getInstructionIndex (const MachineInstr * instr) const
+    {
+    }
+  };
+}
+
+using namespace llvm;
+namespace
+{
+struct __attribute__ ((visibility ("hidden"))) StrongPHIElimination:public
+    MachineFunctionPass
+  {
+    static char ID;
+  StrongPHIElimination ():MachineFunctionPass (&ID)
+    {
+    }
+    bool runOnMachineFunction (MachineFunction & Fn);
+  };
+}
+
+static RegisterPass < StrongPHIElimination > X ("strong-phi-node-elimination",
+						"Eliminate PHI nodes for register allocation, intelligently");
+bool
+StrongPHIElimination::runOnMachineFunction (MachineFunction & Fn)
+{
+  LiveIntervals & LI = getAnalysis < LiveIntervals > ();
+  std::vector < MachineInstr * >phis;
+  for (std::vector < MachineInstr * >::iterator I = phis.begin (), E =
+       phis.end (); I != E;)
+    {
+      MachineInstr *PInstr = *(I++);
+      unsigned DestReg = PInstr->getOperand (0).getReg ();
+      LiveInterval & PI = LI.getInterval (DestReg);
+      if (PInstr->registerDefIsDead (DestReg))
+	{
+	  if (PI.containsOneValue ())
+	    {
+	      LiveIndex idx =
+		LI.getDefIndex (LI.getInstructionIndex (PInstr));
+	      PI.removeRange (*PI.getLiveRangeContaining (idx), true);
+	    }
+	}
+    }
+}
Index: gcc/testsuite/g++.dg/torture/pr42883.C
===================================================================
--- gcc/testsuite/g++.dg/torture/pr42883.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/torture/pr42883.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,63 @@
+// { dg-do compile }
+
+typedef __SIZE_TYPE__ size_t;
+namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {
+    template<typename _Tp>     class new_allocator     {
+    public:
+	typedef size_t size_type;
+	typedef _Tp* pointer;
+	typedef _Tp& reference;
+	void       deallocate(pointer __p, size_type)       {
+	    ::operator delete(__p);
+	}
+    };
+}
+namespace std __attribute__ ((__visibility__ ("default"))) {
+    template<typename _Tp>     class allocator: public __gnu_cxx::new_allocator<_Tp>     {
+    public:
+	template<typename _Tp1>         struct rebind         {
+	    typedef allocator<_Tp1> other;
+	};
+    };
+    template<typename _Tp, typename _Alloc>     struct _Vector_base     {
+	typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;
+	struct _Vector_impl       : public _Tp_alloc_type       {
+	    typename _Tp_alloc_type::pointer _M_start;
+	    typename _Tp_alloc_type::pointer _M_end_of_storage;
+	};
+	~_Vector_base()       {
+	    _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage         - this->_M_impl._M_start);
+	}
+	_Vector_impl _M_impl;
+	void       _M_deallocate(typename _Tp_alloc_type::pointer __p, size_t __n)       {
+	    if (__p)    _M_impl.deallocate(__p, __n);
+	}
+    };
+    template<typename _Tp, typename _Alloc = std::allocator<_Tp> >     class vector : protected _Vector_base<_Tp, _Alloc>     {
+	typedef _Vector_base<_Tp, _Alloc> _Base;
+	typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
+    public:
+	typedef typename _Tp_alloc_type::reference reference;
+	typedef size_t size_type;
+	size_type       size() const       {
+	}
+	reference       operator[](size_type __n)       {
+	}
+    };
+};
+class vtkConvexPointSet  {
+public:
+    static vtkConvexPointSet *New();
+};
+void MakeInternalMesh() {
+    std::vector< int > tempFaces[2];
+    std::vector< int > firstFace;
+    int i, j, k;
+    for(i = 0; i < 1000; i++)     {
+	for(int pointCount = 0; pointCount < 1000; pointCount++) 	{
+	    for(j = 0; j < (int)tempFaces[0].size(); k++)
+	      if(tempFaces[0][j] == tempFaces[1][k]) 		break;
+	}
+	vtkConvexPointSet::New();
+    }
+}
Index: gcc/testsuite/g++.dg/torture/pr42110.C
===================================================================
--- gcc/testsuite/g++.dg/torture/pr42110.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/torture/pr42110.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,27 @@
+/* { dg-do compile } */
+bool foo();
+
+struct A
+{
+  A* fooA() { if (foo()) foo(); return this; }
+
+  virtual void barA(char);
+};
+
+template<int> struct B
+{
+  A *p, *q;
+
+  void fooB(char c) { p->fooA()->barA(c); }
+};
+
+template<int N> inline void bar(B<N> b) { b.fooB(0); }
+
+extern template void bar(B<0>);
+
+void (*f)(B<0>) = bar;
+
+void baz()
+{
+  B<0>().fooB(0);
+}
Index: gcc/testsuite/g++.dg/torture/pr42714.C
===================================================================
--- gcc/testsuite/g++.dg/torture/pr42714.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/torture/pr42714.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,37 @@
+struct QVectorData {
+    static QVectorData shared_null;
+};
+template <typename T> class QVector {
+    union {
+        QVectorData *d;
+    };
+public:
+    inline QVector() : d(&QVectorData::shared_null) { }
+    inline QVector(const QVector<T> &v) : d(v.d) { }
+};
+class QXmlStreamAttribute { };
+class QXmlStreamAttributes : public QVector<QXmlStreamAttribute> { };
+class __attribute__ ((visibility("default"))) Smoke {
+public:
+    union StackItem;
+    typedef StackItem* Stack;
+    typedef short Index;
+};
+class SmokeBinding { };
+namespace __smokeqt {
+    class x_QXmlStreamAttributes : public QXmlStreamAttributes {
+        SmokeBinding* _binding;
+    public:
+        static void x_11(Smoke::Stack x) {
+            x_QXmlStreamAttributes* xret = new x_QXmlStreamAttributes();
+        }
+        explicit x_QXmlStreamAttributes() : QXmlStreamAttributes() { }
+    };
+    void xcall_QXmlStreamAttributes(Smoke::Index xi, void *obj,
+                                    Smoke::Stack args)
+      {
+        switch(xi) {
+            case 11: x_QXmlStreamAttributes::x_11(args);
+        }
+      }
+}
Index: gcc/testsuite/g++.dg/torture/pr43068.C
===================================================================
--- gcc/testsuite/g++.dg/torture/pr43068.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/torture/pr43068.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-freorder-blocks -ftracer} */
+
+struct A {
+    virtual A *f();
+};
+struct B : virtual A {
+    virtual B *f();
+};
+B *B::f() { return 0; }
Index: gcc/testsuite/g++.dg/torture/pr42871.C
===================================================================
--- gcc/testsuite/g++.dg/torture/pr42871.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/torture/pr42871.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,40 @@
+struct C
+{
+  ~C ();
+  int c3;
+};
+
+C *b2;
+
+static void
+b1 (const C &x, unsigned b3, unsigned b4)
+{
+  unsigned i = 0;
+  for (; i < b3; i++)
+    if (i < b4)
+      {
+        b2[0].c3 = x.c3;
+        return;
+      }
+}
+
+int a ();
+
+void
+bar (unsigned b3, unsigned b4)
+{
+  C c[100];
+  for (int i = 0; i < 100; i++)
+    {
+      c[i].c3 = i;
+      for (int j = 0; j < b3; j++)
+        if (j < b4)
+          {
+            b2[0].c3 = 0;
+            break;
+          }
+      b1 (c[i], b3, b4);
+      a ();
+    }
+}
+
Index: gcc/testsuite/g++.dg/torture/pr42773.C
===================================================================
--- gcc/testsuite/g++.dg/torture/pr42773.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/torture/pr42773.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,54 @@
+// { dg-do compile }
+// { dg-options "-fno-exceptions" }
+
+typedef unsigned int uint;
+struct QShared {
+    bool deref() {
+	return !--count;
+    }
+    uint count;
+};
+template <class T> class QValueListNode {
+public:
+    QValueListNode<T>* next;
+    QValueListNode<T>* prev;
+};
+template <class T> class QValueListPrivate : public QShared {
+public:
+    typedef QValueListNode<T> Node;
+    typedef QValueListNode<T>* NodePtr;
+    QValueListPrivate();
+    void derefAndDelete()     {
+	if ( deref() )      delete this;
+    }
+    ~QValueListPrivate();
+    NodePtr node;
+};
+template <class T>  QValueListPrivate<T>::QValueListPrivate() {
+    node = new Node;
+    node->next = node->prev = node;
+}
+template <class T>  QValueListPrivate<T>::~QValueListPrivate() {
+    NodePtr p = node->next;
+    while( p != node ) {
+	NodePtr x = p->next;
+	delete p;
+	p = x;
+    }
+}
+template <class T> class QValueList {
+public:
+    QValueList() {
+	sh = new QValueListPrivate<T>;
+    }
+    ~QValueList() {
+	sh->derefAndDelete();
+    }
+    QValueListPrivate<T>* sh;
+};
+class Cell {
+    QValueList<Cell*> obscuringCells() const;
+};
+QValueList<Cell*> Cell::obscuringCells() const {
+    QValueList<Cell*> empty;
+}
Index: gcc/testsuite/g++.dg/torture/pr42890.C
===================================================================
--- gcc/testsuite/g++.dg/torture/pr42890.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/torture/pr42890.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,25 @@
+// PR tree-optimization/42890
+// { dg-do compile }
+
+extern "C" int puts (const char *) throw ();
+
+struct S
+{
+  const char *a;
+  const char **b;
+  S (const char *s) { a = s; b = &a; }
+  ~S () { puts (a); }
+};
+
+void
+foo (int (*fn) (const char *))
+{
+  S a ("foo");
+  fn ("bar");
+}
+
+int
+main ()
+{
+  foo (puts);
+}
Index: gcc/testsuite/g++.dg/torture/pr42739.C
===================================================================
--- gcc/testsuite/g++.dg/torture/pr42739.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/torture/pr42739.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+
+struct s { ~s() { s(); } };
+
+int f()
+{
+  M:
+    s o = s();
+    f();
+    f();
+
+  L:
+    goto *(f() ? &&L : &&M);
+
+    return 0;
+}
Index: gcc/testsuite/g++.dg/ipa/iinline-1.C
===================================================================
--- gcc/testsuite/g++.dg/ipa/iinline-1.C	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/g++.dg/ipa/iinline-1.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -2,7 +2,7 @@
    inlining..  */
 /* { dg-do compile } */
 /* { dg-options "-O3 -fdump-ipa-inline -fno-early-inlining"  } */
-/* { dg-options "-O3 -fdump-ipa-inline -fno-early-inlining -fpie" { target { ! nonpic } } } */
+/* { dg-add-options bind_pic_locally } */
 
 extern void non_existent (const char *, int);
 
Index: gcc/testsuite/g++.dg/template/typedef25.C
===================================================================
--- gcc/testsuite/g++.dg/template/typedef25.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/template/typedef25.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,43 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin PR c++/42225
+// { dg-options "-std=c++0x" }
+// { dg-do compile }
+
+template<class T>
+struct A
+{
+    typedef T I;
+    static const char *i;
+};
+
+template<class T, int>
+struct B
+{
+    typedef T TT;
+    typedef decltype(TT::i)  TT_I0;
+    typedef decltype(&TT::i) TT_I1;
+    typedef decltype(*TT::i) TT_I2;
+    typedef A<TT_I0> TA0;
+    typedef A<TT_I1> TA1;
+    typedef A<TT_I2> TA2;
+};
+
+template<class T>
+void
+foo()
+{
+    typedef T TT;
+    typedef decltype(TT::i)  TT_I0;
+    typedef decltype(&TT::i) TT_I1;
+    typedef decltype(*TT::i) TT_I2;
+    typedef A<TT_I0> TA0;
+    typedef A<TT_I1> TA1;
+    typedef A<TT_I2> TA2;
+}
+
+int
+main()
+{
+    foo<A<int> >();
+}
+
Index: gcc/testsuite/g++.dg/template/conv10.C
===================================================================
--- gcc/testsuite/g++.dg/template/conv10.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/template/conv10.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,9 @@
+// PR c++/41994
+
+template<typename T> struct A
+{
+  operator T();
+  A() { T (A::*f)() = &A::operator T; }
+};
+
+A<int> a;
Index: gcc/testsuite/g++.dg/template/typedef26.C
===================================================================
--- gcc/testsuite/g++.dg/template/typedef26.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/template/typedef26.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,40 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin: PR c++/42225
+// { dg-do compile }
+
+struct A
+{
+    typedef int TI;
+};
+
+template<class T0>
+struct S0
+{
+    int i;
+};
+
+template<class _T, int>
+struct S1
+{
+    typedef _T T;
+    typedef typename T::TI TTI;
+    typedef S0<TTI> TT0;
+    typedef S0<typename T::TI> TT1;
+};
+
+template<class T>
+void
+foo(const T&)
+{
+    typedef typename T::TI TTI;
+    typedef S0<TTI> TT1;
+    typedef S0<typename T::TI> TT2;
+}
+
+int
+main()
+{
+    A a;
+    foo (a);
+}
+
Index: gcc/testsuite/g++.dg/template/inherit4.C
===================================================================
--- gcc/testsuite/g++.dg/template/inherit4.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/template/inherit4.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,14 @@
+// PR c++/21008, DR 515
+
+struct A {
+  int foo_;
+};
+template <typename T> struct B: public A { };
+template <typename T> struct C: B<T> {
+  int foo() {
+    return A::foo_;  // #1
+  }
+};
+int f(C<int>* p) {
+  return p->foo();
+}
Index: gcc/testsuite/g++.dg/template/ref4.C
===================================================================
--- gcc/testsuite/g++.dg/template/ref4.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/template/ref4.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,12 @@
+// PR c++/41972
+
+struct X {
+  static const double  x;
+};
+template <const double& _test_>
+  class Foo { };
+template <typename _ignore_>
+struct Y {
+  typedef Foo<X::x> type;
+};
+
Index: gcc/testsuite/g++.dg/template/typedef27.C
===================================================================
--- gcc/testsuite/g++.dg/template/typedef27.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/template/typedef27.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,55 @@
+// Origin: PR c++/42713
+// { dg-do compile }
+
+template<class T>
+struct S
+{
+};
+
+template<class T>
+struct S0
+{
+    typedef T TT;
+};
+
+template<class U, class V>
+struct super_struct : S0<V>
+{
+    typedef S0<V> super;
+};
+
+template<class U, class V, class W>
+struct S1 : super_struct<U, V>
+{
+    typedef super_struct<U, V> super;
+    typedef typename super::super Super2;
+    typedef typename Super2::TT Super2TT;
+    void
+    foo()
+    {
+        S<Super2TT> s1;
+    }
+};
+
+template<class U, class V>
+struct S2 : super_struct<U, V>
+{
+    typedef super_struct<U, V> super;
+    typedef typename super::super Super2;
+    typedef typename Super2::TT Super2TT;
+    void
+    foo()
+    {
+        S<Super2TT> s1;
+    }
+};
+
+int
+main()
+{
+    S1<int, S<int>, int> s1;
+    s1.foo();
+    S2<int, S<int> > s2;
+    s2.foo();
+}
+
Index: gcc/testsuite/g++.dg/template/const3.C
===================================================================
--- gcc/testsuite/g++.dg/template/const3.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/template/const3.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,20 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin PR c++/42251
+// { dg-do "compile" }
+
+struct foo
+{
+    static const bool b = false;
+};
+
+template<bool x>
+struct S1
+{
+};
+
+template<bool x>
+struct S2
+    : S1<foo::b>
+{
+};
+
Index: gcc/testsuite/g++.dg/template/typedef28.C
===================================================================
--- gcc/testsuite/g++.dg/template/typedef28.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/template/typedef28.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,28 @@
+// Origin: PR c++/42820
+// { dg-do compile }
+
+
+template <class T> struct vector{};
+struct Traits{struct Primitive{struct Id{};};};
+
+template <class Tree, class Polyhedron> struct Tree_vs_naive
+{
+  typedef typename Tree::Primitive Primitive;
+
+  void f() const
+  {
+	  typedef vector<typename Primitive::Id> Id_vector;
+  }
+};
+
+template <class Tree> void test_hint_strategies()
+{
+  vector<typename Tree::Primitive::Id> v;
+}
+
+int main(void)
+{
+  test_hint_strategies<Traits>();
+}
+
+
Index: gcc/testsuite/g++.dg/template/instantiate11.C
===================================================================
--- gcc/testsuite/g++.dg/template/instantiate11.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/template/instantiate11.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,25 @@
+// PR c++/42608
+// { dg-do compile }
+
+template <class U, class V>
+struct A;
+
+template <class V>
+struct A<int, V>
+{
+  void f ();
+};
+
+template struct A<int, int>;
+
+int
+main ()
+{
+  A<int, int> a;
+  a.f ();
+  return 0;
+}
+
+// Make sure we get undefined reference error if
+// A<int, int>::f () isn't instantiated elsewhere.
+// { dg-final { scan-assembler-not "weak\[\n\t\]*_ZN1AIiiE1fEv" } }
Index: gcc/testsuite/g++.dg/template/ptrmem20.C
===================================================================
--- gcc/testsuite/g++.dg/template/ptrmem20.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/template/ptrmem20.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,16 @@
+// PR c++/43079
+
+struct A {};
+
+struct B
+{
+  void foo() const;
+  void foo();
+};
+
+template<void (A::*)()> void bar();
+
+void baz()
+{
+  bar<&B::foo>();  // { dg-error "not a valid template argument|no match" }
+}
Index: gcc/testsuite/g++.dg/template/sizeof12.C
===================================================================
--- gcc/testsuite/g++.dg/template/sizeof12.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/template/sizeof12.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,19 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin PR c++/41863
+
+template<int X>
+struct Bar
+{
+};
+
+template<typename T>
+class Foo
+{
+  T m_foo;
+
+  void
+  crash()
+  {
+    Bar<sizeof(m_foo)> bar;
+  }
+};
Index: gcc/testsuite/g++.dg/template/arg7.C
===================================================================
--- gcc/testsuite/g++.dg/template/arg7.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/template/arg7.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,11 @@
+// PR c++/27425, 34274
+
+template<typename T> struct A
+{
+  template<template<T> class> struct B {}; // { dg-error "void|mismatch|expected" }
+  // { dg-bogus "not supported" "" { target *-*-* } 5 }
+  template<T> struct C;			   // { dg-error "void" }
+  B<C> b;
+};
+
+A<void> a;			// { dg-message "instantiated" }
Index: gcc/testsuite/g++.dg/template/memclass4.C
===================================================================
--- gcc/testsuite/g++.dg/template/memclass4.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/template/memclass4.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,70 @@
+// Origin: PR c++/42824
+// { dg-do compile }
+
+template<int T>
+class int_ {
+};
+
+template<int T, int T2>
+class Unit {
+public:
+    Unit(const Unit<T, T2>& other) {}
+};
+
+template<int T>
+class Quan {
+public:
+    Quan(void) {}
+
+    template<int T2>
+    Quan(double value, Unit<T, T2> unit) {}
+};
+typedef Quan<0> Scalar;
+
+template<int T>
+class hlp {
+public:
+   typedef Quan<T> type;
+};
+
+class Mtrl {
+public:
+    template<int T>
+    struct AssoType {
+        typedef typename hlp<T>::type type;
+    };
+};
+
+template<class T>
+class Eval {
+public:
+    Eval(const T& object){}
+
+    template<int V>
+    void eval() {
+        eval<V> (int_<0>());
+    }
+private:
+    template<typename U> struct Wrap {};
+
+    template<int V, int V2>
+    void value(Wrap<Quan<V2> >) {}
+
+    template<int V>
+    void value(Wrap<Scalar>) {}
+
+    template<int V>
+    void eval(int_<0>) {
+        typedef typename T::template AssoType<V>::type Type;
+        value<V>(Wrap<Type>());
+    }
+};
+
+class Foo {
+public:
+    static void eval(const Mtrl& mtrl) {
+        Eval<Mtrl> h(mtrl);
+        h.eval<0> ();
+    }
+};
+
Index: gcc/testsuite/g++.dg/template/array21.C
===================================================================
--- gcc/testsuite/g++.dg/template/array21.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/template/array21.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,50 @@
+// PR c++/42447
+
+template<int>
+  void* get(int);
+
+template<typename>
+  struct unique_ptr;
+
+template<typename _Tp>
+  struct unique_ptr<_Tp[]>
+  {
+    typedef int __tuple_type;
+
+    void*
+    get() const
+    { return ::get<0>(_M_t); }
+
+    __tuple_type _M_t;
+  };
+
+template <typename T> class dynamic_dispatch;
+
+template <typename TC>
+  struct dynamic_dispatch<void (TC::*)(int&)>
+  {
+    struct entry { };
+    unique_ptr<entry[]> m_Start;
+
+    template <typename UC>
+      void attach_handler(void (UC::*m)(int&))
+      {
+        entry* p = 0;
+        do {
+        } while(--p != m_Start.get());
+      }
+  };
+
+template <typename TC>
+  class request_dispatcher
+  : private dynamic_dispatch<void (TC::*)(int&)>
+  { request_dispatcher(); };
+
+struct file_reader
+{
+  void execute_command(int&);
+};
+
+template <>
+  request_dispatcher<file_reader>::request_dispatcher()
+  { this->attach_handler(&file_reader::execute_command); }
Index: gcc/testsuite/g++.dg/template/typedef21.C
===================================================================
--- gcc/testsuite/g++.dg/template/typedef21.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/template/typedef21.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,11 @@
+// PR c++/37037
+
+typedef void F(void);
+template <typename T> struct S 
+{
+    static F f;
+};
+template class S<int>;
+template <class T> void S<T>::f(void)
+{}
+
Index: gcc/testsuite/g++.dg/template/typedef23.C
===================================================================
--- gcc/testsuite/g++.dg/template/typedef23.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/template/typedef23.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,25 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin PR c++/42069
+// { dg-do compile }
+
+struct A
+{
+  static const int N = 0;
+};
+
+template<int> struct B {};
+
+template<typename T, int>
+struct C
+{
+  typedef T U;
+  B<U::N> b;
+};
+
+template<typename T>
+struct C<T*, 0>
+{
+  B<T::N> b;
+};
+
+C<A*, 0> c;
Index: gcc/testsuite/g++.dg/template/typedef24.C
===================================================================
--- gcc/testsuite/g++.dg/template/typedef24.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/template/typedef24.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,33 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin PR c++/42225
+// { dg-do compile }
+
+template<class T>
+struct A
+{
+    typedef T I;
+};
+
+template<class T, int>
+struct B
+{
+    typedef T TT;
+    typedef typename TT::I TT_I;
+    typedef A<TT_I> TA;
+};
+
+template<class T>
+void
+foo()
+{
+    typedef T TT;
+    typedef typename TT::I TT_I;
+    typedef A<TT_I> TA;
+}
+
+int
+main()
+{
+    foo<A<int> >();
+}
+
Index: gcc/testsuite/g++.dg/overload/rvalue1.C
===================================================================
--- gcc/testsuite/g++.dg/overload/rvalue1.C	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/overload/rvalue1.C	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,10 @@
+// PR c++/42655
+
+void unused(const bool &) { }
+
+int main() {
+  volatile bool x = false;
+  unused(!!x); // type of "!x" is bool
+  unused(!x); // type of "!x" is bool
+}
+
Index: gcc/testsuite/lib/gnat.exp
===================================================================
--- gcc/testsuite/lib/gnat.exp	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/lib/gnat.exp	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,4 +1,4 @@
-# Copyright (C) 2006, 2007, 2008 Free Software Foundation, Inc.
+# Copyright (C) 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
 
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
@@ -83,7 +83,6 @@
     global gluefile wrap_flags
     global gnat_initialized
     global GNAT_UNDER_TEST
-    global GNAT_UNDER_TEST_ORIG
     global TOOL_EXECUTABLE
     global gnat_libgcc_s_path
     global gnat_target_current
@@ -98,7 +97,6 @@
 	} else {
 	    set GNAT_UNDER_TEST "[local_find_gnatmake]"
 	}
-        set GNAT_UNDER_TEST_ORIG "$GNAT_UNDER_TEST"
     }
 
     if ![info exists tmpdir] then {
@@ -129,22 +127,31 @@
     global gluefile wrap_flags
     global srcdir
     global GNAT_UNDER_TEST
-    global GNAT_UNDER_TEST_ORIG
     global TOOL_OPTIONS
     global ld_library_path
     global gnat_libgcc_s_path
     global gnat_target_current
 
-    # If we detect a change of target we need to recompute
-    # the appropriate RTS by calling get_multilibs.
+    # If we detect a change of target, we need to recompute both
+    # GNAT_UNDER_TEST and the appropriate RTS.
     if { $gnat_target_current!="[current_target_name]" } {
-       set gnat_target_current "[current_target_name]"
-       if [info exists TOOL_OPTIONS] {
-           set gnat_rts_opt "--RTS=[get_multilibs ${TOOL_OPTIONS}]/libada"
-       } else {
-           set gnat_rts_opt "--RTS=[get_multilibs]/libada"
-       }
-        set GNAT_UNDER_TEST "$GNAT_UNDER_TEST_ORIG $gnat_rts_opt"
+	set gnat_target_current "[current_target_name]"
+	if [info exists TOOL_OPTIONS] {
+	    set rtsdir "[get_multilibs ${TOOL_OPTIONS}]/libada"
+	} else {
+	    set rtsdir "[get_multilibs]/libada"
+	}
+	if [info exists TOOL_EXECUTABLE] {
+	    set GNAT_UNDER_TEST "$TOOL_EXECUTABLE"
+	} else {
+	    set GNAT_UNDER_TEST "[local_find_gnatmake]"
+	}
+        set GNAT_UNDER_TEST "$GNAT_UNDER_TEST --RTS=$rtsdir"
+
+	# gnatlink looks for system.ads itself and has no --RTS option, so
+	# specify via environment
+	setenv ADA_INCLUDE_PATH "$rtsdir/adainclude"
+	setenv ADA_OBJECTS_PATH "$rtsdir/adainclude"
     }
 
     set ld_library_path ".:${gnat_libgcc_s_path}"
@@ -263,7 +270,13 @@
         }
         if { $file != "" } {
     	set root [file dirname $file]
-    	set CC "$file --GCC=$root/xgcc --GNATBIND=$root/gnatbind --GNATLINK=$root/gnatlink -cargs -B$root -largs --LINK=$root/xgcc -B$root -margs";
+	# Need to pass full --GCC, including multilib flags, to gnatlink,
+	# otherwise gcc from PATH is invoked.
+	set dest [target_info name]
+	set gnatlink_gcc "--GCC=$root/xgcc -B$root [board_info $dest multilib_flags]"
+	# Escape blanks to get them through DejaGnu's exec machinery.
+	regsub -all {\s} "$gnatlink_gcc" {\\&} gnatlink_gcc
+    	set CC "$file --GCC=$root/xgcc --GNATBIND=$root/gnatbind --GNATLINK=$root/gnatlink -cargs -B$root -largs $gnatlink_gcc -margs";
         } else {
     	set CC [transform gnatmake]
         }
Index: gcc/testsuite/lib/target-supports-dg.exp
===================================================================
--- gcc/testsuite/lib/target-supports-dg.exp	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/lib/target-supports-dg.exp	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -235,10 +235,27 @@
 	append compiler_flags "[board_info $dest multilib_flags] "
     }
 
-    # The target list might be an effective-target keyword, so replace
-    # the original list with "*-*-*", since we already know it matches.
-    set result [check_conditional_xfail [lreplace $args 1 1 "*-*-*"]]
+    # The next two arguments are optional.  If they were not specified,
+    # use the defaults.
+    if { [llength $args] == 2 } {
+	lappend $args [list "*"]
+    }
+    if { [llength $args] == 3 } {
+	lappend $args [list ""]
+    }
 
+    # If the option strings are the defaults, or the same as the
+    # defaults, there is no need to call check_conditional_xfail to
+    # compare them to the actual options.
+    if { [string compare [lindex $args 2] "*"] == 0
+	 && [string compare [lindex $args 3] "" ] == 0 } {
+	set result 1    
+    } else {
+	# The target list might be an effective-target keyword, so replace
+	# the original list with "*-*-*", since we already know it matches.
+	set result [check_conditional_xfail [lreplace $args 1 1 "*-*-*"]]
+    }
+
     # Any value in this variable was left over from an earlier test.
     set compiler_flags ""
 
@@ -256,14 +273,18 @@
 # group of tests or flags specified with a previous dg-options command.
 
 proc dg-skip-if { args } {
+    # Verify the number of arguments.  The last two are optional.
+    set args [lreplace $args 0 0]
+    if { [llength $args] < 2 || [llength $args] > 4 } {
+	error "dg-skip-if 2: need 2, 3, or 4 arguments"
+    }
+
     # Don't bother if we're already skipping the test.
     upvar dg-do-what dg-do-what
     if { [lindex ${dg-do-what} 1] == "N" } {
       return
     }
 
-    set args [lreplace $args 0 0]
-
     set selector [list target [lindex $args 1]]
     if { [dg-process-target $selector] == "S" } {
 	if [check-flags $args] {
@@ -276,31 +297,53 @@
 # Like check_conditional_xfail, but callable from a dg test.
 
 proc dg-xfail-if { args } {
+    # Verify the number of arguments.  The last three are optional.
+    set args [lreplace $args 0 0]
+    if { [llength $args] < 2 || [llength $args] > 4 } {
+	error "dg-xfail-if: need 2, 3, or 4 arguments"
+    }
+
     # Don't change anything if we're already skipping the test.
     upvar dg-do-what dg-do-what
     if { [lindex ${dg-do-what} 1] == "N" } {
       return
     }
 
-    set args [lreplace $args 0 0]
     set selector [list target [lindex $args 1]]
     if { [dg-process-target $selector] == "S" } {
 	global compiler_conditional_xfail_data
-	set compiler_conditional_xfail_data [lreplace $args 1 1 "*-*-*"]
+
+	# The target list might be an effective-target keyword.  Replace
+	# the original list with "*-*-*", since we already know it matches.
+	set args [lreplace $args 1 1 "*-*-*"]
+
+	# Supply default values for unspecified optional arguments.
+	if { [llength $args] == 2 } {
+	    lappend $args [list "*"]
+	}
+	if { [llength $args] == 3 } {
+	    lappend $args [list ""]
+	}
+
+	set compiler_conditional_xfail_data $args
     }
 }
 
 # Like dg-xfail-if but for the execute step.
 
 proc dg-xfail-run-if { args } {
+    # Verify the number of arguments.  The last two are optional.
+    set args [lreplace $args 0 0]
+    if { [llength $args] < 2 || [llength $args] > 4 } {
+	error "dg-xfail-run-if: need 2, 3, or 4 arguments"
+    }
+
     # Don't bother if we're already skipping the test.
     upvar dg-do-what dg-do-what
     if { [lindex ${dg-do-what} 1] == "N" } {
       return
     }
 
-    set args [lreplace $args 0 0]
-
     set selector [list target [lindex $args 1]]
     if { [dg-process-target $selector] == "S" } {
 	if [check-flags $args] {
Index: gcc/testsuite/lib/target-supports.exp
===================================================================
--- gcc/testsuite/lib/target-supports.exp	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/lib/target-supports.exp	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -2787,6 +2787,28 @@
     return $flags
 }
 
+# Add to FLAGS the flags needed to enable functions to bind locally
+# when using pic/PIC passes in the testsuite.
+
+proc add_options_for_bind_pic_locally { flags } {
+    if {[check_no_compiler_messages using_pic2 assembly {
+        #if __PIC__ != 2
+        #error FOO
+        #endif
+    }]} {
+	return "$flags -fPIE"
+    }
+    if {[check_no_compiler_messages using_pic1 assembly {
+        #if __PIC__ != 1
+        #error FOO
+        #endif
+    }]} {
+	return "$flags -fpie"
+    }
+
+    return $flags
+}
+
 # Return 1 if the target provides a full C99 runtime.
 
 proc check_effective_target_c99_runtime { } {
@@ -2894,3 +2916,24 @@
 	#endif
     }]
 }
+
+# Return 1 if the language for the compiler under test is C.
+
+proc check_effective_target_c { } {
+ global tool
+    if [string match $tool "gcc"] {
+   return 1
+    }
+ return 0
+}
+
+# Return 1 if the language for the compiler under test is C++.
+
+proc check_effective_target_c++ { } {
+ global tool
+    if [string match $tool "g++"] {
+   return 1
+    }
+ return 0
+}
+
Index: gcc/testsuite/gfortran.dg/data_value_1.f90
===================================================================
--- gcc/testsuite/gfortran.dg/data_value_1.f90	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/gfortran.dg/data_value_1.f90	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -3,12 +3,14 @@
 ! is not a constant and so the DATA statement did not have
 ! a constant value expression.
 !
+! Modified dg-error for PR41807
+!
 ! Contributed by Philippe Marguinaud <philippe.marguinaud@meteo.fr>
 !
       TYPE POINT
         REAL :: X 
       ENDTYPE
       TYPE(POINT) :: P
-      DATA P / POINT(1.+X) / ! { dg-error "non-constant DATA value" }
+      DATA P / POINT(1.+X) / ! { dg-error "non-constant initialization" }
       print *, p
       END
Index: gcc/testsuite/gfortran.dg/interface_assignment_5.f90
===================================================================
--- gcc/testsuite/gfortran.dg/interface_assignment_5.f90	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/interface_assignment_5.f90	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,49 @@
+! { dg-do compile }
+!
+! PR 42677: [4.5 Regression] Bogus Error: Ambiguous interfaces '...' in intrinsic assignment operator
+!
+! Contributed by Harald Anlauf <anlauf@gmx.de>
+
+module mod1
+  implicit none
+  type t_m
+     integer :: i = 0
+  end type t_m
+!------------------------------------------------------------------------------
+  interface assignment (=)
+     module procedure assign_m
+  end interface
+!------------------------------------------------------------------------------
+contains
+  subroutine assign_m (y, x)
+    type(t_m) ,intent(inout) :: y
+    type(t_m) ,intent(in)    :: x
+  end subroutine assign_m
+end module mod1
+!==============================================================================
+module mod2
+  use mod1, only: t_m, assignment(=)
+  implicit none
+  type t_atm
+     integer :: k
+  end type t_atm
+!------------------------------------------------------------------------------
+  interface assignment(=)
+     module procedure assign_to_atm
+  end interface
+!------------------------------------------------------------------------------
+  interface
+     pure subroutine delete_m (x)
+       use mod1
+       type(t_m) ,intent(in) :: x
+     end subroutine delete_m
+  end interface
+!------------------------------------------------------------------------------
+contains
+  subroutine assign_to_atm (atm, r)
+    type(t_atm) ,intent(inout) :: atm
+    integer     ,intent(in)    :: r
+  end subroutine assign_to_atm
+end module mod2
+ 
+! { dg-final { cleanup-modules "mod1 mod2" } }
Index: gcc/testsuite/gfortran.dg/alloc_comp_bounds_1.f90
===================================================================
--- gcc/testsuite/gfortran.dg/alloc_comp_bounds_1.f90	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/alloc_comp_bounds_1.f90	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,50 @@
+! { dg-do run }
+! Test the fix for PR38324, in which the bounds were not set correctly for
+! constructor assignments with allocatable components.
+!
+! Contributed by Dominique d'Humieres <dominiq@lps.ens.fr>
+!
+  integer, parameter :: ik4 = 4
+  integer, parameter :: ik8 = 8
+  integer, parameter :: from = -1, to = 2
+  call foo
+  call bar
+contains
+  subroutine foo
+    type :: struct
+      integer(4), allocatable :: ib(:)
+    end type struct
+    integer(ik4), allocatable :: ia(:)
+    type(struct) :: x
+    allocate(ia(from:to))
+    if (any(lbound(ia) .ne. -1) .or. any(ubound(ia) .ne. 2)) call abort
+    if (any(lbound(ia(:)) .ne. 1) .or. any(ubound(ia(:)) .ne. 4)) call abort
+    if (any(lbound(ia(from:to)) .ne. 1) .or. any(ubound(ia(from:to)) .ne. 4)) call abort
+    x=struct(ia)
+    if (any(lbound(x%ib) .ne. -1) .or. any(ubound(x%ib) .ne. 2)) call abort
+    x=struct(ia(:))
+    if (any(lbound(x%ib) .ne. 1) .or. any(ubound(x%ib) .ne. 4)) call abort
+    x=struct(ia(from:to))
+    if (any(lbound(x%ib) .ne. 1) .or. any(ubound(x%ib) .ne. 4)) call abort
+    deallocate(ia)
+  end subroutine
+  subroutine bar
+    type :: struct
+      integer(4), allocatable :: ib(:)
+    end type struct
+    integer(ik8), allocatable :: ia(:)
+    type(struct) :: x
+    allocate(ia(from:to))
+    if (any(lbound(ia) .ne. -1) .or. any(ubound(ia) .ne. 2)) call abort
+    if (any(lbound(ia(:)) .ne. 1) .or. any(ubound(ia(:)) .ne. 4)) call abort
+    if (any(lbound(ia(from:to)) .ne. 1) .or. any(ubound(ia(from:to)) .ne. 4)) call abort
+    x=struct(ia)
+    if (any(lbound(x%ib) .ne. -1) .or. any(ubound(x%ib) .ne. 2)) call abort
+    x=struct(ia(:))
+    if (any(lbound(x%ib) .ne. 1) .or. any(ubound(x%ib) .ne. 4)) call abort
+    x=struct(ia(from:to))
+    if (any(lbound(x%ib) .ne. 1) .or. any(ubound(x%ib) .ne. 4)) call abort
+    deallocate(ia)
+  end subroutine
+end
+
Index: gcc/testsuite/gfortran.dg/interface_31.f90
===================================================================
--- gcc/testsuite/gfortran.dg/interface_31.f90	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/interface_31.f90	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,41 @@
+! { dg-do compile }
+! PR42684 (42680) Ice with Interface.
+MODULE mod1
+  IMPLICIT NONE  
+  TYPE ta
+    INTEGER i
+  END TYPE ta
+  INTERFACE OPERATOR(+)
+    MODULE PROCEDURE add_a
+  END INTERFACE OPERATOR(+)  
+CONTAINS  
+  FUNCTION add_a(lhs, rhs) RESULT(r)
+    TYPE(ta), INTENT(IN) :: lhs
+    TYPE(ta), INTENT(IN) :: rhs
+    TYPE(ta) :: r
+    !****
+    r%i = lhs%i + rhs%i
+  END FUNCTION add_a  
+END MODULE mod1
+
+MODULE mod2
+  IMPLICIT NONE 
+  TYPE tb
+    INTEGER j
+  END TYPE tb
+  INTERFACE OPERATOR(+)
+    MODULE PROCEDURE add_b
+  END INTERFACE OPERATOR(+)  
+CONTAINS  
+  SUBROUTINE other_proc()
+    USE mod1    ! Causes ICE
+  END SUBROUTINE other_proc  
+  FUNCTION add_b(lhs, rhs) RESULT(r)
+    TYPE(tb), INTENT(IN) :: lhs
+    TYPE(tb), INTENT(IN) :: rhs
+    TYPE(tb) :: r
+    !****
+    r%j = lhs%j + rhs%j
+  END FUNCTION add_b  
+END MODULE mod2
+! { dg-final { cleanup-modules "mod1 mod2" } }
Index: gcc/testsuite/gfortran.dg/parameter_array_ref_2.f90
===================================================================
--- gcc/testsuite/gfortran.dg/parameter_array_ref_2.f90	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/parameter_array_ref_2.f90	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,39 @@
+! { dg-do compile }
+! Test the fix for the problems in PR41044
+!
+! Contributed by <ros@rzg.mpg.de>
+! Reduced by Joos VandeVondele <jv244@cam.ac.uk>
+!
+  Subroutine PS_INIT (bkgd, punit, pform, psize, rot90, bbox, clip, eps,  &
+                        caller)
+    type psfd                          ! paper size and frame defaults
+      character(3)                     :: n
+      real                             :: p(2)
+      real                             :: f(4)
+    end type psfd
+    character(4)                       :: fn, orich, pfmt
+    type(psfd), parameter              :: pfd(0:11)=(/  &
+         psfd('   ',(/   0.0,   0.0/),(/200.,120.,800.,560./)), &    ! A0_L
+         psfd('A0 ',(/ 840.9,1189.2/),(/140., 84.,560.,400./)), &    ! A0_P
+         psfd('A1 ',(/ 594.6, 840.9/),(/100., 60.,400.,280./)), &    ! A1_P
+         psfd('A2 ',(/ 420.4, 594.6/),(/ 70., 42.,280.,200./)), &    ! A2_P
+         psfd('A3 ',(/ 297.3, 420.4/),(/ 50., 30.,200.,140./)), &    ! A3_P
+         psfd('A4 ',(/ 210.2, 297.3/),(/ 35., 21.,140.,100./)), &    ! A4_P
+         psfd('A5 ',(/ 148.7, 210.2/),(/ 25., 15.,100., 70./)), &    ! A5_P
+         psfd('A6 ',(/ 105.1, 148.7/),(/ 18., 11., 70., 50./)), &    ! A6_P
+         psfd('   ',(/   0.0,   0.0/),(/ 50., 30.,200.,140./)), &    ! Letter_L
+         psfd('LET',(/ 215.9, 279.4/),(/ 35., 21.,140.,100./)), &    ! Letter_P
+         psfd('   ',(/   0.0,   0.0/),(/ 50., 30.,200.,140./)), &    ! Legal_L
+         psfd('LEG',(/ 215.9, 355.6/),(/ 35., 21.,140.,100./))/)     ! Legal_P
+    if (len_trim(pfmt) > 0) then       ! set paper format
+      idx=sum(maxloc(index(pfd%n,pfmt(1:3))))-1
+    end if
+  end subroutine PS_INIT
+
+! This, additional problem, was posted as comment #8 by Tobias Burnus <burnus@gcc.gnu.org>
+  type t
+    integer :: i
+  end type t
+  type(t), parameter :: a(1) = t(4) ! [t(4)] worked OK
+  real(a(1)%i) :: b
+end
Index: gcc/testsuite/gfortran.dg/transfer_intrinsic_3.f90
===================================================================
--- gcc/testsuite/gfortran.dg/transfer_intrinsic_3.f90	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/transfer_intrinsic_3.f90	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,38 @@
+! { dg-do run }
+! Tests the fix for PR41772 in which the empty array reference
+! 'qname(1:n-1)' was not handled correctly in TRANSFER.
+!
+! Contributed by Tobias Burnus <burnus@gcc.gnu.org>
+!
+module m
+  implicit none
+contains
+  pure function str_vs(vs) result(s)
+    character, dimension(:), intent(in) :: vs
+    character(len=size(vs)) :: s
+    s = transfer(vs, s)
+  end function str_vs
+  subroutine has_key_ns(uri, localname, n)
+    character(len=*), intent(in) :: uri, localname
+    integer, intent(in) :: n
+    if ((n .lt. 2) .and. (len (uri) .ne. 0)) then
+      call abort
+    else IF ((n .ge. 2) .and. (len (uri) .ne. n - 1)) then 
+      call abort
+    end if
+  end subroutine
+end module m
+
+  use m
+  implicit none
+  character, dimension(:), pointer :: QName
+  integer :: n
+  allocate(qname(6))
+  qname = (/ 'a','b','c','d','e','f' /)
+
+  do n = 0, 3
+    call has_key_ns(str_vs(qname(1:n-1)),"", n)
+  end do
+  deallocate(qname)
+end
+! { dg-final { cleanup-modules "m" } }
\ No newline at end of file
Index: gcc/testsuite/gfortran.dg/associated_target_3.f90
===================================================================
--- gcc/testsuite/gfortran.dg/associated_target_3.f90	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/associated_target_3.f90	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,35 @@
+! { dg-do run }
+!
+! PR fortran/41777
+!
+module m
+type t2
+ integer :: i
+end type t2
+interface f
+ module procedure f2
+end interface f
+contains
+function f2(a)
+  type(t2), pointer :: f2,a
+  f2 => a
+end function f2
+end module m
+
+use m
+implicit none
+type(t2), pointer :: a
+allocate(a)
+if (.not. associated(a,f(a))) call abort()
+call cmpPtr(a,f2(a))
+call cmpPtr(a,f(a))
+deallocate(a)
+contains
+  subroutine cmpPtr(a,b)
+    type(t2), pointer :: a,b
+!    print *, associated(a,b)
+    if (.not. associated (a, b)) call abort()
+  end subroutine cmpPtr
+end
+
+! { dg-final { cleanup-modules "m" } }
Index: gcc/testsuite/gfortran.dg/pr42294.f
===================================================================
--- gcc/testsuite/gfortran.dg/pr42294.f	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/pr42294.f	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,41 @@
+C PR rtl-optimization/42294
+C { dg-do compile { target powerpc*-*-* ia64-*-* x86_64-*-* } }
+C { dg-options "-O2 -fselective-scheduling2 -fsel-sched-pipelining -funroll-all-loops" }
+
+      SUBROUTINE ORIEN(IW,NATOT,NTOTORB,NATORB,P,T)
+      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
+      DIMENSION NATORB(NATOT),P(NTOTORB*(NTOTORB+1)/2)
+      DIMENSION T(NTOTORB,NTOTORB)
+      DO 9000 IATOM=1,NATOT
+         ILAST = NTOTORB
+         IF (IATOM.NE.NATOT) ILAST=NATORB(IATOM+1)-1
+         DO 8000 IAOI=NATORB(IATOM),ILAST
+            DO 7000 IAOJ = IAOI+1,ILAST
+               R2 = 0.0D+00
+               R3 = 0.0D+00
+               DO 6000 INOTA=1,NATOT
+                  DO 5000 IK=NATORB(INOTA),NTOTORB
+                     IMAI=MAX(IK,IAOI)
+                     IMII=MIN(IK,IAOI)
+                     IMAJ=MAX(IK,IAOJ)
+                     IMIJ=MIN(IK,IAOJ)
+                     IKI=(IMAI*(IMAI-1))/2 + IMII
+                     IKJ=(IMAJ*(IMAJ-1))/2 + IMIJ
+                     PIKI=P(IKI)
+                     PIKJ=P(IKJ)
+                     R2 = R2 + (PIKI**4)-6*(PIKI*PIKI*PIKJ*PIKJ)+(PIKJ)
+ 5000             CONTINUE
+ 6000          CONTINUE
+               R2 = (R2/4.0D+00)
+               Q = SQRT(R2*R2 + R3*R3)
+               IF (Q.LT.1.0D-08) GO TO 7000
+               A = COS(THETA)
+               B = -SIN(THETA)
+               CALL ROT1INT(NTOTORB,IAOI,IAOJ,A,B,P)
+ 7000       CONTINUE
+ 8000    CONTINUE
+ 9000 CONTINUE
+      RETURN
+      END
+
+
Index: gcc/testsuite/gfortran.dg/gomp/pr41344.f
===================================================================
--- gcc/testsuite/gfortran.dg/gomp/pr41344.f	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/gomp/pr41344.f	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,16 @@
+      subroutine xrotate(nerr)
+
+      common /dfm/ndfl
+
+*$omp parallel private(ix)
+      ix = 0
+*$omp do
+      do i=1,ndfl
+         ix = ix + 1
+	 if (ix.gt.5) go to 9000 ! { dg-error "invalid (exit|branch)" }
+      enddo
+*$omp end do
+*$omp end parallel
+
+9000  continue
+      end
Index: gcc/testsuite/gfortran.dg/namelist_60.f90
===================================================================
--- gcc/testsuite/gfortran.dg/namelist_60.f90	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/namelist_60.f90	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,27 @@
+! { dg-do run }
+! PR42901  Reading array of structures from namelist
+! Test case derived from the reporters test case.
+program test_nml
+type field_descr
+  integer number
+end type
+type fsetup
+  type (field_descr), dimension(3) :: vel ! 3 velocity components
+end type
+type (fsetup) field_setup
+namelist /nl_setup/ field_setup
+field_setup%vel%number = 0
+! write(*,nml=nl_setup)
+open(10, status="scratch")
+write(10,'(a)') "&nl_setup"
+write(10,'(a)') " field_setup%vel(1)%number=  3,"
+write(10,'(a)') " field_setup%vel(2)%number=  9,"
+write(10,'(a)') " field_setup%vel(3)%number=  27,"
+write(10,'(a)') "/"
+rewind(10)
+read(10,nml=nl_setup)
+if (field_setup%vel(1)%number .ne. 3) call abort
+if (field_setup%vel(2)%number .ne. 9) call abort
+if (field_setup%vel(3)%number .ne. 27) call abort
+! write(*,nml=nl_setup)
+end program test_nml
Index: gcc/testsuite/gfortran.dg/bounds_check_15.f90
===================================================================
--- gcc/testsuite/gfortran.dg/bounds_check_15.f90	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/bounds_check_15.f90	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,33 @@
+! { dg-do run }
+! { dg-options "-fbounds-check" }
+! Test the fix for PR42783, in which a bogus array bounds violation
+! with missing optional array argument.
+!
+! Contributed by Harald Anlauf <anlauf@gmx.de>
+!
+program gfcbug99
+  implicit none
+  character(len=8), parameter :: mnem_list(2) = "A"
+
+  call foo (mnem_list)  ! This call succeeds
+  call foo ()           ! This call fails
+contains
+  subroutine foo (mnem_list)
+    character(len=8) ,intent(in) ,optional :: mnem_list(:)
+
+    integer            :: i,j
+    character(len=256) :: ml
+    ml = ''
+    j = 0
+    if (present (mnem_list)) then
+       do i = 1, size (mnem_list)
+          if (mnem_list(i) /= "") then
+             j = j + 1
+             if (j > len (ml)/8) call abort ()
+             ml((j-1)*8+1:(j-1)*8+8) = mnem_list(i)
+          end if
+       end do
+    end if
+    if (j > 0) print *, trim (ml(1:8))
+  end subroutine foo
+end program gfcbug99
Index: gcc/testsuite/gfortran.dg/fmt_cache_2.f
===================================================================
--- gcc/testsuite/gfortran.dg/fmt_cache_2.f	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/fmt_cache_2.f	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,36 @@
+! { dg-do run }
+! PR42742 Handle very large format strings correctly
+! Test derived from example developed by Manfred Schwarb.
+      character(12) bufarr(74)
+      character(74*13+30) fmtstr,fmtstr2
+      character(1) delim
+      integer i,j,dat(5),pindx, loopcounter
+      character(983) big_string ! any less and this test fails.
+
+      do i=1,74
+        write(bufarr(i),'(i12)') i
+      enddo
+
+      delim=" "
+      dat(1)=2009
+      dat(2)=10
+      dat(3)=31
+      dat(4)=3
+      dat(5)=0
+      fmtstr="(i2,i6,4(a1,i2.2)"
+      open(10, status="scratch")
+      do j=1,74
+        fmtstr=fmtstr(1:len_trim(fmtstr))//",a1,a12"
+        fmtstr2=fmtstr(1:len_trim(fmtstr))//")"
+c        write(0,*) "interation ",j,": ",len_trim(fmtstr2)
+        do i=1,10
+          write(10,fmtstr2)
+     &           i,dat(1),"-",dat(2),"-",dat(3),
+     &           delim,dat(4),":",dat(5),
+     &           (delim,bufarr(pindx),pindx=1,j)
+        enddo
+        loopcounter = j
+      enddo
+      close(10)
+      if (loopcounter /= 74) call abort
+      end
Index: gcc/testsuite/gfortran.dg/module_write_1.f90
===================================================================
--- gcc/testsuite/gfortran.dg/module_write_1.f90	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/module_write_1.f90	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,59 @@
+! { dg-do compile }
+!
+! PR fortran/41869
+!
+! Was ICEing while module write of symbol 'vs_str' in m_dom_dom
+! because of "len" being private in fox_m_fsys_format.
+!
+module fox_m_fsys_array_str
+contains
+  pure function str_vs(vs) result(s)
+    character, dimension(:), intent(in) :: vs
+    character(len=size(vs)) :: s
+    s = transfer(vs, s)
+  end function str_vs
+  pure function vs_str(s) result(vs)
+    character(len=*), intent(in) :: s
+    character, dimension(len(s)) :: vs
+    vs = transfer(s, vs)
+  end function vs_str
+end module fox_m_fsys_array_str
+
+module fox_m_fsys_format
+  private
+  interface str
+    module procedure  str_logical_array
+  end interface str
+  interface len
+    module procedure str_logical_array_len
+  end interface
+  public :: str
+contains
+  pure function str_logical_array_len(la) result(n)
+    logical, dimension(:), intent(in)   :: la
+  end function str_logical_array_len
+  pure function str_logical_array(la) result(s)
+    logical, dimension(:), intent(in)   :: la
+    character(len=len(la)) :: s
+  end function str_logical_array
+  pure function checkFmt(fmt) result(good)
+    character(len=*), intent(in) :: fmt
+    logical :: good
+    good = len(fmt) > 0
+  end function checkFmt
+end module fox_m_fsys_format
+
+module m_dom_dom
+  use fox_m_fsys_array_str, only: str_vs, vs_str
+end module m_dom_dom
+
+module FoX_dom
+  use fox_m_fsys_format
+  use m_dom_dom
+end module FoX_dom
+
+use FoX_dom
+implicit none
+print *, vs_str("ABC")
+end
+! { dg-final { cleanup-modules "fox_m_fsys_array_str fox_m_fsys_format m_dom_dom fox_dom" } }
Index: gcc/testsuite/gfortran.dg/array_constructor_32.f90
===================================================================
--- gcc/testsuite/gfortran.dg/array_constructor_32.f90	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/array_constructor_32.f90	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,28 @@
+! { dg-do run }
+! PR41807  data statement with nested type constructors
+! Test case provided by Steve Kargl
+  implicit none
+
+  type :: a
+     real :: x(3)
+  end type a
+
+  integer, parameter :: n = 3
+
+  type(a) :: b(n)
+
+  real, parameter :: d1(3) = (/1., 2., 3./)
+  real, parameter :: d2(3) = (/4., 5., 6./)
+  real, parameter :: d3(3) = (/7., 8., 9./)
+
+  integer :: i, z(n)
+ 
+  data (b(i), i = 1, n) /a(d1), a(d2), a(d3)/
+  data (z(i), i = 1, n) / 1, 2, 3/
+
+  if (any(z.ne.[1, 2, 3])) call abort
+  if (any(b(1)%x.ne.[1, 2, 3]) .or. &
+      any(b(2)%x.ne.[4, 5, 6]) .or. &
+      any(b(3)%x.ne.[7, 8, 9])) call abort
+end
+
Index: gcc/testsuite/gfortran.dg/func_result_5.f90
===================================================================
--- gcc/testsuite/gfortran.dg/func_result_5.f90	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/func_result_5.f90	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,14 @@
+! { dg-do compile }
+!
+! PR fortran/42650
+!
+! Result type was not working
+!
+
+type(t) function func2() result(res)
+  type t
+    sequence
+    integer :: i = 5
+  end type t
+  res%i = 2
+end function func2
Index: gcc/testsuite/gfortran.dg/internal_pack_8.f90
===================================================================
--- gcc/testsuite/gfortran.dg/internal_pack_8.f90	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/internal_pack_8.f90	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,33 @@
+! { dg-do run }
+!
+! Test the fix for PR43111, in which necessary calls to
+! internal PACK/UNPACK were not being generated because
+! of an over agressive fix to PR41113/7.
+!
+! Contributed by Joost VandeVondele <jv244@cam.ac.uk>
+!
+SUBROUTINE S2(I)
+ INTEGER :: I(4)
+ !write(6,*) I
+ IF (ANY(I.NE.(/3,5,7,9/))) CALL ABORT()
+END SUBROUTINE S2
+
+MODULE M1
+ TYPE T1
+  INTEGER, POINTER, DIMENSION(:) :: data
+ END TYPE T1
+CONTAINS
+ SUBROUTINE S1()
+   TYPE(T1) :: d
+   INTEGER, TARGET, DIMENSION(10) :: scratch=(/(i,i=1,10)/)
+   INTEGER :: i=2
+   d%data=>scratch(1:9:2)
+!   write(6,*) d%data(i:)
+   CALL S2(d%data(i:))
+ END SUBROUTINE S1
+END MODULE M1
+
+USE M1
+CALL S1
+END
+! { dg-final { cleanup-modules "M1" } }
Index: gcc/testsuite/gfortran.dg/char_array_arg_1.f90
===================================================================
--- gcc/testsuite/gfortran.dg/char_array_arg_1.f90	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/char_array_arg_1.f90	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,17 @@
+! { dg-do compile }
+! Test the fix for pr41167, in which the first argument of 'pack', below,
+! was simplified incorrectly, with the results indicated.
+!
+! Contributed by Harald Anlauf <anlauf@gmx.de>
+!
+program gfcbug88
+  implicit none
+  type t
+     character(len=8) :: name
+  end type t
+  type(t) ,parameter :: obstyp(2)= (/ t ('A'), t ('B') /)
+  character(9) :: chr(1)
+
+  print *, pack (" "//obstyp(:)% name, (/ .true., .false. /))  ! Used to ICE on compilation
+  chr = pack (" "//obstyp(:)% name, (/ .true., .false. /))  ! Used to give conversion error
+end program gfcbug88
Index: gcc/testsuite/gfortran.dg/pr41928.f90
===================================================================
--- gcc/testsuite/gfortran.dg/pr41928.f90	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/pr41928.f90	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,263 @@
+! { dg-do compile }
+! { dg-options "-O -fbounds-check -w" }
+MODULE kinds
+  INTEGER, PARAMETER :: dp = SELECTED_REAL_KIND ( 14, 200 )
+  INTEGER, DIMENSION(:), ALLOCATABLE     :: nco,ncoset,nso,nsoset
+  INTEGER, DIMENSION(:,:,:), ALLOCATABLE :: co,coset
+END MODULE kinds
+MODULE ai_moments
+  USE kinds
+CONTAINS
+  SUBROUTINE cossin(la_max,npgfa,zeta,rpgfa,la_min,&
+                    lb_max,npgfb,zetb,rpgfb,lb_min,&
+                    rac,rbc,kvec,cosab,sinab)
+    REAL(KIND=dp), DIMENSION(ncoset(la_max),&
+      ncoset(lb_max))                        :: sc, ss
+    DO ipgf=1,npgfa
+      DO jpgf=1,npgfb
+        IF (la_max > 0) THEN
+          DO la=2,la_max
+            DO ax=2,la
+              DO ay=0,la-ax
+                sc(coset(ax,ay,az),1) = rap(1)*sc(coset(ax-1,ay,az),1) +&
+                              f2 *          kvec(1)*ss(coset(ax-1,ay,az),1)
+                ss(coset(ax,ay,az),1) = rap(1)*ss(coset(ax-1,ay,az),1) +&
+                              f2 *          kvec(1)*sc(coset(ax-1,ay,az),1)
+              END DO
+            END DO
+          END DO
+          IF (lb_max > 0) THEN
+            DO lb=2,lb_max
+              ss(1,coset(0,0,lb)) = rbp(3)*ss(1,coset(0,0,lb-1)) +&
+                           f2 *         kvec(3)*sc(1,coset(0,0,lb-1))
+              DO bx=2,lb
+                DO by=0,lb-bx
+                  ss(1,coset(bx,by,bz)) = rbp(1)*ss(1,coset(bx-1,by,bz)) +&
+                               f2 *           kvec(1)*sc(1,coset(bx-1,by,bz))
+                END DO
+              END DO
+            END DO
+          END IF
+        END IF
+       DO j=ncoset(lb_min-1)+1,ncoset(lb_max)
+        END DO
+      END DO
+    END DO
+  END SUBROUTINE cossin
+  SUBROUTINE moment(la_max,npgfa,zeta,rpgfa,la_min,&
+                    lb_max,npgfb,zetb,rpgfb,&
+                    lc_max,rac,rbc,mab)
+    REAL(KIND=dp), DIMENSION(:), INTENT(IN)  :: zeta, rpgfa
+    REAL(KIND=dp), DIMENSION(:), INTENT(IN)  :: zetb, rpgfb
+    REAL(KIND=dp), DIMENSION(:, :, :), &
+      INTENT(INOUT)                          :: mab
+    REAL(KIND=dp), DIMENSION(3)              :: rab, rap, rbp, rpc
+    REAL(KIND=dp), DIMENSION(ncoset(la_max),&
+      ncoset(lb_max), ncoset(lc_max))        :: s
+    DO ipgf=1,npgfa
+      DO jpgf=1,npgfb
+        IF (rpgfa(ipgf) + rpgfb(jpgf) < dab) THEN
+          DO k=1, ncoset(lc_max)-1
+            DO j=nb+1,nb+ncoset(lb_max)
+              DO i=na+1,na+ncoset(la_max)
+                mab(i,j,k) = 0.0_dp
+              END DO
+            END DO
+          END DO
+        END IF
+        rpc = zetp*(zeta(ipgf)*rac+zetb(jpgf)*rbc)
+        DO l=2, ncoset(lc_max)
+          lx = indco(1,l)
+          l2 = 0
+          IF ( lz > 0 ) THEN
+            IF ( lz > 1 ) l2 = coset(lx,ly,lz-2)
+          ELSE IF ( ly > 0 ) THEN
+            IF ( ly > 1 ) l2 = coset(lx,ly-2,lz)
+            IF ( lx > 1 ) l2 = coset(lx-2,ly,lz)
+          END IF
+          s(1,1,l) = rpc(i)*s(1,1,l1)
+          IF ( l2 > 0 ) s(1,1,l) = s(1,1,l) + f2*REAL(ni,dp)*s(1,1,l2)
+        END DO
+        DO l = 1, ncoset(lc_max)
+          IF ( lx > 0 ) THEN 
+            lx1 = coset(lx-1,ly,lz)
+          END IF
+          IF ( ly > 0 ) THEN 
+            ly1 = coset(lx,ly-1,lz)
+          END IF
+          IF (la_max > 0) THEN
+            DO la=2,la_max
+              IF ( lz1 > 0 ) s(coset(0,0,la),1,l) = s(coset(0,0,la),1,l) + &
+                             f2z*s(coset(0,0,la-1),1,lz1)
+              IF ( ly1 > 0 ) s(coset(0,1,az),1,l) = s(coset(0,1,az),1,l) + &
+                             f2y*s(coset(0,0,az),1,ly1)
+              DO ay=2,la
+                s(coset(0,ay,az),1,l) = rap(2)*s(coset(0,ay-1,az),1,l) +&
+                                       f2*REAL(ay-1,dp)*s(coset(0,ay-2,az),1,l)
+                IF ( ly1 > 0 ) s(coset(0,ay,az),1,l) = s(coset(0,ay,az),1,l) + &
+                             f2y*s(coset(0,ay-1,az),1,ly1)
+              END DO
+              DO ay=0,la-1
+                IF ( lx1 > 0 ) s(coset(1,ay,az),1,l) = s(coset(1,ay,az),1,l) + &
+                             f2x*s(coset(0,ay,az),1,lx1)
+              END DO
+              DO ax=2,la
+                DO ay=0,la-ax
+                  s(coset(ax,ay,az),1,l) = rap(1)*s(coset(ax-1,ay,az),1,l) +&
+                                          f3*s(coset(ax-2,ay,az),1,l) 
+                  IF ( lx1 > 0 ) s(coset(ax,ay,az),1,l) = s(coset(ax,ay,az),1,l) + &
+                                 f2x*s(coset(ax-1,ay,az),1,lx1)
+                END DO
+              END DO
+            END DO
+            IF (lb_max > 0) THEN
+              DO j=2,ncoset(lb_max)
+                DO i=1,ncoset(la_max)
+                  s(i,j,l) = 0.0_dp
+                END DO
+              END DO
+              DO la=la_start,la_max-1
+                DO ax=0,la
+                  DO ay=0,la-ax
+                    s(coset(ax,ay,az),2,l) = s(coset(ax+1,ay,az),1,l) -&
+                                           rab(1)*s(coset(ax,ay,az),1,l)
+                    s(coset(ax,ay,az),4,l) = s(coset(ax,ay,az+1),1,l) -&
+                                           rab(3)*s(coset(ax,ay,az),1,l)
+                  END DO
+                END DO
+              END DO
+              DO ax=0,la_max
+                DO ay=0,la_max-ax
+                  IF (ax == 0) THEN
+                    s(coset(ax,ay,az),2,l) = rbp(1)*s(coset(ax,ay,az),1,l)
+                  ELSE
+                    s(coset(ax,ay,az),2,l) = rbp(1)*s(coset(ax,ay,az),1,l) +&
+                                            fx*s(coset(ax-1,ay,az),1,l)
+                  END IF
+                  IF (lx1 > 0) s(coset(ax,ay,az),2,l) = s(coset(ax,ay,az),2,l) +&
+                        f2x*s(coset(ax,ay,az),1,lx1)
+                  IF (ay == 0) THEN
+                    s(coset(ax,ay,az),3,l) = rbp(2)*s(coset(ax,ay,az),1,l)
+                  ELSE
+                    s(coset(ax,ay,az),3,l) = rbp(2)*s(coset(ax,ay,az),1,l) +&
+                                            fy*s(coset(ax,ay-1,az),1,l)
+                  END IF
+                  IF (ly1 > 0) s(coset(ax,ay,az),3,l) = s(coset(ax,ay,az),3,l) +&
+                        f2y*s(coset(ax,ay,az),1,ly1)
+                  IF (az == 0) THEN
+                    s(coset(ax,ay,az),4,l) = rbp(3)*s(coset(ax,ay,az),1,l)
+                  ELSE
+                    s(coset(ax,ay,az),4,l) = rbp(3)*s(coset(ax,ay,az),1,l) +&
+                                            fz*s(coset(ax,ay,az-1),1,l)
+                  END IF
+                  IF (lz1 > 0) s(coset(ax,ay,az),4,l) = s(coset(ax,ay,az),4,l) +&
+                        f2z*s(coset(ax,ay,az),1,lz1)
+                END DO
+              END DO
+              DO lb=2,lb_max
+                DO la=la_start,la_max-1
+                  DO ax=0,la
+                    DO ay=0,la-ax
+                      s(coset(ax,ay,az),coset(0,0,lb),l) =&
+                        rab(3)*s(coset(ax,ay,az),coset(0,0,lb-1),l)
+                      DO bx=1,lb
+                        DO by=0,lb-bx
+                          s(coset(ax,ay,az),coset(bx,by,bz),l) =&
+                            rab(1)*s(coset(ax,ay,az),coset(bx-1,by,bz),l)
+                        END DO
+                      END DO
+                    END DO
+                  END DO
+                END DO
+                DO ax=0,la_max
+                  DO ay=0,la_max-ax
+                    IF (az == 0) THEN
+                      s(coset(ax,ay,az),coset(0,0,lb),l) =&
+                        rbp(3)*s(coset(ax,ay,az),coset(0,0,lb-1),l) +&
+                        f3*s(coset(ax,ay,az),coset(0,0,lb-2),l)
+                    END IF
+                    IF (lz1 > 0) s(coset(ax,ay,az),coset(0,0,lb),l) =&
+                                 f2z*s(coset(ax,ay,az),coset(0,0,lb-1),lz1)
+                    IF (ay == 0) THEN
+                      IF (ly1 > 0) s(coset(ax,ay,az),coset(0,1,bz),l) =&
+                                 f2y*s(coset(ax,ay,az),coset(0,0,bz),ly1)
+                      DO by=2,lb
+                        s(coset(ax,ay,az),coset(0,by,bz),l) =&
+                          f3*s(coset(ax,ay,az),coset(0,by-2,bz),l)
+                        IF (ly1 > 0) s(coset(ax,ay,az),coset(0,by,bz),l) =&
+                                 f2y*s(coset(ax,ay,az),coset(0,by-1,bz),ly1)
+                      END DO
+                      s(coset(ax,ay,az),coset(0,1,bz),l) =&
+                        fy*s(coset(ax,ay-1,az),coset(0,0,bz),l)
+                    END IF
+                    IF (ax == 0) THEN
+                      DO by=0,lb-1
+                        IF (lx1 > 0) s(coset(ax,ay,az),coset(1,by,bz),l) =&
+                                 f2x*s(coset(ax,ay,az),coset(0,by,bz),lx1)
+                      END DO
+                      DO bx=2,lb
+                        DO by=0,lb-bx
+                          s(coset(ax,ay,az),coset(bx,by,bz),l) =&
+                            f3*s(coset(ax,ay,az),coset(bx-2,by,bz),l)
+                          IF (lx1 > 0) s(coset(ax,ay,az),coset(bx,by,bz),l) =&
+                                 f2x*s(coset(ax,ay,az),coset(bx-1,by,bz),lx1)
+                        END DO
+                      END DO
+                      DO by=0,lb-1
+                        IF (lx1 > 0) s(coset(ax,ay,az),coset(1,by,bz),l) =&
+                                 f2x*s(coset(ax,ay,az),coset(0,by,bz),lx1)
+                      END DO
+                      DO bx=2,lb
+                        DO by=0,lb-bx
+                          s(coset(ax,ay,az),coset(bx,by,bz),l) =&
+                            f3*s(coset(ax,ay,az),coset(bx-2,by,bz),l)
+                          IF (lx1 > 0) s(coset(ax,ay,az),coset(bx,by,bz),l) =&
+                                 f2x*s(coset(ax,ay,az),coset(bx-1,by,bz),lx1)
+                        END DO
+                      END DO
+                    END IF
+                  END DO
+                END DO
+              END DO
+            END IF
+            IF (lb_max > 0) THEN
+              DO lb=2,lb_max
+                IF (lz1 > 0) s(1,coset(0,0,lb),l) = s(1,coset(0,0,lb),l) +&
+                             f2z*s(1,coset(0,0,lb-1),lz1)
+                IF (ly1 > 0) s(1,coset(0,1,bz),l) = s(1,coset(0,1,bz),l) +&
+                             f2y*s(1,coset(0,0,bz),ly1)
+              DO by=2,lb
+                s(1,coset(0,by,bz),l) = rbp(2)*s(1,coset(0,by-1,bz),l) +&
+                                       f2*REAL(by-1,dp)*s(1,coset(0,by-2,bz),l)
+                IF (lx1 > 0) s(1,coset(1,by,bz),l) = s(1,coset(1,by,bz),l) +&
+                             f2x*s(1,coset(0,by,bz),lx1)
+              END DO
+              DO bx=2,lb
+                DO by=0,lb-bx
+                  IF (lx1 > 0) s(1,coset(bx,by,bz),l) = s(1,coset(bx,by,bz),l) +&
+                               f2x*s(1,coset(bx-1,by,bz),lx1)
+                END DO
+              END DO
+            END DO
+          END IF
+        END IF
+        END DO
+        DO k=2,ncoset(lc_max)
+          DO j=1,ncoset(lb_max)
+          END DO
+        END DO
+      END DO
+    END DO
+  END SUBROUTINE moment
+  SUBROUTINE diff_momop(la_max,npgfa,zeta,rpgfa,la_min,&
+                    order,rac,rbc,difmab,mab_ext)
+    REAL(KIND=dp), DIMENSION(:, :, :), &
+      OPTIONAL, POINTER                      :: mab_ext
+    REAL(KIND=dp), ALLOCATABLE, &
+      DIMENSION(:, :, :)                     :: difmab_tmp
+    DO imom = 1,ncoset(order)-1
+      CALL adbdr(la_max,npgfa,rpgfa,la_min,&
+                 difmab_tmp(:,:,2), difmab_tmp(:,:,3))
+    END DO
+  END SUBROUTINE diff_momop
+END MODULE ai_moments
Index: gcc/testsuite/gfortran.dg/namelist_59.f90
===================================================================
--- gcc/testsuite/gfortran.dg/namelist_59.f90	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/namelist_59.f90	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,26 @@
+! { dg-do run }
+! PR41192 NAMELIST input with just a comment ("&NAME ! comment \") error 
+program cmdline
+! comment by itself causes error in gfortran
+   call process(' ')
+   call process('i=10 , j=20 k=30 ! change all three values')
+   call process(' ')
+   call process('! change no values')! before patch this failed.
+end program cmdline
+
+subroutine process(string)
+ implicit none
+ character(len=*) :: string
+ character(len=132) :: lines(3)
+ character(len=255) :: message
+ integer :: i=1,j=2,k=3
+ integer ios
+ namelist /cmd/ i,j,k
+ save cmd
+ lines(1)='&cmd'
+ lines(2)=string
+ lines(3)='/'
+
+ read(lines,nml=cmd,iostat=ios,iomsg=message)
+ if (ios.ne.0) call abort
+end subroutine process
Index: gcc/testsuite/gfortran.dg/pr42166.f90
===================================================================
--- gcc/testsuite/gfortran.dg/pr42166.f90	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/pr42166.f90	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,20 @@
+! { dg-options "-O2 -g" }
+
+MODULE powell
+  INTEGER, PARAMETER :: dp=8
+CONTAINS
+  SUBROUTINE newuob (n,  bmat,  ndim,  d,  vlag,  w, npt)
+    REAL(dp), DIMENSION(ndim, *), INTENT(inout) :: bmat
+    REAL(dp), DIMENSION(*), INTENT(inout)    :: d, vlag, w
+    REAL(dp) :: sum
+    INTEGER, INTENT(in) :: npt
+    DO j=1,n
+       jp=npt+j
+       DO k=1,n
+          sum=sum+bmat(jp,k)*d(k)
+       END DO
+       vlag(jp)=sum
+    END DO
+  END SUBROUTINE newuob
+END MODULE powell
+
Index: gcc/testsuite/gfortran.dg/array_function_5.f90
===================================================================
--- gcc/testsuite/gfortran.dg/array_function_5.f90	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/array_function_5.f90	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,16 @@
+! {  dg-do run )
+! PR41278 internal compiler error related to matmul and transpose
+! Test case prepared by Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+program bug
+  implicit none
+  real, dimension(3,3) :: matA,matB,matC
+
+  matA(1,:)=(/1., 2., 3./)
+  matA(2,:)=(/4., 5., 6./)
+  matA(3,:)=(/7., 8., 9./)
+
+  matB=matmul(transpose(0.5*matA),matA)
+  matC = transpose(0.5*matA)
+  matC = matmul(matC, matA)
+  if (any(matB.ne.matC)) call abort()
+end program bug
Index: gcc/testsuite/gfortran.dg/list_read_10.f90
===================================================================
--- gcc/testsuite/gfortran.dg/list_read_10.f90	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/list_read_10.f90	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,14 @@
+! { dg-do run }
+! PR 42422 - read with a repeat specifyer following a separator
+program main
+  integer, dimension(10) :: i1, i2
+
+  i1 = 0
+  i2 = (/ 1, 2, 3, 5, 5, 5, 5, 0, 0, 0 /)
+  open (10,file="pr42422.dat")
+  write (10,'(A)') ' 1 2 3 4*5 /'
+  rewind 10
+  read (10,*) i1
+  if (any(i1 /= i2)) call abort
+  close (10,status="delete")
+end program main
Index: gcc/testsuite/gfortran.dg/c_assoc_3.f90
===================================================================
--- gcc/testsuite/gfortran.dg/c_assoc_3.f90	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/c_assoc_3.f90	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,13 @@
+! { dg-do compile }
+!
+! PR fortran/43303
+!
+! Contributed by Dennis Wassel
+!
+PROGRAM c_assoc
+  use iso_c_binding
+  type(c_ptr) :: x
+  x = c_null_ptr
+  print *, C_ASSOCIATED(x) ! <<< was ICEing here
+  if (C_ASSOCIATED(x)) call abort ()
+END PROGRAM c_assoc
Index: gcc/testsuite/gfortran.dg/alloc_comp_basics_1.f90
===================================================================
--- gcc/testsuite/gfortran.dg/alloc_comp_basics_1.f90	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/gfortran.dg/alloc_comp_basics_1.f90	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,5 +1,5 @@
 ! { dg-do run }
-! { dg-options "-O2 -fdump-tree-original" }
+! { dg-options "-fdump-tree-original" }
 !
 ! Check some basic functionality of allocatable components, including that they
 ! are nullified when created and automatically deallocated when
Index: gcc/testsuite/gfortran.dg/dependency_25.f90
===================================================================
--- gcc/testsuite/gfortran.dg/dependency_25.f90	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/dependency_25.f90	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,95 @@
+! { dg-do run }
+! Test the fix for PR42736, in which an excessively rigorous dependency
+! checking for the assignment generated an unnecessary temporary, whose
+! rank was wrong.  When accessed by the scalarizer, a segfault ensued.
+!
+! Contributed by Tobias Burnus <burnus@gcc.gnu.org>
+! Reported by Armelius Cameron <armeliusc@gmail.com>
+!
+module UnitValue_Module
+
+  implicit none
+  private
+
+  public :: &
+    operator(*), &
+    assignment(=)
+
+  type, public :: UnitValue
+    real :: &
+      Value = 1.0
+    character(31) :: &
+      Label
+  end type UnitValue
+
+  interface operator(*)
+    module procedure ProductReal_LV
+  end interface operator(*)
+
+  interface assignment(=)
+    module procedure Assign_LV_Real
+  end interface assignment(=)
+
+contains
+
+  elemental function ProductReal_LV(Multiplier, Multiplicand) result(P_R_LV)
+
+    real, intent(in) :: &
+      Multiplier
+    type(UnitValue), intent(in) :: &
+      Multiplicand
+    type(UnitValue) :: &
+      P_R_LV
+
+    P_R_LV%Value = Multiplier * Multiplicand%Value
+    P_R_LV%Label = Multiplicand%Label
+
+  end function ProductReal_LV
+
+
+  elemental subroutine Assign_LV_Real(LeftHandSide, RightHandSide)
+
+    real, intent(inout) :: &
+      LeftHandSide
+    type(UnitValue), intent(in) :: &
+      RightHandSide
+
+    LeftHandSide = RightHandSide%Value
+
+  end subroutine Assign_LV_Real
+
+end module UnitValue_Module
+
+program TestProgram
+
+  use UnitValue_Module
+
+  implicit none
+
+  type :: TableForm
+    real, dimension(:,:), allocatable :: &
+      RealData
+  end type TableForm
+
+  type(UnitValue) :: &
+    CENTIMETER
+
+  type(TableForm), pointer :: &
+    Table
+
+  allocate(Table)
+  allocate(Table%RealData(10,5))
+
+  CENTIMETER%value = 42
+  Table%RealData = 1
+  Table%RealData(:,1) = Table%RealData(:,1) * CENTIMETER
+  Table%RealData(:,2) = Table%RealData(:,2) * CENTIMETER
+  Table%RealData(:,3) = Table%RealData(:,3) * CENTIMETER
+  Table%RealData(:,5) = Table%RealData(:,5) * CENTIMETER
+
+!  print *, Table%RealData
+  if (any (abs(Table%RealData(:,4) - 1) > epsilon(1.0))) call abort ()
+  if (any (abs(Table%RealData(:,[1,2,3,5]) - 42) > epsilon(1.0))) call abort ()
+end program TestProgram
+
+! { dg-final { cleanup-modules "UnitValue_Module" } }
Index: gcc/testsuite/gfortran.dg/equiv_8.f90
===================================================================
--- gcc/testsuite/gfortran.dg/equiv_8.f90	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/equiv_8.f90	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,7 @@
+! { dg-do compile }
+!
+! PR fortran/41755
+!
+      common /uno/ aa
+      equivalence (aa,aaaaa)   (bb,cc) ! { dg-error "Expecting a comma in EQUIVALENCE" }
+      end
Index: gcc/testsuite/gfortran.dg/intrinsic_pack_5.f90
===================================================================
--- gcc/testsuite/gfortran.dg/intrinsic_pack_5.f90	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/intrinsic_pack_5.f90	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,16 @@
+! { dg-do run }
+!
+! PR 41478: Corrupted memory using PACK for derived-types with allocated components
+! PR 42268: [4.4/4.5 Regression] derived type segfault with pack
+!
+! Original test case by Juergen Reuter <reuter@physik.uni-freiburg.de>
+! Modified by Janus Weil <janus@gcc.gnu.org>
+
+type :: container_t
+  integer:: entry = -1
+end type container_t
+type(container_t), dimension(1) :: a1, a2
+a2(1)%entry = 1
+a1 = pack (a2, mask = [.true.])
+if (a1(1)%entry/=1) call abort()
+end
Index: gcc/testsuite/gfortran.dg/array_constructor_35.f90
===================================================================
--- gcc/testsuite/gfortran.dg/array_constructor_35.f90	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/array_constructor_35.f90	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,9 @@
+! { dg-do compile }
+! PR42999  bogus error: Parameter 'i' at (1) has not been declared
+! or is a variable, which does not reduce to a constant expression
+ TYPE DD
+  INTEGER :: I
+ END TYPE DD
+ TYPE(DD) :: X(2)=(/(DD(I),I=1,2)/)
+ END
+
Index: gcc/testsuite/gfortran.dg/generic_21.f90
===================================================================
--- gcc/testsuite/gfortran.dg/generic_21.f90	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/generic_21.f90	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,33 @@
+! { dg-do compile }
+!
+! PR fortran/42858
+!
+! Contributed by Harald Anlauf
+!
+module gfcbug102
+  implicit none
+  type t_vector_segm
+     real ,pointer :: x(:) => NULL()
+  end type t_vector_segm
+
+  type t_vector
+     integer                       :: n_s     =  0
+     type (t_vector_segm) ,pointer :: s (:)   => NULL()
+  end type t_vector
+
+  interface sqrt
+     module procedure sqrt_vector
+  end interface sqrt
+
+contains
+  function sqrt_vector (x) result (y)
+    type (t_vector)             :: y
+    type (t_vector) ,intent(in) :: x
+    integer :: i
+    do i = 1, y% n_s
+       y% s(i)% x = sqrt (x% s(i)% x)
+    end do
+  end function sqrt_vector
+end module gfcbug102
+
+! { dg-final { cleanup-modules "gfcbug102" } }
Index: gcc/testsuite/gfortran.dg/subref_array_pointer_4.f90
===================================================================
--- gcc/testsuite/gfortran.dg/subref_array_pointer_4.f90	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/subref_array_pointer_4.f90	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,27 @@
+! { dg-do run }
+! Tests the fix for PR42309, in which the indexing of 'Q'
+! was off by one.
+!
+! Contributed by Gilbert Scott <gilbert.scott@easynet.co.uk>
+!
+PROGRAM X
+  TYPE T
+    INTEGER :: I
+    REAL :: X
+  END TYPE T
+  TYPE(T), TARGET :: T1(0:3)
+  INTEGER, POINTER :: P(:)
+  REAL :: SOURCE(4) = [10., 20., 30., 40.]
+
+  T1%I = [1, 2, 3, 4]
+  T1%X = SOURCE
+  P => T1%I
+  CALL Z(P)
+  IF (ANY (T1%I .NE. [999, 2, 999, 4])) CALL ABORT
+  IF (ANY (T1%X .NE. SOURCE)) CALL ABORT
+CONTAINS
+  SUBROUTINE Z(Q)
+    INTEGER, POINTER :: Q(:)
+    Q(1:3:2) = 999
+  END SUBROUTINE Z
+END PROGRAM X
Index: gcc/testsuite/gfortran.dg/recursive_check_15.f90
===================================================================
--- gcc/testsuite/gfortran.dg/recursive_check_15.f90	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/recursive_check_15.f90	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,12 @@
+! { dg-do compile }
+! PR41909 ICE with "call foo" in "program foo"
+program test ! { dg-error "Global name" }
+  implicit none
+  call test()  ! { dg-error "" }
+contains
+  subroutine one(a)
+    real, dimension(:,:), intent(inout), optional :: a
+    call two(a)
+  end subroutine one
+end program test
+
Index: gcc/testsuite/gfortran.dg/intent_out_6.f90
===================================================================
--- gcc/testsuite/gfortran.dg/intent_out_6.f90	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/intent_out_6.f90	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,39 @@
+! { dg-do run }
+!
+! PR fortran/41850
+!
+module test_module
+  implicit none
+contains
+  subroutine sub2(a)
+    implicit none
+    real,allocatable,intent(out),optional :: a(:)
+    if(present(a)) then
+      if(allocated(a)) call abort()
+      allocate(a(1))
+      a(1) = 5
+    end if
+  end subroutine sub2
+  subroutine sub1(a)
+    implicit none
+    real,allocatable,intent(out),optional :: a(:)
+!    print *,'in sub1'
+    call sub2(a)
+    if(present(a)) then
+      if(a(1) /= 5) call abort()
+    end if
+  end subroutine sub1
+end module test_module
+
+program test
+  use test_module
+  implicit none
+  real, allocatable :: x(:)
+  allocate(x(1))
+  call sub1()
+  x = 8
+  call sub1(x)
+  if(x(1) /= 5) call abort()
+end program
+
+! { dg-final { cleanup-modules "test_module" } }
Index: gcc/testsuite/gfortran.dg/direct_io_11.f90
===================================================================
--- gcc/testsuite/gfortran.dg/direct_io_11.f90	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/direct_io_11.f90	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,55 @@
+! { dg-do run }
+! PR42090 Problems reading partial records in formatted direct access files
+! Test case from PR, prepared by Jerry DeLisle <jvdelisle@gcc.gnu.org>
+program da_good_now
+  implicit none
+  real :: a, b
+
+  a = 1.111111111
+  b = 2.222222222
+
+  open( 10, file = 't.dat', form = 'formatted', access = 'direct', recl = 12 )
+  write( 10, rec = 1, fmt = '( f6.4, /, f6.4 )' ) a, b
+  close( 10 )
+
+  a = -1.0
+  b = -1.0
+
+  open( 10, file = 't.dat', form = 'formatted', access = 'direct', recl = 12 )
+
+  read( 10, rec = 1, fmt = '( f6.4, /, f6.4 )' ) a, b
+  !write( *, '( "partial record 1", t25, 2( f6.4, 1x ) )' ) a, b
+  a = -1.0
+  b = -1.0
+
+  read( 10, rec = 1, fmt = '( f6.4 )' ) a, b
+  !write( *, '( "partial record 2", t25, 2( f6.4, 1x ) )' ) a, b
+  if (a /= 1.1111 .and. b /= 2.2222) call abort()
+  a = -1.0
+  b = -1.0
+
+  read( 10, rec = 1, fmt = '( f12.4, /, f12.4 )' ) a, b
+  !write( *, '( "full record 1", t25, 2( f6.4, 1x ) )' ) a, b
+  if (a /= 1.1111 .and. b /= 2.2222) call abort()
+  a = -1.0
+  b = -1.0
+
+  read( 10, rec = 1, fmt = '( f12.4 )' ) a, b
+  !write( *, '( "full record 2", t25, 2( f6.4, 1x ) )' ) a, b
+  if (a /= 1.1111 .and. b /= 2.2222) call abort()
+  a = -1.0
+  b = -1.0
+
+  read( 10, rec = 1, fmt = '( f6.4, 6x, /, f6.4, 6x )' ) a, b
+  !write( *, '( "full record with 6x", t25, 2( f6.4, 1x ) )' ) a, b
+  if (a /= 1.1111 .and. b /= 2.2222) call abort()
+  a = -1.0
+  b = -1.0
+
+  read( 10, rec = 1, fmt = '( f6.4 )' ) a
+  read( 10, rec = 2, fmt = '( f6.4 )' ) b
+  !write( *, '( "record at a time", t25, 2( f6.4, 1x ) )' ) a, b
+  if (a /= 1.1111 .and. b /= 2.2222) call abort()
+
+  close( 10, status="delete")
+end program da_good_now
Index: gcc/testsuite/objc/execute/forward-1.x
===================================================================
--- gcc/testsuite/objc/execute/forward-1.x	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/testsuite/objc/execute/forward-1.x	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,8 +1,6 @@
 load_lib target-supports.exp
 
 # XFAIL: PR libobjc/36610, for targets which pass arguments via registers
-# For powerpc-darwin it fails with -fgnu-runtime, passes with -fnext-runtime,
-# but that would be too ugly to handle; let it fail there.
 
 if { ([istarget x86_64-*-linux*] && [check_effective_target_lp64] )
      || [istarget powerpc*-*-linux*]
@@ -15,4 +13,21 @@
     set torture_execute_xfail "*-*-*"
 }
 
+# For darwin and alpha-linux it fails with -fgnu-runtime,
+# passes with -fnext-runtime.
+
+if { ([istarget x86_64-*-darwin*] && [check_effective_target_lp64] )
+     || [istarget powerpc*-*-darwin*]
+     || [istarget alpha*-*-linux*] } {
+    set torture_eval_before_execute {
+	global compiler_conditional_xfail_data
+	set compiler_conditional_xfail_data {
+	    "Target fails with -fgnu-runtime" \
+		"*-*-*" \
+		{ "-fgnu-runtime" } \
+		{ "" }
+	}
+    }
+}
+
 return 0
Index: gcc/testsuite/c-c++-common/builtin-offsetof.c
===================================================================
--- gcc/testsuite/c-c++-common/builtin-offsetof.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/c-c++-common/builtin-offsetof.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,28 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin PR c++/38699
+// { dg-options "-Warray-bounds" }
+// { dg-do compile }
+
+struct A
+{
+  const char *p;
+};
+
+struct B
+{
+    char p[10];
+    struct A a;
+};
+
+void
+f0 ()
+{
+  __builtin_offsetof(struct A, p); // OK
+  __builtin_offsetof(struct A, p[0]); // { dg-error "non constant address" }
+  __builtin_offsetof(struct B, p[0]); // OK
+  __builtin_offsetof(struct B, p[9]); // OK
+  __builtin_offsetof(struct B, p[10]); // OK
+  __builtin_offsetof(struct B, a.p); // OK
+  __builtin_offsetof(struct B, p[0]); // OK
+  __builtin_offsetof(struct B, a.p[0]); // { dg-error "non constant address" }
+}
Index: gcc/testsuite/c-c++-common/pr42674.c
===================================================================
--- gcc/testsuite/c-c++-common/pr42674.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/testsuite/c-c++-common/pr42674.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,13 @@
+/* PR middle-end/42674 */
+/* { dg-do compile } */
+/* { dg-options "-Wreturn-type" } */
+
+extern void bar (void);
+static int foo (void) __attribute__ ((__noreturn__, __used__));
+
+static int
+foo (void)
+{
+  while (1)
+    bar ();
+}
Index: gcc/objcp/ChangeLog
===================================================================
--- gcc/objcp/ChangeLog	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/objcp/ChangeLog	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,3 +1,7 @@
+2010-01-21  Release Manager
+
+	* GCC 4.4.3 released.
+
 2009-10-15  Release Manager
 
 	* GCC 4.4.2 released.
Index: gcc/cp/typeck.c
===================================================================
--- gcc/cp/typeck.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/cp/typeck.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -5463,12 +5463,17 @@
 		 intype, type);
 
       expr = cp_build_unary_op (ADDR_EXPR, expr, 0, complain);
+
+      if (warn_strict_aliasing > 2)
+	strict_aliasing_warning (TREE_TYPE (expr), type, expr);
+
       if (expr != error_mark_node)
 	expr = build_reinterpret_cast_1
 	  (build_pointer_type (TREE_TYPE (type)), expr, c_cast_p,
 	   valid_p, complain);
       if (expr != error_mark_node)
-	expr = cp_build_indirect_ref (expr, 0, complain);
+	/* cp_build_indirect_ref isn't right for rvalue refs.  */
+	expr = convert_from_reference (fold_convert (type, expr));
       return expr;
     }
 
@@ -6091,11 +6096,15 @@
     {
       int from_array;
 
-      if (BRACE_ENCLOSED_INITIALIZER_P (rhs))
-	rhs = digest_init (lhstype, rhs);
+      if (BRACE_ENCLOSED_INITIALIZER_P (newrhs))
+	{
+	  if (check_array_initializer (lhs, lhstype, newrhs))
+	    return error_mark_node;
+	  newrhs = digest_init (lhstype, newrhs);
+	}
 
       else if (!same_or_base_type_p (TYPE_MAIN_VARIANT (lhstype),
-				     TYPE_MAIN_VARIANT (TREE_TYPE (rhs))))
+				     TYPE_MAIN_VARIANT (TREE_TYPE (newrhs))))
 	{
 	  if (complain & tf_error)
 	    error ("incompatible types in assignment of %qT to %qT",
Index: gcc/cp/decl.c
===================================================================
--- gcc/cp/decl.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/cp/decl.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -7133,16 +7133,9 @@
 {
   if (TREE_CODE (member_type) == METHOD_TYPE)
     {
-      tree arg_types;
-
-      arg_types = TYPE_ARG_TYPES (member_type);
-      class_type = (cp_build_qualified_type
-		    (class_type,
-		     cp_type_quals (TREE_TYPE (TREE_VALUE (arg_types)))));
-      member_type
-	= build_method_type_directly (class_type,
-				      TREE_TYPE (member_type),
-				      TREE_CHAIN (arg_types));
+      tree arg_types = TYPE_ARG_TYPES (member_type);
+      cp_cv_quals quals = cp_type_quals (TREE_TYPE (TREE_VALUE (arg_types)));
+      member_type = build_memfn_type (member_type, class_type, quals);
       return build_ptrmemfunc_type (build_pointer_type (member_type));
     }
   else
@@ -7225,11 +7218,8 @@
 	 structural equality checks.  */
       itype = build_index_type (build_min (MINUS_EXPR, sizetype,
 					   size, integer_one_node));
-      if (!TREE_SIDE_EFFECTS (size))
-	{
-	  TYPE_DEPENDENT_P (itype) = 1;
-	  TYPE_DEPENDENT_P_VALID (itype) = 1;
-	}
+      TYPE_DEPENDENT_P (itype) = 1;
+      TYPE_DEPENDENT_P_VALID (itype) = 1;
       SET_TYPE_STRUCTURAL_EQUALITY (itype);
       return itype;
     }
@@ -8898,7 +8888,9 @@
       tree decls = NULL_TREE;
       tree args;
 
-      for (args = TYPE_ARG_TYPES (type); args; args = TREE_CHAIN (args))
+      for (args = TYPE_ARG_TYPES (type);
+	   args && args != void_list_node;
+	   args = TREE_CHAIN (args))
 	{
 	  tree decl = cp_build_parm_decl (NULL_TREE, TREE_VALUE (args));
 
@@ -12361,6 +12353,8 @@
       && !current_function_returns_value && !current_function_returns_null
       /* Don't complain if we abort or throw.  */
       && !current_function_returns_abnormally
+      /* Don't complain if we are declared noreturn.  */
+      && !TREE_THIS_VOLATILE (fndecl)
       && !DECL_NAME (DECL_RESULT (fndecl))
       && !TREE_NO_WARNING (fndecl)
       /* Structor return values (if any) are set by the compiler.  */
Index: gcc/cp/call.c
===================================================================
--- gcc/cp/call.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/cp/call.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -887,10 +887,7 @@
 	  || cp_type_quals (fbase) != cp_type_quals (tbase))
 	return NULL;
 
-      from = cp_build_qualified_type (tbase, cp_type_quals (fbase));
-      from = build_method_type_directly (from,
-					 TREE_TYPE (fromfn),
-					 TREE_CHAIN (TYPE_ARG_TYPES (fromfn)));
+      from = build_memfn_type (fromfn, tbase, cp_type_quals (tbase));
       from = build_ptrmemfunc_type (build_pointer_type (from));
       conv = build_conv (ck_pmem, from, conv);
       conv->base_p = true;
@@ -1221,6 +1218,8 @@
 	  && CONSTRUCTOR_NELTS (expr) == 1)
 	{
 	  expr = CONSTRUCTOR_ELT (expr, 0)->value;
+	  if (error_operand_p (expr))
+	    return NULL;
 	  from = TREE_TYPE (expr);
 	}
     }
@@ -4744,7 +4743,7 @@
   switch (convs->kind)
     {
     case ck_rvalue:
-      expr = convert_bitfield_to_declared_type (expr);
+      expr = decay_conversion (expr);
       if (! MAYBE_CLASS_TYPE_P (totype))
 	return expr;
       /* Else fall through.  */
@@ -6327,8 +6326,9 @@
       /* We couldn't make up our minds; try to figure it out below.  */
     }
 
-  if (ics1->ellipsis_p)
-    /* Both conversions are ellipsis conversions.  */
+  if (ics1->ellipsis_p || ics1->kind == ck_list)
+    /* Both conversions are ellipsis conversions or both are building a
+       std::initializer_list.  */
     return 0;
 
   /* User-defined  conversion sequence U1 is a better conversion sequence
Index: gcc/cp/method.c
===================================================================
--- gcc/cp/method.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/cp/method.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -380,7 +380,7 @@
   DECL_VISIBILITY (thunk_fndecl) = DECL_VISIBILITY (function);
   DECL_VISIBILITY_SPECIFIED (thunk_fndecl)
     = DECL_VISIBILITY_SPECIFIED (function);
-  if (DECL_ONE_ONLY (function))
+  if (DECL_ONE_ONLY (function) || DECL_WEAK (function))
     make_decl_one_only (thunk_fndecl);
 
   if (flag_syntax_only)
Index: gcc/cp/tree.c
===================================================================
--- gcc/cp/tree.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/cp/tree.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -922,10 +922,14 @@
 tree
 canonical_type_variant (tree t)
 {
+  tree r;
+
   if (t == error_mark_node)
     return error_mark_node;
 
-  return cp_build_qualified_type (TYPE_MAIN_VARIANT (t), cp_type_quals (t));
+  r = cp_build_type_attribute_variant (TYPE_MAIN_VARIANT (t),
+				       TYPE_ATTRIBUTES (t));
+  return cp_build_qualified_type (r, cp_type_quals (t));
 }
 
 /* Makes a copy of BINFO and TYPE, which is to be inherited into a
@@ -1909,6 +1913,8 @@
     case TEMPLATE_PARM_INDEX:
       return (TEMPLATE_PARM_IDX (t1) == TEMPLATE_PARM_IDX (t2)
 	      && TEMPLATE_PARM_LEVEL (t1) == TEMPLATE_PARM_LEVEL (t2)
+	      && (TEMPLATE_PARM_PARAMETER_PACK (t1)
+		  == TEMPLATE_PARM_PARAMETER_PACK (t2))
 	      && same_type_p (TREE_TYPE (TEMPLATE_PARM_DECL (t1)),
 			      TREE_TYPE (TEMPLATE_PARM_DECL (t2))));
 
Index: gcc/cp/mangle.c
===================================================================
--- gcc/cp/mangle.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/cp/mangle.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -2071,21 +2071,22 @@
 /* Non-terminal <template-args>.  ARGS is a TREE_VEC of template
    arguments.
 
-     <template-args> ::= I <template-arg>+ E  */
+     <template-args> ::= I <template-arg>* E  */
 
 static void
 write_template_args (tree args)
 {
   int i;
-  int length = TREE_VEC_LENGTH (args);
+  int length = 0;
 
   MANGLE_TRACE_TREE ("template-args", args);
 
   write_char ('I');
 
-  gcc_assert (length > 0);
+  if (args)
+    length = TREE_VEC_LENGTH (args);
 
-  if (TREE_CODE (TREE_VEC_ELT (args, 0)) == TREE_VEC)
+  if (args && TREE_CODE (TREE_VEC_ELT (args, 0)) == TREE_VEC)
     {
       /* We have nested template args.  We want the innermost template
 	 argument list.  */
@@ -2109,12 +2110,7 @@
   if (TREE_CODE (member) == IDENTIFIER_NODE)
     write_source_name (member);
   else if (DECL_P (member))
-    {
-      /* G++ 3.2 incorrectly put out both the "sr" code and
-	 the nested name of the qualified name.  */
-      G.need_abi_warning = 1;
-      write_unqualified_name (member);
-    }
+    write_unqualified_name (member);
   else if (TREE_CODE (member) == TEMPLATE_ID_EXPR)
     {
       tree name = TREE_OPERAND (member, 0);
@@ -2212,17 +2208,27 @@
       write_string ("at");
       write_type (TREE_OPERAND (expr, 0));
     }
-  else if (abi_version_at_least (2) && TREE_CODE (expr) == SCOPE_REF)
+  else if (TREE_CODE (expr) == SCOPE_REF)
     {
       tree scope = TREE_OPERAND (expr, 0);
       tree member = TREE_OPERAND (expr, 1);
 
+      if (!abi_version_at_least (2))
+	{
+	  write_string ("sr");
+	  write_type (scope);
+	  /* G++ 3.2 incorrectly put out both the "sr" code and
+	     the nested name of the qualified name.  */
+	  G.need_abi_warning = 1;
+	  write_encoding (member);
+	}
+
       /* If the MEMBER is a real declaration, then the qualifying
 	 scope was not dependent.  Ideally, we would not have a
 	 SCOPE_REF in those cases, but sometimes we do.  If the second
 	 argument is a DECL, then the name must not have been
 	 dependent.  */
-      if (DECL_P (member))
+      else if (DECL_P (member))
 	write_expression (member);
       else
 	{
@@ -2387,12 +2393,6 @@
 	  sorry ("mangling new-expression");
 	  break;
 
-	/* Handle pointers-to-members specially.  */
-	case SCOPE_REF:
-	  write_type (TREE_OPERAND (expr, 0));
-	  write_member_name (TREE_OPERAND (expr, 1));
-	  break;
-
 	default:
 	  for (i = 0; i < TREE_OPERAND_LENGTH (expr); ++i)
 	    {
@@ -2748,7 +2748,7 @@
   finish_mangling_internal (warn);
   /* Don't obstack_finish here, and the next start_mangling will
      remove the identifier.  */
-  return get_identifier ((const char *) name_base);
+  return get_identifier ((const char *) obstack_base (mangle_obstack));
 }
 
 /* Initialize data structures for mangling.  */
Index: gcc/cp/cp-tree.h
===================================================================
--- gcc/cp/cp-tree.h	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/cp/cp-tree.h	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -883,7 +883,8 @@
    expression for `*this'.  */
 
 #define current_class_ptr \
-  (cfun ? cp_function_chain->x_current_class_ptr : NULL_TREE)
+  (cfun && cp_function_chain					\
+   ? cp_function_chain->x_current_class_ptr : NULL_TREE)
 #define current_class_ref \
   (cfun ? cp_function_chain->x_current_class_ref : NULL_TREE)
 
Index: gcc/cp/ChangeLog
===================================================================
--- gcc/cp/ChangeLog	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/cp/ChangeLog	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,3 +1,187 @@
+2010-02-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/43024
+	* name-lookup.h (current_binding_level): Check for null
+	cp_function_chain.
+
+2010-02-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/43033
+	* name-lookup.c (pushdecl_maybe_friend): Check default args of t
+	instead of x.
+
+2010-01-21  Release Manager
+
+	* GCC 4.4.3 released.
+
+2010-01-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/42674
+	* decl.c (finish_function): Don't emit -Wreturn-type warnings in
+	functions with noreturn attribute.
+
+2010-01-14  Jason Merrill  <jason@redhat.com>
+
+	PR c++/42655
+	* call.c (convert_like_real): Do full decay_conversion for ck_rvalue.
+
+2009-12-22  Jason Merrill  <jason@redhat.com>
+
+	PR c++/42331
+	* typeck.c (cp_build_modify_expr): Fix thinko.
+
+2009-12-21  Jason Merrill  <jason@redhat.com>
+
+	* mangle.c (write_member_name): Move abi-version=1 code back to...
+	(write_expression): ...here.
+
+2009-12-16  Jason Merrill  <jason@redhat.com>
+
+	PR c++/42387
+	* decl.c (compute_array_index_type): Mark a VLA as dependent.
+
+2009-12-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/41183
+	* cp-tree.h (current_class_ptr): Give NULL even when cfun
+	has NULL cfun->language.
+
+2009-11-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/27425
+	PR c++/34274
+	PR c++/42301
+	* pt.c (expand_template_argument_pack): Handle null arg gracefully.
+	(convert_template_argument): Use %T for type.
+
+2009-11-17  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/42061
+	* call.c (reference_binding): Return NULL for initializer list with
+	error operand inside of it.
+
+	PR c++/42059
+	* typeck.c (cp_build_modify_expr): For initializer list call
+	check_array_initializer to make sure lhs isn't a VLA.
+
+2009-11-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/21008, DR 515
+	* semantics.c (finish_non_static_data_member): Don't check
+	derivation in a template.
+
+2009-11-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/37037
+	* decl.c (grokdeclarator): Don't generate a void PARM_DECL.
+
+2009-11-09  Jason Merrill  <jason@redhat.com>
+
+	PR c++/41972
+	* parser.c (cp_parser_template_argument): Accept SCOPE_REF around
+	VAR_DECL.
+
+2009-11-09  Jason Merrill  <jason@redhat.com>
+
+	PR c++/41994
+	* pt.c (tsubst_baselink): tsubst the name.
+
+2009-11-06  Jason Merrill  <jason@redhat.com>
+
+	PR c++/9381
+	* decl2.c (build_memfn_type): Preserve attributes.
+	* tree.c (canonical_type_variant): Likewise.
+	* call.c (standard_conversion): Use build_memfn_type.
+	* pt.c (tsubst): Likewise.
+	* decl.c (build_ptrmem_type): Likewise
+
+2009-11-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/41967
+	* parser.c (cp_parser_omp_for_loop): After diagnosing not perfectly
+	nested loop and parsing statements, don't cp_parser_require }, instead
+	exit the loop if next token is CPP_EOF.
+
+2009-11-04  Jason Merrill  <jason@redhat.com>
+
+	PR c++/35067
+	* method.c (use_thunk): Check DECL_WEAK as well as
+	DECL_ONE_ONLY.
+
+2009-11-03  Jason Merrill  <jason@redhat.com>
+
+	PR c++/36959
+	* decl2.c (cxx_callgraph_analyze_expr): Don't reference a function
+	just because a static variable in it is needed unless -frepo.
+
+2009-11-03  Jason Merrill  <jason@redhat.com>
+
+	PR c++/41876
+	* parser.c (cp_parser_exception_declaration): Pass true to
+	is_condition parm of cp_parser_type_specifier_seq.
+	(cp_parser_omp_for_loop): Likewise.
+
+	PR c++/39786, Core issue 812, 861
+	* name-lookup.c (qualified_lookup_using_namespace): Overhaul.
+
+2009-11-02  Dodji Seketeli  <dodji@redhat.com>
+
+	PR c++/37093
+	* pt.c (check_valid_ptrmem_cst_expr): New function.
+	(convert_nontype_argument): Use it to output an error for
+	illegal pointer to member expressions used as template arguments.
+
+2009-10-31  Jason Merrill  <jason@redhat.com>
+
+	PR c++/41754
+	* call.c (compare_ics): Avoid bad union use when
+	comparing two ck_lists.
+
+2009-10-23  Dodji Seketeli  <dodji@redhat.com>
+
+	PR c++/40808
+	* mangle.c (write_template_args): Allow mangling of empty template
+	argument list. Updated function comments.
+
+2009-10-21  Jakub Jelinek  <jakub@redhat.com>
+
+	* mangle.c (finish_mangling_get_identifier): Use
+	obstack_base (mangle_obstack) instead of name_base.
+
+2009-10-15  Jason Merrill  <jason@redhat.com>
+
+	PR c++/38798
+	* parser.c (CP_PARSER_FLAGS_NO_TYPE_DEFINITIONS): New.
+	(cp_parser_type_specifier): Don't try to parse a class-specifier
+	or enum-specifier in that case.
+	(cp_parser_trailing_type_id): New.
+	(cp_parser_late_return_type_opt): Call it.
+	(cp_parser_type_id_1): Add is_trailing_return parm.
+	(cp_parser_type_specifier_seq): Likewise.
+
+2009-10-14  Larry Evans  <cppljevans@suddenlink.net>
+
+	PR c++/40092
+	* tree.c (cp_tree_equal): Add test for TEMPLATE_PARM_PARAMETER_PACK
+	equality.
+
+2009-10-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/37875
+	* parser.c (cp_parser_decltype): Set greater_than_is_operator_p.
+
+	PR c++/37766
+	* pt.c (type_unification_real): Call convert_template_argument
+	for function default template arguments.
+	(check_default_tmpl_args): Suggest -std=c++0x when function default
+	template args seen in C++98 mode.
+
+2009-10-11  Jason Merrill  <jason@redhat.com>
+
+	PR c++/37204
+	* typeck.c (build_reinterpret_cast_1): Handle rvalue refs
+	properly.
+
 2009-10-15  Release Manager
 
 	* GCC 4.4.2 released.
Index: gcc/cp/pt.c
===================================================================
--- gcc/cp/pt.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/cp/pt.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -2780,6 +2780,8 @@
   for (in_arg = 0; in_arg < nargs; ++in_arg)
     {
       tree arg = TREE_VEC_ELT (args, in_arg);
+      if (arg == NULL_TREE)
+	return args;
       if (ARGUMENT_PACK_P (arg))
         {
           int num_packed = TREE_VEC_LENGTH (ARGUMENT_PACK_ARGS (arg));
@@ -3670,7 +3672,8 @@
   else if (is_friend_decl)
     msg = "default template arguments may not be used in function template friend declarations";
   else if (TREE_CODE (decl) == FUNCTION_DECL && (cxx_dialect == cxx98))
-    msg = "default template arguments may not be used in function templates";
+    msg = ("default template arguments may not be used in function templates "
+	   "without -std=c++0x or -std=gnu++0x");
   else if (is_partial)
     msg = "default template arguments may not be used in partial specializations";
   else
@@ -4321,6 +4324,22 @@
   return fn;
 }
 
+/* Subroutine of convert_nontype_argument.
+   Check if EXPR of type TYPE is a valid pointer-to-member constant.
+   Emit an error otherwise.  */
+
+static bool
+check_valid_ptrmem_cst_expr (tree type, tree expr)
+{
+  STRIP_NOPS (expr);
+  if (expr && (null_ptr_cst_p (expr) || TREE_CODE (expr) == PTRMEM_CST))
+    return true;
+  error ("%qE is not a valid template argument for type %qT",
+	 expr, type);
+  error ("it must be a pointer-to-member of the form `&X::Y'");
+  return false;
+}
+
 /* Attempt to convert the non-type template parameter EXPR to the
    indicated TYPE.  If the conversion is successful, return the
    converted value.  If the conversion is unsuccessful, return
@@ -4620,6 +4639,11 @@
       if (expr == error_mark_node)
 	return error_mark_node;
 
+      /* [temp.arg.nontype] bullet 1 says the pointer to member
+         expression must be a pointer-to-member constant.  */
+      if (!check_valid_ptrmem_cst_expr (type, expr))
+	return error_mark_node;
+
       /* There is no way to disable standard conversions in
 	 resolve_address_of_overloaded_function (called by
 	 instantiate_type). It is possible that the call succeeded by
@@ -4646,6 +4670,11 @@
      qualification conversions (_conv.qual_) are applied.  */
   else if (TYPE_PTRMEM_P (type))
     {
+      /* [temp.arg.nontype] bullet 1 says the pointer to member
+         expression must be a pointer-to-member constant.  */
+      if (!check_valid_ptrmem_cst_expr (type, expr))
+	return error_mark_node;
+
       expr = perform_qualification_conversions (type, expr);
       if (expr == error_mark_node)
 	return expr;
@@ -5061,7 +5090,7 @@
 		      error ("type/value mismatch at argument %d in "
 			     "template parameter list for %qD",
 			     i + 1, in_decl);
-		      error ("  expected a template of type %qD, got %qD",
+		      error ("  expected a template of type %qD, got %qT",
 			     parm, orig_arg);
 		    }
 
@@ -9575,13 +9604,8 @@
 	  {
 	    /* The type of the implicit object parameter gets its
 	       cv-qualifiers from the FUNCTION_TYPE. */
-	    tree method_type;
-	    tree this_type = cp_build_qualified_type (TYPE_MAIN_VARIANT (r),
-						      cp_type_quals (type));
 	    tree memptr;
-	    method_type = build_method_type_directly (this_type,
-						      TREE_TYPE (type),
-						      TYPE_ARG_TYPES (type));
+	    tree method_type = build_memfn_type (type, r, cp_type_quals (type));
 	    memptr = build_ptrmemfunc_type (build_pointer_type (method_type));
 	    return cp_build_qualified_type_real (memptr, cp_type_quals (t),
 						 complain);
@@ -9866,7 +9890,7 @@
     qualifying_scope = tsubst (qualifying_scope, args,
 			       complain, in_decl);
     fns = BASELINK_FUNCTIONS (baselink);
-    optype = BASELINK_OPTYPE (baselink);
+    optype = tsubst (BASELINK_OPTYPE (baselink), args, complain, in_decl);
     if (TREE_CODE (fns) == TEMPLATE_ID_EXPR)
       {
 	template_id_p = true;
@@ -9877,6 +9901,8 @@
 						complain, in_decl);
       }
     name = DECL_NAME (get_first_fn (fns));
+    if (IDENTIFIER_TYPENAME_P (name))
+      name = mangle_conv_op_name_for_type (optype);
     baselink = lookup_fnfields (qualifying_scope, name, /*protect=*/1);
 
     /* If lookup found a single function, mark it as used at this
@@ -9895,8 +9921,7 @@
 		    BASELINK_FUNCTIONS (baselink),
 		    template_args);
     /* Update the conversion operator type.  */
-    BASELINK_OPTYPE (baselink) 
-      = tsubst (optype, args, complain, in_decl);
+    BASELINK_OPTYPE (baselink) = optype;
 
     if (!object_type)
       object_type = current_class_type;
@@ -12657,9 +12682,11 @@
 	     to explicitly check cxx_dialect here.  */
           if (TREE_PURPOSE (TREE_VEC_ELT (tparms, i)))
             {
-              tree arg = tsubst_template_arg
-				(TREE_PURPOSE (TREE_VEC_ELT (tparms, i)),
-				 targs, tf_none, NULL_TREE);
+	      tree parm = TREE_VALUE (TREE_VEC_ELT (tparms, i));
+	      tree arg = TREE_PURPOSE (TREE_VEC_ELT (tparms, i));
+              arg = tsubst_template_arg (arg, targs, tf_none, NULL_TREE);
+	      arg = convert_template_argument (parm, arg, targs, tf_none,
+					       i, NULL_TREE);
               if (arg == error_mark_node)
                 return 1;
               else
Index: gcc/cp/semantics.c
===================================================================
--- gcc/cp/semantics.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/cp/semantics.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1467,6 +1467,14 @@
 
       return build_min (COMPONENT_REF, type, object, decl, NULL_TREE);
     }
+  /* If PROCESSING_TEMPLATE_DECL is nonzero here, then
+     QUALIFYING_SCOPE is also non-null.  Wrap this in a SCOPE_REF
+     for now.  */
+  else if (processing_template_decl)
+    return build_qualified_name (TREE_TYPE (decl),
+				 qualifying_scope,
+				 DECL_NAME (decl),
+				 /*template_p=*/false);
   else
     {
       tree access_type = TREE_TYPE (object);
@@ -1486,15 +1494,6 @@
 	    }
 	}
 
-      /* If PROCESSING_TEMPLATE_DECL is nonzero here, then
-	 QUALIFYING_SCOPE is also non-null.  Wrap this in a SCOPE_REF
-	 for now.  */
-      if (processing_template_decl)
-	return build_qualified_name (TREE_TYPE (decl),
-				     qualifying_scope,
-				     DECL_NAME (decl),
-				     /*template_p=*/false);
-
       perform_or_defer_access_check (TYPE_BINFO (access_type), decl,
 				     decl);
 
Index: gcc/cp/name-lookup.c
===================================================================
--- gcc/cp/name-lookup.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/cp/name-lookup.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,5 +1,5 @@
 /* Definitions for C++ name lookup routines.
-   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009
+   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
    Free Software Foundation, Inc.
    Contributed by Gabriel Dos Reis <gdr@integrable-solutions.net>
 
@@ -840,8 +840,8 @@
 	    add_decl_to_level (x, NAMESPACE_LEVEL (CP_DECL_CONTEXT (t)));
 	}
 
-      if (TREE_CODE (x) == FUNCTION_DECL || DECL_FUNCTION_TEMPLATE_P (x))
-	check_default_args (x);
+      if (TREE_CODE (t) == FUNCTION_DECL || DECL_FUNCTION_TEMPLATE_P (t))
+	check_default_args (t);
 
       if (t != x || DECL_FUNCTION_TEMPLATE_P (t))
 	POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);
@@ -3905,6 +3905,19 @@
   POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, val->value != error_mark_node);
 }
 
+/* Returns true iff VEC contains TARGET.  */
+
+static bool
+tree_vec_contains (VEC(tree,gc)* vec, tree target)
+{
+  unsigned int i;
+  tree elt;
+  for (i = 0; VEC_iterate(tree,vec,i,elt); ++i)
+    if (elt == target)
+      return true;
+  return false;
+}
+
 /* [namespace.qual]
    Accepts the NAME to lookup and its qualifying SCOPE.
    Returns the name/type pair found into the cxx_binding *RESULT,
@@ -3915,62 +3928,72 @@
 				  struct scope_binding *result, int flags)
 {
   /* Maintain a list of namespaces visited...  */
-  tree seen = NULL_TREE;
+  VEC(tree,gc) *seen = NULL;
+  VEC(tree,gc) *seen_inline = NULL;
   /* ... and a list of namespace yet to see.  */
-  tree todo = NULL_TREE;
-  tree todo_maybe = NULL_TREE;
+  VEC(tree,gc) *todo = NULL;
+  VEC(tree,gc) *todo_maybe = NULL;
+  VEC(tree,gc) *todo_inline = NULL;
   tree usings;
   timevar_push (TV_NAME_LOOKUP);
   /* Look through namespace aliases.  */
   scope = ORIGINAL_NAMESPACE (scope);
-  while (scope && result->value != error_mark_node)
+
+  /* Algorithm: Starting with SCOPE, walk through the the set of used
+     namespaces.  For each used namespace, look through its inline
+     namespace set for any bindings and usings.  If no bindings are found,
+     add any usings seen to the set of used namespaces.  */
+  VEC_safe_push (tree, gc, todo, scope);
+
+  while (VEC_length (tree, todo))
     {
-      cxx_binding *binding =
-	cxx_scope_find_binding_for_name (NAMESPACE_LEVEL (scope), name);
-      seen = tree_cons (scope, NULL_TREE, seen);
-      if (binding)
-	ambiguous_decl (result, binding, flags);
+      bool found_here;
+      scope = VEC_pop (tree, todo);
+      if (tree_vec_contains (seen, scope))
+	continue;
+      VEC_safe_push (tree, gc, seen, scope);
+      VEC_safe_push (tree, gc, todo_inline, scope);
 
-      /* Consider strong using directives always, and non-strong ones
-	 if we haven't found a binding yet.  ??? Shouldn't we consider
-	 non-strong ones if the initial RESULT is non-NULL, but the
-	 binding in the given namespace is?  */
-      for (usings = DECL_NAMESPACE_USING (scope); usings;
-	   usings = TREE_CHAIN (usings))
-	/* If this was a real directive, and we have not seen it.  */
-	if (!TREE_INDIRECT_USING (usings))
-	  {
-	    /* Try to avoid queuing the same namespace more than once,
-	       the exception being when a namespace was already
-	       enqueued for todo_maybe and then a strong using is
-	       found for it.  We could try to remove it from
-	       todo_maybe, but it's probably not worth the effort.  */
-	    if (is_associated_namespace (scope, TREE_PURPOSE (usings))
-		&& !purpose_member (TREE_PURPOSE (usings), seen)
-		&& !purpose_member (TREE_PURPOSE (usings), todo))
-	      todo = tree_cons (TREE_PURPOSE (usings), NULL_TREE, todo);
-	    else if ((!result->value && !result->type)
-		     && !purpose_member (TREE_PURPOSE (usings), seen)
-		     && !purpose_member (TREE_PURPOSE (usings), todo)
-		     && !purpose_member (TREE_PURPOSE (usings), todo_maybe))
-	      todo_maybe = tree_cons (TREE_PURPOSE (usings), NULL_TREE,
-				      todo_maybe);
-	  }
-      if (todo)
+      found_here = false;
+      while (VEC_length (tree, todo_inline))
 	{
-	  scope = TREE_PURPOSE (todo);
-	  todo = TREE_CHAIN (todo);
+	  cxx_binding *binding;
+
+	  scope = VEC_pop (tree, todo_inline);
+	  if (tree_vec_contains (seen_inline, scope))
+	    continue;
+	  VEC_safe_push (tree, gc, seen_inline, scope);
+
+	  binding =
+	    cxx_scope_find_binding_for_name (NAMESPACE_LEVEL (scope), name);
+	  if (binding)
+	    {
+	      found_here = true;
+	      ambiguous_decl (result, binding, flags);
+	    }
+
+	  for (usings = DECL_NAMESPACE_USING (scope); usings;
+	       usings = TREE_CHAIN (usings))
+	    if (!TREE_INDIRECT_USING (usings))
+	      {
+		if (is_associated_namespace (scope, TREE_PURPOSE (usings)))
+		  VEC_safe_push (tree, gc, todo_inline, TREE_PURPOSE (usings));
+		else
+		  VEC_safe_push (tree, gc, todo_maybe, TREE_PURPOSE (usings));
+	      }
 	}
-      else if (todo_maybe
-	       && (!result->value && !result->type))
-	{
-	  scope = TREE_PURPOSE (todo_maybe);
-	  todo = TREE_CHAIN (todo_maybe);
-	  todo_maybe = NULL_TREE;
-	}
+
+      if (found_here)
+	VEC_truncate (tree, todo_maybe, 0);
       else
-	scope = NULL_TREE; /* If there never was a todo list.  */
+	while (VEC_length (tree, todo_maybe))
+	  VEC_safe_push (tree, gc, todo, VEC_pop (tree, todo_maybe));
     }
+  VEC_free (tree,gc,todo);
+  VEC_free (tree,gc,todo_maybe);
+  VEC_free (tree,gc,todo_inline);
+  VEC_free (tree,gc,seen);
+  VEC_free (tree,gc,seen_inline);
   POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, result->value != error_mark_node);
 }
 
Index: gcc/cp/decl2.c
===================================================================
--- gcc/cp/decl2.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/cp/decl2.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -108,20 +108,27 @@
 build_memfn_type (tree fntype, tree ctype, cp_cv_quals quals)
 {
   tree raises;
+  tree attrs;
   int type_quals;
 
   if (fntype == error_mark_node || ctype == error_mark_node)
     return error_mark_node;
 
+  gcc_assert (TREE_CODE (fntype) == FUNCTION_TYPE
+	      || TREE_CODE (fntype) == METHOD_TYPE);
+
   type_quals = quals & ~TYPE_QUAL_RESTRICT;
   ctype = cp_build_qualified_type (ctype, type_quals);
+  raises = TYPE_RAISES_EXCEPTIONS (fntype);
+  attrs = TYPE_ATTRIBUTES (fntype);
   fntype = build_method_type_directly (ctype, TREE_TYPE (fntype),
 				       (TREE_CODE (fntype) == METHOD_TYPE
 					? TREE_CHAIN (TYPE_ARG_TYPES (fntype))
 					: TYPE_ARG_TYPES (fntype)));
-  raises = TYPE_RAISES_EXCEPTIONS (fntype);
   if (raises)
     fntype = build_exception_variant (fntype, raises);
+  if (attrs)
+    fntype = cp_build_type_attribute_variant (fntype, attrs);
 
   return fntype;
 }
@@ -3278,6 +3285,7 @@
 	    mark_decl_referenced (vtbl);
 	}
       else if (DECL_CONTEXT (t)
+	       && flag_use_repository
 	       && TREE_CODE (DECL_CONTEXT (t)) == FUNCTION_DECL)
 	/* If we need a static variable in a function, then we
 	   need the containing function.  */
Index: gcc/cp/name-lookup.h
===================================================================
--- gcc/cp/name-lookup.h	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/cp/name-lookup.h	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -263,7 +263,7 @@
 /* The binding level currently in effect.  */
 
 #define current_binding_level			\
-  (*(cfun && cp_function_chain->bindings	\
+  (*(cfun && cp_function_chain && cp_function_chain->bindings \
    ? &cp_function_chain->bindings		\
    : &scope_chain->bindings))
 
Index: gcc/cp/parser.c
===================================================================
--- gcc/cp/parser.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/cp/parser.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1198,8 +1198,12 @@
   /* The construct is optional.  If it is not present, then no error
      should be issued.  */
   CP_PARSER_FLAGS_OPTIONAL = 0x1,
-  /* When parsing a type-specifier, do not allow user-defined types.  */
-  CP_PARSER_FLAGS_NO_USER_DEFINED_TYPES = 0x2
+  /* When parsing a type-specifier, treat user-defined type-names
+     as non-type identifiers.  */
+  CP_PARSER_FLAGS_NO_USER_DEFINED_TYPES = 0x2,
+  /* When parsing a type-specifier, do not try to parse a class-specifier
+     or enum-specifier.  */
+  CP_PARSER_FLAGS_NO_TYPE_DEFINITIONS = 0x4
 } cp_parser_flags;
 
 /* The different kinds of declarators we want to parse.  */
@@ -1735,10 +1739,11 @@
   (cp_parser *);
 static tree cp_parser_template_type_arg
   (cp_parser *);
+static tree cp_parser_trailing_type_id (cp_parser *);
 static tree cp_parser_type_id_1
-  (cp_parser *, bool);
+  (cp_parser *, bool, bool);
 static void cp_parser_type_specifier_seq
-  (cp_parser *, bool, cp_decl_specifier_seq *);
+  (cp_parser *, bool, bool, cp_decl_specifier_seq *);
 static tree cp_parser_parameter_declaration_clause
   (cp_parser *);
 static tree cp_parser_parameter_declaration_list
@@ -5740,6 +5745,7 @@
     = "types may not be defined in a new-type-id";
   /* Parse the type-specifier-seq.  */
   cp_parser_type_specifier_seq (parser, /*is_condition=*/false,
+				/*is_trailing_return=*/false,
 				&type_specifier_seq);
   /* Restore the old message.  */
   parser->type_definition_forbidden_message = saved_message;
@@ -7414,6 +7420,7 @@
     = "types may not be defined in conditions";
   /* Parse the type-specifier-seq.  */
   cp_parser_type_specifier_seq (parser, /*is_condition==*/true,
+				/*is_trailing_return=*/false,
 				&type_specifiers);
   /* Restore the saved message.  */
   parser->type_definition_forbidden_message = saved_message;
@@ -8918,12 +8925,25 @@
     cp_parser_parse_definitely (parser);
   else
     {
+      bool saved_greater_than_is_operator_p;
+
       /* Abort our attempt to parse an id-expression or member access
          expression.  */
       cp_parser_abort_tentative_parse (parser);
 
+      /* Within a parenthesized expression, a `>' token is always
+	 the greater-than operator.  */
+      saved_greater_than_is_operator_p
+	= parser->greater_than_is_operator_p;
+      parser->greater_than_is_operator_p = true;
+
       /* Parse a full expression.  */
       expr = cp_parser_expression (parser, /*cast_p=*/false, NULL);
+
+      /* The `>' token might be the end of a template-id or
+	 template-parameter-list now.  */
+      parser->greater_than_is_operator_p
+	= saved_greater_than_is_operator_p;
     }
 
   /* Go back to evaluating expressions.  */
@@ -9032,6 +9052,7 @@
   attributes = cp_parser_attributes_opt (parser);
   /* Parse the type-specifiers.  */
   cp_parser_type_specifier_seq (parser, /*is_condition=*/false,
+				/*is_trailing_return=*/false,
 				&type_specifiers);
   /* If that didn't work, stop.  */
   if (type_specifiers.type == error_mark_node)
@@ -10679,18 +10700,26 @@
 	cp_parser_abort_tentative_parse (parser);
       else
 	{
+	  tree probe;
+
 	  if (TREE_CODE (argument) == INDIRECT_REF)
 	    {
 	      gcc_assert (REFERENCE_REF_P (argument));
 	      argument = TREE_OPERAND (argument, 0);
 	    }
 
-	  if (TREE_CODE (argument) == VAR_DECL)
+	  /* If we're in a template, we represent a qualified-id referring
+	     to a static data member as a SCOPE_REF even if the scope isn't
+	     dependent so that we can check access control later.  */
+	  probe = argument;
+	  if (TREE_CODE (probe) == SCOPE_REF)
+	    probe = TREE_OPERAND (probe, 1);
+	  if (TREE_CODE (probe) == VAR_DECL)
 	    {
 	      /* A variable without external linkage might still be a
 		 valid constant-expression, so no error is issued here
 		 if the external-linkage check fails.  */
-	      if (!address_p && !DECL_EXTERNAL_LINKAGE_P (argument))
+	      if (!address_p && !DECL_EXTERNAL_LINKAGE_P (probe))
 		cp_parser_simulate_error (parser);
 	    }
 	  else if (is_overloaded_fn (argument))
@@ -10994,6 +11023,9 @@
   switch (keyword)
     {
     case RID_ENUM:
+      if ((flags & CP_PARSER_FLAGS_NO_TYPE_DEFINITIONS))
+	goto elaborated_type_specifier;
+
       /* Look for the enum-specifier.  */
       type_spec = cp_parser_enum_specifier (parser);
       /* If that worked, we're done.  */
@@ -11016,6 +11048,9 @@
     case RID_CLASS:
     case RID_STRUCT:
     case RID_UNION:
+      if ((flags & CP_PARSER_FLAGS_NO_TYPE_DEFINITIONS))
+	goto elaborated_type_specifier;
+
       /* Parse tentatively so that we can back up if we don't find a
 	 class-specifier.  */
       cp_parser_parse_tentatively (parser);
@@ -11882,6 +11917,7 @@
 
       /* Parse the type-specifier-seq.  */
       cp_parser_type_specifier_seq (parser, /*is_condition=*/false,
+				    /*is_trailing_return=*/false,
                                     &type_specifiers);
 
       /* At this point this is surely not elaborated type specifier.  */
@@ -13713,7 +13749,7 @@
 /* Parse a late-specified return type, if any.  This is not a separate
    non-terminal, but part of a function declarator, which looks like
 
-   -> type-id
+   -> trailing-type-specifier-seq abstract-declarator(opt)
 
    Returns the type indicated by the type-id.  */
 
@@ -13731,7 +13767,7 @@
   /* Consume the ->.  */
   cp_lexer_consume_token (parser->lexer);
 
-  return cp_parser_type_id (parser);
+  return cp_parser_trailing_type_id (parser);
 }
 
 /* Parse a declarator-id.
@@ -13784,13 +13820,15 @@
    Returns the TYPE specified.  */
 
 static tree
-cp_parser_type_id_1 (cp_parser* parser, bool is_template_arg)
+cp_parser_type_id_1 (cp_parser* parser, bool is_template_arg,
+		     bool is_trailing_return)
 {
   cp_decl_specifier_seq type_specifier_seq;
   cp_declarator *abstract_declarator;
 
   /* Parse the type-specifier-seq.  */
   cp_parser_type_specifier_seq (parser, /*is_condition=*/false,
+				is_trailing_return,
 				&type_specifier_seq);
   if (type_specifier_seq.type == error_mark_node)
     return error_mark_node;
@@ -13828,14 +13866,19 @@
 
 static tree cp_parser_type_id (cp_parser *parser)
 {
-  return cp_parser_type_id_1 (parser, false);
+  return cp_parser_type_id_1 (parser, false, false);
 }
 
 static tree cp_parser_template_type_arg (cp_parser *parser)
 {
-  return cp_parser_type_id_1 (parser, true);
+  return cp_parser_type_id_1 (parser, true, false);
 }
 
+static tree cp_parser_trailing_type_id (cp_parser *parser)
+{
+  return cp_parser_type_id_1 (parser, false, true);
+}
+
 /* Parse a type-specifier-seq.
 
    type-specifier-seq:
@@ -13849,11 +13892,15 @@
    If IS_CONDITION is true, we are at the start of a "condition",
    e.g., we've just seen "if (".
 
+   If IS_TRAILING_RETURN is true, we are in a trailing-return-type,
+   i.e. we've just seen "->".
+
    Sets *TYPE_SPECIFIER_SEQ to represent the sequence.  */
 
 static void
 cp_parser_type_specifier_seq (cp_parser* parser,
 			      bool is_condition,
+			      bool is_trailing_return,
 			      cp_decl_specifier_seq *type_specifier_seq)
 {
   bool seen_type_specifier = false;
@@ -13863,6 +13910,12 @@
   /* Clear the TYPE_SPECIFIER_SEQ.  */
   clear_decl_specs (type_specifier_seq);
 
+  /* In the context of a trailing return type, enum E { } is an
+     elaborated-type-specifier followed by a function-body, not an
+     enum-specifier.  */
+  if (is_trailing_return)
+    flags |= CP_PARSER_FLAGS_NO_TYPE_DEFINITIONS;
+
   /* Parse the type-specifiers and attributes.  */
   while (true)
     {
@@ -16565,7 +16618,8 @@
     = "types may not be defined in exception-declarations";
 
   /* Parse the type-specifier-seq.  */
-  cp_parser_type_specifier_seq (parser, /*is_condition=*/false,
+  cp_parser_type_specifier_seq (parser, /*is_declaration=*/true,
+				/*is_trailing_return=*/false,
 				&type_specifiers);
   /* If it's a `)', then there is no declarator.  */
   if (cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_PAREN))
@@ -21249,7 +21303,8 @@
 	     cp_parser_condition, from whence the bulk of this is copied.  */
 
 	  cp_parser_parse_tentatively (parser);
-	  cp_parser_type_specifier_seq (parser, /*is_condition=*/false,
+	  cp_parser_type_specifier_seq (parser, /*is_declaration=*/true,
+					/*is_trailing_return=*/false,
 					&type_specifiers);
 	  if (cp_parser_parse_definitely (parser))
 	    {
@@ -21567,7 +21622,8 @@
 	    }
 	  collapse_err = true;
 	  cp_parser_statement_seq_opt (parser, NULL);
-	  cp_parser_require (parser, CPP_CLOSE_BRACE, "%<}%>");
+	  if (cp_lexer_next_token_is (parser->lexer, CPP_EOF))
+	    break;
 	}
     }
 
Index: gcc/tree-ssa-ccp.c
===================================================================
--- gcc/tree-ssa-ccp.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/tree-ssa-ccp.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,6 +1,6 @@
 /* Conditional constant propagation pass for the GNU compiler.
-   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
-   Free Software Foundation, Inc.
+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
+   2010  Free Software Foundation, Inc.
    Adapted from original RTL SSA-CCP by Daniel Berlin <dberlin@dberlin.org>
    Adapted to GIMPLE trees by Diego Novillo <dnovillo@redhat.com>
 
@@ -1727,7 +1727,7 @@
 
 static tree
 maybe_fold_offset_to_component_ref (tree record_type, tree base, tree offset,
-				    tree orig_type, bool base_is_ptr)
+				    tree orig_type)
 {
   tree f, t, field_type, tail_array_field, field_offset;
   tree ret;
@@ -1779,8 +1779,6 @@
       if (cmp == 0
 	  && useless_type_conversion_p (orig_type, field_type))
 	{
-	  if (base_is_ptr)
-	    base = build1 (INDIRECT_REF, record_type, base);
 	  t = build3 (COMPONENT_REF, field_type, base, f, NULL_TREE);
 	  return t;
 	}
@@ -1805,11 +1803,7 @@
 
       /* If we matched, then set offset to the displacement into
 	 this field.  */
-      if (base_is_ptr)
-	new_base = build1 (INDIRECT_REF, record_type, base);
-      else
-	new_base = base;
-      new_base = build3 (COMPONENT_REF, field_type, new_base, f, NULL_TREE);
+      new_base = build3 (COMPONENT_REF, field_type, base, f, NULL_TREE);
 
       /* Recurse to possibly find the match.  */
       ret = maybe_fold_offset_to_array_ref (new_base, t, orig_type,
@@ -1817,7 +1811,7 @@
       if (ret)
 	return ret;
       ret = maybe_fold_offset_to_component_ref (field_type, new_base, t,
-						orig_type, false);
+						orig_type);
       if (ret)
 	return ret;
     }
@@ -1831,8 +1825,6 @@
 
   /* If we get here, we've got an aggregate field, and a possibly 
      nonzero offset into them.  Recurse and hope for a valid match.  */
-  if (base_is_ptr)
-    base = build1 (INDIRECT_REF, record_type, base);
   base = build3 (COMPONENT_REF, field_type, base, f, NULL_TREE);
 
   t = maybe_fold_offset_to_array_ref (base, offset, orig_type,
@@ -1840,7 +1832,7 @@
   if (t)
     return t;
   return maybe_fold_offset_to_component_ref (field_type, base, offset,
-					     orig_type, false);
+					     orig_type);
 }
 
 /* Attempt to express (ORIG_TYPE)BASE+OFFSET as BASE->field_of_orig_type
@@ -1854,57 +1846,44 @@
 {
   tree ret;
   tree type;
-  bool base_is_ptr = true;
 
   STRIP_NOPS (base);
-  if (TREE_CODE (base) == ADDR_EXPR)
-    {
-      base_is_ptr = false;
+  if (TREE_CODE (base) != ADDR_EXPR)
+    return NULL_TREE;
 
-      base = TREE_OPERAND (base, 0);
+  base = TREE_OPERAND (base, 0);
 
-      /* Handle case where existing COMPONENT_REF pick e.g. wrong field of union,
-	 so it needs to be removed and new COMPONENT_REF constructed.
-	 The wrong COMPONENT_REF are often constructed by folding the
-	 (type *)&object within the expression (type *)&object+offset  */
-      if (handled_component_p (base))
+  /* Handle case where existing COMPONENT_REF pick e.g. wrong field of union,
+     so it needs to be removed and new COMPONENT_REF constructed.
+     The wrong COMPONENT_REF are often constructed by folding the
+     (type *)&object within the expression (type *)&object+offset  */
+  if (handled_component_p (base))
+    {
+      HOST_WIDE_INT sub_offset, size, maxsize;
+      tree newbase;
+      newbase = get_ref_base_and_extent (base, &sub_offset,
+					 &size, &maxsize);
+      gcc_assert (newbase);
+      if (size == maxsize
+	  && size != -1
+	  && !(sub_offset & (BITS_PER_UNIT - 1)))
 	{
-          HOST_WIDE_INT sub_offset, size, maxsize;
-	  tree newbase;
-	  newbase = get_ref_base_and_extent (base, &sub_offset,
-					     &size, &maxsize);
-	  gcc_assert (newbase);
-	  if (size == maxsize
-	      && size != -1
-	      && !(sub_offset & (BITS_PER_UNIT - 1)))
-	    {
-	      base = newbase;
-	      if (sub_offset)
-		offset = int_const_binop (PLUS_EXPR, offset,
-					  build_int_cst (TREE_TYPE (offset),
-					  sub_offset / BITS_PER_UNIT), 1);
-	    }
+	  base = newbase;
+	  if (sub_offset)
+	    offset = int_const_binop (PLUS_EXPR, offset,
+				      build_int_cst (TREE_TYPE (offset),
+					     sub_offset / BITS_PER_UNIT), 1);
 	}
-      if (useless_type_conversion_p (orig_type, TREE_TYPE (base))
-	  && integer_zerop (offset))
-	return base;
-      type = TREE_TYPE (base);
     }
-  else
-    {
-      base_is_ptr = true;
-      if (!POINTER_TYPE_P (TREE_TYPE (base)))
-	return NULL_TREE;
-      type = TREE_TYPE (TREE_TYPE (base));
-    }
-  ret = maybe_fold_offset_to_component_ref (type, base, offset,
-					    orig_type, base_is_ptr);
+  if (useless_type_conversion_p (orig_type, TREE_TYPE (base))
+      && integer_zerop (offset))
+    return base;
+  type = TREE_TYPE (base);
+
+  ret = maybe_fold_offset_to_component_ref (type, base, offset, orig_type);
   if (!ret)
-    {
-      if (base_is_ptr)
-	base = build1 (INDIRECT_REF, type, base);
-      ret = maybe_fold_offset_to_array_ref (base, offset, orig_type, true);
-    }
+    ret = maybe_fold_offset_to_array_ref (base, offset, orig_type, true);
+
   return ret;
 }
 
@@ -2143,7 +2122,7 @@
   t = maybe_fold_offset_to_array_ref (op0, op1, ptd_type, true);
   if (!t)
     t = maybe_fold_offset_to_component_ref (TREE_TYPE (op0), op0, op1,
-					    ptd_type, false);
+					    ptd_type);
   if (t)
     t = build1 (ADDR_EXPR, res_type, t);
 
@@ -3000,7 +2979,10 @@
 	continue;
 
       callee = gimple_call_fndecl (stmt);
-      if (!callee || DECL_BUILT_IN_CLASS (callee) != BUILT_IN_NORMAL)
+      if (!callee
+	  || DECL_BUILT_IN_CLASS (callee) != BUILT_IN_NORMAL
+	  /* All regular builtins are ok, just obviously not alloca.  */
+	  || DECL_FUNCTION_CODE (callee) == BUILT_IN_ALLOCA)
 	return NULL_TREE;
 
       if (DECL_FUNCTION_CODE (callee) == BUILT_IN_STACK_RESTORE)
Index: gcc/dojump.c
===================================================================
--- gcc/dojump.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/dojump.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,6 +1,6 @@
 /* Convert tree expression to rtl instructions, for GNU compiler.
    Copyright (C) 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
-   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
+   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
    Free Software Foundation, Inc.
 
 This file is part of GCC.
@@ -35,13 +35,22 @@
 #include "langhooks.h"
 #include "ggc.h"
 #include "basic-block.h"
+#include "output.h"
 
 static bool prefer_and_bit_test (enum machine_mode, int);
-static void do_jump_by_parts_greater (tree, int, rtx, rtx);
-static void do_jump_by_parts_equality (tree, rtx, rtx);
+static void do_jump_by_parts_greater (tree, int, rtx, rtx, int);
+static void do_jump_by_parts_equality (tree, rtx, rtx, int);
 static void do_compare_and_jump	(tree, enum rtx_code, enum rtx_code, rtx,
-				 rtx);
+				 rtx, int);
 
+/* Invert probability if there is any.  -1 stands for unknown.  */
+
+static inline int
+inv (int prob)
+{
+  return prob == -1 ? -1 : REG_BR_PROB_BASE - prob;
+}
+
 /* At the start of a function, record that we have no previously-pushed
    arguments waiting to be popped.  */
 
@@ -96,17 +105,17 @@
    functions here.  */
 
 void
-jumpifnot (tree exp, rtx label)
+jumpifnot (tree exp, rtx label, int prob)
 {
-  do_jump (exp, label, NULL_RTX);
+  do_jump (exp, label, NULL_RTX, inv (prob));
 }
 
 /* Generate code to evaluate EXP and jump to LABEL if the value is nonzero.  */
 
 void
-jumpif (tree exp, rtx label)
+jumpif (tree exp, rtx label, int prob)
 {
-  do_jump (exp, NULL_RTX, label);
+  do_jump (exp, NULL_RTX, label, prob);
 }
 
 /* Used internally by prefer_and_bit_test.  */
@@ -156,10 +165,12 @@
 
    do_jump always does any pending stack adjust except when it does not
    actually perform a jump.  An example where there is no jump
-   is when EXP is `(foo (), 0)' and IF_FALSE_LABEL is null.  */
+   is when EXP is `(foo (), 0)' and IF_FALSE_LABEL is null.
 
+   PROB is probability of jump to if_true_label, or -1 if unknown.  */
+
 void
-do_jump (tree exp, rtx if_false_label, rtx if_true_label)
+do_jump (tree exp, rtx if_false_label, rtx if_true_label, int prob)
 {
   enum tree_code code = TREE_CODE (exp);
   rtx temp;
@@ -206,11 +217,12 @@
     case LROTATE_EXPR:
     case RROTATE_EXPR:
       /* These cannot change zero->nonzero or vice versa.  */
-      do_jump (TREE_OPERAND (exp, 0), if_false_label, if_true_label);
+      do_jump (TREE_OPERAND (exp, 0), if_false_label, if_true_label, prob);
       break;
 
     case TRUTH_NOT_EXPR:
-      do_jump (TREE_OPERAND (exp, 0), if_true_label, if_false_label);
+      do_jump (TREE_OPERAND (exp, 0), if_true_label, if_false_label,
+	       inv (prob));
       break;
 
     case COND_EXPR:
@@ -226,10 +238,10 @@
 	  }
 
         do_pending_stack_adjust ();
-        do_jump (TREE_OPERAND (exp, 0), label1, NULL_RTX);
-        do_jump (TREE_OPERAND (exp, 1), if_false_label, if_true_label);
+	do_jump (TREE_OPERAND (exp, 0), label1, NULL_RTX, -1);
+	do_jump (TREE_OPERAND (exp, 1), if_false_label, if_true_label, prob);
         emit_label (label1);
-        do_jump (TREE_OPERAND (exp, 2), if_false_label, if_true_label);
+	do_jump (TREE_OPERAND (exp, 2), if_false_label, if_true_label, prob);
 	break;
       }
 
@@ -261,7 +273,8 @@
             && (optab_handler (cmp_optab, TYPE_MODE (type))->insn_code
 		!= CODE_FOR_nothing))
           {
-            do_jump (fold_convert (type, exp), if_false_label, if_true_label);
+	    do_jump (fold_convert (type, exp), if_false_label, if_true_label,
+		     prob);
             break;
           }
         goto normal;
@@ -277,12 +290,14 @@
 		    != MODE_COMPLEX_INT);
 	
         if (integer_zerop (TREE_OPERAND (exp, 1)))
-          do_jump (TREE_OPERAND (exp, 0), if_true_label, if_false_label);
+          do_jump (TREE_OPERAND (exp, 0), if_true_label, if_false_label,
+		   inv (prob));
         else if (GET_MODE_CLASS (TYPE_MODE (inner_type)) == MODE_INT
                  && !can_compare_p (EQ, TYPE_MODE (inner_type), ccp_jump))
-          do_jump_by_parts_equality (exp, if_false_label, if_true_label);
+          do_jump_by_parts_equality (exp, if_false_label, if_true_label, prob);
         else
-          do_compare_and_jump (exp, EQ, EQ, if_false_label, if_true_label);
+          do_compare_and_jump (exp, EQ, EQ, if_false_label, if_true_label,
+			       prob);
         break;
       }
 
@@ -302,12 +317,14 @@
 		    != MODE_COMPLEX_INT);
 	
         if (integer_zerop (TREE_OPERAND (exp, 1)))
-          do_jump (TREE_OPERAND (exp, 0), if_false_label, if_true_label);
+          do_jump (TREE_OPERAND (exp, 0), if_false_label, if_true_label, prob);
         else if (GET_MODE_CLASS (TYPE_MODE (inner_type)) == MODE_INT
            && !can_compare_p (NE, TYPE_MODE (inner_type), ccp_jump))
-          do_jump_by_parts_equality (exp, if_true_label, if_false_label);
+          do_jump_by_parts_equality (exp, if_true_label, if_false_label,
+				     inv (prob));
         else
-          do_compare_and_jump (exp, NE, NE, if_false_label, if_true_label);
+          do_compare_and_jump (exp, NE, NE, if_false_label, if_true_label,
+			       prob);
         break;
       }
 
@@ -315,36 +332,43 @@
       mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));
       if (GET_MODE_CLASS (mode) == MODE_INT
           && ! can_compare_p (LT, mode, ccp_jump))
-        do_jump_by_parts_greater (exp, 1, if_false_label, if_true_label);
+        do_jump_by_parts_greater (exp, 1, if_false_label, if_true_label, prob);
       else
-        do_compare_and_jump (exp, LT, LTU, if_false_label, if_true_label);
+        do_compare_and_jump (exp, LT, LTU, if_false_label, if_true_label,
+			     prob);
       break;
 
     case LE_EXPR:
       mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));
       if (GET_MODE_CLASS (mode) == MODE_INT
           && ! can_compare_p (LE, mode, ccp_jump))
-        do_jump_by_parts_greater (exp, 0, if_true_label, if_false_label);
+        do_jump_by_parts_greater (exp, 0, if_true_label, if_false_label,
+				  inv (prob));
       else
-        do_compare_and_jump (exp, LE, LEU, if_false_label, if_true_label);
+        do_compare_and_jump (exp, LE, LEU, if_false_label, if_true_label,
+			     prob);
       break;
 
     case GT_EXPR:
       mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));
       if (GET_MODE_CLASS (mode) == MODE_INT
           && ! can_compare_p (GT, mode, ccp_jump))
-        do_jump_by_parts_greater (exp, 0, if_false_label, if_true_label);
+        do_jump_by_parts_greater (exp, 0, if_false_label, if_true_label,
+				  prob);
       else
-        do_compare_and_jump (exp, GT, GTU, if_false_label, if_true_label);
+        do_compare_and_jump (exp, GT, GTU, if_false_label, if_true_label,
+			     prob);
       break;
 
     case GE_EXPR:
       mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));
       if (GET_MODE_CLASS (mode) == MODE_INT
           && ! can_compare_p (GE, mode, ccp_jump))
-        do_jump_by_parts_greater (exp, 1, if_true_label, if_false_label);
+        do_jump_by_parts_greater (exp, 1, if_true_label, if_false_label,
+				  inv (prob));
       else
-        do_compare_and_jump (exp, GE, GEU, if_false_label, if_true_label);
+        do_compare_and_jump (exp, GE, GEU, if_false_label, if_true_label,
+			     prob);
       break;
 
     case UNORDERED_EXPR:
@@ -368,9 +392,10 @@
           do_rev = 1;
 
         if (! do_rev)
-          do_compare_and_jump (exp, cmp, cmp, if_false_label, if_true_label);
+          do_compare_and_jump (exp, cmp, cmp, if_false_label, if_true_label, prob);
         else
-          do_compare_and_jump (exp, rcmp, rcmp, if_true_label, if_false_label);
+          do_compare_and_jump (exp, rcmp, rcmp, if_true_label, if_false_label,
+			       inv (prob));
       }
       break;
 
@@ -415,7 +440,7 @@
         mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));
         if (can_compare_p (rcode1, mode, ccp_jump))
           do_compare_and_jump (exp, rcode1, rcode1, if_false_label,
-                               if_true_label);
+                               if_true_label, prob);
         else
           {
             tree op0 = save_expr (TREE_OPERAND (exp, 0));
@@ -429,8 +454,8 @@
 	      
             cmp0 = fold_build2 (tcode1, TREE_TYPE (exp), op0, op1);
             cmp1 = fold_build2 (tcode2, TREE_TYPE (exp), op0, op1);
-	    do_jump (cmp0, 0, if_true_label);
-	    do_jump (cmp1, if_false_label, if_true_label);
+	    do_jump (cmp0, 0, if_true_label, prob);
+	    do_jump (cmp1, if_false_label, if_true_label, prob);
           }
       break;
     }
@@ -443,6 +468,7 @@
 	{
 	  tree exp0 = TREE_OPERAND (exp, 0);
 	  rtx set_label, clr_label;
+	  int setclr_prob = prob;
 
 	  /* Strip narrowing integral type conversions.  */
 	  while (CONVERT_EXPR_P (exp0)
@@ -458,6 +484,7 @@
 	      exp0 = TREE_OPERAND (exp0, 0);
 	      clr_label = if_true_label;
 	      set_label = if_false_label;
+	      setclr_prob = inv (prob);
 	    }
 	  else
 	    {
@@ -480,7 +507,7 @@
 		    = (unsigned HOST_WIDE_INT) 1 << TREE_INT_CST_LOW (shift);
 		  do_jump (build2 (BIT_AND_EXPR, argtype, arg,
 				   build_int_cst_wide_type (argtype, mask, 0)),
-			   clr_label, set_label);
+			   clr_label, set_label, setclr_prob);
 		  break;
 		}
 	    }
@@ -503,7 +530,8 @@
           && (optab_handler (cmp_optab, TYPE_MODE (type))->insn_code
               != CODE_FOR_nothing))
         {
-          do_jump (fold_convert (type, exp), if_false_label, if_true_label);
+	  do_jump (fold_convert (type, exp), if_false_label, if_true_label,
+		   prob);
           break;
         }
 
@@ -526,13 +554,13 @@
       if (if_false_label == NULL_RTX)
         {
 	  drop_through_label = gen_label_rtx ();
-          do_jump (TREE_OPERAND (exp, 0), drop_through_label, NULL_RTX);
-          do_jump (TREE_OPERAND (exp, 1), NULL_RTX, if_true_label);
+          do_jump (TREE_OPERAND (exp, 0), drop_through_label, NULL_RTX, prob);
+          do_jump (TREE_OPERAND (exp, 1), NULL_RTX, if_true_label, prob);
 	}
       else
 	{
-	  do_jump (TREE_OPERAND (exp, 0), if_false_label, NULL_RTX);
-          do_jump (TREE_OPERAND (exp, 1), if_false_label, if_true_label);
+	  do_jump (TREE_OPERAND (exp, 0), if_false_label, NULL_RTX, prob);
+          do_jump (TREE_OPERAND (exp, 1), if_false_label, if_true_label, prob);
 	}
       break;
 
@@ -541,7 +569,7 @@
       /* High branch cost, expand as the bitwise OR of the conditions.
 	 Do the same if the RHS has side effects, because we're effectively
 	 turning a TRUTH_OR_EXPR into a TRUTH_ORIF_EXPR.  */
-      if (BRANCH_COST (optimize_insn_for_speed_p (), false)>= 4
+      if (BRANCH_COST (optimize_insn_for_speed_p (), false) >= 4
 	  || TREE_SIDE_EFFECTS (TREE_OPERAND (exp, 1)))
 	goto normal;
 
@@ -549,13 +577,13 @@
       if (if_true_label == NULL_RTX)
 	{
           drop_through_label = gen_label_rtx ();
-          do_jump (TREE_OPERAND (exp, 0), NULL_RTX, drop_through_label);
-          do_jump (TREE_OPERAND (exp, 1), if_false_label, NULL_RTX);
+          do_jump (TREE_OPERAND (exp, 0), NULL_RTX, drop_through_label, prob);
+          do_jump (TREE_OPERAND (exp, 1), if_false_label, NULL_RTX, prob);
 	}
       else
 	{
-          do_jump (TREE_OPERAND (exp, 0), NULL_RTX, if_true_label);
-          do_jump (TREE_OPERAND (exp, 1), if_false_label, if_true_label);
+          do_jump (TREE_OPERAND (exp, 0), NULL_RTX, if_true_label, prob);
+          do_jump (TREE_OPERAND (exp, 1), if_false_label, if_true_label, prob);
 	}
       break;
 
@@ -577,7 +605,7 @@
       do_compare_rtx_and_jump (temp, CONST0_RTX (GET_MODE (temp)),
 			       NE, TYPE_UNSIGNED (TREE_TYPE (exp)),
 			       GET_MODE (temp), NULL_RTX,
-			       if_false_label, if_true_label);
+			       if_false_label, if_true_label, prob);
     }
 
   if (drop_through_label)
@@ -593,7 +621,8 @@
 
 static void
 do_jump_by_parts_greater_rtx (enum machine_mode mode, int unsignedp, rtx op0,
-			      rtx op1, rtx if_false_label, rtx if_true_label)
+			      rtx op1, rtx if_false_label, rtx if_true_label,
+			      int prob)
 {
   int nwords = (GET_MODE_SIZE (mode) / UNITS_PER_WORD);
   rtx drop_through_label = 0;
@@ -625,11 +654,12 @@
       /* All but high-order word must be compared as unsigned.  */
       do_compare_rtx_and_jump (op0_word, op1_word, GT,
                                (unsignedp || i > 0), word_mode, NULL_RTX,
-                               NULL_RTX, if_true_label);
+			       NULL_RTX, if_true_label, prob);
 
       /* Consider lower words only if these are equal.  */
       do_compare_rtx_and_jump (op0_word, op1_word, NE, unsignedp, word_mode,
-                               NULL_RTX, NULL_RTX, if_false_label);
+			       NULL_RTX, NULL_RTX, if_false_label,
+			       inv (prob));
     }
 
   if (if_false_label)
@@ -645,7 +675,7 @@
 
 static void
 do_jump_by_parts_greater (tree exp, int swap, rtx if_false_label,
-			  rtx if_true_label)
+			  rtx if_true_label, int prob)
 {
   rtx op0 = expand_normal (TREE_OPERAND (exp, swap));
   rtx op1 = expand_normal (TREE_OPERAND (exp, !swap));
@@ -653,7 +683,7 @@
   int unsignedp = TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 0)));
 
   do_jump_by_parts_greater_rtx (mode, unsignedp, op0, op1, if_false_label,
-				if_true_label);
+				if_true_label, prob);
 }
 
 /* Jump according to whether OP0 is 0.  We assume that OP0 has an integer
@@ -663,7 +693,7 @@
 
 static void
 do_jump_by_parts_zero_rtx (enum machine_mode mode, rtx op0,
-			   rtx if_false_label, rtx if_true_label)
+			   rtx if_false_label, rtx if_true_label, int prob)
 {
   int nwords = GET_MODE_SIZE (mode) / UNITS_PER_WORD;
   rtx part;
@@ -685,8 +715,7 @@
   if (part != 0)
     {
       do_compare_rtx_and_jump (part, const0_rtx, EQ, 1, word_mode,
-                               NULL_RTX, if_false_label, if_true_label);
-
+			       NULL_RTX, if_false_label, if_true_label, prob);
       return;
     }
 
@@ -697,7 +726,7 @@
   for (i = 0; i < nwords; i++)
     do_compare_rtx_and_jump (operand_subword_force (op0, i, mode),
                              const0_rtx, EQ, 1, word_mode, NULL_RTX,
-                             if_false_label, NULL_RTX);
+			     if_false_label, NULL_RTX, prob);
 
   if (if_true_label)
     emit_jump (if_true_label);
@@ -713,7 +742,7 @@
 
 static void
 do_jump_by_parts_equality_rtx (enum machine_mode mode, rtx op0, rtx op1,
-			       rtx if_false_label, rtx if_true_label)
+			       rtx if_false_label, rtx if_true_label, int prob)
 {
   int nwords = (GET_MODE_SIZE (mode) / UNITS_PER_WORD);
   rtx drop_through_label = 0;
@@ -721,12 +750,14 @@
 
   if (op1 == const0_rtx)
     {
-      do_jump_by_parts_zero_rtx (mode, op0, if_false_label, if_true_label);
+      do_jump_by_parts_zero_rtx (mode, op0, if_false_label, if_true_label,
+				 prob);
       return;
     }
   else if (op0 == const0_rtx)
     {
-      do_jump_by_parts_zero_rtx (mode, op1, if_false_label, if_true_label);
+      do_jump_by_parts_zero_rtx (mode, op1, if_false_label, if_true_label,
+				 prob);
       return;
     }
 
@@ -737,7 +768,7 @@
     do_compare_rtx_and_jump (operand_subword_force (op0, i, mode),
                              operand_subword_force (op1, i, mode),
                              EQ, 0, word_mode, NULL_RTX,
-			     if_false_label, NULL_RTX);
+			     if_false_label, NULL_RTX, prob);
 
   if (if_true_label)
     emit_jump (if_true_label);
@@ -749,13 +780,14 @@
    with one insn, test the comparison and jump to the appropriate label.  */
 
 static void
-do_jump_by_parts_equality (tree exp, rtx if_false_label, rtx if_true_label)
+do_jump_by_parts_equality (tree exp, rtx if_false_label, rtx if_true_label,
+			   int prob)
 {
   rtx op0 = expand_normal (TREE_OPERAND (exp, 0));
   rtx op1 = expand_normal (TREE_OPERAND (exp, 1));
   enum machine_mode mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));
   do_jump_by_parts_equality_rtx (mode, op0, op1, if_false_label,
-				 if_true_label);
+				 if_true_label, prob);
 }
 
 /* Generate code for a comparison of OP0 and OP1 with rtx code CODE.
@@ -825,7 +857,7 @@
 void
 do_compare_rtx_and_jump (rtx op0, rtx op1, enum rtx_code code, int unsignedp,
 			 enum machine_mode mode, rtx size, rtx if_false_label,
-			 rtx if_true_label)
+			 rtx if_true_label, int prob)
 {
   rtx tem;
   int dummy_true_label = 0;
@@ -837,6 +869,7 @@
       if_true_label = if_false_label;
       if_false_label = 0;
       code = reverse_condition (code);
+      prob = inv (prob);
     }
 
   /* If one operand is constant, make it the second one.  Only do this
@@ -886,52 +919,56 @@
 	{
 	case LTU:
 	  do_jump_by_parts_greater_rtx (mode, 1, op1, op0,
-					if_false_label, if_true_label);
+					if_false_label, if_true_label, prob);
 	  break;
 
 	case LEU:
 	  do_jump_by_parts_greater_rtx (mode, 1, op0, op1,
-					if_true_label, if_false_label);
+					if_true_label, if_false_label,
+					inv (prob));
 	  break;
 
 	case GTU:
 	  do_jump_by_parts_greater_rtx (mode, 1, op0, op1,
-					if_false_label, if_true_label);
+					if_false_label, if_true_label, prob);
 	  break;
 
 	case GEU:
 	  do_jump_by_parts_greater_rtx (mode, 1, op1, op0,
-					if_true_label, if_false_label);
+					if_true_label, if_false_label,
+					inv (prob));
 	  break;
 
 	case LT:
 	  do_jump_by_parts_greater_rtx (mode, 0, op1, op0,
-					if_false_label, if_true_label);
+					if_false_label, if_true_label, prob);
 	  break;
 
 	case LE:
 	  do_jump_by_parts_greater_rtx (mode, 0, op0, op1,
-					if_true_label, if_false_label);
+					if_true_label, if_false_label,
+					inv (prob));
 	  break;
 
 	case GT:
 	  do_jump_by_parts_greater_rtx (mode, 0, op0, op1,
-					if_false_label, if_true_label);
+					if_false_label, if_true_label, prob);
 	  break;
 
 	case GE:
 	  do_jump_by_parts_greater_rtx (mode, 0, op1, op0,
-					if_true_label, if_false_label);
+					if_true_label, if_false_label,
+					inv (prob));
 	  break;
 
 	case EQ:
 	  do_jump_by_parts_equality_rtx (mode, op0, op1, if_false_label,
-					 if_true_label);
+					 if_true_label, prob);
 	  break;
 
 	case NE:
 	  do_jump_by_parts_equality_rtx (mode, op0, op1, if_true_label,
-					 if_false_label);
+					 if_false_label, inv (prob));
 	  break;
 
 	default:
@@ -939,8 +976,32 @@
 	}
     }
   else
-    emit_cmp_and_jump_insns (op0, op1, code, size, mode, unsignedp,
-			     if_true_label);
+    {
+      rtx last = get_last_insn ();
+      emit_cmp_and_jump_insns (op0, op1, code, size, mode, unsignedp,
+			       if_true_label);
+      if (prob != -1 && profile_status != PROFILE_ABSENT)
+       {
+	 for (last = NEXT_INSN (last);
+	      last && NEXT_INSN (last);
+	      last = NEXT_INSN (last))
+	   if (JUMP_P (last))
+	     break;
+	 if (!last
+	     || !JUMP_P (last)
+	     || NEXT_INSN (last)
+	     || !any_condjump_p (last))
+	   {
+	     if (dump_file)
+	       fprintf (dump_file, "Failed to add probability note\n");
+	   }
+	 else
+	   {
+	     gcc_assert (!find_reg_note (last, REG_BR_PROB, 0));
+	     add_reg_note (last, REG_BR_PROB, GEN_INT (prob));
+	   }
+       }
+    }
 
   if (if_false_label)
     emit_jump (if_false_label);
@@ -961,7 +1022,7 @@
 static void
 do_compare_and_jump (tree exp, enum rtx_code signed_code,
 		     enum rtx_code unsigned_code, rtx if_false_label,
-		     rtx if_true_label)
+		     rtx if_true_label, int prob)
 {
   rtx op0, op1;
   tree type;
@@ -1022,7 +1083,7 @@
   do_compare_rtx_and_jump (op0, op1, code, unsignedp, mode,
                            ((mode == BLKmode)
                             ? expr_size (TREE_OPERAND (exp, 0)) : NULL_RTX),
-                           if_false_label, if_true_label);
+                           if_false_label, if_true_label, prob);
 }
 
 #include "gt-dojump.h"
Index: gcc/dbxout.c
===================================================================
--- gcc/dbxout.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/dbxout.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -349,6 +349,7 @@
 {
   dbxout_init,
   dbxout_finish,
+  debug_nothing_void,
   debug_nothing_int_charstar,
   debug_nothing_int_charstar,
   dbxout_start_source_file,
@@ -385,6 +386,7 @@
 {
   dbxout_init,
   dbxout_finish,
+  debug_nothing_void,
   debug_nothing_int_charstar,
   debug_nothing_int_charstar,
   dbxout_start_source_file,
Index: gcc/tree-ssa-math-opts.c
===================================================================
--- gcc/tree-ssa-math-opts.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/tree-ssa-math-opts.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -528,7 +528,9 @@
 		      || DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_MD))
 		{
 		  enum built_in_function code;
-		  bool md_code;
+		  bool md_code, fail;
+		  imm_use_iterator ui;
+		  use_operand_p use_p;
 
 		  code = DECL_FUNCTION_CODE (fndecl);
 		  md_code = DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_MD;
@@ -537,12 +539,34 @@
 		  if (!fndecl)
 		    continue;
 
+		  /* Check that all uses of the SSA name are divisions,
+		     otherwise replacing the defining statement will do
+		     the wrong thing.  */
+		  fail = false;
+		  FOR_EACH_IMM_USE_FAST (use_p, ui, arg1)
+		    {
+		      gimple stmt2 = USE_STMT (use_p);
+		      if (!is_gimple_assign (stmt2)
+			  || gimple_assign_rhs_code (stmt2) != RDIV_EXPR
+			  || gimple_assign_rhs1 (stmt2) == arg1
+			  || gimple_assign_rhs2 (stmt2) != arg1)
+			{
+			  fail = true;
+			  break;
+			}
+		    }
+		  if (fail)
+		    continue;
+
 		  gimple_call_set_fndecl (stmt1, fndecl);
 		  update_stmt (stmt1);
 
-		  gimple_assign_set_rhs_code (stmt, MULT_EXPR);
-		  fold_stmt_inplace (stmt);
-		  update_stmt (stmt);
+		  FOR_EACH_IMM_USE_STMT (stmt, ui, arg1)
+		    {
+		      gimple_assign_set_rhs_code (stmt, MULT_EXPR);
+		      fold_stmt_inplace (stmt);
+		      update_stmt (stmt);
+		    }
 		}
 	    }
 	}
Index: gcc/tree-ssa-dom.c
===================================================================
--- gcc/tree-ssa-dom.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/tree-ssa-dom.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -2491,6 +2491,8 @@
 
       if (arg == lhs)
 	continue;
+      else if (!arg)
+	break;
       else if (!val)
 	val = arg;
       else if (!operand_equal_p (arg, val, 0))
Index: gcc/tree-ssa-alias.c
===================================================================
--- gcc/tree-ssa-alias.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/tree-ssa-alias.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -2335,39 +2335,7 @@
   size_t i;
 
   timevar_push (TV_FLOW_INSENSITIVE);
-  /* For every pointer P, determine which addressable variables may alias
-     with P's symbol memory tag.  */
-  for (i = 0; i < ai->num_pointers; i++)
-    {
-      size_t j;
-      struct alias_map_d *p_map = ai->pointers[i];
-      tree tag = symbol_mem_tag (p_map->var);
-      tree var;
 
-      for (j = 0; j < ai->num_addressable_vars; j++)
-	{
-	  struct alias_map_d *v_map;
-	  var_ann_t v_ann;
-	  
-	  v_map = ai->addressable_vars[j];
-	  var = v_map->var;
-	  v_ann = var_ann (var);
-
-	  /* We used to skip variables that have never been written to
-	     if the memory tag has been never written to directly (or
-	     either of them were call clobbered).  This is not enough
-	     though, as this misses writes through the tags aliases.
-	     So, for correctness we need to include any aliased
-	     variable here.  */
-
-	  if (may_alias_p (p_map->var, p_map->set, var, v_map->set, false))
-	    {
-	      /* Add VAR to TAG's may-aliases set.  */
-	      add_may_alias (tag, var);
-	    }
-	}
-    }
-
   /* Since this analysis is based exclusively on symbols, it fails to
      handle cases where two pointers P and Q have different memory
      tags with conflicting alias set numbers but no aliased symbols in
@@ -2387,7 +2355,11 @@
 
      To avoid this problem, we do a final traversal of AI->POINTERS
      looking for pairs of pointers that have no aliased symbols in
-     common and yet have conflicting alias set numbers.  */
+     common and yet have conflicting alias set numbers.
+
+     Note this has to be done first as we only can avoid adding
+     aliases for common memory tag aliases, not for common symbol
+     aliases as they might get pruned by the operand scanner later.  */
   for (i = 0; i < ai->num_pointers; i++)
     {
       size_t j;
@@ -2418,6 +2390,39 @@
 	}
     }
 
+  /* For every pointer P, determine which addressable variables may alias
+     with P's symbol memory tag.  */
+  for (i = 0; i < ai->num_pointers; i++)
+    {
+      size_t j;
+      struct alias_map_d *p_map = ai->pointers[i];
+      tree tag = symbol_mem_tag (p_map->var);
+      tree var;
+
+      for (j = 0; j < ai->num_addressable_vars; j++)
+	{
+	  struct alias_map_d *v_map;
+	  var_ann_t v_ann;
+	  
+	  v_map = ai->addressable_vars[j];
+	  var = v_map->var;
+	  v_ann = var_ann (var);
+
+	  /* We used to skip variables that have never been written to
+	     if the memory tag has been never written to directly (or
+	     either of them were call clobbered).  This is not enough
+	     though, as this misses writes through the tags aliases.
+	     So, for correctness we need to include any aliased
+	     variable here.  */
+
+	  if (may_alias_p (p_map->var, p_map->set, var, v_map->set, false))
+	    {
+	      /* Add VAR to TAG's may-aliases set.  */
+	      add_may_alias (tag, var);
+	    }
+	}
+    }
+
   /* We have to add all HEAP variables to all SMTs aliases bitmaps.
      As we don't know which effective type the HEAP will have we cannot
      do better here and we need the conflicts with obfuscated pointers
Index: gcc/ipa-inline.c
===================================================================
--- gcc/ipa-inline.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/ipa-inline.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1418,7 +1418,10 @@
     }
 
   /* Now do the automatic inlining.  */
-  if (mode != INLINE_ALL && mode != INLINE_ALWAYS_INLINE)
+  if (mode != INLINE_ALL && mode != INLINE_ALWAYS_INLINE
+      /* Never inline regular functions into always-inline functions
+	 during incremental inlining.  */
+      && !node->local.disregard_inline_limits)
     for (e = node->callees; e; e = e->next_callee)
       {
 	if (!e->callee->local.inlinable
@@ -1606,17 +1609,17 @@
   node->global.stack_frame_offset = 0;
 
   /* Can this function be inlined at all?  */
-  node->local.inlinable = tree_inlinable_function_p (current_function_decl);
+  node->local.inlinable = tree_inlinable_function_p (node->decl);
 
   /* Estimate the number of instructions for this function.
      ??? At -O0 we don't use this information except for the dumps, and
 	 even then only for always_inline functions.  But disabling this
 	 causes ICEs in the inline heuristics...  */
   inline_summary (node)->self_insns
-      = estimate_num_insns_fn (current_function_decl, &eni_inlining_weights);
+      = estimate_num_insns_fn (node->decl, &eni_inlining_weights);
   if (node->local.inlinable && !node->local.disregard_inline_limits)
     node->local.disregard_inline_limits
-      = DECL_DISREGARD_INLINE_LIMITS (current_function_decl);
+      = DECL_DISREGARD_INLINE_LIMITS (node->decl);
 
   /* Inlining characteristics are maintained by the cgraph_mark_inline.  */
   node->global.insns = inline_summary (node)->self_insns;
Index: gcc/config.in
===================================================================
--- gcc/config.in	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/config.in	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -839,6 +839,12 @@
 #endif
 
 
+/* Define 0/1 if your assembler supports .cfi_sections. */
+#ifndef USED_FOR_TARGET
+#undef HAVE_GAS_CFI_SECTIONS_DIRECTIVE
+#endif
+
+
 /* Define if your assembler uses the new HImode fild and fist notation. */
 #ifndef USED_FOR_TARGET
 #undef HAVE_GAS_FILDS_FISTS
Index: gcc/ifcvt.c
===================================================================
--- gcc/ifcvt.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/ifcvt.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -4040,7 +4040,8 @@
 	  if (! note)
 	    continue;
 	  set = single_set (insn);
-	  if (!set || !function_invariant_p (SET_SRC (set)))
+	  if (!set || !function_invariant_p (SET_SRC (set))
+	      || !function_invariant_p (XEXP (note, 0)))
 	    remove_note (insn, note);
 	} while (insn != end && (insn = NEXT_INSN (insn)));
 
@@ -4118,7 +4119,12 @@
 
 #ifdef IFCVT_MULTIPLE_DUMPS
       if (dump_file && cond_exec_changed_p)
-	print_rtl_with_bb (dump_file, get_insns ());
+	{
+	  if (dump_flags & TDF_SLIM)
+	    print_rtl_slim_with_bb (dump_file, get_insns (), dump_flags);
+	  else
+	    print_rtl_with_bb (dump_file, get_insns ());
+	}
 #endif
     }
   while (cond_exec_changed_p);
Index: gcc/dwarf2out.c
===================================================================
--- gcc/dwarf2out.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/dwarf2out.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,6 +1,7 @@
 /* Output Dwarf2 format symbol table information from GCC.
    Copyright (C) 1992, 1993, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-   2003, 2004, 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
+   2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
+   Free Software Foundation, Inc.
    Contributed by Gary Funck (gary@intrepid.com).
    Derived from DWARF 1 implementation of Ron Guilmette (rfg@monkeys.com).
    Extensively modified by Jason Merrill (jason@cygnus.com).
@@ -145,8 +146,19 @@
 #endif
   if (!flag_dwarf2_cfi_asm || !dwarf2out_do_frame ())
     return false;
-  if (saved_do_cfi_asm || !eh_personality_libfunc)
+  if (saved_do_cfi_asm)
     return true;
+  if (!HAVE_GAS_CFI_SECTIONS_DIRECTIVE)
+    {
+#ifdef TARGET_UNWIND_INFO
+      return false;
+#else
+      if (USING_SJLJ_EXCEPTIONS || (!flag_unwind_tables && !flag_exceptions))
+	return false;
+#endif
+    }
+  if (!eh_personality_libfunc)
+    return true;
   if (!HAVE_GAS_CFI_PERSONALITY_DIRECTIVE)
     return false;
 
@@ -4583,6 +4595,7 @@
 
 static void dwarf2out_init (const char *);
 static void dwarf2out_finish (const char *);
+static void dwarf2out_assembly_start (void);
 static void dwarf2out_define (unsigned int, const char *);
 static void dwarf2out_undef (unsigned int, const char *);
 static void dwarf2out_start_source_file (unsigned, const char *);
@@ -4605,6 +4618,7 @@
 {
   dwarf2out_init,
   dwarf2out_finish,
+  dwarf2out_assembly_start,
   dwarf2out_define,
   dwarf2out_undef,
   dwarf2out_start_source_file,
@@ -10627,6 +10641,8 @@
     case CEIL_DIV_EXPR:
     case ROUND_DIV_EXPR:
     case TRUNC_DIV_EXPR:
+      if (TYPE_UNSIGNED (TREE_TYPE (loc)))
+	return 0;
       op = DW_OP_div;
       goto do_binop;
 
@@ -10638,9 +10654,24 @@
     case CEIL_MOD_EXPR:
     case ROUND_MOD_EXPR:
     case TRUNC_MOD_EXPR:
-      op = DW_OP_mod;
-      goto do_binop;
+      if (TYPE_UNSIGNED (TREE_TYPE (loc)))
+	{
+	  op = DW_OP_mod;
+	  goto do_binop;
+	}
+      ret = loc_descriptor_from_tree_1 (TREE_OPERAND (loc, 0), 0);
+      ret1 = loc_descriptor_from_tree_1 (TREE_OPERAND (loc, 1), 0);
+      if (ret == 0 || ret1 == 0)
+	return 0;
 
+      add_loc_descr (&ret, ret1);
+      add_loc_descr (&ret, new_loc_descr (DW_OP_over, 0, 0));
+      add_loc_descr (&ret, new_loc_descr (DW_OP_over, 0, 0));
+      add_loc_descr (&ret, new_loc_descr (DW_OP_div, 0, 0));
+      add_loc_descr (&ret, new_loc_descr (DW_OP_mul, 0, 0));
+      add_loc_descr (&ret, new_loc_descr (DW_OP_minus, 0, 0));
+      break;
+
     case MULT_EXPR:
       op = DW_OP_mul;
       goto do_binop;
@@ -13191,7 +13222,9 @@
   int i;
 
   for (i = VEC_length (tree, incomplete_types) - 1; i >= 0; i--)
-    gen_type_die (VEC_index (tree, incomplete_types, i), comp_unit_die);
+    if (should_emit_struct_debug (VEC_index (tree, incomplete_types, i),
+				  DINFO_USAGE_DIR_USE))
+      gen_type_die (VEC_index (tree, incomplete_types, i), comp_unit_die);
 }
 
 /* Determine what tag to use for a record type.  */
@@ -16187,8 +16220,24 @@
       switch_to_section (cold_text_section);
       ASM_OUTPUT_LABEL (asm_out_file, cold_text_section_label);
     }
+
 }
 
+/* Called before cgraph_optimize starts outputtting functions, variables
+   and toplevel asms into assembly.  */
+
+static void
+dwarf2out_assembly_start (void)
+{
+  if (HAVE_GAS_CFI_SECTIONS_DIRECTIVE && dwarf2out_do_cfi_asm ())
+    {
+#ifndef TARGET_UNWIND_INFO
+      if (USING_SJLJ_EXCEPTIONS || (!flag_unwind_tables && !flag_exceptions))
+#endif
+	fprintf (asm_out_file, "\t.cfi_sections\t.debug_frame\n");
+    }
+}
+
 /* A helper function for dwarf2out_finish called through
    ht_forall.  Emit one queued .debug_str string.  */
 
Index: gcc/expr.c
===================================================================
--- gcc/expr.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/expr.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,6 +1,6 @@
 /* Convert tree expression to rtl instructions, for GNU compiler.
    Copyright (C) 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
-   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
+   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
    Free Software Foundation, Inc.
 
 This file is part of GCC.
@@ -4248,7 +4248,7 @@
       /* Handle expand_expr of a complex value returning a CONCAT.  */
       if (GET_CODE (to_rtx) == CONCAT)
 	{
-	  if (TREE_CODE (TREE_TYPE (from)) == COMPLEX_TYPE)
+	  if (COMPLEX_MODE_P (TYPE_MODE (TREE_TYPE (from))))
 	    {
 	      gcc_assert (bitpos == 0);
 	      result = store_expr (from, to_rtx, false, nontemporal);
@@ -4483,7 +4483,7 @@
 
       do_pending_stack_adjust ();
       NO_DEFER_POP;
-      jumpifnot (TREE_OPERAND (exp, 0), lab1);
+      jumpifnot (TREE_OPERAND (exp, 0), lab1, -1);
       store_expr (TREE_OPERAND (exp, 1), target, call_param_p,
 		  nontemporal);
       emit_jump_insn (gen_jump (lab2));
@@ -5503,7 +5503,7 @@
 		    /* Generate a conditional jump to exit the loop.  */
 		    exit_cond = build2 (LT_EXPR, integer_type_node,
 					index, hi_index);
-		    jumpif (exit_cond, loop_end);
+		    jumpif (exit_cond, loop_end, -1);
 
 		    /* Update the loop counter, and jump to the head of
 		       the loop.  */
@@ -8974,7 +8974,8 @@
 
 	temp = gen_label_rtx ();
 	do_compare_rtx_and_jump (target, cmpop1, comparison_code,
-				 unsignedp, mode, NULL_RTX, NULL_RTX, temp);
+				 unsignedp, mode, NULL_RTX, NULL_RTX, temp,
+				 -1);
       }
       emit_move_insn (target, op1);
       emit_label (temp);
@@ -9125,7 +9126,7 @@
 	emit_move_insn (target, const0_rtx);
 
       op1 = gen_label_rtx ();
-      jumpifnot (exp, op1);
+      jumpifnot (exp, op1, -1);
 
       if (target)
 	emit_move_insn (target, const1_rtx);
@@ -9194,7 +9195,7 @@
        NO_DEFER_POP;
        op0 = gen_label_rtx ();
        op1 = gen_label_rtx ();
-       jumpifnot (TREE_OPERAND (exp, 0), op0);
+       jumpifnot (TREE_OPERAND (exp, 0), op0, -1);
        store_expr (TREE_OPERAND (exp, 1), temp,
  		  modifier == EXPAND_STACK_PARM,
 		  false);
@@ -9240,7 +9241,7 @@
 	    int value = TREE_CODE (rhs) == BIT_IOR_EXPR;
 	    do_jump (TREE_OPERAND (rhs, 1),
 		     value ? label : 0,
-		     value ? 0 : label);
+		     value ? 0 : label, -1);
 	    expand_assignment (lhs, build_int_cst (TREE_TYPE (rhs), value),
 			       MOVE_NONTEMPORAL (exp));
 	    do_pending_stack_adjust ();
@@ -9924,7 +9925,7 @@
   emit_move_insn (target, invert ? const0_rtx : const1_rtx);
   label = gen_label_rtx ();
   do_compare_rtx_and_jump (op0, op1, code, unsignedp, operand_mode, NULL_RTX,
-			   NULL_RTX, label);
+			   NULL_RTX, label, -1);
 
   emit_move_insn (target, invert ? const1_rtx : const0_rtx);
   emit_label (label);
Index: gcc/expr.h
===================================================================
--- gcc/expr.h	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/expr.h	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,6 +1,6 @@
 /* Definitions for code generation pass of GNU compiler.
    Copyright (C) 1987, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
    Free Software Foundation, Inc.
 
 This file is part of GCC.
@@ -564,20 +564,20 @@
 extern tree string_constant (tree, tree *);
 
 /* Generate code to evaluate EXP and jump to LABEL if the value is zero.  */
-extern void jumpifnot (tree, rtx);
+extern void jumpifnot (tree, rtx, int);
 
 /* Generate code to evaluate EXP and jump to LABEL if the value is nonzero.  */
-extern void jumpif (tree, rtx);
+extern void jumpif (tree, rtx, int);
 
 /* Generate code to evaluate EXP and jump to IF_FALSE_LABEL if
    the result is zero, or IF_TRUE_LABEL if the result is one.  */
-extern void do_jump (tree, rtx, rtx);
+extern void do_jump (tree, rtx, rtx, int);
 
 /* Generate rtl to compare two rtx's, will call emit_cmp_insn.  */
 extern rtx compare_from_rtx (rtx, rtx, enum rtx_code, int, enum machine_mode,
 			     rtx);
 extern void do_compare_rtx_and_jump (rtx, rtx, enum rtx_code, int,
-				     enum machine_mode, rtx, rtx, rtx);
+				     enum machine_mode, rtx, rtx, rtx, int);
 
 /* Two different ways of generating switch statements.  */
 extern int try_casesi (tree, tree, tree, tree, rtx, rtx, rtx);
Index: gcc/opts.c
===================================================================
--- gcc/opts.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/opts.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -837,6 +837,8 @@
 	      if (optimize_val != -1)
 		{
 		  optimize = optimize_val;
+		  if ((unsigned int) optimize > 255)
+		    optimize = 255;
 		  optimize_size = 0;
 		}
 	    }
Index: gcc/unwind-dw2.c
===================================================================
--- gcc/unwind-dw2.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/unwind-dw2.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,6 +1,6 @@
 /* DWARF2 exception handling and frame unwind runtime interface routines.
    Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
-   2008, 2009  Free Software Foundation, Inc.
+   2008, 2009, 2010  Free Software Foundation, Inc.
 
    This file is part of GCC.
 
@@ -765,7 +765,7 @@
 		result = second - first;
 		break;
 	      case DW_OP_mod:
-		result = (_Unwind_Sword) second % (_Unwind_Sword) first;
+		result = second % first;
 		break;
 	      case DW_OP_mul:
 		result = second * first;
@@ -789,22 +789,22 @@
 		result = second ^ first;
 		break;
 	      case DW_OP_le:
-		result = (_Unwind_Sword) first <= (_Unwind_Sword) second;
+		result = (_Unwind_Sword) second <= (_Unwind_Sword) first;
 		break;
 	      case DW_OP_ge:
-		result = (_Unwind_Sword) first >= (_Unwind_Sword) second;
+		result = (_Unwind_Sword) second >= (_Unwind_Sword) first;
 		break;
 	      case DW_OP_eq:
-		result = (_Unwind_Sword) first == (_Unwind_Sword) second;
+		result = (_Unwind_Sword) second == (_Unwind_Sword) first;
 		break;
 	      case DW_OP_lt:
-		result = (_Unwind_Sword) first < (_Unwind_Sword) second;
+		result = (_Unwind_Sword) second < (_Unwind_Sword) first;
 		break;
 	      case DW_OP_gt:
-		result = (_Unwind_Sword) first > (_Unwind_Sword) second;
+		result = (_Unwind_Sword) second > (_Unwind_Sword) first;
 		break;
 	      case DW_OP_ne:
-		result = (_Unwind_Sword) first != (_Unwind_Sword) second;
+		result = (_Unwind_Sword) second != (_Unwind_Sword) first;
 		break;
 
 	      default:
Index: gcc/ada/init.c
===================================================================
--- gcc/ada/init.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/ada/init.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -290,28 +290,21 @@
 extern void __gnat_set_code_loc (struct sigcontext *, char *);
 extern size_t __gnat_machine_state_length (void);
 
-/* __gnat_adjust_context_for_raise - see comments along with the default
-   version later in this file.  */
-
 #define HAVE_GNAT_ADJUST_CONTEXT_FOR_RAISE
 
 void
-__gnat_adjust_context_for_raise (int signo, void *context)
+__gnat_adjust_context_for_raise (int signo, void *ucontext)
 {
-  struct sigcontext * sigcontext = (struct sigcontext *) context;
+  struct sigcontext *sigcontext = (struct sigcontext *) ucontext;
 
-  /* The fallback code fetches the faulting insn address from sc_pc, so
-     adjust that when need be.  For SIGFPE, the required adjustment depends
-     on the trap shadow situation (see man ieee).  */
+  /* The unwinder expects the signal context to contain the address of the
+     faulting instruction.  For SIGFPE, this depends on the trap shadow
+     situation (see man ieee).  We nonetheless always compensate for it,
+     considering that PC designates the instruction following the one that
+     trapped.  This is not necessarily true but corresponds to what we have
+     always observed.  */
   if (signo == SIGFPE)
-    {
-      /* ??? We never adjust here, considering that sc_pc always
-	 designates the instruction following the one which trapped.
-	 This is not necessarily true but corresponds to what we have
-	 always observed.  */
-    }
-  else
-    sigcontext->sc_pc ++;
+    sigcontext->sc_pc--;
 }
 
 static void
@@ -2154,8 +2147,11 @@
 				 void *ucontext ATTRIBUTE_UNUSED)
 {
   /* We used to compensate here for the raised from call vs raised from signal
-     exception discrepancy with the GCC ZCX scheme, but this is now dealt with
-     generically (except for the Alpha and IA-64), see GCC PR other/26208.
+     exception discrepancy with the GCC ZCX scheme, but this now can be dealt
+     with generically in the unwinder (see GCC PR other/26208).  This however
+     requires the use of the _Unwind_GetIPInfo routine in raise-gcc.c, which
+     is predicated on the definition of HAVE_GETIPINFO at compile time.  Only
+     the VMS ports still do the compensation described in the few lines below.
 
      *** Call vs signal exception discrepancy with GCC ZCX scheme ***
 
Index: gcc/ada/ChangeLog
===================================================================
--- gcc/ada/ChangeLog	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/ada/ChangeLog	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,3 +1,30 @@
+2010-02-27  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR ada/42253
+	* gcc-interface/utils2.c (build_binary_op) <EQ_EXPR>: Assert that fat
+	pointer base types are variant of each other.  Apply special treatment
+	for null to fat pointer types in all cases.
+
+2010-01-21  Release Manager
+
+	* GCC 4.4.3 released.
+
+2009-10-27  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* raise-gcc (db_region_for): Use _Unwind_GetIPInfo instead of
+	_Unwind_GetIP if HAVE_GETIPINFO is defined.
+	(db_action_for): Likewise.
+
+2009-10-24  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* init.c (__gnat_adjust_context_for_raise): Mention _Unwind_GetIPInfo.
+	* gcc-interface/Makefile.in (GNATLIBCFLAGS_FOR_C): Add HAVE_GETIPINFO.
+	Pass GNATLIBCFLAGS_FOR_C to recursive invocations.
+
+	Backport from mainline:
+	2009-04-10  Eric Botcazou  <ebotcazou@adacore.com>
+	* init.c: Adjust EH support code on Alpha/Tru64.
+
 2009-10-15  Release Manager
 
 	* GCC 4.4.2 released.
Index: gcc/ada/raise-gcc.c
===================================================================
--- gcc/ada/raise-gcc.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/ada/raise-gcc.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -56,6 +56,14 @@
 #include "adaint.h"
 #include "raise.h"
 
+#ifdef __APPLE__
+/* On MacOS X, versions older than 10.5 don't export _Unwind_GetIPInfo.  */
+#undef HAVE_GETIPINFO
+#if __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ >= 1050
+#define HAVE_GETIPINFO 1
+#endif
+#endif
+
 /* The names of a couple of "standard" routines for unwinding/propagation
    actually vary depending on the underlying GCC scheme for exception handling
    (SJLJ or DWARF). We need a consistently named interface to import from
@@ -501,7 +509,14 @@
 static void
 db_region_for (region_descriptor *region, _Unwind_Context *uw_context)
 {
-  _Unwind_Ptr ip = _Unwind_GetIP (uw_context) - 1;
+  int ip_before_insn = 0;
+#ifdef HAVE_GETIPINFO
+  _Unwind_Ptr ip = _Unwind_GetIPInfo (uw_context, &ip_before_insn);
+#else
+  _Unwind_Ptr ip = _Unwind_GetIP (uw_context);
+#endif
+  if (!ip_before_insn)
+    ip--;
 
   if (! (db_accepted_codes () & DB_REGIONS))
     return;
@@ -631,7 +646,14 @@
 static void
 db_action_for (action_descriptor *action, _Unwind_Context *uw_context)
 {
-  _Unwind_Ptr ip = _Unwind_GetIP (uw_context) - 1;
+  int ip_before_insn = 0;
+#ifdef HAVE_GETIPINFO
+  _Unwind_Ptr ip = _Unwind_GetIPInfo (uw_context, &ip_before_insn);
+#else
+  _Unwind_Ptr ip = _Unwind_GetIP (uw_context);
+#endif
+  if (!ip_before_insn)
+    ip--;
 
   db (DB_ACTIONS, "For ip @ 0x%08x => ", ip);
 
@@ -670,14 +692,6 @@
    There are two variants of this routine, depending on the underlying
    mechanism (DWARF/SJLJ), which account for differences in the tables.  */
 
-#ifdef __APPLE__
-/* On MacOS X, versions older than 10.5 don't export _Unwind_GetIPInfo.  */
-#undef HAVE_GETIPINFO
-#if __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ >= 1050
-#define HAVE_GETIPINFO 1
-#endif
-#endif
-
 #ifdef __USING_SJLJ_EXCEPTIONS__
 
 #define __builtin_eh_return_data_regno(x) x
Index: gcc/ada/gcc-interface/Makefile.in
===================================================================
--- gcc/ada/gcc-interface/Makefile.in	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/ada/gcc-interface/Makefile.in	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -106,8 +106,11 @@
 FORCE_DEBUG_ADAFLAGS = -g
 GNATLIBFLAGS = -gnatpg -nostdinc
 GNATLIBCFLAGS = -g -O2
+# Pretend that _Unwind_GetIPInfo is available for the target by default.  This
+# should be autodetected during the configuration of libada and passed down to
+# here, but we need something for --disable-libada and hope for the best.
 GNATLIBCFLAGS_FOR_C = $(GNATLIBCFLAGS) $(TARGET_LIBGCC2_CFLAGS) -fexceptions \
-	-DIN_RTS
+	-DIN_RTS -DHAVE_GETIPINFO
 ALL_ADAFLAGS = $(CFLAGS) $(ADA_CFLAGS) $(ADAFLAGS)
 MOST_ADAFLAGS = $(CFLAGS) $(ADA_CFLAGS) $(SOME_ADAFLAGS)
 THREAD_KIND = native
@@ -2074,6 +2077,7 @@
 	$(MAKE) $(FLAGS_TO_PASS) \
              GNATLIBFLAGS="$(GNATLIBFLAGS)" \
 	     GNATLIBCFLAGS="$(GNATLIBCFLAGS) $(TARGET_LIBGCC2_CFLAGS)" \
+	     GNATLIBCFLAGS_FOR_C="$(GNATLIBCFLAGS_FOR_C)" \
 	     MULTISUBDIR="$(MULTISUBDIR)" \
 	     THREAD_KIND="$(THREAD_KIND)" \
              gnatlib
@@ -2099,6 +2103,7 @@
 	$(MAKE) $(FLAGS_TO_PASS) \
              GNATLIBFLAGS="$(GNATLIBFLAGS)" \
 	     GNATLIBCFLAGS="$(GNATLIBCFLAGS)" \
+	     GNATLIBCFLAGS_FOR_C="$(GNATLIBCFLAGS_FOR_C)" \
 	     MULTISUBDIR="$(MULTISUBDIR)" \
 	     THREAD_KIND="$(THREAD_KIND)" \
              gnatlib-shared-default
@@ -2107,6 +2112,7 @@
 	$(MAKE) $(FLAGS_TO_PASS) \
              GNATLIBFLAGS="$(GNATLIBFLAGS)" \
 	     GNATLIBCFLAGS="$(GNATLIBCFLAGS)" \
+	     GNATLIBCFLAGS_FOR_C="$(GNATLIBCFLAGS_FOR_C)" \
 	     MULTISUBDIR="$(MULTISUBDIR)" \
 	     THREAD_KIND="$(THREAD_KIND)" \
              gnatlib
@@ -2116,6 +2122,7 @@
 	$(MAKE) $(FLAGS_TO_PASS) \
              GNATLIBFLAGS="$(GNATLIBFLAGS)" \
 	     GNATLIBCFLAGS="$(GNATLIBCFLAGS) $(TARGET_LIBGCC2_CFLAGS)" \
+	     GNATLIBCFLAGS_FOR_C="$(GNATLIBCFLAGS_FOR_C)" \
 	     MULTISUBDIR="$(MULTISUBDIR)" \
 	     THREAD_KIND="$(THREAD_KIND)" \
              gnatlib-shared-win32
@@ -2124,6 +2131,7 @@
 	$(MAKE) $(FLAGS_TO_PASS) \
              GNATLIBFLAGS="$(GNATLIBFLAGS)" \
 	     GNATLIBCFLAGS="$(GNATLIBCFLAGS)" \
+	     GNATLIBCFLAGS_FOR_C="$(GNATLIBCFLAGS_FOR_C)" \
 	     MULTISUBDIR="$(MULTISUBDIR)" \
 	     THREAD_KIND="$(THREAD_KIND)" \
              gnatlib
@@ -2137,6 +2145,7 @@
 	$(MAKE) $(FLAGS_TO_PASS) \
              GNATLIBFLAGS="$(GNATLIBFLAGS)" \
 	     GNATLIBCFLAGS="$(GNATLIBCFLAGS) $(TARGET_LIBGCC2_CFLAGS)" \
+	     GNATLIBCFLAGS_FOR_C="$(GNATLIBCFLAGS_FOR_C)" \
 	     MULTISUBDIR="$(MULTISUBDIR)" \
 	     THREAD_KIND="$(THREAD_KIND)" \
              gnatlib
@@ -2156,6 +2165,7 @@
 	     GNATLIBFLAGS="$(GNATLIBFLAGS)" \
 	     GNATLIBCFLAGS="$(GNATLIBCFLAGS) $(TARGET_LIBGCC2_CFLAGS) \
 	                    -fno-common" \
+	     GNATLIBCFLAGS_FOR_C="$(GNATLIBCFLAGS_FOR_C) -fno-common" \
 	     MULTISUBDIR="$(MULTISUBDIR)" \
 	     THREAD_KIND="$(THREAD_KIND)" \
 	     gnatlib
@@ -2179,6 +2189,7 @@
 	$(MAKE) $(FLAGS_TO_PASS) \
              GNATLIBFLAGS="$(GNATLIBFLAGS)" \
 	     GNATLIBCFLAGS="$(GNATLIBCFLAGS)" \
+	     GNATLIBCFLAGS_FOR_C="$(GNATLIBCFLAGS_FOR_C)" \
 	     MULTISUBDIR="$(MULTISUBDIR)" \
 	     THREAD_KIND="$(THREAD_KIND)" \
              gnatlib
@@ -2207,6 +2218,7 @@
 	$(MAKE) $(FLAGS_TO_PASS) \
              GNATLIBFLAGS="$(GNATLIBFLAGS)" \
 	     GNATLIBCFLAGS="$(GNATLIBCFLAGS)" \
+	     GNATLIBCFLAGS_FOR_C="$(GNATLIBCFLAGS_FOR_C)" \
 	     MULTISUBDIR="$(MULTISUBDIR)" \
 	     THREAD_KIND="$(THREAD_KIND)" \
 	     TARGET_LIBGCC2_CFLAGS="$(TARGET_LIBGCC2_CFLAGS)" \
@@ -2220,6 +2232,7 @@
 	     EH_MECHANISM="" \
 	     GNATLIBFLAGS="$(GNATLIBFLAGS)" \
 	     GNATLIBCFLAGS="$(GNATLIBCFLAGS)" \
+	     GNATLIBCFLAGS_FOR_C="$(GNATLIBCFLAGS_FOR_C)" \
 	     MULTISUBDIR="$(MULTISUBDIR)" \
 	     THREAD_KIND="$(THREAD_KIND)" \
 	     TARGET_LIBGCC2_CFLAGS="$(TARGET_LIBGCC2_CFLAGS)" gnatlib
@@ -2232,6 +2245,7 @@
 	     EH_MECHANISM="-gcc" \
 	     GNATLIBFLAGS="$(GNATLIBFLAGS)" \
 	     GNATLIBCFLAGS="$(GNATLIBCFLAGS)" \
+	     GNATLIBCFLAGS_FOR_C="$(GNATLIBCFLAGS_FOR_C)" \
 	     MULTISUBDIR="$(MULTISUBDIR)" \
 	     THREAD_KIND="$(THREAD_KIND)" \
 	     TARGET_LIBGCC2_CFLAGS="$(TARGET_LIBGCC2_CFLAGS)" gnatlib
Index: gcc/ada/gcc-interface/utils2.c
===================================================================
--- gcc/ada/gcc-interface/utils2.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/ada/gcc-interface/utils2.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -879,26 +879,28 @@
 	  return result;
 	}
 
-      /* Otherwise, the base types must be the same unless the objects are
-	 fat pointers or records.  If we have records, use the best type and
-	 convert both operands to that type.  */
+      /* Otherwise, the base types must be the same, unless they are both fat
+	 pointer types or record types.  In the latter case, use the best type
+	 and convert both operands to that type.  */
       if (left_base_type != right_base_type)
 	{
 	  if (TYPE_FAT_POINTER_P (left_base_type)
-	      && TYPE_FAT_POINTER_P (right_base_type)
-	      && TYPE_MAIN_VARIANT (left_base_type)
-		 == TYPE_MAIN_VARIANT (right_base_type))
-	    best_type = left_base_type;
+	      && TYPE_FAT_POINTER_P (right_base_type))
+	    {
+	      gcc_assert (TYPE_MAIN_VARIANT (left_base_type)
+			  == TYPE_MAIN_VARIANT (right_base_type));
+	      best_type = left_base_type;
+	    }
+
 	  else if (TREE_CODE (left_base_type) == RECORD_TYPE
 		   && TREE_CODE (right_base_type) == RECORD_TYPE)
 	    {
-	      /* The only way these are permitted to be the same is if both
-		 types have the same name.  In that case, one of them must
-		 not be self-referential.  Use that one as the best type.
-		 Even better is if one is of fixed size.  */
+	      /* The only way this is permitted is if both types have the same
+		 name.  In that case, one of them must not be self-referential.
+		 Use it as the best type.  Even better with a fixed size.  */
 	      gcc_assert (TYPE_NAME (left_base_type)
-			  && (TYPE_NAME (left_base_type)
-			      == TYPE_NAME (right_base_type)));
+			  && TYPE_NAME (left_base_type)
+			     == TYPE_NAME (right_base_type));
 
 	      if (TREE_CONSTANT (TYPE_SIZE (left_base_type)))
 		best_type = left_base_type;
@@ -911,34 +913,34 @@
 	      else
 		gcc_unreachable ();
 	    }
+
 	  else
 	    gcc_unreachable ();
 
 	  left_operand = convert (best_type, left_operand);
 	  right_operand = convert (best_type, right_operand);
 	}
-
-      /* If we are comparing a fat pointer against zero, we need to
-	 just compare the data pointer.  */
-      else if (TYPE_FAT_POINTER_P (left_base_type)
-	       && TREE_CODE (right_operand) == CONSTRUCTOR
-	       && integer_zerop (VEC_index (constructor_elt,
-					    CONSTRUCTOR_ELTS (right_operand),
-					    0)
-				 ->value))
-	{
-	  right_operand = build_component_ref (left_operand, NULL_TREE,
-					       TYPE_FIELDS (left_base_type),
-					       false);
-	  left_operand = convert (TREE_TYPE (right_operand),
-				  integer_zero_node);
-	}
       else
 	{
 	  left_operand = convert (left_base_type, left_operand);
 	  right_operand = convert (right_base_type, right_operand);
 	}
 
+      /* If we are comparing a fat pointer against zero, we just need to
+	 compare the data pointer.  */
+      if (TYPE_FAT_POINTER_P (left_base_type)
+	  && TREE_CODE (right_operand) == CONSTRUCTOR
+	  && integer_zerop (VEC_index (constructor_elt,
+				       CONSTRUCTOR_ELTS (right_operand),
+				       0)->value))
+	{
+	  left_operand
+	    = build_component_ref (left_operand, NULL_TREE,
+				   TYPE_FIELDS (left_base_type), false);
+	  right_operand
+	    = convert (TREE_TYPE (left_operand), integer_zero_node);
+	}
+
       modulus = NULL_TREE;
       break;
 
Index: gcc/dse.c
===================================================================
--- gcc/dse.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/dse.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1015,9 +1015,6 @@
 {
   switch (GET_CODE (x))
     {
-    case MEM:
-      return MEM_READONLY_P (x);
-
     case CONST:
     case CONST_INT:
     case CONST_DOUBLE:
Index: gcc/c-decl.c
===================================================================
--- gcc/c-decl.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/c-decl.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,6 +1,6 @@
 /* Process declarations and variables for C compiler.
    Copyright (C) 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
-   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
+   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
    Free Software Foundation, Inc.
 
 This file is part of GCC.
@@ -3735,7 +3735,8 @@
   tree complit;
   tree stmt;
 
-  if (type == error_mark_node)
+  if (type == error_mark_node
+      || init == error_mark_node)
     return error_mark_node;
 
   decl = build_decl (VAR_DECL, NULL_TREE, type);
@@ -6777,6 +6778,8 @@
       && !current_function_returns_value && !current_function_returns_null
       /* Don't complain if we are no-return.  */
       && !current_function_returns_abnormally
+      /* Don't complain if we are declared noreturn.  */
+      && !TREE_THIS_VOLATILE (fndecl)
       /* Don't warn for main().  */
       && !MAIN_NAME_P (DECL_NAME (fndecl))
       /* Or if they didn't actually specify a return type.  */
Index: gcc/fortran/trans-expr.c
===================================================================
--- gcc/fortran/trans-expr.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/fortran/trans-expr.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -2118,8 +2118,8 @@
    an actual argument derived type array is copied and then returned
    after the function call.  */
 void
-gfc_conv_subref_array_arg (gfc_se * parmse, gfc_expr * expr,
-			   int g77, sym_intent intent)
+gfc_conv_subref_array_arg (gfc_se * parmse, gfc_expr * expr, int g77,
+			   sym_intent intent, bool formal_ptr)
 {
   gfc_se lse;
   gfc_se rse;
@@ -2132,8 +2132,10 @@
   tree tmp_index;
   tree tmp;
   tree base_type;
+  tree size;
   stmtblock_t body;
   int n;
+  int dimen;
 
   gcc_assert (expr->expr_type == EXPR_VARIABLE);
 
@@ -2262,9 +2264,10 @@
      outside the innermost loop, so the overall transfer could be
      optimized further.  */
   info = &rse.ss->data.info;
+  dimen = info->dimen;
 
   tmp_index = gfc_index_zero_node;
-  for (n = info->dimen - 1; n > 0; n--)
+  for (n = dimen - 1; n > 0; n--)
     {
       tree tmp_str;
       tmp = rse.loop->loopvar[n];
@@ -2324,6 +2327,38 @@
   if (expr->ts.type == BT_CHARACTER)
     parmse->string_length = expr->ts.cl->backend_decl;
 
+  /* Determine the offset for pointer formal arguments and set the
+     lbounds to one.  */
+  if (formal_ptr)
+    {
+      size = gfc_index_one_node;
+      offset = gfc_index_zero_node;  
+      for (n = 0; n < dimen; n++)
+	{
+	  tmp = gfc_conv_descriptor_ubound (parmse->expr,
+					    gfc_rank_cst[n]);
+	  gfc_add_modify (&parmse->pre, tmp,
+			  fold_build2 (PLUS_EXPR, gfc_array_index_type,
+				       tmp, gfc_index_one_node));
+	  tmp = gfc_conv_descriptor_lbound (parmse->expr,
+					    gfc_rank_cst[n]);
+	  gfc_add_modify (&parmse->pre, tmp, gfc_index_one_node);
+	  size = gfc_evaluate_now (size, &parmse->pre);
+	  offset = fold_build2 (MINUS_EXPR, gfc_array_index_type,
+				offset, size);
+	  offset = gfc_evaluate_now (offset, &parmse->pre);
+	  tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,
+			     rse.loop->to[n], rse.loop->from[n]);
+	  tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,
+			     tmp, gfc_index_one_node);
+	  size = fold_build2 (MULT_EXPR, gfc_array_index_type,
+			      size, tmp);
+	}
+
+      tmp = gfc_conv_descriptor_offset (parmse->expr);
+      gfc_add_modify (&parmse->pre, tmp, offset);
+    }
+
   /* We want either the address for the data or the address of the descriptor,
      depending on the mode of passing array arguments.  */
   if (g77)
@@ -2620,8 +2655,11 @@
 		   through arg->name.  */
 		conv_arglist_function (&parmse, arg->expr, arg->name);
 	      else if ((e->expr_type == EXPR_FUNCTION)
-			  && e->symtree->n.sym->attr.pointer
-			  && fsym && fsym->attr.target)
+			&& ((e->value.function.esym
+			     && e->value.function.esym->result->attr.pointer)
+			    || (!e->value.function.esym
+				&& e->symtree->n.sym->attr.pointer))
+			&& fsym && fsym->attr.target)
 		{
 		  gfc_conv_expr (&parmse, e);
 		  parmse.expr = build_fold_addr_expr (parmse.expr);
@@ -2663,21 +2701,27 @@
 		   is converted to a temporary, which is passed and then
 		   written back after the procedure call.  */
 		gfc_conv_subref_array_arg (&parmse, e, f,
-			fsym ? fsym->attr.intent : INTENT_INOUT);
+				fsym ? fsym->attr.intent : INTENT_INOUT,
+				fsym && fsym->attr.pointer);
 	      else
 	        gfc_conv_array_parameter (&parmse, e, argss, f, fsym,
 					  sym->name);
 
-              /* If an ALLOCATABLE dummy argument has INTENT(OUT) and is 
-                 allocated on entry, it must be deallocated.  */
-              if (fsym && fsym->attr.allocatable
-                  && fsym->attr.intent == INTENT_OUT)
-                {
-                  tmp = build_fold_indirect_ref (parmse.expr);
-                  tmp = gfc_trans_dealloc_allocated (tmp);
-                  gfc_add_expr_to_block (&se->pre, tmp);
-                }
-
+	      /* If an ALLOCATABLE dummy argument has INTENT(OUT) and is 
+		 allocated on entry, it must be deallocated.  */
+	      if (fsym && fsym->attr.allocatable
+		  && fsym->attr.intent == INTENT_OUT)
+		{
+		  tmp = build_fold_indirect_ref (parmse.expr);
+		  tmp = gfc_trans_dealloc_allocated (tmp);
+		  if (fsym->attr.optional
+		      && e->expr_type == EXPR_VARIABLE
+		      && e->symtree->n.sym->attr.optional)
+		    tmp = fold_build3 (COND_EXPR, void_type_node,
+				     gfc_conv_expr_present (e->symtree->n.sym),
+				       tmp, build_empty_stmt ());
+		  gfc_add_expr_to_block (&se->pre, tmp);
+		}
 	    } 
 	}
 
@@ -3510,6 +3554,150 @@
 }
 
 
+static tree
+gfc_trans_alloc_subarray_assign (tree dest, gfc_component * cm,
+				 gfc_expr * expr)
+{
+  gfc_se se;
+  gfc_ss *rss;
+  stmtblock_t block;
+  tree offset;
+  int n;
+  tree tmp;
+  tree tmp2;
+  gfc_array_spec *as;
+  gfc_expr *arg = NULL;
+
+  gfc_start_block (&block);
+  gfc_init_se (&se, NULL);
+
+  /* Get the descriptor for the expressions.  */ 
+  rss = gfc_walk_expr (expr);
+  se.want_pointer = 0;
+  gfc_conv_expr_descriptor (&se, expr, rss);
+  gfc_add_block_to_block (&block, &se.pre);
+  gfc_add_modify (&block, dest, se.expr);
+
+  /* Deal with arrays of derived types with allocatable components.  */
+  if (cm->ts.type == BT_DERIVED
+	&& cm->ts.derived->attr.alloc_comp)
+    tmp = gfc_copy_alloc_comp (cm->ts.derived,
+			       se.expr, dest,
+			       cm->as->rank);
+  else
+    tmp = gfc_duplicate_allocatable (dest, se.expr,
+				     TREE_TYPE(cm->backend_decl),
+				     cm->as->rank);
+
+  gfc_add_expr_to_block (&block, tmp);
+  gfc_add_block_to_block (&block, &se.post);
+
+  if (expr->expr_type != EXPR_VARIABLE)
+    gfc_conv_descriptor_data_set (&block, se.expr,
+				  null_pointer_node);
+
+  /* We need to know if the argument of a conversion function is a
+     variable, so that the correct lower bound can be used.  */
+  if (expr->expr_type == EXPR_FUNCTION
+	&& expr->value.function.isym
+	&& expr->value.function.isym->conversion
+	&& expr->value.function.actual->expr
+	&& expr->value.function.actual->expr->expr_type == EXPR_VARIABLE)
+    arg = expr->value.function.actual->expr;
+
+  /* Obtain the array spec of full array references.  */
+  if (arg)
+    as = gfc_get_full_arrayspec_from_expr (arg);
+  else
+    as = gfc_get_full_arrayspec_from_expr (expr);
+
+  /* Shift the lbound and ubound of temporaries to being unity,
+     rather than zero, based. Always calculate the offset.  */
+  offset = gfc_conv_descriptor_offset (dest);
+  gfc_add_modify (&block, offset, gfc_index_zero_node);
+  tmp2 =gfc_create_var (gfc_array_index_type, NULL);
+
+  for (n = 0; n < expr->rank; n++)
+    {
+      tree span;
+      tree lbound;
+      tree ubound;
+
+      /* Obtain the correct lbound - ISO/IEC TR 15581:2001 page 9.
+	 TODO It looks as if gfc_conv_expr_descriptor should return
+	 the correct bounds and that the following should not be
+	 necessary.  This would simplify gfc_conv_intrinsic_bound
+	 as well.  */
+      if (as && as->lower[n])
+	{
+	  gfc_se lbse;
+	  gfc_init_se (&lbse, NULL);
+	  gfc_conv_expr (&lbse, as->lower[n]);
+	  gfc_add_block_to_block (&block, &lbse.pre);
+	  lbound = gfc_evaluate_now (lbse.expr, &block);
+	}
+      else if (as && arg)
+	{
+	  tmp = gfc_get_symbol_decl (arg->symtree->n.sym);
+	  lbound = gfc_conv_descriptor_lbound (tmp, gfc_rank_cst[n]);
+	}
+      else if (as)
+	lbound = gfc_conv_descriptor_lbound (dest, gfc_rank_cst[n]);
+      else
+	lbound = gfc_index_one_node;
+
+      lbound = fold_convert (gfc_array_index_type, lbound);
+
+      /* Shift the bounds and set the offset accordingly.  */
+      tmp = gfc_conv_descriptor_ubound (dest, gfc_rank_cst[n]);
+      span = fold_build2 (MINUS_EXPR, gfc_array_index_type, tmp,
+		gfc_conv_descriptor_lbound (dest, gfc_rank_cst[n]));
+
+      ubound = fold_build2 (PLUS_EXPR, gfc_array_index_type,
+			    span, lbound);
+      gfc_add_modify (&block, tmp, ubound);
+
+      tmp = gfc_conv_descriptor_lbound (dest, gfc_rank_cst[n]);
+      gfc_add_modify (&block, tmp, lbound);
+
+      tmp = fold_build2 (MULT_EXPR, gfc_array_index_type,
+		gfc_conv_descriptor_lbound (dest, gfc_rank_cst[n]),
+		gfc_conv_descriptor_stride (dest, gfc_rank_cst[n]));
+
+      gfc_add_modify (&block, tmp2, tmp);
+      tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,
+			 offset, tmp2);
+      gfc_add_modify (&block, offset, tmp);
+    }
+
+  if (arg)
+    {
+      /* If a conversion expression has a null data pointer
+	 argument, nullify the allocatable component.  */
+      tree non_null_expr;
+      tree null_expr;
+
+      if (arg->symtree->n.sym->attr.allocatable
+	    || arg->symtree->n.sym->attr.pointer)
+	{
+	  non_null_expr = gfc_finish_block (&block);
+	  gfc_start_block (&block);
+	  gfc_conv_descriptor_data_set (&block, dest,
+					null_pointer_node);
+	  null_expr = gfc_finish_block (&block);
+	  tmp = gfc_conv_descriptor_data_get (arg->symtree->n.sym->backend_decl);
+	  tmp = build2 (EQ_EXPR, boolean_type_node, tmp,
+			fold_convert (TREE_TYPE (tmp),
+				      null_pointer_node));
+	  return build3_v (COND_EXPR, tmp,
+			   null_expr, non_null_expr);
+	}
+    }
+
+  return gfc_finish_block (&block);
+}
+
+
 /* Assign a single component of a derived type constructor.  */
 
 static tree
@@ -3520,8 +3708,6 @@
   gfc_ss *rss;
   stmtblock_t block;
   tree tmp;
-  tree offset;
-  int n;
 
   gfc_start_block (&block);
 
@@ -3561,91 +3747,8 @@
  	gfc_conv_descriptor_data_set (&block, dest, null_pointer_node);
       else if (cm->attr.allocatable)
 	{
-	  tree tmp2;
-
-          gfc_init_se (&se, NULL);
- 
-	  rss = gfc_walk_expr (expr);
-	  se.want_pointer = 0;
-	  gfc_conv_expr_descriptor (&se, expr, rss);
-	  gfc_add_block_to_block (&block, &se.pre);
-
-	  tmp = fold_convert (TREE_TYPE (dest), se.expr);
-	  gfc_add_modify (&block, dest, tmp);
-
-	  if (cm->ts.type == BT_DERIVED && cm->ts.derived->attr.alloc_comp)
-	    tmp = gfc_copy_alloc_comp (cm->ts.derived, se.expr, dest,
-				       cm->as->rank);
-	  else
-	    tmp = gfc_duplicate_allocatable (dest, se.expr,
-					     TREE_TYPE(cm->backend_decl),
-					     cm->as->rank);
-
+	  tmp = gfc_trans_alloc_subarray_assign (dest, cm, expr);
 	  gfc_add_expr_to_block (&block, tmp);
-	  gfc_add_block_to_block (&block, &se.post);
-
-	  if (expr->expr_type != EXPR_VARIABLE)
-	    gfc_conv_descriptor_data_set (&block, se.expr, null_pointer_node);
-
-	  /* Shift the lbound and ubound of temporaries to being unity, rather
-	     than zero, based.  Calculate the offset for all cases.  */
-	  offset = gfc_conv_descriptor_offset (dest);
-	  gfc_add_modify (&block, offset, gfc_index_zero_node);
-	  tmp2 =gfc_create_var (gfc_array_index_type, NULL);
-	  for (n = 0; n < expr->rank; n++)
-	    {
-	      if (expr->expr_type != EXPR_VARIABLE
-		    && expr->expr_type != EXPR_CONSTANT)
-		{
-		  tree span;
-		  tmp = gfc_conv_descriptor_ubound (dest, gfc_rank_cst[n]);
-		  span = fold_build2 (MINUS_EXPR, gfc_array_index_type, tmp,
-			    gfc_conv_descriptor_lbound (dest, gfc_rank_cst[n]));
-		  gfc_add_modify (&block, tmp,
-				       fold_build2 (PLUS_EXPR,
-						    gfc_array_index_type,
-						    span, gfc_index_one_node));
-		  tmp = gfc_conv_descriptor_lbound (dest, gfc_rank_cst[n]);
-		  gfc_add_modify (&block, tmp, gfc_index_one_node);
-		}
-	      tmp = fold_build2 (MULT_EXPR, gfc_array_index_type,
-				 gfc_conv_descriptor_lbound (dest,
-							     gfc_rank_cst[n]),
-				 gfc_conv_descriptor_stride (dest,
-							     gfc_rank_cst[n]));
-	      gfc_add_modify (&block, tmp2, tmp);
-	      tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type, offset, tmp2);
-	      gfc_add_modify (&block, offset, tmp);
-	    }
-
-	  if (expr->expr_type == EXPR_FUNCTION
-		&& expr->value.function.isym
-		&& expr->value.function.isym->conversion
-		&& expr->value.function.actual->expr
-		&& expr->value.function.actual->expr->expr_type
-						== EXPR_VARIABLE)
-	    {
-	      /* If a conversion expression has a null data pointer
-		 argument, nullify the allocatable component.  */
-	      gfc_symbol *s;
-	      tree non_null_expr;
-	      tree null_expr;
-	      s = expr->value.function.actual->expr->symtree->n.sym;
-	      if (s->attr.allocatable || s->attr.pointer)
-		{
-		  non_null_expr = gfc_finish_block (&block);
-		  gfc_start_block (&block);
-		  gfc_conv_descriptor_data_set (&block, dest,
-						null_pointer_node);
-		  null_expr = gfc_finish_block (&block);
-		  tmp = gfc_conv_descriptor_data_get (s->backend_decl);
-		  tmp = build2 (EQ_EXPR, boolean_type_node, tmp,
-			        fold_convert (TREE_TYPE (tmp),
-					      null_pointer_node));
-		  return build3_v (COND_EXPR, tmp, null_expr,
-				   non_null_expr);
-		}
-	    }
 	}
       else
 	{
@@ -3948,8 +4051,12 @@
     }
 
   if (expr->expr_type == EXPR_FUNCTION
-	&& expr->symtree->n.sym->attr.pointer
-	&& !expr->symtree->n.sym->attr.dimension)
+      && ((expr->value.function.esym
+	   && expr->value.function.esym->result->attr.pointer
+	   && !expr->value.function.esym->result->attr.dimension)
+	  || (!expr->value.function.esym
+	      && expr->symtree->n.sym->attr.pointer
+	      && !expr->symtree->n.sym->attr.dimension)))
     {
       se->want_pointer = 1;
       gfc_conv_expr (se, expr);
Index: gcc/fortran/trans-array.c
===================================================================
--- gcc/fortran/trans-array.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/fortran/trans-array.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -788,7 +788,6 @@
   src_info = &src_ss->data.info;
   dest_info = &dest_ss->data.info;
   gcc_assert (dest_info->dimen == 2);
-  gcc_assert (src_info->dimen == 2);
 
   /* Get a descriptor for EXPR.  */
   gfc_init_se (&src_se, NULL);
Index: gcc/fortran/symbol.c
===================================================================
--- gcc/fortran/symbol.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/fortran/symbol.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -2693,7 +2693,7 @@
       if (p->gfc_new)
 	{
 	  /* Symbol was new.  */
-	  if (p->attr.in_common && p->common_block->head)
+	  if (p->attr.in_common && p->common_block && p->common_block->head)
 	    {
 	      /* If the symbol was added to any common block, it
 		 needs to be removed to stop the resolver looking
@@ -4237,6 +4237,8 @@
   new_symtree->n.sym->module = gfc_get_string (old_sym->module);
   new_symtree->n.sym->from_intmod = old_sym->from_intmod;
   new_symtree->n.sym->intmod_sym_id = old_sym->intmod_sym_id;
+  if (old_sym->attr.function)
+    new_symtree->n.sym->result = new_symtree->n.sym;
   /* Build the formal arg list.  */
   build_formal_args (new_symtree->n.sym, old_sym, add_optional_arg);
 
Index: gcc/fortran/decl.c
===================================================================
--- gcc/fortran/decl.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/fortran/decl.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,5 +1,5 @@
 /* Declaration statement matcher
-   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008
+   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008, 2009, 2010
    Free Software Foundation, Inc.
    Contributed by Andy Vaught
 
@@ -6597,10 +6597,9 @@
 
   if (initializer == NULL || initializer->ts.type != BT_INTEGER)
     {
-      gfc_error("ENUMERATOR %L not initialized with integer expression",
-		&var_locus);
+      gfc_error ("ENUMERATOR %L not initialized with integer expression",
+		 &var_locus);
       m = MATCH_ERROR;
-      gfc_free_enum_history ();
       goto cleanup;
     }
 
@@ -6666,7 +6665,10 @@
     {
       m = enumerator_decl ();
       if (m == MATCH_ERROR)
-	goto cleanup;
+	{
+	  gfc_free_enum_history ();
+	  goto cleanup;
+	}
       if (m == MATCH_NO)
 	break;
 
Index: gcc/fortran/trans-openmp.c
===================================================================
--- gcc/fortran/trans-openmp.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/fortran/trans-openmp.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1155,6 +1155,7 @@
     {
       int simple = 0;
       int dovar_found = 0;
+      tree dovar_decl;
 
       if (clauses)
 	{
@@ -1195,12 +1196,19 @@
       gfc_conv_expr_val (&se, code->ext.iterator->step);
       gfc_add_block_to_block (pblock, &se.pre);
       step = gfc_evaluate_now (se.expr, pblock);
+      dovar_decl = dovar;
 
       /* Special case simple loops.  */
-      if (integer_onep (step))
-	simple = 1;
-      else if (tree_int_cst_equal (step, integer_minus_one_node))
-	simple = -1;
+      if (TREE_CODE (dovar) == VAR_DECL)
+	{
+	  if (integer_onep (step))
+	    simple = 1;
+	  else if (tree_int_cst_equal (step, integer_minus_one_node))
+	    simple = -1;
+	}
+      else
+	dovar_decl
+	  = gfc_trans_omp_variable (code->ext.iterator->var->symtree->n.sym);
 
       /* Loop body.  */
       if (simple)
@@ -1244,7 +1252,7 @@
       if (!dovar_found)
 	{
 	  tmp = build_omp_clause (OMP_CLAUSE_PRIVATE);
-	  OMP_CLAUSE_DECL (tmp) = dovar;
+	  OMP_CLAUSE_DECL (tmp) = dovar_decl;
 	  omp_clauses = gfc_trans_add_clause (tmp, omp_clauses);
 	}
       else if (dovar_found == 2)
@@ -1264,7 +1272,7 @@
 	      tmp = fold_build2 (MODIFY_EXPR, type, dovar, tmp);
 	      for (c = omp_clauses; c ; c = OMP_CLAUSE_CHAIN (c))
 		if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE
-		    && OMP_CLAUSE_DECL (c) == dovar)
+		    && OMP_CLAUSE_DECL (c) == dovar_decl)
 		  {
 		    OMP_CLAUSE_LASTPRIVATE_STMT (c) = tmp;
 		    break;
@@ -1274,10 +1282,10 @@
 	    {
 	      for (c = par_clauses; c ; c = OMP_CLAUSE_CHAIN (c))
 		if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE
-		    && OMP_CLAUSE_DECL (c) == dovar)
+		    && OMP_CLAUSE_DECL (c) == dovar_decl)
 		  {
 		    tree l = build_omp_clause (OMP_CLAUSE_LASTPRIVATE);
-		    OMP_CLAUSE_DECL (l) = dovar;
+		    OMP_CLAUSE_DECL (l) = dovar_decl;
 		    OMP_CLAUSE_CHAIN (l) = omp_clauses;
 		    OMP_CLAUSE_LASTPRIVATE_STMT (l) = tmp;
 		    omp_clauses = l;
Index: gcc/fortran/gfortran.h
===================================================================
--- gcc/fortran/gfortran.h	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/fortran/gfortran.h	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -2450,6 +2450,8 @@
 gfc_expr *gfc_default_initializer (gfc_typespec *);
 gfc_expr *gfc_get_variable_expr (gfc_symtree *);
 
+gfc_array_spec *gfc_get_full_arrayspec_from_expr (gfc_expr *expr);
+
 bool gfc_traverse_expr (gfc_expr *, gfc_symbol *,
 			bool (*)(gfc_expr *, gfc_symbol *, int*),
 			int);
Index: gcc/fortran/ChangeLog
===================================================================
--- gcc/fortran/ChangeLog	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/fortran/ChangeLog	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,3 +1,140 @@
+2010-03-11  Tobias Burnus  <burnus@net-b.de
+
+	PR fortran/43303
+	* symbol.c (get_iso_c_sym): Set sym->result.
+
+2010-02-16  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/41869
+	* module.c (fix_mio_expr): Fix for private generic procedures.
+
+2010-02-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/43030
+	* resolve.c (gfc_resolve_dim_arg): Call gfc_clear_ts.
+
+	PR fortran/43029
+	* decl.c (enumerator_decl): Don't call gfc_free_enum_history
+	here.
+	(gfc_match_enumerator_def): But here whenever enumerator_decl returns
+	MATCH_ERROR.
+
+2010-02-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/42309
+	* trans-expr.c (gfc_conv_subref_array_arg): Avoid accessing
+	info->dimen after info has been freed.
+
+2010-02-06  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/42309
+	* trans-expr.c (gfc_conv_subref_array_arg): Add new argument
+	'formal_ptr'. If this is true, give returned descriptor unity
+	lbounds, in all dimensions, and the appropriate offset.
+	(gfc_conv_procedure_call); If formal is a pointer, set the last
+	argument of gfc_conv_subref_array_arg to true.
+	* trans.h : Add last argument for gfc_conv_subref_array_arg.
+	* trans-io.c (set_internal_unit, gfc_trans_transfer): Set the
+	new arg of gfc_conv_subref_array_arg to false.
+	* trans-stmt.c (forall_make_variable_temp): The same.
+
+2010-02-02  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/42650
+	* parse.c (decode_specification_statement): Use sym->result not sym.
+
+2010-01-31  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/38324
+	* expr.c (gfc_get_full_arrayspec_from_expr): New function.
+	* gfortran.h : Add prototype for above.
+	* trans-expr.c (gfc_trans_alloc_subarray_assign): New function.
+	(gfc_trans_subcomponent_assign): Call new function to replace
+	the code to deal with allocatable components.
+	* trans-intrinsic.c (gfc_conv_intrinsic_bound): Call
+	gfc_get_full_arrayspec_from_expr to replace existing code.
+
+2010-01-30  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/41044
+	PR fortran/41167
+	* expr.c (remove_subobject_ref): If the constructor is NULL use
+	the expression as the source.
+	(simplify_const_ref): Change the type of expression if
+	there are component references.  Allow for substring to be at
+	the end of an arbitrarily long chain of references.  If an
+	element is found that is not in an EXPR_ARRAY, assume that this
+	is scalar initialization of array. Call remove_subobject_ref in
+	this case with NULL second argument.
+
+2010-01-27  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/42736
+	* trans-stmt.c (gfc_conv_elemental_dependencies): If temporary
+	is required, turn any trailing array elements after a range
+	into ranges so that offsets can be calculated.
+
+2010-01-21  Release Manager
+
+	* GCC 4.4.3 released.
+
+2010-01-09  Jakub Jelinek  <jakub@redhat.com>
+
+	* gfortranspec.c (lang_specific_driver): Update copyright notice
+	dates.
+
+2009-11-30  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR fortran/41278
+	Backport from mainline.
+	* trans-array.c (gfc_conv_array_transpose): Delete unnecessary assert.
+	
+2009-11-26  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR fortran/41807
+	Backport from mainline.
+	* trans-const.c (gfc_conv_const): Fix typo in comment. Replace assert
+	with error message if not constant. Set se->expr to a constant on error.
+	* resolve.c (next_data_value): Delete check for constant.
+	
+2009-11-25  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/42162
+	* trans-openmp.c (gfc_trans_omp_do): When dovar isn't a VAR_DECL,
+	don't use simple loop and handle clauses properly.
+
+2009-11-06  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR fortran/41909
+	* resolve.c (is_illegal_recursion): Return false if sym is program.
+
+2009-11-02  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/41772
+	* trans-intrinsic.c (gfc_conv_intrinsic_transfer): Stop'extent'
+	from going negative.
+
+2009-11-01  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/41850
+	* trans-expr.c (gfc_conv_procedure_call): Deallocate intent-out
+	variables only when present.
+
+2009-10-30  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/41777
+	* trans-expr.c (gfc_conv_procedure_call,gfc_conv_expr_reference):
+	Use for generic EXPR_FUNCTION the attributes of the specific
+	function.
+
+2009-10-19  Tobias Burnus  <burnus@net-b.de>
+	    Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/41755
+	* symbol.c (gfc_undo_symbols): Add NULL check.
+	* match.c (gfc_match_equivalence): Add check for
+	missing comma.
+
 2009-10-15  Release Manager
 
 	* GCC 4.4.2 released.
Index: gcc/fortran/trans-const.c
===================================================================
--- gcc/fortran/trans-const.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/fortran/trans-const.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -336,7 +336,7 @@
 gfc_conv_constant (gfc_se * se, gfc_expr * expr)
 {
   /* We may be receiving an expression for C_NULL_PTR or C_NULL_FUNPTR.  If
-     so, they expr_type will not yet be an EXPR_CONSTANT.  We need to make
+     so, the expr_type will not yet be an EXPR_CONSTANT.  We need to make
      it so here.  */
   if (expr->ts.type == BT_DERIVED && expr->ts.derived
       && expr->ts.derived->attr.is_iso_c)
@@ -349,7 +349,12 @@
         }
     }
 
-  gcc_assert (expr->expr_type == EXPR_CONSTANT);
+  if (expr->expr_type != EXPR_CONSTANT)
+    {
+      gfc_error ("non-constant initialization expression at %L", &expr->where);
+      se->expr = gfc_conv_constant_to_tree (gfc_int_expr (0));
+      return;
+    }
 
   if (se->ss != NULL)
     {
Index: gcc/fortran/trans-stmt.c
===================================================================
--- gcc/fortran/trans-stmt.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/fortran/trans-stmt.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -212,6 +212,7 @@
   gfc_ss *ss;
   gfc_ss_info *info;
   gfc_symbol *fsym;
+  gfc_ref *ref;
   int n;
   tree data;
   tree offset;
@@ -267,6 +268,34 @@
 	  /* Obtain the argument descriptor for unpacking.  */
 	  gfc_init_se (&parmse, NULL);
 	  parmse.want_pointer = 1;
+
+	  /* The scalarizer introduces some specific peculiarities when
+	     handling elemental subroutines; the stride can be needed up to
+	     the dim_array - 1, rather than dim_loop - 1 to calculate
+	     offsets outside the loop.  For this reason, we make sure that
+	     the descriptor has the dimensionality of the array by converting
+	     trailing elements into ranges with end = start.  */
+	  for (ref = e->ref; ref; ref = ref->next)
+	    if (ref->type == REF_ARRAY && ref->u.ar.type == AR_SECTION)
+	      break;
+
+	  if (ref)
+	    {
+	      bool seen_range = false;
+	      for (n = 0; n < ref->u.ar.dimen; n++)
+		{
+		  if (ref->u.ar.dimen_type[n] == DIMEN_RANGE)
+		    seen_range = true;
+
+		  if (!seen_range
+			|| ref->u.ar.dimen_type[n] != DIMEN_ELEMENT)
+		    continue;
+
+		  ref->u.ar.end[n] = gfc_copy_expr (ref->u.ar.start[n]);
+		  ref->u.ar.dimen_type[n] = DIMEN_RANGE;
+		}
+	    }
+
 	  gfc_conv_expr_descriptor (&parmse, e, gfc_walk_expr (e));
 	  gfc_add_block_to_block (&se->pre, &parmse.pre);
 
@@ -1691,7 +1720,7 @@
   if (old_sym->attr.dimension)
     {
       gfc_init_se (&tse, NULL);
-      gfc_conv_subref_array_arg (&tse, e, 0, INTENT_IN);
+      gfc_conv_subref_array_arg (&tse, e, 0, INTENT_IN, false);
       gfc_add_block_to_block (pre, &tse.pre);
       gfc_add_block_to_block (post, &tse.post);
       tse.expr = build_fold_indirect_ref (tse.expr);
Index: gcc/fortran/expr.c
===================================================================
--- gcc/fortran/expr.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/fortran/expr.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1123,8 +1123,13 @@
 {
   gfc_expr *e;
 
-  e = cons->expr;
-  cons->expr = NULL;
+  if (cons)
+    {
+      e = cons->expr;
+      cons->expr = NULL;
+    }
+  else
+    e = gfc_copy_expr (p);
   e->ref = p->ref->next;
   p->ref->next =  NULL;
   gfc_replace_expr (p, e);
@@ -1428,6 +1433,7 @@
 {
   gfc_constructor *cons;
   gfc_expr *newp;
+  gfc_ref *last_ref;
 
   while (p->ref)
     {
@@ -1437,6 +1443,13 @@
 	  switch (p->ref->u.ar.type)
 	    {
 	    case AR_ELEMENT:
+	      /* <type/kind spec>, parameter :: x(<int>) = scalar_expr
+		 will generate this.  */
+	      if (p->expr_type != EXPR_ARRAY)
+		{
+		  remove_subobject_ref (p, NULL);
+		  break;
+		}
 	      if (find_array_element (p->value.constructor, &p->ref->u.ar,
 				      &cons) == FAILURE)
 		return FAILURE;
@@ -1466,18 +1479,25 @@
 			return FAILURE;
 		    }
 
-		  /* If this is a CHARACTER array and we possibly took a
-		     substring out of it, update the type-spec's character
-		     length according to the first element (as all should have
-		     the same length).  */
-		  if (p->ts.type == BT_CHARACTER)
+		  if (p->ts.type == BT_DERIVED
+			&& p->ref->next
+			&& p->value.constructor)
 		    {
-		      int string_len;
+		      /* There may have been component references.  */
+		      p->ts = p->value.constructor->expr->ts;
+		    }
 
-		      gcc_assert (p->ref->next);
-		      gcc_assert (!p->ref->next->next);
-		      gcc_assert (p->ref->next->type == REF_SUBSTRING);
+		  last_ref = p->ref;
+		  for (; last_ref->next; last_ref = last_ref->next) {};
 
+		  if (p->ts.type == BT_CHARACTER
+			&& last_ref->type == REF_SUBSTRING)
+		    {
+		      /* If this is a CHARACTER array and we possibly took
+			 a substring out of it, update the type-spec's
+			 character length according to the first element
+			 (as all should have the same length).  */
+		      int string_len;
 		      if (p->value.constructor)
 			{
 			  const gfc_expr* first = p->value.constructor->expr;
@@ -3327,6 +3347,58 @@
 }
 
 
+/* Returns the array_spec of a full array expression.  A NULL is
+   returned otherwise.  */
+gfc_array_spec *
+gfc_get_full_arrayspec_from_expr (gfc_expr *expr)
+{
+  gfc_array_spec *as;
+  gfc_ref *ref;
+
+  if (expr->rank == 0)
+    return NULL;
+
+  /* Follow any component references.  */
+  if (expr->expr_type == EXPR_VARIABLE
+      || expr->expr_type == EXPR_CONSTANT)
+    {
+      as = expr->symtree->n.sym->as;
+      for (ref = expr->ref; ref; ref = ref->next)
+	{
+	  switch (ref->type)
+	    {
+	    case REF_COMPONENT:
+	      as = ref->u.c.component->as;
+	      continue;
+
+	    case REF_SUBSTRING:
+	      continue;
+
+	    case REF_ARRAY:
+	      {
+		switch (ref->u.ar.type)
+		  {
+		  case AR_ELEMENT:
+		  case AR_SECTION:
+		  case AR_UNKNOWN:
+		    as = NULL;
+		    continue;
+
+		  case AR_FULL:
+		    break;
+		  }
+		break;
+	      }
+	    }
+	}
+    }
+  else
+    as = NULL;
+
+  return as;
+}
+
+
 /* General expression traversal function.  */
 
 bool
Index: gcc/fortran/module.c
===================================================================
--- gcc/fortran/module.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/fortran/module.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -2846,13 +2846,29 @@
     }
   else if (e->expr_type == EXPR_FUNCTION && e->value.function.name)
     {
+      gfc_symbol *sym;
+
       /* In some circumstances, a function used in an initialization
 	 expression, in one use associated module, can fail to be
 	 coupled to its symtree when used in a specification
 	 expression in another module.  */
+
       fname = e->value.function.esym ? e->value.function.esym->name
 				     : e->value.function.isym->name;
       e->symtree = gfc_find_symtree (gfc_current_ns->sym_root, fname);
+
+      if (e->symtree)
+	return;
+
+      /* This is probably a reference to a private procedure from another
+	 module.  To prevent a segfault, make a generic with no specific
+	 instances.  If this module is used, without the required
+	 specific coming from somewhere, the appropriate error message
+	 is issued.  */
+      gfc_get_symbol (fname, gfc_current_ns, &sym);
+      sym->attr.flavor = FL_PROCEDURE;
+      sym->attr.generic = 1;
+      e->symtree = gfc_find_symtree (gfc_current_ns->sym_root, fname);
     }
 }
 
Index: gcc/fortran/trans.h
===================================================================
--- gcc/fortran/trans.h	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/fortran/trans.h	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -314,7 +314,7 @@
 int gfc_conv_function_call (gfc_se *, gfc_symbol *, gfc_actual_arglist *,
 			    tree);
 
-void gfc_conv_subref_array_arg (gfc_se *, gfc_expr *, int, sym_intent);
+void gfc_conv_subref_array_arg (gfc_se *, gfc_expr *, int, sym_intent, bool);
 
 /* gfc_trans_* shouldn't call push/poplevel, use gfc_push/pop_scope */
 
Index: gcc/fortran/gfortranspec.c
===================================================================
--- gcc/fortran/gfortranspec.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/fortran/gfortranspec.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,6 +1,6 @@
 /* Specific flags and argument handling of the Fortran front-end.
    Copyright (C) 1997, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
-   2007, 2008, 2009
+   2007, 2008, 2009, 2010
    Free Software Foundation, Inc.
 
 This file is part of GCC.
@@ -379,7 +379,7 @@
 
 	case OPTION_version:
 	  printf ("GNU Fortran %s%s\n", pkgversion_string, version_string);
-	  printf ("Copyright %s 2009 Free Software Foundation, Inc.\n\n",
+	  printf ("Copyright %s 2010 Free Software Foundation, Inc.\n\n",
 		  _("(C)"));
 	  printf (_("GNU Fortran comes with NO WARRANTY, to the extent permitted by law.\n\
 You may redistribute copies of GNU Fortran\n\
Index: gcc/fortran/resolve.c
===================================================================
--- gcc/fortran/resolve.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/fortran/resolve.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,5 +1,5 @@
 /* Perform type resolution on the various structures.
-   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
+   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
    Free Software Foundation, Inc.
    Contributed by Andy Vaught
 
@@ -1100,6 +1100,9 @@
   gfc_symbol* proc_sym;
   gfc_symbol* context_proc;
 
+  if (sym->attr.flavor == FL_PROGRAM)
+    return false;
+
   gcc_assert (sym->attr.flavor == FL_PROCEDURE);
 
   /* If we've got an ENTRY, find real procedure.  */
@@ -3719,6 +3722,7 @@
     {
       gfc_typespec ts;
 
+      gfc_clear_ts (&ts);
       ts.type = BT_INTEGER;
       ts.kind = gfc_index_integer_kind;
 
@@ -9444,10 +9448,6 @@
 {
   while (mpz_cmp_ui (values.left, 0) == 0)
     {
-      if (!gfc_is_constant_expr (values.vnode->expr))
-	gfc_error ("non-constant DATA value at %L",
-		   &values.vnode->expr->where);
-
       if (values.vnode->next == NULL)
 	return FAILURE;
 
Index: gcc/fortran/trans-io.c
===================================================================
--- gcc/fortran/trans-io.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/fortran/trans-io.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -746,7 +746,7 @@
 	  /* Use a temporary for components of arrays of derived types
 	     or substring array references.  */
 	  gfc_conv_subref_array_arg (&se, e, 0,
-		last_dt == READ ? INTENT_IN : INTENT_OUT);
+		last_dt == READ ? INTENT_IN : INTENT_OUT, false);
 	  tmp = build_fold_indirect_ref (se.expr);
 	  se.expr = gfc_build_addr_expr (pchar_type_node, tmp);
 	  tmp = gfc_conv_descriptor_data_get (tmp);
@@ -2191,7 +2191,7 @@
 	  if (seen_vector && last_dt == READ)
 	    {
 	      /* Create a temp, read to that and copy it back.  */
-	      gfc_conv_subref_array_arg (&se, expr, 0, INTENT_OUT);
+	      gfc_conv_subref_array_arg (&se, expr, 0, INTENT_OUT, false);
 	      tmp =  se.expr;
 	    }
 	  else
Index: gcc/fortran/match.c
===================================================================
--- gcc/fortran/match.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/fortran/match.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -3269,7 +3269,10 @@
       if (gfc_match_eos () == MATCH_YES)
 	break;
       if (gfc_match_char (',') != MATCH_YES)
-	goto syntax;
+	{
+	  gfc_error ("Expecting a comma in EQUIVALENCE at %C");
+	  goto cleanup;
+	}
     }
 
   return MATCH_YES;
Index: gcc/fortran/parse.c
===================================================================
--- gcc/fortran/parse.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/fortran/parse.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -110,7 +110,7 @@
   match ("import", gfc_match_import, ST_IMPORT);
   match ("use", gfc_match_use, ST_USE);
 
-  if (gfc_current_block ()->ts.type != BT_DERIVED)
+  if (gfc_current_block ()->result->ts.type != BT_DERIVED)
     goto end_of_block;
 
   match (NULL, gfc_match_st_function, ST_STATEMENT_FUNCTION);
Index: gcc/fortran/check.c
===================================================================
--- gcc/fortran/check.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/fortran/check.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -596,10 +596,8 @@
 
   where = &pointer->where;
 
-  if (pointer->expr_type == EXPR_VARIABLE)
-    attr1 = gfc_variable_attr (pointer, NULL);
-  else if (pointer->expr_type == EXPR_FUNCTION)
-    attr1 = pointer->symtree->n.sym->attr;
+  if (pointer->expr_type == EXPR_VARIABLE || pointer->expr_type == EXPR_FUNCTION)
+    attr1 = gfc_expr_attr (pointer);
   else if (pointer->expr_type == EXPR_NULL)
     goto null_arg;
   else
@@ -621,10 +619,8 @@
   if (target->expr_type == EXPR_NULL)
     goto null_arg;
 
-  if (target->expr_type == EXPR_VARIABLE)
-    attr2 = gfc_variable_attr (target, NULL);
-  else if (target->expr_type == EXPR_FUNCTION)
-    attr2 = target->symtree->n.sym->attr;
+  if (target->expr_type == EXPR_VARIABLE || target->expr_type == EXPR_FUNCTION)
+    attr2 = gfc_expr_attr (target);
   else
     {
       gfc_error ("'%s' argument of '%s' intrinsic at %L must be a pointer "
Index: gcc/fortran/trans-intrinsic.c
===================================================================
--- gcc/fortran/trans-intrinsic.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/fortran/trans-intrinsic.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -832,7 +832,6 @@
   gfc_se argse;
   gfc_ss *ss;
   gfc_array_spec * as;
-  gfc_ref *ref;
 
   arg = expr->value.function.actual;
   arg2 = arg->next;
@@ -901,43 +900,8 @@
   ubound = gfc_conv_descriptor_ubound (desc, bound);
   lbound = gfc_conv_descriptor_lbound (desc, bound);
   
-  /* Follow any component references.  */
-  if (arg->expr->expr_type == EXPR_VARIABLE
-      || arg->expr->expr_type == EXPR_CONSTANT)
-    {
-      as = arg->expr->symtree->n.sym->as;
-      for (ref = arg->expr->ref; ref; ref = ref->next)
-	{
-	  switch (ref->type)
-	    {
-	    case REF_COMPONENT:
-	      as = ref->u.c.component->as;
-	      continue;
+  as = gfc_get_full_arrayspec_from_expr (arg->expr);
 
-	    case REF_SUBSTRING:
-	      continue;
-
-	    case REF_ARRAY:
-	      {
-		switch (ref->u.ar.type)
-		  {
-		  case AR_ELEMENT:
-		  case AR_SECTION:
-		  case AR_UNKNOWN:
-		    as = NULL;
-		    continue;
-
-		  case AR_FULL:
-		    break;
-		  }
-		break;
-	      }
-	    }
-	}
-    }
-  else
-    as = NULL;
-
   /* 13.14.53: Result value for LBOUND
 
      Case (i): For an array section or for an array expression other than a
@@ -3903,6 +3867,8 @@
 scalar_transfer:
   extent = fold_build2 (MIN_EXPR, gfc_array_index_type,
 			dest_word_len, source_bytes);
+  extent = fold_build2 (MAX_EXPR, gfc_array_index_type,
+			extent, gfc_index_zero_node);
 
   if (expr->ts.type == BT_CHARACTER)
     {
Index: gcc/ira-lives.c
===================================================================
--- gcc/ira-lives.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/ira-lives.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -500,7 +500,7 @@
   for (use = 0; use < recog_data.n_operands; use++)
     {
       if (use == def || recog_data.operand_type[use] == OP_OUT)
-	return;
+	continue;
       
       if (recog_op_alt[use][alt].anything_ok)
 	use_cl = ALL_REGS;
@@ -513,7 +513,7 @@
       if ((use_match = recog_op_alt[use][alt].matches) >= 0)
 	{
 	  if (use_match == def)
-	    return;
+	    continue;
 	  
 	  if (recog_op_alt[use_match][alt].anything_ok)
 	    use_cl = ALL_REGS;
Index: gcc/configure.ac
===================================================================
--- gcc/configure.ac	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/configure.ac	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -2297,6 +2297,17 @@
     then echo 1; else echo 0; fi`],
   [Define 0/1 if your assembler supports .cfi_personality.])
 
+gcc_GAS_CHECK_FEATURE([cfi sections directive],
+  gcc_cv_as_cfi_sections_directive, ,,
+[	.text
+	.cfi_sections .debug_frame, .eh_frame
+	.cfi_startproc
+	.cfi_endproc])
+AC_DEFINE_UNQUOTED(HAVE_GAS_CFI_SECTIONS_DIRECTIVE,
+  [`if test $gcc_cv_as_cfi_sections_directive = yes;
+    then echo 1; else echo 0; fi`],
+  [Define 0/1 if your assembler supports .cfi_sections.])
+
 # GAS versions up to and including 2.11.0 may mis-optimize
 # .eh_frame data.
 gcc_GAS_CHECK_FEATURE(eh_frame optimization, gcc_cv_as_eh_frame,
Index: gcc/BASE-VER
===================================================================
--- gcc/BASE-VER	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/BASE-VER	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1 +1 @@
-4.4.2
+4.4.4
Index: gcc/function.c
===================================================================
--- gcc/function.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/function.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -4274,12 +4274,8 @@
   tree guard_decl = targetm.stack_protect_guard ();
   rtx x, y;
 
-  /* Avoid expand_expr here, because we don't want guard_decl pulled
-     into registers unless absolutely necessary.  And we know that
-     crtl->stack_protect_guard is a local stack slot, so this skips
-     all the fluff.  */
-  x = validize_mem (DECL_RTL (crtl->stack_protect_guard));
-  y = validize_mem (DECL_RTL (guard_decl));
+  x = expand_normal (crtl->stack_protect_guard);
+  y = expand_normal (guard_decl);
 
   /* Allow the target to copy from Y to X without leaking Y into a
      register.  */
@@ -4312,12 +4308,8 @@
   rtx label = gen_label_rtx ();
   rtx x, y, tmp;
 
-  /* Avoid expand_expr here, because we don't want guard_decl pulled
-     into registers unless absolutely necessary.  And we know that
-     crtl->stack_protect_guard is a local stack slot, so this skips
-     all the fluff.  */
-  x = validize_mem (DECL_RTL (crtl->stack_protect_guard));
-  y = validize_mem (DECL_RTL (guard_decl));
+  x = expand_normal (crtl->stack_protect_guard);
+  y = expand_normal (guard_decl);
 
   /* Allow the target to compare Y with X without leaking either into
      a register.  */
Index: gcc/sdbout.c
===================================================================
--- gcc/sdbout.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/sdbout.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -307,6 +307,7 @@
 {
   sdbout_init,			         /* init */
   sdbout_finish,		         /* finish */
+  debug_nothing_void,			 /* assembly_start */
   debug_nothing_int_charstar,	         /* define */
   debug_nothing_int_charstar,	         /* undef */
   sdbout_start_source_file,	         /* start_source_file */
Index: gcc/tree-vect-analyze.c
===================================================================
--- gcc/tree-vect-analyze.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/tree-vect-analyze.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -3213,6 +3213,7 @@
 {
   int i = 0, j, prev = -1, next, k;
   bool supported;
+  sbitmap load_index;
 
   /* FORNOW: permutations are only supported for loop-aware SLP.  */
   if (!slp_instn)
@@ -3233,6 +3234,8 @@
     return false;
 
   supported = true;
+  load_index = sbitmap_alloc (group_size);
+  sbitmap_zero (load_index); 
   for (j = 0; j < group_size; j++)
     {
       for (i = j * group_size, k = 0;
@@ -3246,9 +3249,19 @@
           }
 
          prev = next;
-       }  
+       } 
+
+      if (TEST_BIT (load_index, prev))
+        {
+          supported = false;
+          break;
+        }
+
+      SET_BIT (load_index, prev);
     }
 
+  sbitmap_free (load_index);
+
   if (supported && i == group_size * group_size
       && vect_supported_slp_permutation_p (slp_instn))
     return true;
@@ -3495,7 +3508,9 @@
       FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, gimple_op (stmt, 0))
 	if (vinfo_for_stmt (use_stmt)
 	    && !STMT_SLP_TYPE (vinfo_for_stmt (use_stmt))
-            && STMT_VINFO_RELEVANT (vinfo_for_stmt (use_stmt)))
+            && (STMT_VINFO_RELEVANT (vinfo_for_stmt (use_stmt))
+                || STMT_VINFO_DEF_TYPE (vinfo_for_stmt (use_stmt)) 
+                    == vect_reduction_def))
 	  vect_mark_slp_stmts (node, hybrid, i);
 
   vect_detect_hybrid_slp_stmts (SLP_TREE_LEFT (node));
Index: gcc/c-typeck.c
===================================================================
--- gcc/c-typeck.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/c-typeck.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -2527,6 +2527,7 @@
 {
   tree typetail, valtail;
   int parmnum;
+  bool error_args = false;
   const bool type_generic = fundecl
     && lookup_attribute ("type generic", TYPE_ATTRIBUTES(TREE_TYPE (fundecl)));
   tree selector;
@@ -2737,6 +2738,9 @@
 	/* Convert `short' and `char' to full-size `int'.  */
 	argarray[parmnum] = default_conversion (val);
 
+      if (argarray[parmnum] == error_mark_node)
+	error_args = true;
+
       if (typetail)
 	typetail = TREE_CHAIN (typetail);
     }
@@ -2749,7 +2753,7 @@
       return -1;
     }
 
-  return parmnum;
+  return error_args ? -1 : parmnum;
 }
 
 /* This is the entry point used by the parser to build unary operators
Index: gcc/gimplify.c
===================================================================
--- gcc/gimplify.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/gimplify.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,6 +1,6 @@
 /* Tree lowering pass.  This pass converts the GENERIC functions-as-trees
    tree representation into the GIMPLE form.
-   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
    Free Software Foundation, Inc.
    Major work done by Sebastian Pop <s.pop@laposte.net>,
    Diego Novillo <dnovillo@redhat.com> and Jason Merrill <jason@redhat.com>.
@@ -2762,6 +2762,32 @@
 {
   tree type = TREE_TYPE (expr);
 
+  if (TREE_CODE (expr) == NE_EXPR
+      && TREE_CODE (TREE_OPERAND (expr, 0)) == CALL_EXPR
+      && integer_zerop (TREE_OPERAND (expr, 1)))
+    {
+      tree call = TREE_OPERAND (expr, 0);
+      tree fn = get_callee_fndecl (call);
+
+      /* For __builtin_expect ((long) (x), y) recurse into x as well.  */
+      if (fn
+	  && DECL_BUILT_IN_CLASS (fn) == BUILT_IN_NORMAL
+	  && DECL_FUNCTION_CODE (fn) == BUILT_IN_EXPECT
+	  && call_expr_nargs (call) == 2)
+	{
+	  tree arg = CALL_EXPR_ARG (call, 0);
+	  if (arg)
+	    {
+	      if (TREE_CODE (arg) == NOP_EXPR
+		  && TREE_TYPE (arg) == TREE_TYPE (call))
+		arg = TREE_OPERAND (arg, 0);
+	      arg = gimple_boolify (arg);
+	      CALL_EXPR_ARG (call, 0)
+		= fold_convert (TREE_TYPE (call), arg);
+	    }
+	}
+    }
+
   if (TREE_CODE (type) == BOOLEAN_TYPE)
     return expr;
 
@@ -3684,6 +3710,21 @@
 	      }
 	  }
 
+	/* If the target is volatile and we have non-zero elements
+	   initialize the target from a temporary.  */
+	if (TREE_THIS_VOLATILE (object)
+	    && !TREE_ADDRESSABLE (type)
+	    && num_nonzero_elements > 0)
+	  {
+	    tree temp = create_tmp_var (TYPE_MAIN_VARIANT (type), NULL);
+	    TREE_OPERAND (*expr_p, 0) = temp;
+	    *expr_p = build2 (COMPOUND_EXPR, TREE_TYPE (*expr_p),
+			      *expr_p,
+			      build2 (MODIFY_EXPR, void_type_node,
+				      object, temp));
+	    return GS_OK;
+	  }
+
 	if (notify_temp_creation)
 	  return GS_OK;
 
@@ -3931,11 +3972,14 @@
     switch (TREE_CODE (*from_p))
       {
       case VAR_DECL:
-	/* If we're assigning from a constant constructor, move the
-	   constructor expression to the RHS of the MODIFY_EXPR.  */
+	/* If we're assigning from a read-only variable initialized with
+	   a constructor, do the direct assignment from the constructor,
+	   but only if neither source nor target are volatile since this
+	   latter assignment might end up being done on a per-field basis.  */
 	if (DECL_INITIAL (*from_p)
 	    && TREE_READONLY (*from_p)
 	    && !TREE_THIS_VOLATILE (*from_p)
+	    && !TREE_THIS_VOLATILE (*to_p)
 	    && TREE_CODE (DECL_INITIAL (*from_p)) == CONSTRUCTOR)
 	  {
 	    tree old_from = *from_p;
@@ -6134,6 +6178,8 @@
   tree tmp_load;
 
    tmp_load = create_tmp_var (type, NULL);
+   if (TREE_CODE (type) == COMPLEX_TYPE || TREE_CODE (type) == VECTOR_TYPE)
+     DECL_GIMPLE_REG_P (tmp_load) = 1;
    if (goa_stabilize_expr (&rhs, pre_p, addr, tmp_load) < 0)
      return GS_ERROR;
 
Index: gcc/c-pragma.c
===================================================================
--- gcc/c-pragma.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/c-pragma.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -244,146 +244,6 @@
 }
 #endif  /* HANDLE_PRAGMA_PACK */
 
-struct def_pragma_macro_value GTY(())
-{
-  struct def_pragma_macro_value *prev;
-  cpp_macro *value;
-};
-
-struct def_pragma_macro GTY(())
-{
-  hashval_t hash;
-  const char *name;
-  struct def_pragma_macro_value value;
-};
-
-static GTY((param_is (struct def_pragma_macro))) htab_t pushed_macro_table;
-
-#ifdef HANDLE_PRAGMA_PUSH_POP_MACRO
-/* Hash table control functions for pushed_macro_table.  */
-static hashval_t
-dpm_hash (const void *p)
-{
-  return ((const struct def_pragma_macro *)p)->hash;
-}
-
-static int
-dpm_eq (const void *pa, const void *pb)
-{
-  const struct def_pragma_macro *const a = (const struct def_pragma_macro *) pa,
-    *const b = (const struct def_pragma_macro *) pb;
-  return a->hash == b->hash && strcmp (a->name, b->name) == 0;
-}
-
-/* #pragma push_macro("MACRO_NAME")
-   #pragma pop_macro("MACRO_NAME") */
-
-static void
-handle_pragma_push_macro (cpp_reader *reader)
-{
-  tree x, id = 0;
-  enum cpp_ttype token;
-  struct def_pragma_macro dummy, *c;
-  const char *macroname;
-  void **slot;
-
-  if (pragma_lex (&x) != CPP_OPEN_PAREN)
-    GCC_BAD ("missing %<(%> after %<#pragma push_macro%> - ignored");
-
-  token = pragma_lex (&id);
-
-  /* Silently ignore */
-  if (token == CPP_CLOSE_PAREN)
-    return;
-  if (token != CPP_STRING)
-    GCC_BAD ("invalid constant in %<#pragma push_macro%> - ignored");
-
-  if (pragma_lex (&x) != CPP_CLOSE_PAREN)
-    GCC_BAD ("missing %<)%> after %<#pragma push_macro%> - ignored");
-
-  if (pragma_lex (&x) != CPP_EOF)
-    warning (OPT_Wpragmas, "junk at end of %<#pragma push_macro%>");
-
-  /* Check for empty string, and silently ignore.  */
-  if (TREE_STRING_LENGTH (id) < 1)
-    return;
-  macroname = TREE_STRING_POINTER (id);
-
-  if (pushed_macro_table == NULL)
-    pushed_macro_table = htab_create_ggc (15, dpm_hash, dpm_eq, 0);
-
-  dummy.hash = htab_hash_string (macroname);
-  dummy.name = macroname;
-  slot = htab_find_slot_with_hash (pushed_macro_table, &dummy,
-				   dummy.hash, INSERT);
-  c = (struct def_pragma_macro *) *slot;
-  if (c == NULL)
-    {
-      *slot = c = GGC_NEW (struct def_pragma_macro);
-      c->hash = dummy.hash;
-      c->name = ggc_alloc_string (macroname, TREE_STRING_LENGTH (id) - 1);
-      c->value.prev = NULL;
-    }
-  else
-    {
-      struct def_pragma_macro_value *v;
-      v = GGC_NEW (struct def_pragma_macro_value);
-      *v = c->value;
-      c->value.prev = v;
-    }
-
-  c->value.value = cpp_push_definition (reader, macroname);
-}
-
-static void
-handle_pragma_pop_macro (cpp_reader *reader)
-{
-  tree x, id = 0;
-  enum cpp_ttype token;
-  struct def_pragma_macro dummy, *c;
-  const char *macroname;
-  void **slot = NULL;
-
-  if (pragma_lex (&x) != CPP_OPEN_PAREN)
-    GCC_BAD ("missing %<(%> after %<#pragma pop_macro%> - ignored");
-
-  token = pragma_lex (&id);
-
-  /* Silently ignore */
-  if (token == CPP_CLOSE_PAREN)
-    return;
-  if (token != CPP_STRING)
-    GCC_BAD ("invalid constant in %<#pragma pop_macro%> - ignored");
-
-  if (pragma_lex (&x) != CPP_CLOSE_PAREN)
-    GCC_BAD ("missing %<)%> after %<#pragma pop_macro%> - ignored");
-
-  if (pragma_lex (&x) != CPP_EOF)
-    warning (OPT_Wpragmas, "junk at end of %<#pragma pop_macro%>");
-
-  /* Check for empty string, and silently ignore.  */
-  if (TREE_STRING_LENGTH (id) < 1)
-    return;
-  macroname = TREE_STRING_POINTER (id);
-
-  dummy.hash = htab_hash_string (macroname);
-  dummy.name = macroname;
-  if (pushed_macro_table)
-    slot = htab_find_slot_with_hash (pushed_macro_table, &dummy,
-				     dummy.hash, NO_INSERT);
-  if (slot == NULL)
-    return;
-  c = (struct def_pragma_macro *) *slot;
-
-  cpp_pop_definition (reader, c->name, c->value.value);
-
-  if (c->value.prev)
-    c->value = *c->value.prev;
-  else
-    htab_clear_slot (pushed_macro_table, slot);
-}
-#endif /* HANDLE_PRAGMA_PUSH_POP_MACRO */
-
 static GTY(()) tree pending_weaks;
 
 #ifdef HANDLE_PRAGMA_WEAK
@@ -1316,10 +1176,6 @@
   c_register_pragma (0, "pack", handle_pragma_pack);
 #endif
 #endif
-#ifdef HANDLE_PRAGMA_PUSH_POP_MACRO
-  c_register_pragma (0 ,"push_macro", handle_pragma_push_macro);
-  c_register_pragma (0 ,"pop_macro", handle_pragma_pop_macro);
-#endif
 #ifdef HANDLE_PRAGMA_WEAK
   c_register_pragma (0, "weak", handle_pragma_weak);
 #endif
Index: gcc/loop-doloop.c
===================================================================
--- gcc/loop-doloop.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/loop-doloop.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,5 +1,5 @@
 /* Perform doloop optimizations
-   Copyright (C) 2004, 2005, 2006, 2007, 2008 Free Software Foundation,
+   Copyright (C) 2004, 2005, 2006, 2007, 2008, 2010 Free Software Foundation,
    Inc.
    Based on code by Michael P. Hayes (m.hayes@elec.canterbury.ac.nz)
 
@@ -291,7 +291,8 @@
   op0 = force_operand (op0, NULL_RTX);
   op1 = force_operand (op1, NULL_RTX);
   label = block_label (dest);
-  do_compare_rtx_and_jump (op0, op1, code, 0, mode, NULL_RTX, NULL_RTX, label);
+  do_compare_rtx_and_jump (op0, op1, code, 0, mode, NULL_RTX,
+			   NULL_RTX, label, -1);
 
   jump = get_last_insn ();
   if (!jump || !JUMP_P (jump))
Index: gcc/expmed.c
===================================================================
--- gcc/expmed.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/expmed.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,7 +1,7 @@
 /* Medium-level subroutines: convert bit-field store and extract
    and shifts, multiplies and divides to rtl instructions.
    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
    Free Software Foundation, Inc.
 
 This file is part of GCC.
@@ -4121,7 +4121,8 @@
 		else if (d == -1)
 		  quotient = expand_unop (compute_mode, neg_optab, op0,
 					  tquotient, 0);
-		else if (abs_d == (unsigned HOST_WIDE_INT) 1 << (size - 1))
+		else if (HOST_BITS_PER_WIDE_INT >= size
+			 && abs_d == (unsigned HOST_WIDE_INT) 1 << (size - 1))
 		  {
 		    /* This case is not handled correctly below.  */
 		    quotient = emit_store_flag (tquotient, EQ, op0, op1,
@@ -5607,7 +5608,7 @@
   emit_move_insn (target, const1_rtx);
   label = gen_label_rtx ();
   do_compare_rtx_and_jump (op0, op1, code, unsignedp, mode, NULL_RTX,
-			   NULL_RTX, label);
+			   NULL_RTX, label, -1);
 
   emit_move_insn (target, const0_rtx);
   emit_label (label);
@@ -5625,5 +5626,5 @@
 {
   int unsignedp = (op == LTU || op == LEU || op == GTU || op == GEU);
   do_compare_rtx_and_jump (arg1, arg2, op, unsignedp, mode,
-			   NULL_RTX, NULL_RTX, label);
+			   NULL_RTX, NULL_RTX, label, -1);
 }
Index: gcc/except.c
===================================================================
--- gcc/except.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/except.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,6 +1,6 @@
 /* Implements exception handling.
    Copyright (C) 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
    Free Software Foundation, Inc.
    Contributed by Mike Stump <mrs@cygnus.com>.
 
@@ -1834,7 +1834,7 @@
 
 #ifdef DONT_USE_BUILTIN_SETJMP
   {
-    rtx x;
+    rtx x, last;
     x = emit_library_call_value (setjmp_libfunc, NULL_RTX, LCT_RETURNS_TWICE,
 				 TYPE_MODE (integer_type_node), 1,
 				 plus_constant (XEXP (fc, 0),
@@ -1842,7 +1842,12 @@
 
     emit_cmp_and_jump_insns (x, const0_rtx, NE, 0,
 			     TYPE_MODE (integer_type_node), 0, dispatch_label);
-    add_reg_br_prob_note (get_insns (), REG_BR_PROB_BASE/100);
+    last = get_last_insn ();
+    if (JUMP_P (last) && any_condjump_p (last))
+      {
+        gcc_assert (!find_reg_note (last, REG_BR_PROB, 0));
+        add_reg_note (last, REG_BR_PROB, GEN_INT (REG_BR_PROB_BASE / 100));
+      }
   }
 #else
   expand_builtin_setjmp_setup (plus_constant (XEXP (fc, 0), sjlj_fc_jbuf_ofs),
Index: gcc/cfgexpand.c
===================================================================
--- gcc/cfgexpand.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/cfgexpand.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,5 +1,5 @@
 /* A pass for lowering trees to RTL.
-   Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009
+   Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010
    Free Software Foundation, Inc.
 
 This file is part of GCC.
@@ -379,46 +379,6 @@
 }
 
 
-/* Verify that there is exactly single jump instruction since last and attach
-   REG_BR_PROB note specifying probability.
-   ??? We really ought to pass the probability down to RTL expanders and let it
-   re-distribute it when the conditional expands into multiple conditionals.
-   This is however difficult to do.  */
-void
-add_reg_br_prob_note (rtx last, int probability)
-{
-  if (profile_status == PROFILE_ABSENT)
-    return;
-  for (last = NEXT_INSN (last); last && NEXT_INSN (last); last = NEXT_INSN (last))
-    if (JUMP_P (last))
-      {
-	/* It is common to emit condjump-around-jump sequence when we don't know
-	   how to reverse the conditional.  Special case this.  */
-	if (!any_condjump_p (last)
-	    || !JUMP_P (NEXT_INSN (last))
-	    || !simplejump_p (NEXT_INSN (last))
-	    || !NEXT_INSN (NEXT_INSN (last))
-	    || !BARRIER_P (NEXT_INSN (NEXT_INSN (last)))
-	    || !NEXT_INSN (NEXT_INSN (NEXT_INSN (last)))
-	    || !LABEL_P (NEXT_INSN (NEXT_INSN (NEXT_INSN (last))))
-	    || NEXT_INSN (NEXT_INSN (NEXT_INSN (NEXT_INSN (last)))))
-	  goto failed;
-	gcc_assert (!find_reg_note (last, REG_BR_PROB, 0));
-	add_reg_note (last, REG_BR_PROB,
-		      GEN_INT (REG_BR_PROB_BASE - probability));
-	return;
-      }
-  if (!last || !JUMP_P (last) || !any_condjump_p (last))
-    goto failed;
-  gcc_assert (!find_reg_note (last, REG_BR_PROB, 0));
-  add_reg_note (last, REG_BR_PROB, GEN_INT (probability));
-  return;
-failed:
-  if (dump_file)
-    fprintf (dump_file, "Failed to add probability note\n");
-}
-
-
 #ifndef STACK_ALIGNMENT_NEEDED
 #define STACK_ALIGNMENT_NEEDED 1
 #endif
@@ -1116,6 +1076,14 @@
       if (really_expand)
         expand_one_register_var (var);
     }
+  else if (!host_integerp (DECL_SIZE_UNIT (var), 1))
+    {
+      if (really_expand)
+	{
+	  error ("size of variable %q+D is too large", var);
+	  expand_one_error_var (var);
+	}
+    }
   else if (defer_stack_allocation (var, toplevel))
     add_stack_var (var);
   else
@@ -1661,8 +1629,8 @@
      two-way jump that needs to be decomposed into two basic blocks.  */
   if (false_edge->dest == bb->next_bb)
     {
-      jumpif (pred, label_rtx_for_bb (true_edge->dest));
-      add_reg_br_prob_note (last, true_edge->probability);
+      jumpif (pred, label_rtx_for_bb (true_edge->dest),
+	      true_edge->probability);
       maybe_dump_rtl_for_gimple_stmt (stmt, last);
       if (true_edge->goto_locus)
 	{
@@ -1677,8 +1645,8 @@
     }
   if (true_edge->dest == bb->next_bb)
     {
-      jumpifnot (pred, label_rtx_for_bb (false_edge->dest));
-      add_reg_br_prob_note (last, false_edge->probability);
+      jumpifnot (pred, label_rtx_for_bb (false_edge->dest),
+		 false_edge->probability);
       maybe_dump_rtl_for_gimple_stmt (stmt, last);
       if (false_edge->goto_locus)
 	{
@@ -1692,8 +1660,7 @@
       return NULL;
     }
 
-  jumpif (pred, label_rtx_for_bb (true_edge->dest));
-  add_reg_br_prob_note (last, true_edge->probability);
+  jumpif (pred, label_rtx_for_bb (true_edge->dest), true_edge->probability);
   last = get_last_insn ();
   if (false_edge->goto_locus)
     {
Index: gcc/tree-cfgcleanup.c
===================================================================
--- gcc/tree-cfgcleanup.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/tree-cfgcleanup.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,5 +1,5 @@
 /* CFG cleanup for trees.
-   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
+   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
    Free Software Foundation, Inc.
 
 This file is part of GCC.
@@ -517,7 +517,7 @@
   control_bb = single_pred (bb);
   stmt = last_stmt (control_bb);
 
-  if (gimple_code (stmt) != GIMPLE_OMP_SECTIONS_SWITCH)
+  if (stmt == NULL || gimple_code (stmt) != GIMPLE_OMP_SECTIONS_SWITCH)
     return false;
 
   /* The block with the control statement normally has two entry edges -- one
Index: gcc/tree-ssa-pre.c
===================================================================
--- gcc/tree-ssa-pre.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/tree-ssa-pre.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -453,9 +453,6 @@
    cleaned up.  */
 static bitmap need_eh_cleanup;
 
-/* Which expressions have been seen during a given phi translation.  */
-static bitmap seen_during_translate;
-
 /* The phi_translate_table caches phi translations for a given
    expression and predecessor.  */
 
@@ -1400,14 +1397,12 @@
 
 
 /* Translate EXPR using phis in PHIBLOCK, so that it has the values of
-   the phis in PRED.  SEEN is a bitmap saying which expression we have
-   translated since we started translation of the toplevel expression.
-   Return NULL if we can't find a leader for each part of the
-   translated expression.  */
+   the phis in PRED.  Return NULL if we can't find a leader for each part
+   of the translated expression.  */
 
 static pre_expr
-phi_translate_1 (pre_expr expr, bitmap_set_t set1, bitmap_set_t set2,
-		 basic_block pred, basic_block phiblock, bitmap seen)
+phi_translate (pre_expr expr, bitmap_set_t set1, bitmap_set_t set2,
+	       basic_block pred, basic_block phiblock)
 {
   pre_expr oldexpr = expr;
   pre_expr phitrans;
@@ -1422,16 +1417,6 @@
   if (phitrans)
     return phitrans;
 
-  /* Prevent cycles when we have recursively dependent leaders.  This
-     can only happen when phi translating the maximal set.  */
-  if (seen)
-    {
-      unsigned int expr_id = get_expression_id (expr);
-      if (bitmap_bit_p (seen, expr_id))
-	return NULL;
-      bitmap_set_bit (seen, expr_id);
-    }
-
   switch (expr->kind)
     {
       /* Constants contain no values that need translation.  */
@@ -1455,10 +1440,10 @@
 	      continue;
 	    else
 	      {
+                pre_expr leader, result;
 		unsigned int op_val_id = VN_INFO (newnary.op[i])->value_id;
-		pre_expr leader = find_leader_in_sets (op_val_id, set1, set2);
-		pre_expr result = phi_translate_1 (leader, set1, set2,
-						   pred, phiblock, seen);
+		leader = find_leader_in_sets (op_val_id, set1, set2);
+                result = phi_translate (leader, set1, set2, pred, phiblock);
 		if (result && result != leader)
 		  {
 		    tree name = get_representative_for (result);
@@ -1559,8 +1544,7 @@
 	      {
 		unsigned int op_val_id = VN_INFO (op0)->value_id;
 		leader = find_leader_in_sets (op_val_id, set1, set2);
-		opresult = phi_translate_1 (leader, set1, set2,
-					    pred, phiblock, seen);
+		opresult = phi_translate (leader, set1, set2, pred, phiblock);
 		if (opresult && opresult != leader)
 		  {
 		    tree name = get_representative_for (opresult);
@@ -1577,8 +1561,7 @@
 	      {
 		unsigned int op_val_id = VN_INFO (op1)->value_id;
 		leader = find_leader_in_sets (op_val_id, set1, set2);
-		opresult = phi_translate_1 (leader, set1, set2,
-					    pred, phiblock, seen);
+		opresult = phi_translate (leader, set1, set2, pred, phiblock);
 		if (opresult && opresult != leader)
 		  {
 		    tree name = get_representative_for (opresult);
@@ -1594,8 +1577,7 @@
 	      {
 		unsigned int op_val_id = VN_INFO (op2)->value_id;
 		leader = find_leader_in_sets (op_val_id, set1, set2);
-		opresult = phi_translate_1 (leader, set1, set2,
-					    pred, phiblock, seen);
+		opresult = phi_translate (leader, set1, set2, pred, phiblock);
 		if (opresult && opresult != leader)
 		  {
 		    tree name = get_representative_for (opresult);
@@ -1724,20 +1706,6 @@
     }
 }
 
-/* Translate EXPR using phis in PHIBLOCK, so that it has the values of
-   the phis in PRED.
-   Return NULL if we can't find a leader for each part of the
-   translated expression.  */
-
-static pre_expr
-phi_translate (pre_expr expr, bitmap_set_t set1, bitmap_set_t set2,
-	       basic_block pred, basic_block phiblock)
-{
-  bitmap_clear (seen_during_translate);
-  return phi_translate_1 (expr, set1, set2, pred, phiblock,
-			  seen_during_translate);
-}
-
 /* For each expression in SET, translate the values through phi nodes
    in PHIBLOCK using edge PHIBLOCK->PRED, and store the resulting
    expressions in DEST.  */
@@ -1750,7 +1718,7 @@
   pre_expr expr;
   int i;
 
-  if (!phi_nodes (phiblock))
+  if (gimple_seq_empty_p (phi_nodes (phiblock)))
     {
       bitmap_set_copy (dest, set);
       return;
@@ -1763,10 +1731,18 @@
       translated = phi_translate (expr, set, NULL, pred, phiblock);
 
       /* Don't add empty translations to the cache  */
-      if (translated)
-	phi_trans_add (expr, translated, pred);
+      if (!translated)
+	continue;
 
-      if (translated != NULL)
+      phi_trans_add (expr, translated, pred);
+
+      /* We might end up with multiple expressions from SET being
+	 translated to the same value.  In this case we do not want
+	 to retain the NARY or REFERENCE expression but prefer a NAME
+	 which would be the leader.  */
+      if (translated->kind == NAME)
+	bitmap_value_replace_in_set (dest, translated);
+      else
 	bitmap_value_insert_into_set (dest, translated);
     }
   VEC_free (pre_expr, heap, exprs);
@@ -2132,14 +2108,14 @@
 	  goto maybe_dump_sets;
 	}
 
-      if (phi_nodes (first))
+      if (!gimple_seq_empty_p (phi_nodes (first)))
 	phi_translate_set (ANTIC_OUT, ANTIC_IN (first), block, first);
       else
 	bitmap_set_copy (ANTIC_OUT, ANTIC_IN (first));
 
       for (i = 0; VEC_iterate (basic_block, worklist, i, bprime); i++)
 	{
-	  if (phi_nodes (bprime))
+	  if (!gimple_seq_empty_p (phi_nodes (bprime)))
 	    {
 	      bitmap_set_t tmp = bitmap_set_new ();
 	      phi_translate_set (tmp, ANTIC_IN (bprime), block, bprime);
@@ -2289,7 +2265,7 @@
 	      FOR_EACH_EXPR_ID_IN_SET (ANTIC_IN (bprime), i, bi)
 		bitmap_value_insert_into_set (PA_OUT,
 					      expression_for_id (i));
-	      if (phi_nodes (bprime))
+	      if (!gimple_seq_empty_p (phi_nodes (bprime)))
 		{
 		  bitmap_set_t pa_in = bitmap_set_new ();
 		  phi_translate_set (pa_in, PA_IN (bprime), block, bprime);
@@ -4146,7 +4122,6 @@
   expression_to_id = htab_create (num_ssa_names * 3,
 				  pre_expr_hash,
 				  pre_expr_eq, NULL);
-  seen_during_translate = BITMAP_ALLOC (&grand_bitmap_obstack);
   bitmap_set_pool = create_alloc_pool ("Bitmap sets",
 				       sizeof (struct bitmap_set), 30);
   pre_expr_pool = create_alloc_pool ("pre_expr nodes",
Index: gcc/simplify-rtx.c
===================================================================
--- gcc/simplify-rtx.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/simplify-rtx.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,6 +1,6 @@
 /* RTL simplification functions for GNU compiler.
    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
    Free Software Foundation, Inc.
 
 This file is part of GCC.
@@ -3863,7 +3863,8 @@
       && rtx_equal_p (op1, XEXP (op0, 1))
       /* Don't recurse "infinitely" for (LTU/GEU (PLUS b b) b).  */
       && !rtx_equal_p (op1, XEXP (op0, 0)))
-    return simplify_gen_relational (code, mode, cmp_mode, op0, XEXP (op0, 0));
+    return simplify_gen_relational (code, mode, cmp_mode, op0,
+				    copy_rtx (XEXP (op0, 0)));
 
   if (op1 == const0_rtx)
     {
Index: gcc/po/ChangeLog
===================================================================
--- gcc/po/ChangeLog	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/po/ChangeLog	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,3 +1,11 @@
+2010-01-21  Release Manager
+
+	* GCC 4.4.3 released.
+
+2009-11-10  Joseph Myers  <joseph@codesourcery.com>
+
+	* id.po: Update.
+
 2009-10-15  Release Manager
 
 	* GCC 4.4.2 released.
Index: gcc/po/id.po
===================================================================
--- gcc/po/id.po	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/po/id.po	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,14 +1,14 @@
 # Pesan Bahasa Indonesia untuk GCC
 # Copyright (C) 2008 Free Software Foundation, Inc.
 # This file is distributed under the same license as the gcc package.
-# Arif E. Nugroho <arif_endro@yahoo.com>, 2008.
+# Arif E. Nugroho <arif_endro@yahoo.com>, 2008, 2009.
 #
 msgid ""
 msgstr ""
-"Project-Id-Version: gcc 4.4-b20081121\n"
+"Project-Id-Version: gcc 4.4.1\n"
 "Report-Msgid-Bugs-To: http://gcc.gnu.org/bugs.html\n"
 "POT-Creation-Date: 2009-07-15 13:37+0200\n"
-"PO-Revision-Date: 2008-11-30 09:00+0700\n"
+"PO-Revision-Date: 2009-11-10 09:00+0700\n"
 "Last-Translator: Arif E. Nugroho <arif_endro@yahoo.com>\n"
 "Language-Team: Indonesian <translation-team-id@lists.sourceforge.net>\n"
 "MIME-Version: 1.0\n"
@@ -628,7 +628,7 @@
 #: cppspec.c:106
 #, c-format
 msgid "\"%s\" is not a valid option to the preprocessor"
-msgstr "\"%s\" bukan sebuah opsi valid untuk preprosesor"
+msgstr "\"%s\" bukan sebuah pilihan valid untuk preprosesor"
 
 #: cppspec.c:128
 #, c-format
@@ -850,11 +850,11 @@
 #: gcc.c:3225
 #, c-format
 msgid "Usage: %s [options] file...\n"
-msgstr "Penggunaan: %s [opsi] berkas...\n"
+msgstr "Penggunaan: %s [pilihan] berkas...\n"
 
 #: gcc.c:3226
 msgid "Options:\n"
-msgstr "Opsi:\n"
+msgstr "Pilihan:\n"
 
 #: gcc.c:3228
 msgid "  -pass-exit-codes         Exit with highest error code from a phase\n"
@@ -866,25 +866,23 @@
 
 #: gcc.c:3230
 msgid "  --target-help            Display target specific command line options\n"
-msgstr "  --target-help            Tampilkan target spesifik opsi baris perintah\n"
+msgstr "  --target-help            Tampilkan target spesifik pilihan baris perintah\n"
 
 #: gcc.c:3231
-#, fuzzy
 msgid "  --help={target|optimizers|warnings|params|[^]{joined|separate|undocumented}}[,...]\n"
-msgstr "  --help={target|optimisasi|peringatan|tidak terdokumentasi|parameter}[,{[^]tergabung|[^]dipisahkan}]\n"
+msgstr "  --help={target|optimisasi|peringatan|parameter|[^]{tergabung|dipisahkan|tidak terdokumentasi}}[,...]\n"
 
 #: gcc.c:3232
 msgid "                           Display specific types of command line options\n"
-msgstr "                           Tampilkan tipe spesifik dari opsi baris perintah\n"
+msgstr "                           Tampilkan tipe spesifik dari pilihan baris perintah\n"
 
 #: gcc.c:3234
 msgid "  (Use '-v --help' to display command line options of sub-processes)\n"
-msgstr "  (Gunakan '-v --help' untuk menampilkan opsi baris perintah dari sub-proses)\n"
+msgstr "  (Gunakan '-v --help' untuk menampilkan pilihan baris perintah dari sub-proses)\n"
 
 #: gcc.c:3235
-#, fuzzy
 msgid "  --version                Display compiler version information\n"
-msgstr "  --help                   Tampilkan informasi ini\n"
+msgstr "  --version                Tampilkan informasi versi penyusun\n"
 
 #: gcc.c:3236
 msgid "  -dumpspecs               Display all of the built in spec strings\n"
@@ -923,7 +921,7 @@
 "  -print-multi-lib         Display the mapping between command line options and\n"
 "                           multiple library search directories\n"
 msgstr ""
-"  -print-multi-lib         Tampilkan pemetaan diantara opsi baris perintah dan\n"
+"  -print-multi-lib         Tampilkan pemetaan diantara pilihan baris perintah dan\n"
 "                           multiple pencarian direktori perpustakaan\n"
 
 #: gcc.c:3247
@@ -940,15 +938,15 @@
 
 #: gcc.c:3250
 msgid "  -Wa,<options>            Pass comma-separated <options> on to the assembler\n"
-msgstr "  -Wa,<opsi>               Lewatkan dipisahkan-oleh-koma <opsi> ke perakit\n"
+msgstr "  -Wa,<pilihan>               Lewatkan dipisahkan-oleh-koma <pilihan> ke perakit\n"
 
 #: gcc.c:3251
 msgid "  -Wp,<options>            Pass comma-separated <options> on to the preprocessor\n"
-msgstr "  -Wp,<opsi>               Lewatkan dipisahkan-oleh-koma <opsi> ke preprosesor\n"
+msgstr "  -Wp,<pilihan>               Lewatkan dipisahkan-oleh-koma <pilihan> ke preprosesor\n"
 
 #: gcc.c:3252
 msgid "  -Wl,<options>            Pass comma-separated <options> on to the linker\n"
-msgstr "  -Wl,<opsi>               Lewatkan dipisahkan-oleh-koma <opsi> ke penghubung\n"
+msgstr "  -Wl,<pilihan>               Lewatkan dipisahkan-oleh-koma <pilihan> ke penghubung\n"
 
 #: gcc.c:3253
 msgid "  -Xassembler <arg>        Pass <arg> on to the assembler\n"
@@ -1012,7 +1010,7 @@
 
 #: gcc.c:3269
 msgid "  -###                     Like -v but options quoted and commands not executed\n"
-msgstr "  -###                     Seperti -v tetapi opsi diquote dan perintah tidak dijalankan\n"
+msgstr "  -###                     Seperti -v tetapi pilihan diquote dan perintah tidak dijalankan\n"
 
 #: gcc.c:3270
 msgid "  -E                       Preprocess only; do not compile, assemble or link\n"
@@ -1051,14 +1049,14 @@
 " other options on to these processes the -W<letter> options must be used.\n"
 msgstr ""
 "\n"
-"Opsi dimulai dengan -g, -f, -m, -O, -W, atau --param secara otomatis\n"
+"Pilihan dimulai dengan -g, -f, -m, -O, -W, atau --param secara otomatis\n"
 " dilewatkan ke berbagai sub-proses dipanggil oleh %s. Dalam tujuan untuk melewatkan\n"
-" ke opsi lain di proses ini opsi -W<huruf> harus digunakan.\n"
+" ke pilihan lain di proses ini pilihan -W<huruf> harus digunakan.\n"
 
 #: gcc.c:3411
 #, c-format
 msgid "'-%c' option must have argument"
-msgstr "'-%c' opsi harus memiliki argumen"
+msgstr "'-%c' pilihan harus memiliki argumen"
 
 #: gcc.c:3437
 #, c-format
@@ -1066,9 +1064,9 @@
 msgstr "tidak dapat menjalankan '%s': %s"
 
 #: gcc.c:3439
-#, fuzzy, c-format
+#, c-format
 msgid "couldn't run '%s': %s: %s"
-msgstr "tidak dapat menjalankan '%s': %s"
+msgstr "tidak dapat menjalankan '%s': %s: %s"
 
 #. translate_options () has turned --version into -fversion.
 #: gcc.c:3643
@@ -1307,7 +1305,7 @@
 "\n"
 msgstr ""
 "\n"
-"Opsi penghubung\n"
+"Pilihan penghubung\n"
 "===============\n"
 "\n"
 
@@ -1372,7 +1370,7 @@
 "=================\n"
 "\n"
 msgstr ""
-"Opsi perakit\n"
+"Pilihan perakit\n"
 "============\n"
 "\n"
 
@@ -1776,7 +1774,7 @@
 
 #: ipa-inline.c:980
 msgid "target specific option mismatch"
-msgstr "opsi target spesifik tidak cocok"
+msgstr "pilihan target spesifik tidak cocok"
 
 #: ipa-inline.c:1056
 msgid "--param inline-unit-growth limit reached"
@@ -1842,63 +1840,61 @@
 #: opts.c:1283
 #, c-format
 msgid " No options with the desired characteristics were found\n"
-msgstr " Tidak ada opsi dengan karakteristik yang diinginkan ditemukan\n"
+msgstr " Tidak ada pilihan dengan karakteristik yang diinginkan ditemukan\n"
 
 #: opts.c:1292
 #, c-format
 msgid " None found.  Use --help=%s to show *all* the options supported by the %s front-end\n"
-msgstr " Tidak ditemukan apapun. Gunakan --help=%s untuk menunjukan *seluruh* opsi yang didukung oleh %s front-end\n"
+msgstr " Tidak ditemukan apapun. Gunakan --help=%s untuk menunjukan *seluruh* pilihan yang didukung oleh %s front-end\n"
 
 #: opts.c:1298
 #, c-format
 msgid " All options with the desired characteristics have already been displayed\n"
-msgstr " Seluruh opsi dengan karakteristik yang diinginkan telah ditampilkan\n"
+msgstr " Seluruh pilihan dengan karakteristik yang diinginkan telah ditampilkan\n"
 
 #: opts.c:1352
 msgid "The following options are target specific"
-msgstr "Opsi berikut adalah target spesifik"
+msgstr "Pilihan berikut adalah target spesifik"
 
 #: opts.c:1355
 msgid "The following options control compiler warning messages"
-msgstr "Opsi berikut mengontrol pesan peringatan kompiler"
+msgstr "Pilihan berikut mengontrol pesan peringatan kompiler"
 
 #: opts.c:1358
 msgid "The following options control optimizations"
-msgstr "Opsi berikut mengontrol optimisasi"
+msgstr "Pilihan berikut mengontrol optimisasi"
 
 #: opts.c:1361 opts.c:1400
 msgid "The following options are language-independent"
-msgstr "Opsi berikut adalah independen terhadap bahasa pemrograman"
+msgstr "Pilihan berikut adalah independen terhadap bahasa pemrograman"
 
 #: opts.c:1364
 msgid "The --param option recognizes the following as parameters"
-msgstr "Opsi --param dikenal sebagai parameters"
+msgstr "Pilihan --param dikenal sebagai parameters"
 
 #: opts.c:1370
 msgid "The following options are specific to just the language "
-msgstr "Opsi berikut hanya spesifik terhadap bahasa "
+msgstr "Pilihan berikut hanya spesifik terhadap bahasa "
 
 #: opts.c:1372
 msgid "The following options are supported by the language "
-msgstr "Opsi berikut tidak didukung oleh bahasa "
+msgstr "Pilihan berikut tidak didukung oleh bahasa "
 
 #: opts.c:1383
 msgid "The following options are not documented"
-msgstr "Opsi berikut tidak terdokumentasi"
+msgstr "Pilihan berikut tidak terdokumentasi"
 
 #: opts.c:1385
-#, fuzzy
 msgid "The following options take separate arguments"
-msgstr "Opsi berikut tidak terdokumentasi"
+msgstr "Pilihan berikut mengambil argumen terpisah"
 
 #: opts.c:1387
-#, fuzzy
 msgid "The following options take joined arguments"
-msgstr "Opsi berikut tidak terdokumentasi"
+msgstr "Pilihan berikut mengambil argumen tergabung"
 
 #: opts.c:1398
 msgid "The following options are language-related"
-msgstr "Opsi berikut adalah berhubungan dengan bahasa"
+msgstr "Pilihan berikut adalah berhubungan dengan bahasa"
 
 #: opts.c:1558
 #, c-format
@@ -1908,7 +1904,7 @@
 #: opts.c:1566
 #, c-format
 msgid "warning: unrecognized argument to --help= option: %.*s\n"
-msgstr "peringatan: argumen tidak dikenal ke opsi --help=: %.*s\n"
+msgstr "peringatan: argumen tidak dikenal ke pilihan --help=: %.*s\n"
 
 #: protoize.c:583
 #, c-format
@@ -2335,11 +2331,11 @@
 
 #: toplev.c:1276
 msgid "options passed: "
-msgstr "opsi dilewatkan: "
+msgstr "pilihan dilewatkan: "
 
 #: toplev.c:1310
 msgid "options enabled: "
-msgstr "opsi aktif: "
+msgstr "pilihan aktif: "
 
 #: toplev.c:1445
 #, c-format
@@ -2847,7 +2843,7 @@
 
 #: params.def:755
 msgid "max size of conflict table in MB"
-msgstr ""
+msgstr "ukuran maksimal dari tabel konflik dalam MB"
 
 #: params.def:763
 msgid "The maximum ratio between array size and switch branches for a switch conversion to take place"
@@ -2855,7 +2851,7 @@
 
 #: params.def:771
 msgid "max basic blocks number in loop for loop invariant motion"
-msgstr ""
+msgstr "jumlah maksimal blok dasar dalam loop untuk gerakan loop invariant"
 
 #: config/alpha/alpha.c:5039
 #, c-format
@@ -3303,19 +3299,19 @@
 msgstr "UNSPEC tidak valid sebagai operan"
 
 #: config/i386/i386.c:11065 config/i386/i386.c:11104 config/i386/i386.c:11278
-#, fuzzy, c-format
+#, c-format
 msgid "operand is not a condition code, invalid operand code 'D'"
-msgstr "operan bukan sebuah konstanta ataupun sebuah kode kondisi, kode operan 'c' tidak valid"
+msgstr "operan bukan sebuah kode kondisi, kode operan 'D' tidak valid"
 
 #: config/i386/i386.c:11129
-#, fuzzy, c-format
+#, c-format
 msgid "operand is neither a constant nor a condition code, invalid operand code 'C'"
-msgstr "operan bukan sebuah konstanta ataupun sebuah kode kondisi, kode operan 'c' tidak valid"
+msgstr "operan bukan sebuah konstanta ataupun sebuah kode kondisi, kode operan 'C' tidak valid"
 
 #: config/i386/i386.c:11139
-#, fuzzy, c-format
+#, c-format
 msgid "operand is neither a constant nor a condition code, invalid operand code 'F'"
-msgstr "operan bukan sebuah konstanta ataupun sebuah kode kondisi, kode operan 'c' tidak valid"
+msgstr "operan bukan sebuah konstanta ataupun sebuah kode kondisi, kode operan 'F' tidak valid"
 
 #: config/i386/i386.c:11157
 #, c-format
@@ -3323,9 +3319,9 @@
 msgstr "operan bukan sebuah konstanta ataupun sebuah kode kondisi, kode operan 'c' tidak valid"
 
 #: config/i386/i386.c:11167
-#, fuzzy, c-format
+#, c-format
 msgid "operand is neither a constant nor a condition code, invalid operand code 'f'"
-msgstr "operan bukan sebuah konstanta ataupun sebuah kode kondisi, kode operan 'c' tidak valid"
+msgstr "operan bukan sebuah konstanta ataupun sebuah kode kondisi, kode operan 'f' tidak valid"
 
 #: config/i386/i386.c:11292
 #, c-format
@@ -3850,17 +3846,17 @@
 #: fortran/arith.c:2064
 #, no-c-format
 msgid "Arithmetic overflow converting %s to %s at %L. This check can be disabled with the option -fno-range-check"
-msgstr "Aritmetik overflow mengubah %s ke %s di %L. Pemeriksaan ini dapat dinon-aktifkan dengan opsi -fno-range-check"
+msgstr "Aritmetik overflow mengubah %s ke %s di %L. Pemeriksaan ini dapat dinon-aktifkan dengan pilihan -fno-range-check"
 
 #: fortran/arith.c:2069
 #, no-c-format
 msgid "Arithmetic underflow converting %s to %s at %L. This check can be disabled with the option -fno-range-check"
-msgstr "Aritmetik underflow mengubah %s ke %s di %L. Pemeriksaan ini dapat dinon-aktifkan dengan opsi -fno-range-check"
+msgstr "Aritmetik underflow mengubah %s ke %s di %L. Pemeriksaan ini dapat dinon-aktifkan dengan pilihan -fno-range-check"
 
 #: fortran/arith.c:2074
 #, no-c-format
 msgid "Arithmetic NaN converting %s to %s at %L. This check can be disabled with the option -fno-range-check"
-msgstr "Aritmetik NaN mengubah %s ke %s di %L. Pemeriksaan ini dapat dinon-aktifkan dengan opsi -fno-range-check"
+msgstr "Aritmetik NaN mengubah %s ke %s di %L. Pemeriksaan ini dapat dinon-aktifkan dengan pilihan -fno-range-check"
 
 #: fortran/arith.c:2079
 #, no-c-format
@@ -4083,9 +4079,9 @@
 msgstr "'dim' argumen dari '%s' instrinsik di %L bukan sebuah indeks dimensi yang valid"
 
 #: fortran/check.c:431
-#, fuzzy, no-c-format
+#, no-c-format
 msgid "Unequal character lengths (%ld/%ld) in %s at %L"
-msgstr "Panjang karakter tidak sama (%ld dan %ld) dalam %s intrinsik di %L"
+msgstr "Panjang karakter tidak sama (%ld/%ld) dalam %s di %L"
 
 #: fortran/check.c:537 fortran/check.c:2039 fortran/check.c:2054
 #, no-c-format
@@ -4211,9 +4207,9 @@
 msgstr "'a1' argumen dari '%s' intrinsik di %L harus berupa INTEGER, REAL, atau KARAKTER"
 
 #: fortran/check.c:1821
-#, fuzzy, no-c-format
+#, no-c-format
 msgid "Argument types of '%s' intrinsic at %L must match (%s/%s)"
-msgstr "'a%d' argumen dari '%s' intrinsik di %L harus berupa %s(%d)"
+msgstr "Tipe argumen dari '%s' intrinsik di %L harus sesuai dengan (%s/%s)"
 
 #: fortran/check.c:1835
 #, no-c-format
@@ -4306,9 +4302,9 @@
 msgstr "Bentuk berbeda dalam dimensi %d untuk argumen MASK dan FIELD dari UNPACK di %L"
 
 #: fortran/check.c:3190 fortran/check.c:3222
-#, fuzzy, no-c-format
+#, no-c-format
 msgid "Size of '%s' argument of '%s' intrinsic at %L too small (%i/%i)"
-msgstr "'%s' argumen dari '%s' intrinsik di %L harus berupa %s"
+msgstr "Ukuran dari '%s' argumen dari '%s' intrinsik di %L terlalu kecil (%i/%i)"
 
 #: fortran/check.c:3230
 #, no-c-format
@@ -4636,9 +4632,9 @@
 msgstr "Jenis %d tidak didukung untuk tipe %s di %C"
 
 #: fortran/decl.c:1992
-#, fuzzy, no-c-format
+#, no-c-format
 msgid "C kind type parameter is for type %s but type at %L is %s"
-msgstr "parameter jenis C adalah untuk tipe %s tetapi simbol '%s' di %L adalah tipe %s"
+msgstr "Jenis tipe parameter C adalah untuk tipe %s tetapi tipe di %L adalah %s"
 
 #: fortran/decl.c:2001
 #, no-c-format
@@ -5136,7 +5132,7 @@
 #: fortran/decl.c:5619
 #, no-c-format
 msgid "Cray pointer declaration at %C requires -fcray-pointer flag"
-msgstr "Deklarasi penunjuk cray di %C membutuhkan opsi -fcray-pointer"
+msgstr "Deklarasi penunjuk cray di %C membutuhkan pilihan -fcray-pointer"
 
 #: fortran/decl.c:5714
 #, no-c-format
@@ -5757,17 +5753,17 @@
 #: fortran/expr.c:2974 fortran/resolve.c:6570
 #, no-c-format
 msgid "Arithmetic underflow of bit-wise transferred BOZ at %L. This check can be disabled with the option -fno-range-check"
-msgstr "Aritmetik underflow dari bit-wise dipindahkan BOZ di %L. Pemeriksaan ini dapat dinon-aktifkan dengan opsi -fno-range-check"
+msgstr "Aritmetik underflow dari bit-wise dipindahkan BOZ di %L. Pemeriksaan ini dapat dinon-aktifkan dengan pilihan -fno-range-check"
 
 #: fortran/expr.c:2978 fortran/resolve.c:6574
 #, no-c-format
 msgid "Arithmetic overflow of bit-wise transferred BOZ at %L. This check can be disabled with the option -fno-range-check"
-msgstr "Aritmetik overflow dari bit-wise dipindahkan BOZ di %L. Pemeriksaan ini dapat dinonaktifkan dengan opsi -fno-range-check"
+msgstr "Aritmetik overflow dari bit-wise dipindahkan BOZ di %L. Pemeriksaan ini dapat dinonaktifkan dengan pilihan -fno-range-check"
 
 #: fortran/expr.c:2982 fortran/resolve.c:6578
 #, no-c-format
 msgid "Arithmetic NaN of bit-wise transferred BOZ at %L. This check can be disabled with the option -fno-range-check"
-msgstr "Aritmetik NaN dari bit-wise dipindahkan BOZ di %L. Pemeriksaan ini dapat dinon-aktifkan dengan opsi -fno-range-check"
+msgstr "Aritmetik NaN dari bit-wise dipindahkan BOZ di %L. Pemeriksaan ini dapat dinon-aktifkan dengan pilihan -fno-range-check"
 
 #: fortran/expr.c:3004
 #, no-c-format
@@ -5810,14 +5806,14 @@
 msgstr "Objek penunjuk buruk dalam prosedur PURE di %L"
 
 #: fortran/expr.c:3134
-#, fuzzy, no-c-format
+#, no-c-format
 msgid "Invalid procedure pointer assignment at %L"
-msgstr "Tingkat berbeda dalam penempatan penunjuk di %L"
+msgstr "Penempatan penunjuk prosedur tidak valid di %L"
 
 #: fortran/expr.c:3140
-#, fuzzy, no-c-format
+#, no-c-format
 msgid "Abstract interface '%s' is invalid in procedure pointer assignment at %L"
-msgstr "Jenis parameter berbeda dalam penempatan penunjuk di %L"
+msgstr "Antarmuka abstrak '%s' tidak valid dalam penempatan penunjuk prosedur di %L"
 
 #: fortran/expr.c:3159
 #, no-c-format
@@ -6202,7 +6198,7 @@
 #: fortran/intrinsic.c:840
 #, no-c-format
 msgid "The intrinsic '%s' at %L is not included in the selected standard but %s and '%s' will be treated as if declared EXTERNAL.  Use an appropriate -std=* option or define -fall-intrinsics to allow this intrinsic."
-msgstr "Intrinsik '%s' di %L tidak dimasukan dalam standar yang dipilih tetapi %s dan '%s' akan diperlakukan seperti jika dideklarasikan EXTERNAL. Gunakan sebuah opsi -std=* yang sesuai atau definisikan -fall-intrinsics untuk mengijinkan intrinsik ini."
+msgstr "Intrinsik '%s' di %L tidak dimasukan dalam standar yang dipilih tetapi %s dan '%s' akan diperlakukan seperti jika dideklarasikan EXTERNAL. Gunakan sebuah pilihan -std=* yang sesuai atau definisikan -fall-intrinsics untuk mengijinkan intrinsik ini."
 
 #: fortran/intrinsic.c:3079
 #, no-c-format
@@ -6372,9 +6368,8 @@
 msgstr "Fortran 2008: 'G0' dalam format di %C"
 
 #: fortran/io.c:745
-#, fuzzy
 msgid "E specifier not allowed with g0 descriptor"
-msgstr "Diduga P edit deskripsi"
+msgstr "Penspesifikasi E tidak diperbolehkan dengan pendeskripsi g0"
 
 #: fortran/io.c:759 fortran/io.c:761 fortran/io.c:822 fortran/io.c:824
 #, no-c-format
@@ -7303,19 +7298,19 @@
 msgstr "Error menulis berkas modul '%s' untuk menulis: %s"
 
 #: fortran/module.c:4876
-#, fuzzy, no-c-format
+#, no-c-format
 msgid "Can't delete module file '%s': %s"
-msgstr "%s: tidak dapat menghapus berkas '%s': %s\n"
+msgstr "tidak dapat menghapus berkas modul '%s': %s"
 
 #: fortran/module.c:4879
-#, fuzzy, no-c-format
+#, no-c-format
 msgid "Can't rename module file '%s' to '%s': %s"
-msgstr "%s: peringatan: tidak dapat mengubah nama berkas '%s' ke '%s': %s\n"
+msgstr "tidak dapat mengubah nama berkas modul '%s' ke '%s': %s"
 
 #: fortran/module.c:4885
-#, fuzzy, no-c-format
+#, no-c-format
 msgid "Can't delete temporary module file '%s': %s"
-msgstr "%s: tidak dapat menghapus berkas informasi tambahan '%s': %s\n"
+msgstr "Tidak dapat menghapus berkas modul sementara '%s': %s"
 
 #: fortran/module.c:4905 fortran/module.c:4987
 #, no-c-format
@@ -7345,12 +7340,12 @@
 #: fortran/module.c:5116
 #, no-c-format
 msgid "Use of the NUMERIC_STORAGE_SIZE named constant from intrinsic module ISO_FORTRAN_ENV at %L is incompatible with option %s"
-msgstr "Penggunaan dari NUMERIC_STORAGE_SIZE konstanta bernama dari modul intrinsik ISO_FORTRAN_ENV di %L adalah tidak kompatibel dengan opsi %s"
+msgstr "Penggunaan dari NUMERIC_STORAGE_SIZE konstanta bernama dari modul intrinsik ISO_FORTRAN_ENV di %L adalah tidak kompatibel dengan pilihan %s"
 
 #: fortran/module.c:5144
 #, no-c-format
 msgid "Use of the NUMERIC_STORAGE_SIZE named constant from intrinsic module ISO_FORTRAN_ENV at %C is incompatible with option %s"
-msgstr "Penggunaan dari NUMERIC_STORAGE_SIZE konstanta bernama dari modul intrinsik ISO_FORTRAN_ENV di %C adalah tidak kompatibel dengan opsi %s"
+msgstr "Penggunaan dari NUMERIC_STORAGE_SIZE konstanta bernama dari modul intrinsik ISO_FORTRAN_ENV di %C adalah tidak kompatibel dengan pilihan %s"
 
 #: fortran/module.c:5160
 #, no-c-format
@@ -7394,12 +7389,12 @@
 #: fortran/module.c:5252
 #, no-c-format
 msgid "Parse error when checking module version for file '%s' opened at %C"
-msgstr ""
+msgstr "Parse error ketika memeriksa versi modul untuk berkas '%s' dibuka di %C"
 
 #: fortran/module.c:5257
 #, no-c-format
 msgid "Wrong module version '%s' (expected '"
-msgstr ""
+msgstr "Versi modul salah '%s' (diduga '"
 
 #: fortran/module.c:5270
 #, no-c-format
@@ -7640,7 +7635,7 @@
 #: fortran/options.c:233
 #, no-c-format
 msgid "Option -fwhole-program is not supported for Fortran"
-msgstr "Opsi -fwhole-program tidak didukung untuk Fortran"
+msgstr "Pilihan -fwhole-program tidak didukung untuk Fortran"
 
 #: fortran/options.c:287
 #, no-c-format
@@ -7660,32 +7655,32 @@
 #: fortran/options.c:318
 #, no-c-format
 msgid "Flag -fno-automatic overwrites -fmax-stack-var-size=%d"
-msgstr "Opsi -fno-automatic overwrites -fmax-stack-var-size=%d"
+msgstr "Pilihan -fno-automatic overwrites -fmax-stack-var-size=%d"
 
 #: fortran/options.c:321
 #, no-c-format
 msgid "Flag -fno-automatic overwrites -frecursive"
-msgstr "Opsi -fno-automatic overwrites -frecursive"
+msgstr "Pilihan -fno-automatic overwrites -frecursive"
 
 #: fortran/options.c:323
 #, no-c-format
 msgid "Flag -fno-automatic overwrites -frecursive implied by -fopenmp"
-msgstr "Opsi -fno-automatic overwrites -frecursive diimplikasikan dengan -fopenmp"
+msgstr "Pilihan -fno-automatic overwrites -frecursive diimplikasikan dengan -fopenmp"
 
 #: fortran/options.c:327
 #, no-c-format
 msgid "Flag -frecursive overwrites -fmax-stack-var-size=%d"
-msgstr "Opsi -frecursive overwrites -fmax-stack-var-size=%d"
+msgstr "Pilihan -frecursive overwrites -fmax-stack-var-size=%d"
 
 #: fortran/options.c:331
 #, no-c-format
 msgid "Flag -fmax-stack-var-size=%d overwrites -frecursive implied by -fopenmp"
-msgstr "Opsi -fmax-stack-var-size=%d overwrites -frecursive diimplikasikan dengan -fopenmp"
+msgstr "Pilihan -fmax-stack-var-size=%d overwrites -frecursive diimplikasikan dengan -fopenmp"
 
 #: fortran/options.c:404
 #, no-c-format
 msgid "gfortran: Only one -J option allowed"
-msgstr "gfortran: Hanya satu opsi -J diperbolehkan"
+msgstr "gfortran: Hanya satu pilihan -J diperbolehkan"
 
 #: fortran/options.c:447
 #, no-c-format
@@ -7715,12 +7710,12 @@
 #: fortran/options.c:712
 #, no-c-format
 msgid "Unrecognized option to -finit-logical: %s"
-msgstr "Opsi ke -finit-logical: %s tidak dikenal"
+msgstr "Pilihan ke -finit-logical: %s tidak dikenal"
 
 #: fortran/options.c:726
 #, no-c-format
 msgid "Unrecognized option to -finit-real: %s"
-msgstr "Opsi ke -finit-real: %s tidak dikenal"
+msgstr "Pilihan ke -finit-real: %s tidak dikenal"
 
 #: fortran/options.c:742
 #, no-c-format
@@ -8114,7 +8109,7 @@
 #: fortran/primary.c:222
 #, no-c-format
 msgid "Integer too big for its kind at %C. This check can be disabled with the option -fno-range-check"
-msgstr "Integer terlalu besar untuk jenis ini di %C. Pemeriksaan ini dapat dinon-aktifkan dengan opsi -fno-range-check"
+msgstr "Integer terlalu besar untuk jenis ini di %C. Pemeriksaan ini dapat dinon-aktifkan dengan pilihan -fno-range-check"
 
 #: fortran/primary.c:251
 #, no-c-format
@@ -8284,7 +8279,7 @@
 #: fortran/primary.c:2103
 #, no-c-format
 msgid "Fortran 2003: Structure constructor with missing optional arguments at %C"
-msgstr "Fortran 2003: Konstruktor struktur dengan argumen opsional hilang di %C"
+msgstr "Fortran 2003: Konstruktor struktur dengan argumen pilihanonal hilang di %C"
 
 #: fortran/primary.c:2111
 #, no-c-format
@@ -8589,7 +8584,7 @@
 #: fortran/resolve.c:1163
 #, no-c-format
 msgid "Non-RECURSIVE procedure '%s' at %L is possibly calling itself recursively.  Declare it RECURSIVE or use -frecursive"
-msgstr ""
+msgstr "Bukan prosedur REKURSIF '%s' di %L mungkin memanggil dirinya sendiri secara rekursif. Deklarasikan itu secara RECURSIVE atau gunakan -frecursive"
 
 #: fortran/resolve.c:1196 fortran/resolve.c:6023 fortran/resolve.c:6778
 #, no-c-format
@@ -8644,7 +8639,7 @@
 #: fortran/resolve.c:1523
 #, no-c-format
 msgid "'%s' at %L is an array and OPTIONAL; IF IT IS MISSING, it cannot be the actual argument of an ELEMENTAL procedure unless there is a non-optional argument with the same rank (12.4.1.5)"
-msgstr "'%s' di %L adalah sebuah array dan OPSIONAL; JIKA INI HILANG, ini tidak dapat berupa argumen aktual dari sebual prosedur ELEMENTAL kecuali disana ada sebuah tidak opsional argumen dengan tingkat sama (12.4.1.5)"
+msgstr "'%s' di %L adalah sebuah array dan OPSIONAL; JIKA INI HILANG, ini tidak dapat berupa argumen aktual dari sebual prosedur ELEMENTAL kecuali disana ada sebuah tidak pilihanonal argumen dengan tingkat sama (12.4.1.5)"
 
 #: fortran/resolve.c:1545
 msgid "elemental procedure"
@@ -8776,14 +8771,14 @@
 msgstr "Referensi fungsi ke '%s' di %L adalah ke sebuah prosedur bukan-PURE dalam sebuah prosedur PURE"
 
 #: fortran/resolve.c:2493
-#, fuzzy, no-c-format
+#, no-c-format
 msgid "ENTRY '%s' at %L cannot be called recursively, as function '%s' is not RECURSIVE"
-msgstr "Panggilan ke MASUKAN '%s' di %L adalah rekursif, bukan fungsi '%s' tidak terdeklarasi sebagai REKURSIF"
+msgstr "MASUKAN '%s' di %L tidak dapat dipanggil secara rekursif, karena fungsi '%s' tidak REKURSIF"
 
 #: fortran/resolve.c:2497
-#, fuzzy, no-c-format
+#, no-c-format
 msgid "Function '%s' at %L cannot be called recursively, as it is not RECURSIVE"
-msgstr "Fungsi '%s' di %L tidak dapat memanggil dirinya sendiri, karena ini bukan REKURSIF"
+msgstr "Fungsi '%s' di %L tidak dapat dipanggil secara rekursif, karena ini bukan REKURSIF"
 
 #: fortran/resolve.c:2544
 #, no-c-format
@@ -8831,14 +8826,14 @@
 msgstr "'%s' di %L memiliki sebuah tipe, yang tidak konsisten dengan CALL di %L"
 
 #: fortran/resolve.c:2957
-#, fuzzy, no-c-format
+#, no-c-format
 msgid "ENTRY '%s' at %L cannot be called recursively, as subroutine '%s' is not RECURSIVE"
-msgstr "Panggilan ke MASUKAN '%s' di %L adalah rekursif, tetapi subroutine '%s' tidak dideklarasikan sebagai REKURSIF"
+msgstr "MASUKAN '%s' di %L tidak dapat dipanggil secara rekursif, karena subroutine '%s' tidak REKURSIF"
 
 #: fortran/resolve.c:2961
-#, fuzzy, no-c-format
+#, no-c-format
 msgid "SUBROUTINE '%s' at %L cannot be called recursively, as it is not RECURSIVE"
-msgstr "SUBROUTINE '%s' di %L tidak dapat memanggil dirinya sendiri, karena ini bukan REKURSIF"
+msgstr "SUBROUTINE '%s' di %L tidak dapat dipanggil secara rekursif, karena ini bukan REKURSIF"
 
 #: fortran/resolve.c:3035
 #, no-c-format
@@ -9769,9 +9764,9 @@
 msgstr "Panjang karakter dari komponen '%s' butuh untuk menjadi sebuah ekspresi spesifikasi konstan di %L"
 
 #: fortran/resolve.c:8735
-#, fuzzy, no-c-format
+#, no-c-format
 msgid "Fortran 2003: the component '%s' is a PRIVATE type and cannot be a component of '%s', which is PUBLIC at %L"
-msgstr "Komponen '%s' adalah sebuah tipe PRIVATE dan tidak dapat berupa sebuah komponen dari '%s', yang mana adalah PUBLIK di %L"
+msgstr "Fortran 2003: Komponen '%s' adalah sebuah tipe PRIVATE dan tidak dapat berupa sebuah komponen dari '%s', yang mana adalah PUBLIK di %L"
 
 #: fortran/resolve.c:8746
 #, no-c-format
@@ -9871,7 +9866,7 @@
 #: fortran/resolve.c:9118
 #, no-c-format
 msgid "The intrinsic '%s' declared INTRINSIC at %L is not available in the current standard settings but %s.  Use an appropriate -std=* option or enable -fall-intrinsics in order to use it."
-msgstr "Intrinsik '%s' dideklarasikan INTRINSIC di %L tidak tersedia dalam konfigurasi baku sekarang tetapi %s. Gunakan sebuah opsi -std=* yang sesuai atau aktifkan -fall-intrinsics untuk menggunakan itu."
+msgstr "Intrinsik '%s' dideklarasikan INTRINSIC di %L tidak tersedia dalam konfigurasi baku sekarang tetapi %s. Gunakan sebuah pilihan -std=* yang sesuai atau aktifkan -fall-intrinsics untuk menggunakan itu."
 
 #: fortran/resolve.c:9162
 #, no-c-format
@@ -9929,9 +9924,9 @@
 msgstr "Threadprivate di %L bukan SAVEd"
 
 #: fortran/resolve.c:9448
-#, fuzzy, no-c-format
+#, no-c-format
 msgid "non-constant DATA value at %L"
-msgstr "bukan-konstanta array dalam pernyataan DATA %L"
+msgstr "bukan-konstanta nilai DATA di %L"
 
 #: fortran/resolve.c:9488
 #, no-c-format
@@ -10066,12 +10061,12 @@
 #: fortran/resolve.c:10349
 #, no-c-format
 msgid "First argument of operator interface at %L cannot be optional"
-msgstr "Argumen pertama dari antar-muka operator di %L tidak dapat berupa opsional"
+msgstr "Argumen pertama dari antar-muka operator di %L tidak dapat berupa pilihanonal"
 
 #: fortran/resolve.c:10361
 #, no-c-format
 msgid "Second argument of operator interface at %L cannot be optional"
-msgstr "Argumen kedua dari antar-muka operator di %L tidak dapat berupa opsional"
+msgstr "Argumen kedua dari antar-muka operator di %L tidak dapat berupa pilihanonal"
 
 #: fortran/resolve.c:10365
 #, no-c-format
@@ -10768,7 +10763,7 @@
 #: fortran/trans-array.c:3957
 #, no-c-format
 msgid "The number of elements in the array constructor at %L requires an increase of the allowed %d upper limit.   See -fmax-array-constructor option"
-msgstr "Jumlah dari elemen dalam konstruktor array di %L membutuhkan sebuah peningkatan dari batas atas %d yang diijinkan. Lihat opsi -fmax-array-constructor"
+msgstr "Jumlah dari elemen dalam konstruktor array di %L membutuhkan sebuah peningkatan dari batas atas %d yang diijinkan. Lihat pilihan -fmax-array-constructor"
 
 #: fortran/trans-array.c:5315
 #, no-c-format
@@ -11198,7 +11193,7 @@
 
 #: config/vax/netbsd-elf.h:41
 msgid "the -shared option is not currently supported for VAX ELF"
-msgstr "opsi -shared saat ini tidak didukung untuk VAX ELF"
+msgstr "pilihan -shared saat ini tidak didukung untuk VAX ELF"
 
 #: config/i386/nwld.h:34
 msgid "Static linking is not supported.\n"
@@ -11598,7 +11593,7 @@
 
 #: config/mcore/mcore.opt:56 config/fr30/fr30.opt:27
 msgid "Assume that run-time support has been provided, so omit -lsim from the linker command line"
-msgstr ""
+msgstr "Asumsikan bahwa dukungan waktu jalan telah disediakan, jadi abaikan -lsim dari baris perintah penggabung"
 
 #: config/mcore/mcore.opt:60
 msgid "Use arbitrary sized immediates in bit operations"
@@ -12161,9 +12156,8 @@
 msgstr "Ijinkan percabangan untuk dipack dengan instruksi lain"
 
 #: config/picochip/picochip.opt:23
-#, fuzzy
 msgid "Specify which type of AE to target. This option sets the mul-type and byte-access."
-msgstr "Spesifikasikan tipe mana dari AE untuk target. Opsi in menset tipe-mul"
+msgstr "Spesifikasikan tipe mana dari AE untuk target. Pilihan ini menset mul-type dan byte-access."
 
 #: config/picochip/picochip.opt:27
 msgid "Specify which type of multiplication to use. Can be mem, mac or none."
@@ -12178,9 +12172,8 @@
 msgstr "Aktifkan keluaran debug untuk dihasilkan."
 
 #: config/picochip/picochip.opt:39
-#, fuzzy
 msgid "Allow a symbol value to be used as an immediate value in an instruction."
-msgstr "Ijinkan sebuah nilai simbol untuk digunakan sebagai sebuah nilai langsung dalam sebuah"
+msgstr "Ijinkan sebuah nilai simbol untuk digunakan sebagai sebuah nilai langsung dalam sebuah instruksi."
 
 #: config/picochip/picochip.opt:43
 msgid "Generate warnings when inefficient code is known to be generated."
@@ -12689,7 +12682,7 @@
 
 #: config/cris/cris.opt:149
 msgid "Use the most feature-enabling options allowed by other options"
-msgstr "Gunakan opsi paling feature-enabling yang diijinkan oleh opsi lain"
+msgstr "Gunakan pilihan paling feature-enabling yang diijinkan oleh pilihan lain"
 
 #: config/cris/cris.opt:158
 msgid "Override -mbest-lib-options"
@@ -12883,11 +12876,11 @@
 
 #: config/rs6000/rs6000.opt:48
 msgid "Use PowerPC General Purpose group optional instructions"
-msgstr "Gunakan grup opsional instruksi PowerPC General Purpose"
+msgstr "Gunakan grup pilihanonal instruksi PowerPC General Purpose"
 
 #: config/rs6000/rs6000.opt:52
 msgid "Use PowerPC Graphics group optional instructions"
-msgstr "Gunakan grup opsional instruksi PowerPC Graphics"
+msgstr "Gunakan grup pilihanonal instruksi PowerPC Graphics"
 
 #: config/rs6000/rs6000.opt:56
 msgid "Use PowerPC V2.01 single field mfcr instruction"
@@ -12955,7 +12948,7 @@
 
 #: config/rs6000/rs6000.opt:124
 msgid "Avoid generation of indexed load/store instructions when possible"
-msgstr ""
+msgstr "Abaikan pembuatan dari indeks instruksi muat/simpan jika memungkinkan"
 
 #: config/rs6000/rs6000.opt:128
 msgid "Do not generate fused multiply/add instructions"
@@ -13015,7 +13008,7 @@
 
 #: config/rs6000/rs6000.opt:194
 msgid "Deprecated option.  Use -mvrsave/-mno-vrsave instead"
-msgstr "Opsi ditinggalkan. Gunakan -mvrsave/-mno-vrsave lebih baik"
+msgstr "Pilihan ditinggalkan. Gunakan -mvrsave/-mno-vrsave lebih baik"
 
 #: config/rs6000/rs6000.opt:198
 msgid "Generate isel instructions"
@@ -13023,7 +13016,7 @@
 
 #: config/rs6000/rs6000.opt:202
 msgid "Deprecated option.  Use -misel/-mno-isel instead"
-msgstr "Opsi ditinggalkan. Gunakan -misel/-mno-isel lebih baik"
+msgstr "Pilihan ditinggalkan. Gunakan -misel/-mno-isel lebih baik"
 
 #: config/rs6000/rs6000.opt:206
 msgid "Generate SPE SIMD instructions on E500"
@@ -13035,7 +13028,7 @@
 
 #: config/rs6000/rs6000.opt:214
 msgid "Deprecated option.  Use -mspe/-mno-spe instead"
-msgstr "Opsi ditinggalkan. Gunakan -mspe/-mno-spe lebih baik"
+msgstr "Pilihan ditinggalkan. Gunakan -mspe/-mno-spe lebih baik"
 
 #: config/rs6000/rs6000.opt:218
 msgid "Enable debug output"
@@ -14607,7 +14600,7 @@
 
 #: config/bfin/bfin.opt:101
 msgid "Assume ICPLBs are enabled at runtime."
-msgstr ""
+msgstr "Asumsikan ICPLB telah aktif di waktu jalan."
 
 #: java/lang.opt:69
 msgid "Warn if deprecated empty statements are found"
@@ -14719,7 +14712,7 @@
 
 #: common.opt:32
 msgid "Display descriptions of a specific class of options.  <class> is one or more of optimizers, target, warnings, undocumented, params"
-msgstr "Tampilkan deskripsi dari opsi spesifik class. <class> adalah satu atau lebih dari pengoptimasi, target, peringatan, tidak terdokumentasi, params"
+msgstr "Tampilkan deskripsi dari pilihan spesifik class. <class> adalah satu atau lebih dari pengoptimasi, target, peringatan, tidak terdokumentasi, params"
 
 #: common.opt:36
 msgid "Alias for --help=target"
@@ -14743,7 +14736,7 @@
 
 #: common.opt:71
 msgid "This switch is deprecated; use -Wextra instead"
-msgstr "Opsi ini sudah ditinggalkan; lebih baik gunakan -Wextra"
+msgstr "Pilihan ini sudah ditinggalkan; lebih baik gunakan -Wextra"
 
 #: common.opt:75
 msgid "Warn about returning structures, unions or arrays"
@@ -15055,7 +15048,7 @@
 
 #: common.opt:448
 msgid "Amend appropriate diagnostic messages with the command line option that controls them"
-msgstr "Tambahkan pesan diagnosa yang sesuai dengan opsi baris perintah yang mengontrolnya"
+msgstr "Tambahkan pesan diagnosa yang sesuai dengan pilihan baris perintah yang mengontrolnya"
 
 #: common.opt:452
 msgid "Dump various compiler internals to a file"
@@ -15255,13 +15248,12 @@
 msgstr "Lakukan optimisasi berdasarkan struktur layout"
 
 #: common.opt:680
-#, fuzzy
 msgid "-fira-algorithm=[CB|priority] Set the used IRA algorithm"
-msgstr "-fire-algorithm=[regional|CB|mixed] Set penggunaan algoritma IRA"
+msgstr "-fire-algorithm=[CB|prioritas] Set penggunaan algoritma IRA"
 
 #: common.opt:684
 msgid "-fira-region=[one|all|mixed] Set regions for IRA"
-msgstr ""
+msgstr "-fira-region=[one|all|mixed] Set daerah untuk IRA"
 
 #: common.opt:688
 msgid "Do optimistic coalescing."
@@ -15445,19 +15437,19 @@
 
 #: common.opt:880
 msgid "Enable common options for generating profile info for profile feedback directed optimizations"
-msgstr "Aktifkan opsi umum untuk menghasilkan informasi profile untuk feedback profile direkted optimisasi"
+msgstr "Aktifkan pilihan umum untuk menghasilkan informasi profile untuk feedback profile direkted optimisasi"
 
 #: common.opt:884
 msgid "Enable common options for generating profile info for profile feedback directed optimizations, and set -fprofile-dir="
-msgstr "Aktifkan opsi umum untuk menghasilkan informasi profile untuk feedback profile direkted optimisasi, dan set -fprofile-dir="
+msgstr "Aktifkan pilihan umum untuk menghasilkan informasi profile untuk feedback profile direkted optimisasi, dan set -fprofile-dir="
 
 #: common.opt:888
 msgid "Enable common options for performing profile feedback directed optimizations"
-msgstr "Aktifkan opsi umum untuk melakukan profile feedback directed optimisasi"
+msgstr "Aktifkan pilihan umum untuk melakukan profile feedback directed optimisasi"
 
 #: common.opt:892
 msgid "Enable common options for performing profile feedback directed optimizations, and set -fprofile-dir="
-msgstr "Aktifkan opsi umum untuk melakukan profile feedback directed optimisasi, dan set -fprofile-dir="
+msgstr "Aktifkan pilihan umum untuk melakukan profile feedback directed optimisasi, dan set -fprofile-dir="
 
 #: common.opt:896
 msgid "Insert code to profile values of expressions"
@@ -15469,7 +15461,7 @@
 
 #: common.opt:913
 msgid "Record gcc command line switches in the object file."
-msgstr "Rekam opsi baris perintah gcc dalam berkas objek."
+msgstr "Rekam pilihan baris perintah gcc dalam berkas objek."
 
 #: common.opt:917
 msgid "Return small aggregates in registers"
@@ -16105,7 +16097,7 @@
 
 #: c.opt:216
 msgid "This switch is deprecated; use -Werror=implicit-function-declaration instead"
-msgstr "Opsi ini sudah ditinggalkan; lebih baik gunakan -Werror=implicit-function-declaration"
+msgstr "Pilihan ini sudah ditinggalkan; lebih baik gunakan -Werror=implicit-function-declaration"
 
 #: c.opt:220
 msgid "Warn if testing floating point numbers for equality"
@@ -16253,7 +16245,7 @@
 
 #: c.opt:373
 msgid "Warn about packed bit-fields whose offset changed in GCC 4.4"
-msgstr ""
+msgstr "Peringatkan tentang pemaketan bit-filed yang offset-nya berbah dalam GCC 4.4"
 
 #: c.opt:377
 msgid "Warn about possibly missing parentheses"
@@ -16325,7 +16317,7 @@
 
 #: c.opt:445
 msgid "Deprecated.  This switch has no effect"
-msgstr "Ditinggalkan. Opsi ini tidak memiliki efek"
+msgstr "Ditinggalkan. Pilihan ini tidak memiliki efek"
 
 #: c.opt:453
 msgid "Warn about features not present in traditional C"
@@ -16520,9 +16512,8 @@
 msgstr "Aktifkan Objectif-C setjmp eksepsi penanganan waktu-jalan"
 
 #: c.opt:694
-#, fuzzy
 msgid "Enable OpenMP (implies -frecursive in Fortran)"
-msgstr "Aktifkan OpenMP (juga sets frecursive)"
+msgstr "Aktifkan OpenMP (mengindikasikan -frecursive dalam Fortran)"
 
 #: c.opt:698
 msgid "Recognize C++ keywords like \"compl\" and \"xor\""
@@ -16530,7 +16521,7 @@
 
 #: c.opt:702
 msgid "Enable optional diagnostics"
-msgstr "Aktifkan opsional diagnosa"
+msgstr "Aktifkan pilihanonal diagnosa"
 
 #: c.opt:709
 msgid "Look for and use PCH files even when preprocessing"
@@ -16674,7 +16665,7 @@
 
 #: c.opt:862
 msgid "Specify <path> as a prefix for next two options"
-msgstr "Spesifikasikan <jalur> sebagai sebuah prefix untuk dua opsi berikutnya"
+msgstr "Spesifikasikan <jalur> sebagai sebuah prefix untuk dua pilihan berikutnya"
 
 #: c.opt:866
 msgid "Set <dir> to be the system root directory"
@@ -16774,7 +16765,7 @@
 
 #: ada/gcc-interface/lang.opt:100
 msgid "Specify options to GNAT"
-msgstr "Spesifikasikan opsi ke GNAT"
+msgstr "Spesifikasikan pilihan ke GNAT"
 
 #: attribs.c:284
 #, gcc-internal-format
@@ -17277,7 +17268,7 @@
 #: c-common.c:4763
 #, gcc-internal-format
 msgid "multiple default labels in one switch"
-msgstr "multiple default label dalam satu opsi"
+msgstr "multiple default label dalam satu pilihan"
 
 #: c-common.c:4764
 #, gcc-internal-format
@@ -17642,12 +17633,12 @@
 #: c-common.c:7074
 #, gcc-internal-format
 msgid "Bad option %s to optimize attribute."
-msgstr "Opsi %s buruk untuk mengoptimasi atribut."
+msgstr "Pilihan %s buruk untuk mengoptimasi atribut."
 
 #: c-common.c:7077
 #, gcc-internal-format
 msgid "Bad option %s to pragma attribute"
-msgstr "Opsi %s buruk untuk atribut pragma"
+msgstr "Pilihan %s buruk untuk atribut pragma"
 
 #: c-common.c:7270
 #, gcc-internal-format
@@ -18551,9 +18542,9 @@
 
 #. C99 6.7.5.2p4
 #: c-decl.c:4431
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%<[*]%> not in a declaration"
-msgstr "%<[*]%> tidak diperbolehkan selain dari sebuah deklarasi"
+msgstr "%<[*]%> tidak dalam sebuah deklarasi"
 
 #: c-decl.c:4444
 #, gcc-internal-format
@@ -18985,7 +18976,7 @@
 #: c-decl.c:6859
 #, gcc-internal-format
 msgid "use option -std=c99 or -std=gnu99 to compile your code"
-msgstr "gunakan opsi -std=c99 atau -std=gnu99 untuk mengkompile kode anda"
+msgstr "gunakan pilihan -std=c99 atau -std=gnu99 untuk mengkompile kode anda"
 
 #: c-decl.c:6890
 #, gcc-internal-format
@@ -19897,7 +19888,7 @@
 #: c-opts.c:324
 #, gcc-internal-format
 msgid "obsolete option -I- used, please use -iquote instead"
-msgstr "opsi ditinggalkan -I- digunakan, lebih baik mohon gunakan -iquote"
+msgstr "pilihan ditinggalkan -I- digunakan, lebih baik mohon gunakan -iquote"
 
 #: c-opts.c:495
 #, gcc-internal-format
@@ -19907,7 +19898,7 @@
 #: c-opts.c:582
 #, gcc-internal-format
 msgid "switch %qs is no longer supported"
-msgstr "opsi %qs tidak lagi didukung"
+msgstr "pilihan %qs tidak lagi didukung"
 
 #: c-opts.c:689
 #, gcc-internal-format
@@ -19962,22 +19953,22 @@
 #: c-opts.c:1226
 #, gcc-internal-format
 msgid "The C parser does not support -dy, option ignored"
-msgstr "C parser tidak mendukung -dy, opsi diabaikan"
+msgstr "C parser tidak mendukung -dy, pilihan diabaikan"
 
 #: c-opts.c:1230
 #, gcc-internal-format
 msgid "The Objective-C parser does not support -dy, option ignored"
-msgstr "Objective-C parser tidak mendukung -dy, opsi diabaikan"
+msgstr "Objective-C parser tidak mendukung -dy, pilihan diabaikan"
 
 #: c-opts.c:1233
 #, gcc-internal-format
 msgid "The C++ parser does not support -dy, option ignored"
-msgstr "C++ parser tidak mendukung -dy, opsi diabaikan"
+msgstr "C++ parser tidak mendukung -dy, pilihan diabaikan"
 
 #: c-opts.c:1237
 #, gcc-internal-format
 msgid "The Objective-C++ parser does not support -dy, option ignored"
-msgstr "Objective-C++ parser tidak mendukung -dy, opsi diabaikan"
+msgstr "Objective-C++ parser tidak mendukung -dy, pilihan diabaikan"
 
 #: c-opts.c:1287
 #, gcc-internal-format
@@ -20734,12 +20725,12 @@
 #: c-pragma.c:852
 #, gcc-internal-format
 msgid "missing option after %<#pragma GCC diagnostic%> kind"
-msgstr "hilang jenis opsi setelah %<#pragma GCC diagnosa%>"
+msgstr "hilang jenis pilihan setelah %<#pragma GCC diagnosa%>"
 
 #: c-pragma.c:866
 #, gcc-internal-format
 msgid "unknown option after %<#pragma GCC diagnostic%> kind"
-msgstr "jenis opsi tidak dikenal setelah %<#pragma GCC diagnosa%>"
+msgstr "jenis pilihan tidak dikenal setelah %<#pragma GCC diagnosa%>"
 
 #: c-pragma.c:879
 #, gcc-internal-format
@@ -21553,7 +21544,7 @@
 #: c-typeck.c:7375
 #, gcc-internal-format
 msgid "%<long%> switch expression not converted to %<int%> in ISO C"
-msgstr "opsi %<long%> ekspresi tidak diubah ke %<int%> dalam ISO C"
+msgstr "pilihan %<long%> ekspresi tidak diubah ke %<int%> dalam ISO C"
 
 #: c-typeck.c:7418
 #, gcc-internal-format
@@ -22616,17 +22607,17 @@
 #: gcc.c:1325
 #, gcc-internal-format
 msgid "incomplete '%s' option"
-msgstr "opsi '%s' tidak lengkap"
+msgstr "pilihan '%s' tidak lengkap"
 
 #: gcc.c:1336
 #, gcc-internal-format
 msgid "missing argument to '%s' option"
-msgstr "hilang argumen ke opsi '%s'"
+msgstr "hilang argumen ke pilihan '%s'"
 
 #: gcc.c:1349
 #, gcc-internal-format
 msgid "extraneous argument to '%s' option"
-msgstr "kelebihan argumen ke opsi '%s'"
+msgstr "kelebihan argumen ke pilihan '%s'"
 
 #: gcc.c:4029
 #, gcc-internal-format
@@ -22654,7 +22645,7 @@
 #: gcc.c:5495
 #, gcc-internal-format
 msgid "spec failure: unrecognized spec option '%c'"
-msgstr "spec gagal: opsi spec tidak dikenal '%c'"
+msgstr "spec gagal: pilihan spec tidak dikenal '%c'"
 
 #: gcc.c:6401
 #, gcc-internal-format
@@ -22669,7 +22660,7 @@
 #: gcc.c:6511
 #, gcc-internal-format
 msgid "unrecognized option '-%s'"
-msgstr "opsi '-%s' tidak dikenal"
+msgstr "pilihan '-%s' tidak dikenal"
 
 #: gcc.c:6726 gcc.c:6789
 #, gcc-internal-format
@@ -22884,17 +22875,17 @@
 #: opts.c:442
 #, gcc-internal-format
 msgid "command line option \"%s\" is valid for %s but not for %s"
-msgstr "opsi baris perintah \"%s\" valid untuk %s tetapi tidak untuk %s"
+msgstr "pilihan baris perintah \"%s\" valid untuk %s tetapi tidak untuk %s"
 
 #: opts.c:473 opts.c:769
 #, gcc-internal-format
 msgid "unrecognized command line option \"%s\""
-msgstr "opsi baris perintah \"%s\" tidak dikenal"
+msgstr "pilihan baris perintah \"%s\" tidak dikenal"
 
 #: opts.c:534
 #, gcc-internal-format
 msgid "command line option %qs is not supported by this configuration"
-msgstr "opsi baris perintah %qs tidak didukung dalam konfigurasi ini"
+msgstr "pilihan baris perintah %qs tidak didukung dalam konfigurasi ini"
 
 #: opts.c:587
 #, gcc-internal-format
@@ -22937,9 +22928,9 @@
 msgstr "-freorder-blocks-and-partition tidak bekerja dalam arsitektur ini"
 
 #: opts.c:1081
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "-fira-algorithm=CB does not work on this architecture"
-msgstr "-fira tidak bekerja dalam arsitektur ini"
+msgstr "-fira-algorithm=CB tidak bekerja dalam arsitektur ini"
 
 #: opts.c:1390
 #, gcc-internal-format
@@ -22977,9 +22968,9 @@
 msgstr "algoritma ira \"%s\" tidak diketahui"
 
 #: opts.c:1980
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "unknown ira region \"%s\""
-msgstr "algoritma ira \"%s\" tidak diketahui"
+msgstr "daerah ira \"%s\" tidak diketahui"
 
 #: opts.c:2083
 #, gcc-internal-format
@@ -23014,7 +23005,7 @@
 #: opts.c:2313
 #, gcc-internal-format
 msgid "-Werror=%s: No option -%s"
-msgstr "-Werror=%s: Tidak ada opsi -%s"
+msgstr "-Werror=%s: Tidak ada pilihan -%s"
 
 #: params.c:69
 #, gcc-internal-format
@@ -23399,7 +23390,7 @@
 #: stor-layout.c:969
 #, gcc-internal-format
 msgid "Offset of packed bit-field %qD has changed in GCC 4.4"
-msgstr ""
+msgstr "Offset dari packet bit-field %qD telah berubah dalam GCC 4.4"
 
 #: stor-layout.c:1273
 #, gcc-internal-format
@@ -23464,7 +23455,7 @@
 #: toplev.c:519
 #, gcc-internal-format
 msgid "invalid option argument %qs"
-msgstr "opsi argumen %qs tidak valid"
+msgstr "pilihan argumen %qs tidak valid"
 
 #: toplev.c:617
 #, gcc-internal-format
@@ -23514,7 +23505,7 @@
 #: toplev.c:1090
 #, gcc-internal-format
 msgid "unrecognized gcc debugging option: %c"
-msgstr "opsi debuggin gcc: %c tidak dikenal"
+msgstr "pilihan debuggin gcc: %c tidak dikenal"
 
 #: toplev.c:1347
 #, gcc-internal-format
@@ -23589,7 +23580,7 @@
 #: toplev.c:1920
 #, gcc-internal-format
 msgid "-fprefetch-loop-arrays not supported for this target (try -march switches)"
-msgstr "-fprefetch-loop-array tidak didukung untuk target ini (coba opsi -march)"
+msgstr "-fprefetch-loop-array tidak didukung untuk target ini (coba pilihan -march)"
 
 #: toplev.c:1929
 #, gcc-internal-format
@@ -23599,7 +23590,7 @@
 #: toplev.c:1940
 #, gcc-internal-format
 msgid "-fassociative-math disabled; other options take precedence"
-msgstr "-fassociative-math non-aktif; opsi lain mengambil prioritas"
+msgstr "-fassociative-math non-aktif; pilihan lain mengambil prioritas"
 
 #: toplev.c:1956
 #, gcc-internal-format
@@ -23632,9 +23623,9 @@
 msgstr "SSA nama dalam daftar bebas tetapi tetap direferensikan"
 
 #: tree-cfg.c:2829
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "Indirect reference's operand is not a register or a constant."
-msgstr "%s: Sumber operan ketiga bukan sebuah konstanta"
+msgstr "Referensi tidak langsung operan bukan sebuah register atau konstanta."
 
 #: tree-cfg.c:2838
 #, gcc-internal-format
@@ -23644,7 +23635,7 @@
 #: tree-cfg.c:2844
 #, gcc-internal-format
 msgid "MODIFY_EXPR not expected while having tuples."
-msgstr ""
+msgstr "MODIFY_EXPR tidak terduga ketika memiliki tuples."
 
 #: tree-cfg.c:2865
 #, gcc-internal-format
@@ -24079,7 +24070,7 @@
 #: tree-dump.c:1060
 #, gcc-internal-format
 msgid "ignoring unknown option %q.*s in %<-fdump-%s%>"
-msgstr "mengabaikan opsi tidak dikenal %q.*s dalam %<-fdump-%s%>"
+msgstr "mengabaikan pilihan tidak dikenal %q.*s dalam %<-fdump-%s%>"
 
 #: tree-eh.c:1993
 #, gcc-internal-format
@@ -24244,19 +24235,19 @@
 msgstr "fungsionalitas tidak terimplementasi"
 
 #: tree-ssa-structalias.c:4791
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "initialized from %qE"
-msgstr "tidak terinisialisasi const %qD"
+msgstr "terinisialisasi dari %qE"
 
 #: tree-ssa-structalias.c:4795
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "initialized from here"
-msgstr "dipanggil dari sini"
+msgstr "terinisialisasi dari sini"
 
 #: tree-ssa-structalias.c:4844
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "dereferencing pointer %qD does break strict-aliasing rules"
-msgstr "dereferencing tipe-punned penunjuk %D akan melanggar aturan strict aliasing"
+msgstr "dereferencing penunjuk %qD akan melanggar aturan strict aliasing"
 
 #: tree-ssa.c:252
 #, gcc-internal-format
@@ -24782,13 +24773,13 @@
 #: config/darwin-c.c:85
 #, gcc-internal-format
 msgid "too many #pragma options align=reset"
-msgstr "terlalu banyak opsi #pragma align=reset"
+msgstr "terlalu banyak pilihan #pragma align=reset"
 
 #: config/darwin-c.c:105 config/darwin-c.c:108 config/darwin-c.c:110
 #: config/darwin-c.c:112
 #, gcc-internal-format
 msgid "malformed '#pragma options', ignoring"
-msgstr "salah bentuk '#pragma opsi', diabaikan"
+msgstr "salah bentuk '#pragma pilihan', diabaikan"
 
 #: config/darwin-c.c:115
 #, gcc-internal-format
@@ -24944,7 +24935,7 @@
 #: config/alpha/alpha.c:233 config/rs6000/rs6000.c:2193
 #, gcc-internal-format
 msgid "bad value %qs for -mtls-size switch"
-msgstr "nilai buruk %qs untuk opsi -mtls-size"
+msgstr "nilai buruk %qs untuk pilihan -mtls-size"
 
 #: config/alpha/alpha.c:287
 #, gcc-internal-format
@@ -24964,22 +24955,22 @@
 #: config/alpha/alpha.c:339
 #, gcc-internal-format
 msgid "bad value %qs for -mtrap-precision switch"
-msgstr "nilai buruk %qs untuk opsi -mtrap-precision"
+msgstr "nilai buruk %qs untuk pilihan -mtrap-precision"
 
 #: config/alpha/alpha.c:353
 #, gcc-internal-format
 msgid "bad value %qs for -mfp-rounding-mode switch"
-msgstr "nilai buruk %qs untuk opsi -mfp-rounding-mode"
+msgstr "nilai buruk %qs untuk pilihan -mfp-rounding-mode"
 
 #: config/alpha/alpha.c:368
 #, gcc-internal-format
 msgid "bad value %qs for -mfp-trap-mode switch"
-msgstr "nilai buruk %qs untuk opsi -mfp-trap-mode"
+msgstr "nilai buruk %qs untuk pilihan -mfp-trap-mode"
 
 #: config/alpha/alpha.c:382 config/alpha/alpha.c:394
 #, gcc-internal-format
 msgid "bad value %qs for -mcpu switch"
-msgstr "nilai buruk %qs untuk opsi -mcpu"
+msgstr "nilai buruk %qs untuk pilihan -mcpu"
 
 #: config/alpha/alpha.c:401
 #, gcc-internal-format
@@ -25035,17 +25026,17 @@
 #: config/arm/arm.c:1182
 #, gcc-internal-format
 msgid "switch -mcpu=%s conflicts with -march= switch"
-msgstr "opsi -mcpu=%s konflik dengan opsi -march="
+msgstr "pilihan -mcpu=%s konflik dengan pilihan -march="
 
 #: config/arm/arm.c:1192 config/rs6000/rs6000.c:1593 config/sparc/sparc.c:764
 #, gcc-internal-format
 msgid "bad value (%s) for %s switch"
-msgstr "nilai (%s) buruk untuk opsi %s"
+msgstr "nilai (%s) buruk untuk pilihan %s"
 
 #: config/arm/arm.c:1305
 #, gcc-internal-format
 msgid "invalid ABI option: -mabi=%s"
-msgstr "opsi ABI tidak valid: -mabi=%s"
+msgstr "pilihan ABI tidak valid: -mabi=%s"
 
 #: config/arm/arm.c:1313
 #, gcc-internal-format
@@ -25115,12 +25106,12 @@
 #: config/arm/arm.c:1445
 #, gcc-internal-format
 msgid "invalid floating point emulation option: -mfpe=%s"
-msgstr "opsi emulasi titik pecahan tidak valid: -mfpe=%s"
+msgstr "pilihan emulasi titik pecahan tidak valid: -mfpe=%s"
 
 #: config/arm/arm.c:1462
 #, gcc-internal-format
 msgid "invalid floating point option: -mfpu=%s"
-msgstr "opsi titik pecahan tidak valid: -mfpu=%s"
+msgstr "pilihan titik pecahan tidak valid: -mfpu=%s"
 
 #: config/arm/arm.c:1502
 #, gcc-internal-format
@@ -25145,7 +25136,7 @@
 #: config/arm/arm.c:1542
 #, gcc-internal-format
 msgid "invalid thread pointer option: -mtp=%s"
-msgstr "opsi thread pointer tidak valid: -mtp=%s"
+msgstr "pilihan thread pointer tidak valid: -mtp=%s"
 
 #: config/arm/arm.c:1555
 #, gcc-internal-format
@@ -25224,7 +25215,7 @@
 #: config/arm/arm.c:19618
 #, gcc-internal-format
 msgid "the mangling of %<va_list%> has changed in GCC 4.4"
-msgstr ""
+msgstr "mangling dari %<va_list%> telah berubah dalam GCC 4.4"
 
 #: config/arm/pe.c:158 config/mcore/mcore.c:2900
 #, gcc-internal-format
@@ -25239,17 +25230,17 @@
 #: config/avr/avr.c:399
 #, gcc-internal-format
 msgid "the -mno-tablejump switch is deprecated"
-msgstr ""
+msgstr "pilihan -mno-tablejump sudah ditinggalkan"
 
 #: config/avr/avr.c:400
 #, gcc-internal-format
 msgid "GCC 4.4 is the last release with this switch"
-msgstr ""
+msgstr "GCC 4.4 adalah keluaran terakhir dengan pilihan ini"
 
 #: config/avr/avr.c:401
 #, gcc-internal-format
 msgid "use the -fno-jump-tables switch instead"
-msgstr ""
+msgstr "lebih baik gunakan pilihan -fno-jump-tables"
 
 #: config/avr/avr.c:4626
 #, gcc-internal-format
@@ -25419,7 +25410,7 @@
 #: config/cris/cris.c:2454
 #, gcc-internal-format
 msgid "that particular -g option is invalid with -maout and -melinux"
-msgstr "opsi -g tertentu tidak valid dengan -maout dan -melinux"
+msgstr "pilihan -g tertentu tidak valid dengan -maout dan -melinux"
 
 #: config/cris/cris.c:2680
 #, gcc-internal-format
@@ -25608,12 +25599,12 @@
 #: config/i386/i386.c:2713
 #, gcc-internal-format
 msgid "generic CPU can be used only for %stune=%s %s"
-msgstr "CPU generik hanya dapat digunakan untuk opsi %stune=%s %s"
+msgstr "CPU generik hanya dapat digunakan untuk pilihan %stune=%s %s"
 
 #: config/i386/i386.c:2716 config/i386/i386.c:2844
 #, gcc-internal-format
 msgid "bad value (%s) for %sarch=%s %s"
-msgstr "nilai (%s) buruk untuk opsi %sarch=%s %s"
+msgstr "nilai (%s) buruk untuk pilihan %sarch=%s %s"
 
 #: config/i386/i386.c:2728
 #, gcc-internal-format
@@ -25623,12 +25614,12 @@
 #: config/i386/i386.c:2734
 #, gcc-internal-format
 msgid "bad value (%s) for %scmodel=%s %s"
-msgstr "nilai (%s) buruk untuk opsi %scmodel=%s %s"
+msgstr "nilai (%s) buruk untuk pilihan %scmodel=%s %s"
 
 #: config/i386/i386.c:2758
 #, gcc-internal-format
 msgid "bad value (%s) for %sasm=%s %s"
-msgstr "nilai (%s) buruk untuk opsi %sasm=%s %s"
+msgstr "nilai (%s) buruk untuk pilihan %sasm=%s %s"
 
 #: config/i386/i386.c:2762
 #, gcc-internal-format
@@ -25656,9 +25647,9 @@
 msgstr "%sregparm=%d%s tidak berada diantara 0 dan %d"
 
 #: config/i386/i386.c:2918
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%salign-loops%s is obsolete, use -falign-loops%s"
-msgstr "%salign-loops%s sudah ditinggalkan, gunakan %salign-loops%s"
+msgstr "%salign-loops%s sudah ditinggalkan, gunakan -falign-loops%s"
 
 #: config/i386/i386.c:2924 config/i386/i386.c:2939 config/i386/i386.c:2954
 #, gcc-internal-format
@@ -25666,14 +25657,14 @@
 msgstr "%salign-loops=%d%s tidak berada diantara 0 dan %d"
 
 #: config/i386/i386.c:2933
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%salign-jumps%s is obsolete, use -falign-jumps%s"
-msgstr "%salign-jumps%s sudah ditinggalkan, gunakan %salign-jumps%s"
+msgstr "%salign-jumps%s sudah ditinggalkan, gunakan -falign-jumps%s"
 
 #: config/i386/i386.c:2948
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%salign-functions%s is obsolete, use -falign-functions%s"
-msgstr "%salign-functions%s sudah ditinggalkan, gunakan %salign-functions%s"
+msgstr "%salign-functions%s sudah ditinggalkan, gunakan -falign-functions%s"
 
 #: config/i386/i386.c:2983
 #, gcc-internal-format
@@ -25688,7 +25679,7 @@
 #: config/i386/i386.c:3005
 #, gcc-internal-format
 msgid "bad value (%s) for %stls-dialect=%s %s"
-msgstr "nilai (%s) buruk untuk opsi %stls-dialect=%s %s"
+msgstr "nilai (%s) buruk untuk pilihan %stls-dialect=%s %s"
 
 #: config/i386/i386.c:3013
 #, gcc-internal-format
@@ -25728,12 +25719,12 @@
 #: config/i386/i386.c:3155
 #, gcc-internal-format
 msgid "bad value (%s) for %sfpmath=%s %s"
-msgstr "nilai (%s) buruk untuk opsi %sfpmath=%s %s"
+msgstr "nilai (%s) buruk untuk pilihan %sfpmath=%s %s"
 
 #: config/i386/i386.c:3171
 #, gcc-internal-format
 msgid "unknown vectorization library ABI type (%s) for %sveclibabi=%s %s"
-msgstr "perpusatakaan vektorisasi tidak dikenal tipe ABI (%s) untuk opsi %sveclibabi=%s %s"
+msgstr "perpusatakaan vektorisasi tidak dikenal tipe ABI (%s) untuk pilihan %sveclibabi=%s %s"
 
 #: config/i386/i386.c:3191
 #, gcc-internal-format
@@ -25753,7 +25744,7 @@
 #: config/i386/i386.c:3637
 #, gcc-internal-format
 msgid "option(\"%s\") was already specified"
-msgstr "opsi(\"%s\") telah dispesifikasikan"
+msgstr "pilihan(\"%s\") telah dispesifikasikan"
 
 #: config/i386/i386.c:4231 config/i386/i386.c:4275
 #, gcc-internal-format
@@ -25808,7 +25799,7 @@
 #: config/i386/i386.c:4722
 #, gcc-internal-format
 msgid "ms_abi attribute requires -maccumulate-outgoing-args or subtarget optimization implying it"
-msgstr ""
+msgstr "atribut ms_abi membutuhkan -maccumulate-outgoing-args atau mengindikasikan optimasi subtarget"
 
 #: config/i386/i386.c:4840
 #, gcc-internal-format
@@ -25818,17 +25809,17 @@
 #: config/i386/i386.c:5020
 #, gcc-internal-format
 msgid "The ABI of passing struct with a flexible array member has changed in GCC 4.4"
-msgstr ""
+msgstr "ABI dari melewatkan struct dengan sebuah anggota array flexible telah berubah dalam GCC 4.4"
 
 #: config/i386/i386.c:5139
 #, gcc-internal-format
 msgid "The ABI of passing union with long double has changed in GCC 4.4"
-msgstr ""
+msgstr "ABI dari melewatkan union dengan long double telah berubah dalam GCC 4.4"
 
 #: config/i386/i386.c:5254
 #, gcc-internal-format
 msgid "The ABI of passing structure with complex float member has changed in GCC 4.4"
-msgstr ""
+msgstr "ABI dari melewatkan structure dengan anggota float kompleks telah berubah dalam GCC 4.4"
 
 #: config/i386/i386.c:5399
 #, gcc-internal-format
@@ -25928,12 +25919,12 @@
 #: config/i386/i386.c:24864
 #, gcc-internal-format
 msgid "%qE needs unknown isa option"
-msgstr "%qE membutuhkan opsi isa tidak diketahui"
+msgstr "%qE membutuhkan pilihan isa tidak diketahui"
 
 #: config/i386/i386.c:24868
 #, gcc-internal-format
 msgid "%qE needs isa option %s"
-msgstr "%qE membutuhkan opsi isa %s"
+msgstr "%qE membutuhkan pilihan isa %s"
 
 #: config/i386/i386.c:26511
 #, gcc-internal-format
@@ -25988,7 +25979,7 @@
 #: config/i386/djgpp.h:180
 #, gcc-internal-format
 msgid "-mbnu210 is ignored (option is obsolete)"
-msgstr "-mbnu210 diabaikan (opsi ini sudah ditinggalkan)"
+msgstr "-mbnu210 diabaikan (pilihan ini sudah ditinggalkan)"
 
 #: config/i386/i386-interix.h:256
 #, gcc-internal-format
@@ -26035,22 +26026,22 @@
 #: config/ia64/ia64.c:5225
 #, gcc-internal-format
 msgid "bad value %<%s%> for -mtls-size= switch"
-msgstr "nilai %<%s%> buruk untuk opsi -mtls-size="
+msgstr "nilai %<%s%> buruk untuk pilihan -mtls-size="
 
 #: config/ia64/ia64.c:5254
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "value %<%s%> for -mtune= switch is deprecated"
-msgstr "nilai %<%s%> buruk untuk opsi -mtune="
+msgstr "nilai %<%s%> untuk pilihan -mtune= sudah ditinggalkan"
 
 #: config/ia64/ia64.c:5256
 #, gcc-internal-format
 msgid "GCC 4.4 is the last release with Itanium1 tuning support"
-msgstr ""
+msgstr "GCC 4.4 adalah keluaran terakhir dengan dukungan penyesuaian Itanium1"
 
 #: config/ia64/ia64.c:5263
 #, gcc-internal-format
 msgid "bad value %<%s%> for -mtune= switch"
-msgstr "nilai %<%s%> buruk untuk opsi -mtune="
+msgstr "nilai %<%s%> buruk untuk pilihan -mtune="
 
 #: config/ia64/ia64.c:5282
 #, gcc-internal-format
@@ -26235,7 +26226,7 @@
 #: config/mips/mips.c:13777
 #, gcc-internal-format
 msgid "%<-%s%> conflicts with the other architecture options, which specify a %s processor"
-msgstr "%<-%s%> konflik dengan opsi arsitektur lain, yang menspesifikasikan sebuah %s prosesor"
+msgstr "%<-%s%> konflik dengan pilihan arsitektur lain, yang menspesifikasikan sebuah %s prosesor"
 
 #: config/mips/mips.c:13793
 #, gcc-internal-format
@@ -26388,7 +26379,7 @@
 #: config/pa/pa.c:494
 #, gcc-internal-format
 msgid "-g option disabled"
-msgstr "-g opsi tidak aktif"
+msgstr "-g pilihan tidak aktif"
 
 #: config/pa/pa.c:8388
 #, gcc-internal-format
@@ -26398,7 +26389,7 @@
 #: config/pa/pa-hpux11.h:84
 #, gcc-internal-format
 msgid "-munix=98 option required for C89 Amendment 1 features.\n"
-msgstr "-munix=98 opsi dibutuhkan untuk feature C89 Amendment 1.\n"
+msgstr "-munix=98 pilihan dibutuhkan untuk feature C89 Amendment 1.\n"
 
 #: config/picochip/picochip.c:379
 #, gcc-internal-format
@@ -26489,7 +26480,7 @@
 #: config/picochip/picochip.c:4128
 #, gcc-internal-format
 msgid "%s (disable warning using -mno-inefficient-warnings)"
-msgstr "%s (Non-aktifkan peringatan menggunakan opsi -mno-inefficient-warnings)"
+msgstr "%s (Non-aktifkan peringatan menggunakan pilihan -mno-inefficient-warnings)"
 
 #: config/rs6000/host-darwin.c:62
 #, gcc-internal-format
@@ -26618,7 +26609,7 @@
 #: config/rs6000/rs6000.c:1655
 #, gcc-internal-format
 msgid "unknown -mdebug-%s switch"
-msgstr "opsi -mdebug-%s tidak dikenal"
+msgstr "pilihan -mdebug-%s tidak dikenal"
 
 #: config/rs6000/rs6000.c:1667
 #, gcc-internal-format
@@ -26628,12 +26619,12 @@
 #: config/rs6000/rs6000.c:2176
 #, gcc-internal-format
 msgid "unknown -m%s= option specified: '%s'"
-msgstr "opsi -m%s= tidak diketahui dispesifikasikan: '%s'"
+msgstr "pilihan -m%s= tidak diketahui dispesifikasikan: '%s'"
 
 #: config/rs6000/rs6000.c:2222
 #, gcc-internal-format
 msgid "unknown value %s for -mfpu"
-msgstr "nilai %s tidak diketahui untuk opsi -mfpu"
+msgstr "nilai %s tidak diketahui untuk pilihan -mfpu"
 
 #: config/rs6000/rs6000.c:2415
 #, gcc-internal-format
@@ -26668,12 +26659,12 @@
 #: config/rs6000/rs6000.c:2478
 #, gcc-internal-format
 msgid "invalid option for -mfloat-gprs: '%s'"
-msgstr "opsi untuk -mfloat-gprs tidak valid: '%s'"
+msgstr "pilihan untuk -mfloat-gprs tidak valid: '%s'"
 
 #: config/rs6000/rs6000.c:2488
 #, gcc-internal-format
 msgid "Unknown switch -mlong-double-%s"
-msgstr "opsi -mlong-double-%s tidak diketahui"
+msgstr "pilihan -mlong-double-%s tidak diketahui"
 
 #: config/rs6000/rs6000.c:2509
 #, gcc-internal-format
@@ -26683,17 +26674,17 @@
 #: config/rs6000/rs6000.c:2517
 #, gcc-internal-format
 msgid "unknown -malign-XXXXX option specified: '%s'"
-msgstr "opsi -malign-XXXXX tidak diketahui dispesifikasikan: '%s'"
+msgstr "pilihan -malign-XXXXX tidak diketahui dispesifikasikan: '%s'"
 
 #: config/rs6000/rs6000.c:2524
 #, gcc-internal-format
 msgid "-msingle-float option equivalent to -mhard-float"
-msgstr "opsi -msingle-float ekuivalen dengan -mhard-float"
+msgstr "pilihan -msingle-float ekuivalen dengan -mhard-float"
 
 #: config/rs6000/rs6000.c:2540
 #, gcc-internal-format
 msgid "-msimple-fpu option ignored"
-msgstr "opsi -msimple-fpu diabaikan"
+msgstr "pilihan -msimple-fpu diabaikan"
 
 #: config/rs6000/rs6000.c:5376
 #, gcc-internal-format
@@ -27177,7 +27168,7 @@
 #: config/sparc/sparc.c:728
 #, gcc-internal-format
 msgid "bad value (%s) for -mcmodel= switch"
-msgstr "nilai (%s) buruk untuk opsi -mcmodel="
+msgstr "nilai (%s) buruk untuk pilihan -mcmodel="
 
 #: config/sparc/sparc.c:733
 #, gcc-internal-format
@@ -27242,7 +27233,7 @@
 #: config/stormy16/stormy16.c:1875
 #, gcc-internal-format
 msgid "switch statement of size %lu entries too large"
-msgstr "pernyataan opsi dari ukuran %lu masukan terlalu besar"
+msgstr "pernyataan pilihan dari ukuran %lu masukan terlalu besar"
 
 #: config/stormy16/stormy16.c:2244
 #, gcc-internal-format
@@ -27377,7 +27368,7 @@
 #: config/xtensa/xtensa.c:2061
 #, gcc-internal-format
 msgid "boolean registers required for the floating-point option"
-msgstr "register boolean dibutuhkan untuk opsi titik pecahan"
+msgstr "register boolean dibutuhkan untuk pilihan titik pecahan"
 
 #: config/xtensa/xtensa.c:2096
 #, gcc-internal-format
@@ -27577,9 +27568,9 @@
 msgstr "mengubah %<false%> ke tipe penunjuk untuk argumen %P dari %qD"
 
 #: cp/call.c:4573
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "too many braces around initializer for %qT"
-msgstr "hilang kurung diantara penginisialisasi untuk %qT"
+msgstr "terlalu banyak kurung diantara penginisialisasi untuk %qT"
 
 #: cp/call.c:4595 cp/cvt.c:217
 #, gcc-internal-format
@@ -27698,19 +27689,19 @@
 msgstr "  karena urutan konversi untuk argumen lebih baik"
 
 #: cp/call.c:6899
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "default argument mismatch in overload resolution"
-msgstr "argumen baku dispesifikasikan dalam spesialisasi eksplisit"
+msgstr "argumen baku tidak cocok dalam kelebihan beban resolusi"
 
 #: cp/call.c:6902
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid " candidate 1: %q+#F"
-msgstr "kandidat adalah: %+#D"
+msgstr " kandidat 1: %q+#F"
 
 #: cp/call.c:6904
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid " candidate 2: %q+#F"
-msgstr "kandidat adalah: %+#D"
+msgstr " kandidat 2: %q+#F"
 
 #: cp/call.c:6942
 #, gcc-internal-format
@@ -28707,9 +28698,9 @@
 msgstr "tidak dapat menginisialisasi %qT dari %qT"
 
 #: cp/decl.c:4437
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "name used in a GNU-style designated initializer for an array"
-msgstr "nama %qD digunakan dalam sebuah gaya GNU didesign penginisialisasi untuk sebuah array"
+msgstr "nama digunakan dalam sebuah gaya GNU diperuntukan penginisialisasi untuk sebuah array"
 
 #: cp/decl.c:4442
 #, gcc-internal-format
@@ -29377,9 +29368,9 @@
 msgstr "tidak dapat mendeklarasikan penunjuk ke %q#T anggota"
 
 #: cp/decl.c:8500
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "cannot declare %s to qualified function type %qT"
-msgstr "tidak dapat mendeklarasikan bit-field %qD dengan tipe fungsi"
+msgstr "tidak dapat mendeklarasikan %s untuk fungsi yang dikualifikasikan dengan tipe %qT"
 
 #: cp/decl.c:8537
 #, gcc-internal-format
@@ -29627,9 +29618,9 @@
 msgstr "%<inline%> penspesifikasi tidak valid untuk fungsi %qs dideklarasikan diluar dari lingkup global"
 
 #: cp/decl.c:9365
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%q#T is not a class or a namespace"
-msgstr "%qT bukan sebuah class atau namespace"
+msgstr "%q#T bukan sebuah kelas atau ruang nama"
 
 #: cp/decl.c:9373
 #, gcc-internal-format
@@ -29637,9 +29628,9 @@
 msgstr "virtual bukan kelas fungsi %qs"
 
 #: cp/decl.c:9380
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%qs defined in a non-class scope"
-msgstr "%qE atribut diabaikan dalam tipe bukan-class"
+msgstr "%qs didefinisikan dalam sebuah lingkup bukan kelas"
 
 #: cp/decl.c:9413
 #, gcc-internal-format
@@ -29975,9 +29966,9 @@
 msgstr "%<operator=%> seharusnya mengembalikan referensi ke %<*this%>"
 
 #: cp/decl.c:11874
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "invalid function declaration"
-msgstr "deklarasi anggota fungsi tidak valid"
+msgstr "deklarasi fungsi tidak valid"
 
 #: cp/decl.c:11958
 #, gcc-internal-format
@@ -30050,9 +30041,9 @@
 msgstr "metoda Java %qD memiliki tipe parameter %qT bukan Java"
 
 #: cp/decl2.c:579
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "template parameter lists provided don't match the template parameters of %qD"
-msgstr "parameter template tidak cocok dengan template"
+msgstr "daftar parameter template yang disediakan tidak cocok dengan paramter template dari %qD"
 
 #: cp/decl2.c:647
 #, gcc-internal-format
@@ -30368,9 +30359,9 @@
 msgstr "%J%qD seharusnya diinisialisasi dalam daftar anggota inisialisasi"
 
 #: cp/init.c:454
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%Jvalue-initialization of %q#D, which has reference type"
-msgstr "%J inisialisasi-baku dari %q#D, yang memiliki tipe referensi"
+msgstr "%Jinisialisasi-nilai dari %q#D, yang memiliki tipe referensi"
 
 #. TYPE_NEEDS_CONSTRUCTING can be set just because we have a
 #. vtable; still give this diagnostic.
@@ -30530,9 +30521,9 @@
 msgstr "permintaan untuk anggota %qD adalah ambigu"
 
 #: cp/init.c:2136
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "non-constant array size in new, unable to verify length of initializer-list"
-msgstr "indeks array bukan konstan dalam penginisialisasi"
+msgstr "bukan ukuran konstanta array dalam new, tidak dapat memverifikasi panjang dari daftar penginisialisasi"
 
 #: cp/init.c:2145
 #, gcc-internal-format
@@ -30657,17 +30648,17 @@
 #: cp/mangle.c:1903
 #, gcc-internal-format
 msgid "mangling unknown fixed point type"
-msgstr ""
+msgstr "mangling tipe fixed point tidak diketahui"
 
 #: cp/mangle.c:2332
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "mangling %C"
-msgstr "peringatan: "
+msgstr "mangling %C"
 
 #: cp/mangle.c:2387
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "mangling new-expression"
-msgstr "hilang ekspresi peningkatan"
+msgstr "mangling ekspresi-baru"
 
 #: cp/mangle.c:2407
 #, gcc-internal-format
@@ -31104,9 +31095,9 @@
 msgstr "%Htidak didukung akhiran bukan-standar di konstanta floating"
 
 #: cp/parser.c:3154
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%Hfixed-point types not supported in C++"
-msgstr "tipe titik tetap tidak didukung untuk target ini"
+msgstr "%Htipe titik tetap tidak didukung dalam C++"
 
 #: cp/parser.c:3235
 #, gcc-internal-format
@@ -31354,9 +31345,9 @@
 msgstr "gunakan %<%T::template %D%> untuk mengindikasikan bahwa ini adalah template"
 
 #: cp/parser.c:10483
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%Hexpected parameter pack before %<...%>"
-msgstr "diduga deklarasi penspesifikasi atau %<...%>"
+msgstr "%Hdiduga parameter pack sebelum %<...%>"
 
 #: cp/parser.c:10893
 #, gcc-internal-format
@@ -32127,14 +32118,14 @@
 msgstr "%qE bukan sebuah argumen template yang valid untuk tipe %qT karena objek %qD bukan eksternal linkage"
 
 #: cp/pt.c:4578
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%qE is not a valid template argument for type %qT"
-msgstr "%qE bukan sebuah argumen template yang valid untuk tipe %qT karena ini adalah sebuah penunjuk"
+msgstr "%qE bukan sebuah argumen template yang valid untuk tipe %qT"
 
 #: cp/pt.c:4579
 #, gcc-internal-format
 msgid "it must be the address of a function with external linkage"
-msgstr ""
+msgstr "ini harus berupa alamat dari sebuah fungsi dengan hubungan eksternal"
 
 #: cp/pt.c:4593
 #, gcc-internal-format
@@ -32199,9 +32190,9 @@
 #. Not sure if this is reachable, but it doesn't hurt
 #. to be robust.
 #: cp/pt.c:5091
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "type mismatch in nontype parameter pack"
-msgstr "tipe tidak cocok dalam referensi komponen"
+msgstr "tipe tidak cocok dalam paket parameter bukan tipe"
 
 #: cp/pt.c:5113
 #, gcc-internal-format
@@ -33108,9 +33099,9 @@
 msgstr "penggunaan tidak valid dari %qD"
 
 #: cp/typeck.c:2150
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "object type %qT does not match destructor name ~%qT"
-msgstr "tipe kualifikasi %qT tidak cocok dengan nama destruktor ~%qT"
+msgstr "tipe objek %qT tidak cocok dengan nama destruktor ~%qT"
 
 #: cp/typeck.c:2158
 #, gcc-internal-format
@@ -33796,9 +33787,9 @@
 msgstr "penunjuk ke anggota tipe %qT tidak kompatibel dengan tipe objek %qT"
 
 #: cp/typeck2.c:1450
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "invalid value-initialization of reference types"
-msgstr "nilai-inisialisasi dari referensi"
+msgstr "nilai-inisialisasi dari referensi tidak valid"
 
 #: cp/typeck2.c:1637
 #, gcc-internal-format
@@ -33883,12 +33874,12 @@
 #: fortran/trans-types.c:378
 #, gcc-internal-format
 msgid "integer kind=8 not available for -fdefault-integer-8 option"
-msgstr "integer kind=8 tidak tersedia untuk opsi -fdefault-integer-8"
+msgstr "integer kind=8 tidak tersedia untuk pilihan -fdefault-integer-8"
 
 #: fortran/trans-types.c:401
 #, gcc-internal-format
 msgid "real kind=8 not available for -fdefault-real-8 option"
-msgstr "real kind=8 tidak tersedia untuk opsi -fdefault-real-8"
+msgstr "real kind=8 tidak tersedia untuk pilihan -fdefault-real-8"
 
 #: fortran/trans-types.c:414
 #, gcc-internal-format
Index: gcc/varasm.c
===================================================================
--- gcc/varasm.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/varasm.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,7 +1,7 @@
 /* Output variables, constants and external declarations, for GNU compiler.
    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997,
-   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
-   Free Software Foundation, Inc.
+   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
+   2010  Free Software Foundation, Inc.
 
 This file is part of GCC.
 
@@ -2309,13 +2309,15 @@
   /* We want to output annotation for weak and external symbols at
      very last to check if they are references or not.  */
 
-  if (SUPPORTS_WEAK && DECL_WEAK (decl)
+  if (SUPPORTS_WEAK
+      && DECL_WEAK (decl)
       /* TREE_STATIC is a weird and abused creature which is not
 	 generally the right test for whether an entity has been
 	 locally emitted, inlined or otherwise not-really-extern, but
 	 for declarations that can be weak, it happens to be
 	 match.  */
-      && !TREE_STATIC (decl))
+      && !TREE_STATIC (decl)
+      && lookup_attribute ("weak", DECL_ATTRIBUTES (decl)))
     weak_decls = tree_cons (NULL, decl, weak_decls);
 
 #ifdef ASM_OUTPUT_EXTERNAL
@@ -4070,6 +4072,9 @@
 	  && !VEC_empty (constructor_elt, CONSTRUCTOR_ELTS (ctor)));
 }
 
+static tree initializer_constant_valid_p_1 (tree value, tree endtype,
+					    tree *cache);
+
 /* A subroutine of initializer_constant_valid_p.  VALUE is a MINUS_EXPR,
    PLUS_EXPR or POINTER_PLUS_EXPR.  This looks for cases of VALUE
    which are valid when ENDTYPE is an integer of any size; in
@@ -4079,7 +4084,7 @@
    returns NULL.  */
 
 static tree
-narrowing_initializer_constant_valid_p (tree value, tree endtype)
+narrowing_initializer_constant_valid_p (tree value, tree endtype, tree *cache)
 {
   tree op0, op1;
 
@@ -4118,11 +4123,14 @@
       op1 = inner;
     }
 
-  op0 = initializer_constant_valid_p (op0, endtype);
-  op1 = initializer_constant_valid_p (op1, endtype);
+  op0 = initializer_constant_valid_p_1 (op0, endtype, cache);
+  if (!op0)
+    return NULL_TREE;
 
+  op1 = initializer_constant_valid_p_1 (op1, endtype,
+					cache ? cache + 2 : NULL);
   /* Both initializers must be known.  */
-  if (op0 && op1)
+  if (op1)
     {
       if (op0 == op1
 	  && (op0 == null_pointer_node
@@ -4143,7 +4151,8 @@
   return NULL_TREE;
 }
 
-/* Return nonzero if VALUE is a valid constant-valued expression
+/* Helper function of initializer_constant_valid_p.
+   Return nonzero if VALUE is a valid constant-valued expression
    for use in initializing a static variable; one that can be an
    element of a "constant" initializer.
 
@@ -4151,10 +4160,12 @@
    if it is relocatable, return the variable that determines the relocation.
    We assume that VALUE has been folded as much as possible;
    therefore, we do not need to check for such things as
-   arithmetic-combinations of integers.  */
+   arithmetic-combinations of integers.
 
-tree
-initializer_constant_valid_p (tree value, tree endtype)
+   Use CACHE (pointer to 2 tree values) for caching if non-NULL.  */
+
+static tree
+initializer_constant_valid_p_1 (tree value, tree endtype, tree *cache)
 {
   tree ret;
 
@@ -4167,18 +4178,33 @@
 	  tree elt;
 	  bool absolute = true;
 
+	  if (cache && cache[0] == value)
+	    return cache[1];
 	  FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (value), idx, elt)
 	    {
 	      tree reloc;
-	      reloc = initializer_constant_valid_p (elt, TREE_TYPE (elt));
+	      reloc = initializer_constant_valid_p_1 (elt, TREE_TYPE (elt),
+						      NULL);
 	      if (!reloc)
-		return NULL_TREE;
+		{
+		  if (cache)
+		    {
+		      cache[0] = value;
+		      cache[1] = NULL_TREE;
+		    }
+		  return NULL_TREE;
+		}
 	      if (reloc != null_pointer_node)
 		absolute = false;
 	    }
 	  /* For a non-absolute relocation, there is no single
 	     variable that can be "the variable that determines the
 	     relocation."  */
+	  if (cache)
+	    {
+	      cache[0] = value;
+	      cache[1] = absolute ? null_pointer_node : error_mark_node;
+	    }
 	  return absolute ? null_pointer_node : error_mark_node;
 	}
 
@@ -4219,7 +4245,8 @@
       }
 
     case NON_LVALUE_EXPR:
-      return initializer_constant_valid_p (TREE_OPERAND (value, 0), endtype);
+      return initializer_constant_valid_p_1 (TREE_OPERAND (value, 0),
+					     endtype, cache);
 
     case VIEW_CONVERT_EXPR:
       {
@@ -4234,13 +4261,13 @@
 	if (AGGREGATE_TYPE_P (src_type) && !AGGREGATE_TYPE_P (dest_type))
 	  {
 	    if (TYPE_MODE (endtype) == TYPE_MODE (dest_type))
-	      return initializer_constant_valid_p (src, endtype);
+	      return initializer_constant_valid_p_1 (src, endtype, cache);
 	    else
 	      return NULL_TREE;
 	  }
 
 	/* Allow all other kinds of view-conversion.  */
-	return initializer_constant_valid_p (src, endtype);
+	return initializer_constant_valid_p_1 (src, endtype, cache);
       }
 
     CASE_CONVERT:
@@ -4255,18 +4282,18 @@
 	    || (FLOAT_TYPE_P (dest_type) && FLOAT_TYPE_P (src_type))
 	    || (TREE_CODE (dest_type) == OFFSET_TYPE
 		&& TREE_CODE (src_type) == OFFSET_TYPE))
-	  return initializer_constant_valid_p (src, endtype);
+	  return initializer_constant_valid_p_1 (src, endtype, cache);
 
 	/* Allow length-preserving conversions between integer types.  */
 	if (INTEGRAL_TYPE_P (dest_type) && INTEGRAL_TYPE_P (src_type)
 	    && (TYPE_PRECISION (dest_type) == TYPE_PRECISION (src_type)))
-	  return initializer_constant_valid_p (src, endtype);
+	  return initializer_constant_valid_p_1 (src, endtype, cache);
 
 	/* Allow conversions between other integer types only if
 	   explicit value.  */
 	if (INTEGRAL_TYPE_P (dest_type) && INTEGRAL_TYPE_P (src_type))
 	  {
-	    tree inner = initializer_constant_valid_p (src, endtype);
+	    tree inner = initializer_constant_valid_p_1 (src, endtype, cache);
 	    if (inner == null_pointer_node)
 	      return null_pointer_node;
 	    break;
@@ -4275,7 +4302,7 @@
 	/* Allow (int) &foo provided int is as wide as a pointer.  */
 	if (INTEGRAL_TYPE_P (dest_type) && POINTER_TYPE_P (src_type)
 	    && (TYPE_PRECISION (dest_type) >= TYPE_PRECISION (src_type)))
-	  return initializer_constant_valid_p (src, endtype);
+	  return initializer_constant_valid_p_1 (src, endtype, cache);
 
 	/* Likewise conversions from int to pointers, but also allow
 	   conversions from 0.  */
@@ -4289,78 +4316,120 @@
 	    if (integer_zerop (src))
 	      return null_pointer_node;
 	    else if (TYPE_PRECISION (dest_type) <= TYPE_PRECISION (src_type))
-	      return initializer_constant_valid_p (src, endtype);
+	      return initializer_constant_valid_p_1 (src, endtype, cache);
 	  }
 
 	/* Allow conversions to struct or union types if the value
 	   inside is okay.  */
 	if (TREE_CODE (dest_type) == RECORD_TYPE
 	    || TREE_CODE (dest_type) == UNION_TYPE)
-	  return initializer_constant_valid_p (src, endtype);
+	  return initializer_constant_valid_p_1 (src, endtype, cache);
       }
       break;
 
     case POINTER_PLUS_EXPR:
     case PLUS_EXPR:
+      /* Any valid floating-point constants will have been folded by now;
+	 with -frounding-math we hit this with addition of two constants.  */
+      if (TREE_CODE (endtype) == REAL_TYPE)
+	return NULL_TREE;
+      if (cache && cache[0] == value)
+	return cache[1];
       if (! INTEGRAL_TYPE_P (endtype)
 	  || TYPE_PRECISION (endtype) >= POINTER_SIZE)
 	{
-	  tree valid0 = initializer_constant_valid_p (TREE_OPERAND (value, 0),
-						      endtype);
-	  tree valid1 = initializer_constant_valid_p (TREE_OPERAND (value, 1),
-						      endtype);
+	  tree ncache[4] = { NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE };
+	  tree valid0
+	    = initializer_constant_valid_p_1 (TREE_OPERAND (value, 0),
+					      endtype, ncache);
+	  tree valid1
+	    = initializer_constant_valid_p_1 (TREE_OPERAND (value, 1),
+					      endtype, ncache + 2);
 	  /* If either term is absolute, use the other term's relocation.  */
 	  if (valid0 == null_pointer_node)
-	    return valid1;
-	  if (valid1 == null_pointer_node)
-	    return valid0;
+	    ret = valid1;
+	  else if (valid1 == null_pointer_node)
+	    ret = valid0;
+	  /* Support narrowing pointer differences.  */
+	  else
+	    ret = narrowing_initializer_constant_valid_p (value, endtype,
+							  ncache);
 	}
-
+      else
       /* Support narrowing pointer differences.  */
-      ret = narrowing_initializer_constant_valid_p (value, endtype);
-      if (ret != NULL_TREE)
-	return ret;
+	ret = narrowing_initializer_constant_valid_p (value, endtype, NULL);
+      if (cache)
+	{
+	  cache[0] = value;
+	  cache[1] = ret;
+	}
+      return ret;
 
-      break;
-
     case MINUS_EXPR:
+      if (TREE_CODE (endtype) == REAL_TYPE)
+	return NULL_TREE;
+      if (cache && cache[0] == value)
+	return cache[1];
       if (! INTEGRAL_TYPE_P (endtype)
 	  || TYPE_PRECISION (endtype) >= POINTER_SIZE)
 	{
-	  tree valid0 = initializer_constant_valid_p (TREE_OPERAND (value, 0),
-						      endtype);
-	  tree valid1 = initializer_constant_valid_p (TREE_OPERAND (value, 1),
-						      endtype);
+	  tree ncache[4] = { NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE };
+	  tree valid0
+	    = initializer_constant_valid_p_1 (TREE_OPERAND (value, 0),
+					      endtype, ncache);
+	  tree valid1
+	    = initializer_constant_valid_p_1 (TREE_OPERAND (value, 1),
+					      endtype, ncache + 2);
 	  /* Win if second argument is absolute.  */
 	  if (valid1 == null_pointer_node)
-	    return valid0;
+	    ret = valid0;
 	  /* Win if both arguments have the same relocation.
 	     Then the value is absolute.  */
-	  if (valid0 == valid1 && valid0 != 0)
-	    return null_pointer_node;
-
+	  else if (valid0 == valid1 && valid0 != 0)
+	    ret = null_pointer_node;
 	  /* Since GCC guarantees that string constants are unique in the
 	     generated code, a subtraction between two copies of the same
 	     constant string is absolute.  */
-	  if (valid0 && TREE_CODE (valid0) == STRING_CST
-	      && valid1 && TREE_CODE (valid1) == STRING_CST
-	      && operand_equal_p (valid0, valid1, 1))
-	    return null_pointer_node;
+	  else if (valid0 && TREE_CODE (valid0) == STRING_CST
+		   && valid1 && TREE_CODE (valid1) == STRING_CST
+		   && operand_equal_p (valid0, valid1, 1))
+	    ret = null_pointer_node;
+	  /* Support narrowing differences.  */
+	  else
+	    ret = narrowing_initializer_constant_valid_p (value, endtype,
+							  ncache);
 	}
+      else
+	/* Support narrowing differences.  */
+	ret = narrowing_initializer_constant_valid_p (value, endtype, NULL);
+      if (cache)
+	{
+	  cache[0] = value;
+	  cache[1] = ret;
+	}
+      return ret;
 
-      /* Support narrowing differences.  */
-      ret = narrowing_initializer_constant_valid_p (value, endtype);
-      if (ret != NULL_TREE)
-	return ret;
-
-      break;
-
     default:
       break;
     }
 
-  return 0;
+  return NULL_TREE;
 }
+
+/* Return nonzero if VALUE is a valid constant-valued expression
+   for use in initializing a static variable; one that can be an
+   element of a "constant" initializer.
+
+   Return null_pointer_node if the value is absolute;
+   if it is relocatable, return the variable that determines the relocation.
+   We assume that VALUE has been folded as much as possible;
+   therefore, we do not need to check for such things as
+   arithmetic-combinations of integers.  */
+tree
+initializer_constant_valid_p (tree value, tree endtype)
+{
+  return initializer_constant_valid_p_1 (value, endtype, NULL);
+}
 
 /* Output assembler code for constant EXP to FILE, with no label.
    This includes the pseudo-op such as ".int" or ".byte", and a newline.
@@ -4485,8 +4554,8 @@
     case REAL_TYPE:
       if (TREE_CODE (exp) != REAL_CST)
 	error ("initializer for floating value is not a floating constant");
-
-      assemble_real (TREE_REAL_CST (exp), TYPE_MODE (TREE_TYPE (exp)), align);
+      else
+	assemble_real (TREE_REAL_CST (exp), TYPE_MODE (TREE_TYPE (exp)), align);
       break;
 
     case COMPLEX_TYPE:
@@ -5002,6 +5071,9 @@
     warning (0, "weak declaration of %q+D not supported", decl);
 
   mark_weak (decl);
+  if (!lookup_attribute ("weak", DECL_ATTRIBUTES (decl)))
+    DECL_ATTRIBUTES (decl)
+      = tree_cons (get_identifier ("weak"), NULL, DECL_ATTRIBUTES (decl));
 }
 
 static void
Index: gcc/rtl.h
===================================================================
--- gcc/rtl.h	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/rtl.h	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,6 +1,6 @@
 /* Register Transfer Language (RTL) definitions for GCC
    Copyright (C) 1987, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
-   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
+   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
    Free Software Foundation, Inc.
 
 This file is part of GCC.
@@ -2305,8 +2305,6 @@
 /* In predict.c */
 extern void invert_br_probabilities (rtx);
 extern bool expensive_function_p (int);
-/* In cfgexpand.c */
-extern void add_reg_br_prob_note (rtx last, int probability);
 
 /* In var-tracking.c */
 extern unsigned int variable_tracking_main (void);
Index: gcc/tree-inline.c
===================================================================
--- gcc/tree-inline.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/tree-inline.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -2729,6 +2729,8 @@
 {
   HOST_WIDE_INT size;
 
+  gcc_assert (!VOID_TYPE_P (type));
+
   size = int_size_in_bytes (type);
 
   if (size < 0 || size > MOVE_MAX_PIECES * MOVE_RATIO (!optimize_size))
@@ -2980,7 +2982,8 @@
 	  {
 	    tree t;
 	    for (t = TYPE_ARG_TYPES (funtype); t; t = TREE_CHAIN (t))
-	      cost += estimate_move_cost (TREE_VALUE (t));
+	      if (!VOID_TYPE_P (TREE_VALUE (t)))
+		cost += estimate_move_cost (TREE_VALUE (t));
 	  }
 	else
 	  {
@@ -4268,6 +4271,46 @@
   return true;
 }
 
+/* Delete all unreachable basic blocks and update callgraph.
+   Doing so is somewhat nontrivial because we need to update all clones and
+   remove inline function that become unreachable.  */
+
+static bool
+delete_unreachable_blocks_update_callgraph (copy_body_data *id)
+{
+  bool changed = false;
+  basic_block b, next_bb;
+
+  find_unreachable_blocks ();
+
+  /* Delete all unreachable basic blocks.  */
+
+  for (b = ENTRY_BLOCK_PTR->next_bb; b != EXIT_BLOCK_PTR; b = next_bb)
+    {
+      next_bb = b->next_bb;
+
+      if (!(b->flags & BB_REACHABLE))
+	{
+          gimple_stmt_iterator bsi;
+
+          for (bsi = gsi_start_bb (b); !gsi_end_p (bsi); gsi_next (&bsi))
+	    if (gimple_code (gsi_stmt (bsi)) == GIMPLE_CALL)
+	      {
+	        struct cgraph_edge *e;
+
+	        if ((e = cgraph_edge (id->dst_node, gsi_stmt (bsi))) != NULL)
+		  cgraph_remove_edge (e);
+	      }
+	  delete_basic_block (b);
+	  changed = true;
+	}
+    }
+
+  if (changed)
+    tidy_fallthru_edges ();
+  return changed;
+}
+
 /* Create a copy of a function's tree.
    OLD_DECL and NEW_DECL are FUNCTION_DECL tree nodes
    of the original function and the new copied function
@@ -4442,7 +4485,7 @@
       free_dominance_info (CDI_DOMINATORS);
       free_dominance_info (CDI_POST_DOMINATORS);
       if (!update_clones)
-        delete_unreachable_blocks ();
+        delete_unreachable_blocks_update_callgraph (&id);
       update_ssa (TODO_update_ssa);
       if (!update_clones)
 	{
Index: gcc/combine.c
===================================================================
--- gcc/combine.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/combine.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -2445,10 +2445,16 @@
 	  i2dest = SET_DEST (temp);
 	  i2dest_killed = dead_or_set_p (i2, i2dest);
 
+          /* Replace the source in I2 with the new constant and make the
+             resulting insn the new pattern for I3.  Then skip to
+             where we validate the pattern.  Everything was set up above.  */
 	  SUBST (SET_SRC (temp),
 		 immed_double_const (olo, ohi, GET_MODE (SET_DEST (temp))));
 
 	  newpat = PATTERN (i2);
+
+          /* The dest of I3 has been replaced with the dest of I2.  */
+          changed_i3_dest = 1;
 	  goto validate_replacement;
 	}
     }
@@ -2820,8 +2826,6 @@
 	}
     }
 
-  /* We come here when we are replacing a destination in I2 with the
-     destination of I3.  */
  validate_replacement:
 
   /* Note which hard regs this insn has as inputs.  */
@@ -7039,15 +7043,14 @@
       tem = make_compound_operation (SUBREG_REG (x), in_code);
 
       {
-	rtx simplified;
-	simplified = simplify_subreg (GET_MODE (x), tem, GET_MODE (tem),
-				      SUBREG_BYTE (x));
+	rtx simplified = simplify_subreg (mode, tem, GET_MODE (SUBREG_REG (x)),
+					  SUBREG_BYTE (x));
 
 	if (simplified)
 	  tem = simplified;
 
 	if (GET_CODE (tem) != GET_CODE (SUBREG_REG (x))
-	    && GET_MODE_SIZE (mode) < GET_MODE_SIZE (GET_MODE (tem))
+	    && GET_MODE_SIZE (mode) < GET_MODE_SIZE (GET_MODE (SUBREG_REG (x)))
 	    && subreg_lowpart_p (x))
 	  {
 	    rtx newer = force_to_mode (tem, mode, ~(HOST_WIDE_INT) 0,
@@ -8512,6 +8515,12 @@
   enum rtx_code outer_code, inner_code;
   rtx decomposed, distributed, inner_op0, inner_op1, new_op0, new_op1, tmp;
 
+  /* Distributivity is not true for floating point as it can change the
+     value.  So we don't do it unless -funsafe-math-optimizations.  */
+  if (FLOAT_MODE_P (GET_MODE (x))
+      && ! flag_unsafe_math_optimizations)
+    return NULL_RTX;
+
   decomposed = XEXP (x, n);
   if (!ARITHMETIC_P (decomposed))
     return NULL_RTX;
@@ -13035,4 +13044,3 @@
   TODO_ggc_collect,                     /* todo_flags_finish */
  }
 };
-
Index: gcc/c-common.c
===================================================================
--- gcc/c-common.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/c-common.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -7633,15 +7633,14 @@
       error ("cannot apply %<offsetof%> when %<operator[]%> is overloaded");
       return error_mark_node;
 
-    case INTEGER_CST:
-      gcc_assert (integer_zerop (expr));
-      return size_zero_node;
-
     case NOP_EXPR:
     case INDIRECT_REF:
-      base = fold_offsetof_1 (TREE_OPERAND (expr, 0), stop_ref);
-      gcc_assert (base == error_mark_node || base == size_zero_node);
-      return base;
+      if (!integer_zerop (TREE_OPERAND (expr, 0)))
+	{
+	  error ("cannot apply %<offsetof%> to a non constant address");
+	  return error_mark_node;
+	}
+      return size_zero_node;
 
     case COMPONENT_REF:
       base = fold_offsetof_1 (TREE_OPERAND (expr, 0), stop_ref);
Index: gcc/config.gcc
===================================================================
--- gcc/config.gcc	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/config.gcc	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -714,7 +714,7 @@
 	case ${target} in
 	arm*-*-linux-*eabi)
 	    tm_file="$tm_file arm/bpabi.h arm/linux-eabi.h"
-	    tmake_file="$tmake_file arm/t-arm-elf arm/t-bpabi arm/t-linux-eabi"
+	    tmake_file="$tmake_file arm/t-arm-elf arm/t-bpabi arm/t-linux-eabi t-slibgcc-libgcc"
   	    # The BPABI long long divmod functions return a 128-bit value in
 	    # registers r0-r3.  Correctly modeling that requires the use of
 	    # TImode.
@@ -1088,7 +1088,7 @@
 			tmake_file="${tmake_file} i386/t-linux64"
 			need_64bit_hwint=yes
 			case X"${with_cpu}" in
-			Xgeneric|Xcore2|Xnocona|Xx86-64|Xamdfam10|Xbarcelona|Xk8|Xopteron|Xathlon64|Xathlon-fx)
+			Xgeneric|Xcore2|Xnocona|Xx86-64|Xamdfam10|Xbarcelona|Xk8|Xopteron|Xathlon64|Xathlon-fx|Xathlon64-sse3|Xk8-sse3|Xopteron-sse3)
 				;;
 			X)
 				if test x$with_cpu_64 = x; then
@@ -1097,7 +1097,7 @@
 				;;
 			*)
 				echo "Unsupported CPU used in --with-cpu=$with_cpu, supported values:" 1>&2
-				echo "generic core2 nocona x86-64 amdfam10 barcelona k8 opteron athlon64 athlon-fx" 1>&2
+				echo "generic core2 nocona x86-64 amdfam10 barcelona k8 opteron athlon64 athlon-fx athlon64-sse3 k8-sse3 opteron-sse3" 1>&2
 				exit 1
 				;;
 			esac
@@ -1202,7 +1202,7 @@
 		# libgcc/configure.ac instead.
 		need_64bit_hwint=yes
 		case X"${with_cpu}" in
-		Xgeneric|Xcore2|Xnocona|Xx86-64|Xamdfam10|Xbarcelona|Xk8|Xopteron|Xathlon64|Xathlon-fx)
+		Xgeneric|Xcore2|Xnocona|Xx86-64|Xamdfam10|Xbarcelona|Xk8|Xopteron|Xathlon64|Xathlon-fx|Xathlon64-sse3|Xk8-sse3|Xopteron-sse3)
 			;;
 		X)
 			if test x$with_cpu_64 = x; then
@@ -1211,7 +1211,7 @@
 			;;
 		*)
 			echo "Unsupported CPU used in --with-cpu=$with_cpu, supported values:" 1>&2
-			echo "generic core2 nocona x86-64 amdfam10 barcelona k8 opteron athlon64 athlon-fx" 1>&2
+			echo "generic core2 nocona x86-64 amdfam10 barcelona k8 opteron athlon64 athlon-fx athlon64-sse3 k8-sse3 opteron-sse3" 1>&2
 			exit 1
 			;;
 		esac
@@ -2191,7 +2191,7 @@
 	extra_parts="crti.o crtn.o crtbegin.o crtend.o"
 	;;
 sparc-*-linux*)		# SPARC's running GNU/Linux, libc6
-	tm_file="${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h linux.h"
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h sparc/gas.h linux.h"
 	extra_options="${extra_options} sparc/long-double-switch.opt"
 	tmake_file="${tmake_file} sparc/t-linux"
 	if test x$enable_targets = xall; then
@@ -2303,7 +2303,7 @@
 	esac
 	;;
 sparc64-*-linux*)		# 64-bit SPARC's running GNU/Linux
-	tm_file="sparc/biarch64.h ${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h linux.h sparc/linux64.h"
+	tm_file="sparc/biarch64.h ${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h sparc/gas.h linux.h sparc/linux64.h"
 	extra_options="${extra_options} sparc/long-double-switch.opt"
 	tmake_file="${tmake_file} sparc/t-linux sparc/t-linux64 sparc/t-crtfm"
 	;;
@@ -2472,7 +2472,10 @@
         amdfam10-*|barcelona-*)
           with_cpu=amdfam10
           ;;
-        k8-*|opteron-*|athlon_64-*)
+        k8_sse3-*|opteron_sse3-*|athlon64_sse3-*)
+          with_cpu=k8-sse3
+          ;;
+        k8-*|opteron-*|athlon64-*|athlon_fx-*)
           with_cpu=k8
           ;;
         athlon_xp-*|athlon_mp-*|athlon_4-*)
@@ -2518,7 +2521,10 @@
         amdfam10-*|barcelona-*)
           with_cpu=amdfam10
           ;;
-        k8-*|opteron-*|athlon_64-*)
+        k8_sse3-*|opteron_sse3-*|athlon64_sse3-*)
+          with_cpu=k8-sse3
+          ;;
+        k8-*|opteron-*|athlon64-*|athlon_fx-*)
           with_cpu=k8
           ;;
         nocona-*)
@@ -2675,7 +2681,7 @@
 
 		case "$with_fpu" in
 		"" \
-		| fpa | fpe2 | fpe3 | maverick | vfp | vfp3 | neon )
+		| fpa | fpe2 | fpe3 | maverick | vfp | vfp3 | vfpv3 | vfpv3-d16 | neon )
 			# OK
 			;;
 		*)
@@ -2812,7 +2818,7 @@
 				esac
 				# OK
 				;;
-			"" | amdfam10 | barcelona | k8 | opteron | athlon64 | athlon-fx | nocona | core2 | generic)
+			"" | amdfam10 | barcelona | k8-sse3 | opteron-sse3 | athlon64-sse3 | k8 | opteron | athlon64 | athlon-fx | nocona | core2 | generic)
 				# OK
 				;;
 			*)
Index: gcc/Makefile.in
===================================================================
--- gcc/Makefile.in	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/Makefile.in	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -3,7 +3,7 @@
 
 # Copyright (C) 1987, 1988, 1990, 1991, 1992, 1993, 1994, 1995, 1996,
 # 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
-# 2008, 2009 Free Software Foundation, Inc.
+# 2008, 2009, 2010 Free Software Foundation, Inc.
 
 #This file is part of GCC.
 
@@ -2514,7 +2514,7 @@
    tree-pass.h $(DF_H) $(DIAGNOSTIC_H) vecprim.h
 dojump.o : dojump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \
    $(FLAGS_H) $(FUNCTION_H) $(EXPR_H) $(OPTABS_H) $(INSN_ATTR_H) insn-config.h \
-   langhooks.h $(GGC_H) gt-dojump.h vecprim.h $(BASIC_BLOCK_H)
+   langhooks.h $(GGC_H) gt-dojump.h vecprim.h $(BASIC_BLOCK_H) output.h
 builtins.o : builtins.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
    $(TREE_H) $(GIMPLE_H) $(FLAGS_H) $(TARGET_H) $(FUNCTION_H) $(REGS_H) \
    $(EXPR_H) $(OPTABS_H) insn-config.h $(RECOG_H) output.h typeclass.h \
Index: gcc/tree-ssa-structalias.c
===================================================================
--- gcc/tree-ssa-structalias.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/tree-ssa-structalias.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -2803,7 +2803,7 @@
 get_constraint_for_ptr_offset (tree ptr, tree offset,
 			       VEC (ce_s, heap) **results)
 {
-  struct constraint_expr *c;
+  struct constraint_expr c;
   unsigned int j, n;
   unsigned HOST_WIDE_INT rhsunitoffset, rhsoffset;
 
@@ -2854,13 +2854,13 @@
   for (j = 0; j < n; j++)
     {
       varinfo_t curr;
-      c = VEC_index (ce_s, *results, j);
-      curr = get_varinfo (c->var);
+      c = *VEC_index (ce_s, *results, j);
+      curr = get_varinfo (c.var);
 
-      if (c->type == ADDRESSOF
+      if (c.type == ADDRESSOF
 	  && !curr->is_full_var)
 	{
-	  varinfo_t temp, curr = get_varinfo (c->var);
+	  varinfo_t temp, curr = get_varinfo (c.var);
 
 	  /* Search the sub-field which overlaps with the
 	     pointed-to offset.  As we deal with positive offsets
@@ -2896,15 +2896,17 @@
 	      c2.offset = 0;
 	      VEC_safe_push (ce_s, heap, *results, &c2);
 	    }
-	  c->var = temp->id;
-	  c->offset = 0;
+	  c.var = temp->id;
+	  c.offset = 0;
 	}
-      else if (c->type == ADDRESSOF
+      else if (c.type == ADDRESSOF
 	       /* If this varinfo represents a full variable just use it.  */
 	       && curr->is_full_var)
-	c->offset = 0;
+	c.offset = 0;
       else
-	c->offset = rhsoffset;
+	c.offset = rhsoffset;
+
+      VEC_replace (ce_s, *results, j, &c);
     }
 }
 
Index: gcc/tree-ssa-reassoc.c
===================================================================
--- gcc/tree-ssa-reassoc.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/tree-ssa-reassoc.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,5 +1,5 @@
 /* Reassociation for trees.
-   Copyright (C) 2005, 2007, 2008, 2009 Free Software Foundation, Inc.
+   Copyright (C) 2005, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
    Contributed by Daniel Berlin <dan@dberlin.org>
 
 This file is part of GCC.
@@ -844,7 +844,7 @@
   if ((!op1def || gimple_nop_p (op1def))
       && (!op2def || gimple_nop_p (op2def)))
     {
-      gsi = gsi_start_bb (single_succ (ENTRY_BLOCK_PTR));
+      gsi = gsi_after_labels (single_succ (ENTRY_BLOCK_PTR));
       gsi_insert_before (&gsi, sum, GSI_NEW_STMT);
     }
   else if ((!op1def || gimple_nop_p (op1def))
@@ -853,7 +853,7 @@
     {
       if (gimple_code (op2def) == GIMPLE_PHI)
 	{
-	  gsi = gsi_start_bb (gimple_bb (op2def));
+	  gsi = gsi_after_labels (gimple_bb (op2def));
 	  gsi_insert_before (&gsi, sum, GSI_NEW_STMT);
 	}
       else
@@ -878,7 +878,7 @@
     {
       if (gimple_code (op1def) == GIMPLE_PHI)
 	{
-	  gsi = gsi_start_bb (gimple_bb (op1def));
+	  gsi = gsi_after_labels (gimple_bb (op1def));
 	  gsi_insert_before (&gsi, sum, GSI_NEW_STMT);
 	}
       else
Index: gcc/config/alpha/predicates.md
===================================================================
--- gcc/config/alpha/predicates.md	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/config/alpha/predicates.md	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -439,9 +439,11 @@
        (match_code "mem"))
 {
   rtx base;
+  int offset;
 
   if (MEM_ALIGN (op) >= 32)
     return 1;
+
   op = XEXP (op, 0);
 
   /* LEGITIMIZE_RELOAD_ADDRESS creates (plus (plus reg const_hi) const_lo)
@@ -449,14 +451,29 @@
   if (reload_in_progress
       && GET_CODE (op) == PLUS
       && GET_CODE (XEXP (op, 0)) == PLUS)
-    base = XEXP (XEXP (op, 0), 0);
+    {
+      base = XEXP (XEXP (op, 0), 0);
+      offset = INTVAL (XEXP (op, 1));
+    }
   else
     {
       if (! memory_address_p (mode, op))
 	return 0;
-      base = (GET_CODE (op) == PLUS ? XEXP (op, 0) : op);
+      if (GET_CODE (op) == PLUS)
+	{
+	  base = XEXP (op, 0);
+	  offset = INTVAL (XEXP (op, 1));
+	}
+      else
+	{
+	  base = op;
+	  offset = 0;
+	}
     }
 
+  if (offset % GET_MODE_SIZE (mode))
+    return 0;
+
   return (GET_CODE (base) == REG && REGNO_POINTER_ALIGN (REGNO (base)) >= 32);
 })
 
@@ -467,9 +484,11 @@
        (match_code "mem"))
 {
   rtx base;
+  int offset;
 
   if (MEM_ALIGN (op) >= 32)
     return 0;
+
   op = XEXP (op, 0);
 
   /* LEGITIMIZE_RELOAD_ADDRESS creates (plus (plus reg const_hi) const_lo)
@@ -477,14 +496,29 @@
   if (reload_in_progress
       && GET_CODE (op) == PLUS
       && GET_CODE (XEXP (op, 0)) == PLUS)
-    base = XEXP (XEXP (op, 0), 0);
+    {
+      base = XEXP (XEXP (op, 0), 0);
+      offset = INTVAL (XEXP (op, 1));
+    }
   else
     {
       if (! memory_address_p (mode, op))
 	return 0;
-      base = (GET_CODE (op) == PLUS ? XEXP (op, 0) : op);
+      if (GET_CODE (op) == PLUS)
+	{
+	  base = XEXP (op, 0);
+	  offset = INTVAL (XEXP (op, 1));
+	}
+      else
+	{
+	  base = op;
+	  offset = 0;
+	}
     }
 
+  if (offset % GET_MODE_SIZE (mode))
+    return 1;
+
   return (GET_CODE (base) == REG && REGNO_POINTER_ALIGN (REGNO (base)) < 32);
 })
 
Index: gcc/config/alpha/alpha.c
===================================================================
--- gcc/config/alpha/alpha.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/config/alpha/alpha.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -391,7 +391,7 @@
 	    break;
 	  }
       if (! cpu_table [i].name)
-	error ("bad value %qs for -mcpu switch", alpha_tune_string);
+	error ("bad value %qs for -mtune switch", alpha_tune_string);
     }
 
   /* Do some sanity checks on the above options.  */
@@ -1457,6 +1457,10 @@
   else
     offset = disp & 3;
 
+  /* The location should not cross aligned word boundary.  */
+  gcc_assert (offset + GET_MODE_SIZE (GET_MODE (ref))
+	      <= GET_MODE_SIZE (SImode));
+
   /* Access the entire aligned word.  */
   *paligned_mem = widen_memory_access (ref, SImode, -offset);
 
Index: gcc/config/alpha/alpha.md
===================================================================
--- gcc/config/alpha/alpha.md	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/config/alpha/alpha.md	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -4350,7 +4350,7 @@
 		 (match_dup 4)))]
 {
   if (can_create_pseudo_p ())
-    operands[5] = gen_reg_rtx (DImode);
+    operands[5] = gen_reg_rtx (SImode);
   else if (reg_overlap_mentioned_p (operands[5], operands[4]))
     operands[5] = operands[0];
 })
@@ -4376,9 +4376,9 @@
 				 (match_dup 4))))]
 {
   if (can_create_pseudo_p ())
-    operands[5] = gen_reg_rtx (DImode);
+    operands[5] = gen_reg_rtx (SImode);
   else if (reg_overlap_mentioned_p (operands[5], operands[4]))
-    operands[5] = operands[0];
+    operands[5] = gen_lowpart (SImode, operands[0]);
 })
 
 (define_insn_and_split "*cmp_ssub_di"
@@ -4426,7 +4426,7 @@
 		 (match_dup 4)))]
 {
   if (can_create_pseudo_p ())
-    operands[5] = gen_reg_rtx (DImode);
+    operands[5] = gen_reg_rtx (SImode);
   else if (reg_overlap_mentioned_p (operands[5], operands[4]))
     operands[5] = operands[0];
 })
@@ -4452,9 +4452,9 @@
 				  (match_dup 4))))]
 {
   if (can_create_pseudo_p ())
-    operands[5] = gen_reg_rtx (DImode);
+    operands[5] = gen_reg_rtx (SImode);
   else if (reg_overlap_mentioned_p (operands[5], operands[4]))
-    operands[5] = operands[0];
+    operands[5] = gen_lowpart (SImode, operands[0]);
 })
 
 ;; Here are the CALL and unconditional branch insns.  Calls on NT and OSF
Index: gcc/config/s390/s390.c
===================================================================
--- gcc/config/s390/s390.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/config/s390/s390.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -224,6 +224,9 @@
 
 extern int reload_completed;
 
+/* Kept up to date using the SCHED_VARIABLE_ISSUE hook.  */
+static rtx last_scheduled_insn;
+
 /* Save information from a "cmpxx" operation until the branch or scc is
    emitted.  */
 rtx s390_compare_op0, s390_compare_op1;
@@ -9799,9 +9802,12 @@
   if (!REG_P (*op0) || !REG_P (*op1))
     return false;
 
+  if (GET_MODE_CLASS (GET_MODE (*op0)) != MODE_INT)
+    return false;
+
   /* Swap the COMPARE arguments and its mask if there is a
      conflicting access in the previous insn.  */
-  prev_insn = PREV_INSN (insn);
+  prev_insn = prev_active_insn (insn);
   if (prev_insn != NULL_RTX && INSN_P (prev_insn)
       && reg_referenced_p (*op1, PATTERN (prev_insn)))
     s390_swap_cmp (cond, op0, op1, insn);
@@ -9812,7 +9818,7 @@
      the operands, or if swapping them would cause a conflict
      with the previous insn, issue a NOP after the COMPARE in
      order to separate the two instuctions.  */
-  next_insn = NEXT_INSN (insn);
+  next_insn = next_active_insn (insn);
   if (next_insn != NULL_RTX && INSN_P (next_insn)
       && s390_non_addr_reg_read_p (*op1, next_insn))
     {
@@ -9970,7 +9976,128 @@
     }
 }
 
+/* Return true if INSN is a fp load insn writing register REGNO.  */
+static inline bool
+s390_fpload_toreg (rtx insn, unsigned int regno)
+{
+  rtx set;
+  enum attr_type flag = s390_safe_attr_type (insn);
 
+  if (flag != TYPE_FLOADSF && flag != TYPE_FLOADDF)
+    return false;
+
+  set = single_set (insn);
+
+  if (set == NULL_RTX)
+    return false;
+
+  if (!REG_P (SET_DEST (set)) || !MEM_P (SET_SRC (set)))
+    return false;
+
+  if (REGNO (SET_DEST (set)) != regno)
+    return false;
+
+  return true;
+}
+
+/* This value describes the distance to be avoided between an
+   aritmetic fp instruction and an fp load writing the same register.
+   Z10_EARLYLOAD_DISTANCE - 1 as well as Z10_EARLYLOAD_DISTANCE + 1 is
+   fine but the exact value has to be avoided. Otherwise the FP
+   pipeline will throw an exception causing a major penalty.  */
+#define Z10_EARLYLOAD_DISTANCE 7
+
+/* Rearrange the ready list in order to avoid the situation described
+   for Z10_EARLYLOAD_DISTANCE.  A problematic load instruction is
+   moved to the very end of the ready list.  */
+static void
+s390_z10_prevent_earlyload_conflicts (rtx *ready, int *nready_p)
+{
+  unsigned int regno;
+  int nready = *nready_p;
+  rtx tmp;
+  int i;
+  rtx insn;
+  rtx set;
+  enum attr_type flag;
+  int distance;
+
+  /* Skip DISTANCE - 1 active insns.  */
+  for (insn = last_scheduled_insn, distance = Z10_EARLYLOAD_DISTANCE - 1;
+       distance > 0 && insn != NULL_RTX;
+       distance--, insn = prev_active_insn (insn))
+    if (CALL_P (insn) || JUMP_P (insn))
+      return;
+
+  if (insn == NULL_RTX)
+    return;
+
+  set = single_set (insn);
+
+  if (set == NULL_RTX || !REG_P (SET_DEST (set))
+      || GET_MODE_CLASS (GET_MODE (SET_DEST (set))) != MODE_FLOAT)
+    return;
+
+  flag = s390_safe_attr_type (insn);
+
+  if (flag == TYPE_FLOADSF || flag == TYPE_FLOADDF)
+    return;
+
+  regno = REGNO (SET_DEST (set));
+  i = nready - 1;
+
+  while (!s390_fpload_toreg (ready[i], regno) && i > 0)
+    i--;
+
+  if (!i)
+    return;
+
+  tmp = ready[i];
+  memmove (&ready[1], &ready[0], sizeof (rtx) * i);
+  ready[0] = tmp;
+}
+
+/* This function is called via hook TARGET_SCHED_REORDER before
+   issueing one insn from list READY which contains *NREADYP entries.
+   For target z10 it reorders load instructions to avoid early load
+   conflicts in the floating point pipeline  */
+static int
+s390_sched_reorder (FILE *file ATTRIBUTE_UNUSED, int verbose ATTRIBUTE_UNUSED,
+		    rtx *ready, int *nreadyp, int clock ATTRIBUTE_UNUSED)
+{
+  if (s390_tune == PROCESSOR_2097_Z10)
+    if (reload_completed && *nreadyp > 1)
+      s390_z10_prevent_earlyload_conflicts (ready, nreadyp);
+
+  return s390_issue_rate ();
+}
+
+/* This function is called via hook TARGET_SCHED_VARIABLE_ISSUE after
+   the scheduler has issued INSN.  It stores the last issued insn into
+   last_scheduled_insn in order to make it available for
+   s390_sched_reorder.  */
+static int
+s390_sched_variable_issue (FILE *file ATTRIBUTE_UNUSED,
+                           int verbose ATTRIBUTE_UNUSED,
+                         rtx insn, int more)
+{
+  last_scheduled_insn = insn;
+
+  if (GET_CODE (PATTERN (insn)) != USE
+      && GET_CODE (PATTERN (insn)) != CLOBBER)
+    return more - 1;
+  else
+    return more;
+}
+
+static void
+s390_sched_init (FILE *file ATTRIBUTE_UNUSED,
+		 int verbose ATTRIBUTE_UNUSED,
+		 int max_ready ATTRIBUTE_UNUSED)
+{
+  last_scheduled_insn = NULL_RTX;
+}
+
 /* Initialize GCC target structure.  */
 
 #undef  TARGET_ASM_ALIGNED_HI_OP
@@ -10024,6 +10151,13 @@
 #undef TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD
 #define TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD s390_first_cycle_multipass_dfa_lookahead
 
+#undef TARGET_SCHED_VARIABLE_ISSUE
+#define TARGET_SCHED_VARIABLE_ISSUE s390_sched_variable_issue
+#undef TARGET_SCHED_REORDER
+#define TARGET_SCHED_REORDER s390_sched_reorder
+#undef TARGET_SCHED_INIT
+#define TARGET_SCHED_INIT s390_sched_init
+
 #undef TARGET_CANNOT_COPY_INSN_P
 #define TARGET_CANNOT_COPY_INSN_P s390_cannot_copy_insn_p
 #undef TARGET_RTX_COSTS
Index: gcc/config/s390/s390.md
===================================================================
--- gcc/config/s390/s390.md	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/config/s390/s390.md	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1864,8 +1864,8 @@
 })
 
 (define_insn "*movqi"
-  [(set (match_operand:QI 0 "nonimmediate_operand" "=d,d,d,d,R,T,Q,S")
-        (match_operand:QI 1 "general_operand" "d,n,R,T,d,d,n,n"))]
+  [(set (match_operand:QI 0 "nonimmediate_operand" "=d,d,d,d,R,T,Q,S,?Q")
+        (match_operand:QI 1 "general_operand"      " d,n,R,T,d,d,n,n,?Q"))]
   ""
   "@
    lr\t%0,%1
@@ -1875,9 +1875,10 @@
    stc\t%1,%0
    stcy\t%1,%0
    mvi\t%S0,%b1
-   mviy\t%S0,%b1"
-  [(set_attr "op_type" "RR,RI,RX,RXY,RX,RXY,SI,SIY")
-   (set_attr "type" "lr,*,*,*,store,store,store,store")
+   mviy\t%S0,%b1
+   *"
+  [(set_attr "op_type" "RR,RI,RX,RXY,RX,RXY,SI,SIY,SS")
+   (set_attr "type" "lr,*,*,*,store,store,store,store,*")
    (set_attr "z10prop" "z10_fr_E1,
                         z10_fwd_A1,
                         z10_super_E1,
@@ -1885,7 +1886,8 @@
                         z10_rec,
                         z10_rec,
                         z10_super,
-                        z10_super")])
+                        z10_super,
+                        *")])
 
 (define_peephole2
   [(set (match_operand:QI 0 "nonimmediate_operand" "")
@@ -2262,6 +2264,22 @@
   "mvc\t%O0(%2,%R0),%S1"
   [(set_attr "op_type" "SS")])
 
+; This splitter converts a QI to QI mode copy into a BLK mode copy in
+; order to have it implemented with mvc.
+
+(define_split
+  [(set (match_operand:QI 0 "memory_operand" "")
+        (match_operand:QI 1 "memory_operand" ""))]
+  "reload_completed"
+  [(parallel
+    [(set (match_dup 0) (match_dup 1))
+     (use (const_int 1))])]
+{
+  operands[0] = adjust_address (operands[0], BLKmode, 0);
+  operands[1] = adjust_address (operands[1], BLKmode, 0);
+})
+
+
 (define_peephole2
   [(parallel
     [(set (match_operand:BLK 0 "memory_operand" "")
@@ -7049,21 +7067,6 @@
    (set_attr "type"     "fsimp<mode>")])
 
 ;;
-;;- Copy sign instructions
-;;
-
-; cpsdr
-(define_insn "copysign<mode>3"
-  [(set (match_operand:FP 0 "register_operand" "=f")
-	(unspec:FP [(match_operand:FP 1 "register_operand" "<fT0>")
-		    (match_operand:FP 2 "register_operand" "f")]
-		    UNSPEC_COPYSIGN))]
-  "TARGET_DFP"
-  "cpsdr\t%0,%2,%1"
-  [(set_attr "op_type"  "RRF")
-   (set_attr "type"     "fsimp<mode>")])
-
-;;
 ;;- Square root instructions.
 ;;
 
Index: gcc/config/s390/2097.md
===================================================================
--- gcc/config/s390/2097.md	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/config/s390/2097.md	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -57,7 +57,8 @@
                   z10_int_fr_A3"
                   "z10_other_super, z10_other_super_c_E1, z10_other_super_E1, \
                   z10_int_super, z10_int_super_E1, \
-                  z10_lr, z10_store_super")
+                  z10_lr, z10_store_super"
+                  " ! s390_agen_dep_p")
 
 
 ; Forwarding from z10_super to frz10_ and z10_rec.
@@ -68,7 +69,8 @@
                   z10_store_super"
                   "z10_int_fr, z10_int_fr_E1, z10_int_fr_A3, \
                   z10_other_fr, z10_other_fr_A3, z10_lr_fr, z10_lr_fr_E1, \
-                  z10_other_fr_E1, z10_store_rec")
+                  z10_other_fr_E1, z10_store_rec"
+                  " ! s390_agen_dep_p")
 
 
 ; Forwarding from z10_fwd and z10_fr to z10_rec and z10_fr.
@@ -84,7 +86,8 @@
                   z10_int_fr_A3"
                   "z10_int_fr, z10_int_fr_E1, z10_int_fr_A3, \
                   z10_other_fr, z10_other_fr_A3, z10_lr_fr, z10_lr_fr_E1, \
-                  z10_other_fr_E1, z10_store_rec")
+                  z10_other_fr_E1, z10_store_rec"
+                  " ! s390_agen_dep_p")
 
 
 ;
@@ -205,16 +208,13 @@
        (and (eq_attr "type" "lr")
             (eq_attr "z10prop" "z10_fr")))
   "z10_e1_ANY, z10_Gate_ANY")
-;  "z10_e1_ANY")
 
 (define_insn_reservation "z10_lr_fr_E1" 6
   (and (eq_attr "cpu" "z10")
        (and (eq_attr "type" "lr")
             (eq_attr "z10prop" "z10_fr_E1")))
   "z10_e1_ANY, z10_Gate_ANY")
-;  "z10_e1_ANY")
 
-
 (define_insn_reservation "z10_la" 6
   (and (eq_attr "cpu" "z10")
        (and (eq_attr "type" "la")
@@ -227,14 +227,12 @@
        (and (eq_attr "type" "la")
             (eq_attr "z10prop" "z10_fwd")))
   "z10_e1_ANY, z10_Gate_ANY")
-;  "z10_e1_ANY")
 
 (define_insn_reservation "z10_la_fwd_A1" 6
   (and (eq_attr "cpu" "z10")
        (and (eq_attr "type" "la")
             (eq_attr "z10prop" "z10_fwd_A1")))
   "z10_e1_ANY, z10_Gate_ANY")
-;  "z10_e1_ANY")
 
 
 ; larl-type instructions
@@ -666,13 +664,14 @@
 ; Address-related bypasses
 ;
 
-; Here is the cycle diagram for Address-related bypasses:
+; Here is the cycle diagram for address-related bypasses:
 ; ... G1 G2 G3 A0 A1 A2 A3 E1 P1 P2 P3 R0 ...
-;         ^  ^    ^     ^  ^
-;         |  |    |     |  E1-type bypasses provide the new addr AFTER this cycle
-;         |  |    |     A3-type bypasses provide the new addr AFTER this cycle
-;         |  |    A1-type bypasses provide the new addr AFTER this cycle
-;         |  AGI resolution, actual USE of address is DURING this cycle
+;         ^  ^    ^     ^  ^        ^
+;         |  |    |     |  |        without bypass, its available AFTER this cycle
+;         |  |    |     |  E1-type bypasses provide the new value AFTER this cycle
+;         |  |    |     A3-type bypasses provide the new value AFTER this cycle
+;         |  |    A1-type bypasses provide the new value AFTER this cycle
+;         |  AGI resolution, actual USE of new value is DURING this cycle
 ;         AGI detection
 
 (define_bypass 3 "z10_larl_A1, z10_la_fwd_A1, z10_other_fwd_A1, \
@@ -682,7 +681,6 @@
                   z10_cs, z10_stm, z10_other"
 	         "s390_agen_dep_p")
 
-
 (define_bypass 5 "z10_larl_fwd_A3, z10_load_fwd_A3, z10_other_fwd_A3, \
                   z10_other_fr_A3, z10_int_fwd_A3, z10_int_fr_A3"
                  "z10_agen, z10_la, z10_branch, z10_call, z10_load, \
@@ -699,8 +697,14 @@
                   z10_cs, z10_stm, z10_other"
  	         "s390_agen_dep_p")
 
+(define_bypass 9 "z10_int_super, z10_int_fwd, z10_int_fr"
+                 "z10_agen, z10_la, z10_branch, z10_call, z10_load, \
+                  z10_store, \
+                  z10_cs, z10_stm, z10_other"
+ 	         "s390_agen_dep_p")
 
 
+
 ;
 ; Try to avoid transitions between DFU-, BFU- and FXU-executed instructions as there is a
 ; dispatch delay required.
Index: gcc/config/spu/spu-protos.h
===================================================================
--- gcc/config/spu/spu-protos.h	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/config/spu/spu-protos.h	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -51,6 +51,8 @@
 extern int iohl_immediate_p (rtx op, enum machine_mode mode);
 extern int arith_immediate_p (rtx op, enum machine_mode mode,
 			      HOST_WIDE_INT low, HOST_WIDE_INT high);
+extern bool exp2_immediate_p (rtx op, enum machine_mode mode, int low,
+			      int high);
 extern int spu_constant_address_p (rtx x);
 extern int spu_legitimate_constant_p (rtx x);
 extern int spu_legitimate_address (enum machine_mode mode, rtx x,
@@ -64,17 +66,16 @@
 					tree type, int *pretend_size,
 					int no_rtl);
 extern void spu_conditional_register_usage (void);
-extern int aligned_mem_p (rtx mem);
 extern int spu_expand_mov (rtx * ops, enum machine_mode mode);
-extern void spu_split_load (rtx * ops);
-extern void spu_split_store (rtx * ops);
-extern int spu_valid_move (rtx * ops);
+extern int spu_split_load (rtx * ops);
+extern int spu_split_store (rtx * ops);
 extern int fsmbi_const_p (rtx x);
 extern int cpat_const_p (rtx x, enum machine_mode mode);
 extern rtx gen_cpat_const (rtx * ops);
 extern void constant_to_array (enum machine_mode mode, rtx x,
 			       unsigned char *arr);
 extern rtx array_to_constant (enum machine_mode mode, unsigned char *arr);
+extern rtx spu_gen_exp2 (enum machine_mode mode, rtx x);
 extern void spu_allocate_stack (rtx op0, rtx op1);
 extern void spu_restore_stack_nonlocal (rtx op0, rtx op1);
 extern void spu_restore_stack_block (rtx op0, rtx op1);
@@ -88,6 +89,7 @@
 extern void spu_expand_sign_extend (rtx ops[]);
 extern void spu_expand_vector_init (rtx target, rtx vals);
 extern void spu_init_expanders (void);
+extern void spu_split_convert (rtx *);
 
 /* spu-c.c */
 extern tree spu_resolve_overloaded_builtin (tree fndecl, tree fnargs);
Index: gcc/config/spu/predicates.md
===================================================================
--- gcc/config/spu/predicates.md	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/config/spu/predicates.md	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -39,14 +39,14 @@
        (ior (not (match_code "subreg"))
             (match_test "valid_subreg (op)"))))
 
-(define_predicate "spu_mem_operand"
-  (and (match_operand 0 "memory_operand")
-       (match_test "reload_in_progress || reload_completed || aligned_mem_p (op)")))
-
 (define_predicate "spu_mov_operand"
-  (ior (match_operand 0 "spu_mem_operand")
+  (ior (match_operand 0 "memory_operand")
        (match_operand 0 "spu_nonmem_operand")))
 
+(define_predicate "spu_dest_operand"
+  (ior (match_operand 0 "memory_operand")
+       (match_operand 0 "spu_reg_operand")))
+
 (define_predicate "call_operand"
   (and (match_code "mem")
        (match_test "(!TARGET_LARGE_MEM && satisfies_constraint_S (op))
@@ -104,3 +104,19 @@
        (ior (match_test "GET_MODE (XEXP (op, 0)) == HImode")
 	    (match_test "GET_MODE (XEXP (op, 0)) == SImode"))))
 
+(define_predicate "spu_inv_exp2_operand"
+  (and (match_code "const_double,const_vector")
+       (and (match_operand 0 "immediate_operand")
+	    (match_test "exp2_immediate_p (op, mode, -126, 0)"))))
+
+(define_predicate "spu_exp2_operand"
+  (and (match_code "const_double,const_vector")
+       (and (match_operand 0 "immediate_operand")
+	    (match_test "exp2_immediate_p (op, mode, 0, 127)"))))
+
+(define_predicate "shiftrt_operator"
+  (match_code "lshiftrt,ashiftrt"))
+
+(define_predicate "extend_operator"
+  (match_code "sign_extend,zero_extend"))
+
Index: gcc/config/spu/spu.c
===================================================================
--- gcc/config/spu/spu.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/config/spu/spu.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -189,9 +189,9 @@
 static void spu_va_start (tree, rtx);
 static tree spu_gimplify_va_arg_expr (tree valist, tree type,
 				      gimple_seq * pre_p, gimple_seq * post_p);
-static int regno_aligned_for_load (int regno);
 static int store_with_one_insn_p (rtx mem);
 static int mem_is_padded_component_ref (rtx x);
+static int reg_aligned_for_addr (rtx x);
 static bool spu_assemble_integer (rtx x, unsigned int size, int aligned_p);
 static void spu_asm_globalize_label (FILE * file, const char *name);
 static unsigned char spu_rtx_costs (rtx x, int code, int outer_code,
@@ -210,6 +210,7 @@
 static int spu_sms_res_mii (struct ddg *g);
 static void asm_file_start (void);
 static unsigned int spu_section_type_flags (tree, const char *, int);
+static rtx spu_expand_load (rtx, rtx, rtx, int);
 
 extern const char *reg_names[];
 rtx spu_compare_op0, spu_compare_op1;
@@ -576,66 +577,85 @@
 void
 spu_expand_extv (rtx ops[], int unsignedp)
 {
+  rtx dst = ops[0], src = ops[1];
   HOST_WIDE_INT width = INTVAL (ops[2]);
   HOST_WIDE_INT start = INTVAL (ops[3]);
-  HOST_WIDE_INT src_size, dst_size;
-  enum machine_mode src_mode, dst_mode;
-  rtx dst = ops[0], src = ops[1];
-  rtx s;
+  HOST_WIDE_INT align_mask;
+  rtx s0, s1, mask, r0;
 
-  dst = adjust_operand (ops[0], 0);
-  dst_mode = GET_MODE (dst);
-  dst_size = GET_MODE_BITSIZE (GET_MODE (dst));
+  gcc_assert (REG_P (dst) && GET_MODE (dst) == TImode);
 
-  src = adjust_operand (src, &start);
-  src_mode = GET_MODE (src);
-  src_size = GET_MODE_BITSIZE (GET_MODE (src));
+  if (MEM_P (src))
+    {
+      /* First, determine if we need 1 TImode load or 2.  We need only 1
+         if the bits being extracted do not cross the alignment boundary
+         as determined by the MEM and its address. */
 
-  if (start > 0)
-    {
-      s = gen_reg_rtx (src_mode);
-      switch (src_mode)
+      align_mask = -MEM_ALIGN (src);
+      if ((start & align_mask) == ((start + width - 1) & align_mask))
 	{
-	case SImode:
-	  emit_insn (gen_ashlsi3 (s, src, GEN_INT (start)));
-	  break;
-	case DImode:
-	  emit_insn (gen_ashldi3 (s, src, GEN_INT (start)));
-	  break;
-	case TImode:
-	  emit_insn (gen_ashlti3 (s, src, GEN_INT (start)));
-	  break;
-	default:
-	  abort ();
+	  /* Alignment is sufficient for 1 load. */
+	  s0 = gen_reg_rtx (TImode);
+	  r0 = spu_expand_load (s0, 0, src, start / 8);
+	  start &= 7;
+	  if (r0)
+	    emit_insn (gen_rotqby_ti (s0, s0, r0));
 	}
-      src = s;
+      else
+	{
+	  /* Need 2 loads. */
+	  s0 = gen_reg_rtx (TImode);
+	  s1 = gen_reg_rtx (TImode);
+	  r0 = spu_expand_load (s0, s1, src, start / 8);
+	  start &= 7;
+
+	  gcc_assert (start + width <= 128);
+	  if (r0)
+	    {
+	      rtx r1 = gen_reg_rtx (SImode);
+	      mask = gen_reg_rtx (TImode);
+	      emit_move_insn (mask, GEN_INT (-1));
+	      emit_insn (gen_rotqby_ti (s0, s0, r0));
+	      emit_insn (gen_rotqby_ti (s1, s1, r0));
+	      if (GET_CODE (r0) == CONST_INT)
+		r1 = GEN_INT (INTVAL (r0) & 15);
+	      else
+		emit_insn (gen_andsi3 (r1, r0, GEN_INT (15)));
+	      emit_insn (gen_shlqby_ti (mask, mask, r1));
+	      emit_insn (gen_selb (s0, s1, s0, mask));
+	    }
+	}
+
     }
+  else if (GET_CODE (src) == SUBREG)
+    {
+      rtx r = SUBREG_REG (src);
+      gcc_assert (REG_P (r) && SCALAR_INT_MODE_P (GET_MODE (r)));
+      s0 = gen_reg_rtx (TImode);
+      if (GET_MODE_SIZE (GET_MODE (r)) < GET_MODE_SIZE (TImode))
+	emit_insn (gen_rtx_SET (VOIDmode, s0, gen_rtx_ZERO_EXTEND (TImode, r)));
+      else
+	emit_move_insn (s0, src);
+    }
+  else
+    {
+      gcc_assert (REG_P (src) && GET_MODE (src) == TImode);
+      s0 = gen_reg_rtx (TImode);
+      emit_move_insn (s0, src);
+    }
 
-  if (width < src_size)
+  /* Now s0 is TImode and contains the bits to extract at start. */
+
+  if (start)
+    emit_insn (gen_rotlti3 (s0, s0, GEN_INT (start)));
+
+  if (128 - width)
     {
-      rtx pat;
-      int icode;
-      switch (src_mode)
-	{
-	case SImode:
-	  icode = unsignedp ? CODE_FOR_lshrsi3 : CODE_FOR_ashrsi3;
-	  break;
-	case DImode:
-	  icode = unsignedp ? CODE_FOR_lshrdi3 : CODE_FOR_ashrdi3;
-	  break;
-	case TImode:
-	  icode = unsignedp ? CODE_FOR_lshrti3 : CODE_FOR_ashrti3;
-	  break;
-	default:
-	  abort ();
-	}
-      s = gen_reg_rtx (src_mode);
-      pat = GEN_FCN (icode) (s, src, GEN_INT (src_size - width));
-      emit_insn (pat);
-      src = s;
+      tree c = build_int_cst (NULL_TREE, 128 - width);
+      s0 = expand_shift (RSHIFT_EXPR, TImode, s0, c, s0, unsignedp);
     }
 
-  convert_move (dst, src, unsignedp);
+  emit_move_insn (dst, s0);
 }
 
 void
@@ -728,38 +748,41 @@
     }
   if (GET_CODE (ops[0]) == MEM)
     {
-      rtx aligned = gen_reg_rtx (SImode);
       rtx low = gen_reg_rtx (SImode);
-      rtx addr = gen_reg_rtx (SImode);
       rtx rotl = gen_reg_rtx (SImode);
       rtx mask0 = gen_reg_rtx (TImode);
+      rtx addr;
+      rtx addr0;
+      rtx addr1;
       rtx mem;
 
-      emit_move_insn (addr, XEXP (ops[0], 0));
-      emit_insn (gen_andsi3 (aligned, addr, GEN_INT (-16)));
+      addr = force_reg (Pmode, XEXP (ops[0], 0));
+      addr0 = gen_rtx_AND (Pmode, addr, GEN_INT (-16));
       emit_insn (gen_andsi3 (low, addr, GEN_INT (15)));
       emit_insn (gen_negsi2 (rotl, low));
       emit_insn (gen_rotqby_ti (shift_reg, shift_reg, rotl));
       emit_insn (gen_rotqmby_ti (mask0, mask, rotl));
-      mem = change_address (ops[0], TImode, aligned);
+      mem = change_address (ops[0], TImode, addr0);
       set_mem_alias_set (mem, 0);
       emit_move_insn (dst, mem);
       emit_insn (gen_selb (dst, dst, shift_reg, mask0));
-      emit_move_insn (mem, dst);
       if (start + width > MEM_ALIGN (ops[0]))
 	{
 	  rtx shl = gen_reg_rtx (SImode);
 	  rtx mask1 = gen_reg_rtx (TImode);
 	  rtx dst1 = gen_reg_rtx (TImode);
 	  rtx mem1;
+	  addr1 = plus_constant (addr, 16);
+	  addr1 = gen_rtx_AND (Pmode, addr1, GEN_INT (-16));
 	  emit_insn (gen_subsi3 (shl, GEN_INT (16), low));
 	  emit_insn (gen_shlqby_ti (mask1, mask, shl));
-	  mem1 = adjust_address (mem, TImode, 16);
+	  mem1 = change_address (ops[0], TImode, addr1);
 	  set_mem_alias_set (mem1, 0);
 	  emit_move_insn (dst1, mem1);
 	  emit_insn (gen_selb (dst1, dst1, shift_reg, mask1));
 	  emit_move_insn (mem1, dst1);
 	}
+      emit_move_insn (mem, dst);
     }
   else
     emit_insn (gen_selb (dst, copy_rtx (dst), shift_reg, mask));
@@ -1585,6 +1608,13 @@
       output_addr_const (file, GEN_INT (val));
       return;
 
+    case 'v':
+    case 'w':
+      constant_to_array (mode, x, arr);
+      val = (((arr[0] << 1) + (arr[1] >> 7)) & 0xff) - 127;
+      output_addr_const (file, GEN_INT (code == 'w' ? -val : val));
+      return;
+
     case 0:
       if (xcode == REG)
 	fprintf (file, "%s", reg_names[REGNO (x)]);
@@ -1597,7 +1627,7 @@
       return;
 
       /* unused letters
-	              o qr  uvw yz
+	              o qr  u   yz
 	AB            OPQR  UVWXYZ */
     default:
       output_operand_lossage ("invalid %%xn code");
@@ -1618,6 +1648,8 @@
   rtx pic_reg = pic_offset_table_rtx;
   if (!reload_completed && !reload_in_progress)
     abort ();
+  if (current_function_is_leaf && !df_regs_ever_live_p (LAST_ARG_REGNUM))
+    pic_reg = gen_rtx_REG (SImode, LAST_ARG_REGNUM);
   return pic_reg;
 }
 
@@ -2765,6 +2797,25 @@
 
   pad_bb ();
 
+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))
+    if (NONJUMP_INSN_P (insn) && INSN_CODE (insn) == CODE_FOR_hbr)
+      {
+	/* Adjust the LABEL_REF in a hint when we have inserted a nop
+	   between its branch label and the branch .  We don't move the
+	   label because GCC expects it at the beginning of the block. */
+	rtx unspec = SET_SRC (XVECEXP (PATTERN (insn), 0, 0));
+	rtx label_ref = XVECEXP (unspec, 0, 0);
+	rtx label = XEXP (label_ref, 0);
+	rtx branch;
+	int offset = 0;
+	for (branch = NEXT_INSN (label);
+	     !JUMP_P (branch) && !CALL_P (branch);
+	     branch = NEXT_INSN (branch))
+	  if (NONJUMP_INSN_P (branch))
+	    offset += get_attr_length (branch);
+	if (offset > 0)
+	  XVECEXP (unspec, 0, 0) = plus_constant (label_ref, offset);
+      }
 
   if (spu_flag_var_tracking)
     {
@@ -2972,7 +3023,7 @@
       insn = ready[i];
       if (INSN_CODE (insn) == -1
 	  || INSN_CODE (insn) == CODE_FOR_blockage
-	  || INSN_CODE (insn) == CODE_FOR__spu_convert)
+	  || (INSN_P (insn) && get_attr_length (insn) == 0))
 	{
 	  ready[i] = ready[nready - 1];
 	  ready[nready - 1] = insn;
@@ -3103,8 +3154,8 @@
       || INSN_CODE (dep_insn) == CODE_FOR_blockage)
     return 0;
 
-  if (INSN_CODE (insn) == CODE_FOR__spu_convert
-      || INSN_CODE (dep_insn) == CODE_FOR__spu_convert)
+  if ((INSN_P (insn) && get_attr_length (insn) == 0)
+      || (INSN_P (dep_insn) && get_attr_length (dep_insn) == 0))
     return 0;
 
   /* Make sure hbrps are spread out. */
@@ -3503,6 +3554,58 @@
   return val >= low && val <= high;
 }
 
+/* TRUE when op is an immediate and an exact power of 2, and given that
+   OP is 2^scale, scale >= LOW && scale <= HIGH.  When OP is a vector,
+   all entries must be the same. */
+bool
+exp2_immediate_p (rtx op, enum machine_mode mode, int low, int high)
+{
+  enum machine_mode int_mode;
+  HOST_WIDE_INT val;
+  unsigned char arr[16];
+  int bytes, i, j;
+
+  gcc_assert (GET_CODE (op) == CONST_INT || GET_CODE (op) == CONST_DOUBLE
+	      || GET_CODE (op) == CONST_VECTOR);
+
+  if (GET_CODE (op) == CONST_VECTOR
+      && !const_vector_immediate_p (op))
+    return 0;
+
+  if (GET_MODE (op) != VOIDmode)
+    mode = GET_MODE (op);
+
+  constant_to_array (mode, op, arr);
+
+  if (VECTOR_MODE_P (mode))
+    mode = GET_MODE_INNER (mode);
+
+  bytes = GET_MODE_SIZE (mode);
+  int_mode = mode_for_size (GET_MODE_BITSIZE (mode), MODE_INT, 0);
+
+  /* Check that bytes are repeated. */
+  for (i = bytes; i < 16; i += bytes)
+    for (j = 0; j < bytes; j++)
+      if (arr[j] != arr[i + j])
+	return 0;
+
+  val = arr[0];
+  for (j = 1; j < bytes; j++)
+    val = (val << 8) | arr[j];
+
+  val = trunc_int_for_mode (val, int_mode);
+
+  /* Currently, we only handle SFmode */
+  gcc_assert (mode == SFmode);
+  if (mode == SFmode)
+    {
+      int exp = (val >> 23) - 127;
+      return val > 0 && (val & 0x007fffff) == 0
+	     &&  exp >= low && exp <= high;
+    }
+  return FALSE;
+}
+
 /* We accept:
    - any 32-bit constant (SImode, SFmode)
    - any constant that can be generated with fsmbi (any mode)
@@ -3533,44 +3636,36 @@
 /* Valid address are:
    - symbol_ref, label_ref, const
    - reg
-   - reg + const, where either reg or const is 16 byte aligned
+   - reg + const_int, where const_int is 16 byte aligned
    - reg + reg, alignment doesn't matter
   The alignment matters in the reg+const case because lqd and stqd
-  ignore the 4 least significant bits of the const.  (TODO: It might be
-  preferable to allow any alignment and fix it up when splitting.) */
+  ignore the 4 least significant bits of the const.  We only care about
+  16 byte modes because the expand phase will change all smaller MEM
+  references to TImode.  */
 int
 spu_legitimate_address (enum machine_mode mode ATTRIBUTE_UNUSED,
 			rtx x, int reg_ok_strict)
 {
-  if (mode == TImode && GET_CODE (x) == AND
+  int aligned = GET_MODE_SIZE (mode) >= 16;
+  if (aligned
+      && GET_CODE (x) == AND
       && GET_CODE (XEXP (x, 1)) == CONST_INT
-      && INTVAL (XEXP (x, 1)) == (HOST_WIDE_INT) -16)
+      && INTVAL (XEXP (x, 1)) == (HOST_WIDE_INT) - 16)
     x = XEXP (x, 0);
   switch (GET_CODE (x))
     {
+    case LABEL_REF:
     case SYMBOL_REF:
-    case LABEL_REF:
+    case CONST:
       return !TARGET_LARGE_MEM;
 
-    case CONST:
-      if (!TARGET_LARGE_MEM && GET_CODE (XEXP (x, 0)) == PLUS)
-	{
-	  rtx sym = XEXP (XEXP (x, 0), 0);
-	  rtx cst = XEXP (XEXP (x, 0), 1);
-
-	  /* Accept any symbol_ref + constant, assuming it does not
-	     wrap around the local store addressability limit.  */
-	  if (GET_CODE (sym) == SYMBOL_REF && GET_CODE (cst) == CONST_INT)
-	    return 1;
-	}
-      return 0;
-
     case CONST_INT:
       return INTVAL (x) >= 0 && INTVAL (x) <= 0x3ffff;
 
     case SUBREG:
       x = XEXP (x, 0);
-      gcc_assert (GET_CODE (x) == REG);
+      if (REG_P (x))
+	return 0;
 
     case REG:
       return INT_REG_OK_FOR_BASE_P (x, reg_ok_strict);
@@ -3584,29 +3679,25 @@
 	  op0 = XEXP (op0, 0);
 	if (GET_CODE (op1) == SUBREG)
 	  op1 = XEXP (op1, 0);
-	/* We can't just accept any aligned register because CSE can
-	   change it to a register that is not marked aligned and then
-	   recog will fail.   So we only accept frame registers because
-	   they will only be changed to other frame registers. */
 	if (GET_CODE (op0) == REG
 	    && INT_REG_OK_FOR_BASE_P (op0, reg_ok_strict)
 	    && GET_CODE (op1) == CONST_INT
 	    && INTVAL (op1) >= -0x2000
 	    && INTVAL (op1) <= 0x1fff
-	    && (regno_aligned_for_load (REGNO (op0)) || (INTVAL (op1) & 15) == 0))
-	  return 1;
+	    && (!aligned || (INTVAL (op1) & 15) == 0))
+	  return TRUE;
 	if (GET_CODE (op0) == REG
 	    && INT_REG_OK_FOR_BASE_P (op0, reg_ok_strict)
 	    && GET_CODE (op1) == REG
 	    && INT_REG_OK_FOR_INDEX_P (op1, reg_ok_strict))
-	  return 1;
+	  return TRUE;
       }
       break;
 
     default:
       break;
     }
-  return 0;
+  return FALSE;
 }
 
 /* When the address is reg + const_int, force the const_int into a
@@ -4061,62 +4152,16 @@
     }
 }
 
-/* This is called to decide when we can simplify a load instruction.  We
-   must only return true for registers which we know will always be
-   aligned.  Taking into account that CSE might replace this reg with
-   another one that has not been marked aligned.  
-   So this is really only true for frame, stack and virtual registers,
-   which we know are always aligned and should not be adversely effected
-   by CSE.  */
+/* This is called any time we inspect the alignment of a register for
+   addresses.  */
 static int
-regno_aligned_for_load (int regno)
+reg_aligned_for_addr (rtx x)
 {
-  return regno == FRAME_POINTER_REGNUM
-    || (frame_pointer_needed && regno == HARD_FRAME_POINTER_REGNUM)
-    || regno == ARG_POINTER_REGNUM
-    || regno == STACK_POINTER_REGNUM
-    || (regno >= FIRST_VIRTUAL_REGISTER 
-	&& regno <= LAST_VIRTUAL_REGISTER);
+  int regno =
+    REGNO (x) < FIRST_PSEUDO_REGISTER ? ORIGINAL_REGNO (x) : REGNO (x);
+  return REGNO_POINTER_ALIGN (regno) >= 128;
 }
 
-/* Return TRUE when mem is known to be 16-byte aligned. */
-int
-aligned_mem_p (rtx mem)
-{
-  if (MEM_ALIGN (mem) >= 128)
-    return 1;
-  if (GET_MODE_SIZE (GET_MODE (mem)) >= 16)
-    return 1;
-  if (GET_CODE (XEXP (mem, 0)) == PLUS)
-    {
-      rtx p0 = XEXP (XEXP (mem, 0), 0);
-      rtx p1 = XEXP (XEXP (mem, 0), 1);
-      if (regno_aligned_for_load (REGNO (p0)))
-	{
-	  if (GET_CODE (p1) == REG && regno_aligned_for_load (REGNO (p1)))
-	    return 1;
-	  if (GET_CODE (p1) == CONST_INT && (INTVAL (p1) & 15) == 0)
-	    return 1;
-	}
-    }
-  else if (GET_CODE (XEXP (mem, 0)) == REG)
-    {
-      if (regno_aligned_for_load (REGNO (XEXP (mem, 0))))
-	return 1;
-    }
-  else if (ALIGNED_SYMBOL_REF_P (XEXP (mem, 0)))
-    return 1;
-  else if (GET_CODE (XEXP (mem, 0)) == CONST)
-    {
-      rtx p0 = XEXP (XEXP (XEXP (mem, 0), 0), 0);
-      rtx p1 = XEXP (XEXP (XEXP (mem, 0), 0), 1);
-      if (GET_CODE (p0) == SYMBOL_REF
-	  && GET_CODE (p1) == CONST_INT && (INTVAL (p1) & 15) == 0)
-	return 1;
-    }
-  return 0;
-}
-
 /* Encode symbol attributes (local vs. global, tls model) of a SYMBOL_REF
    into its SYMBOL_REF_FLAGS.  */
 static void
@@ -4143,9 +4188,12 @@
 static int
 store_with_one_insn_p (rtx mem)
 {
+  enum machine_mode mode = GET_MODE (mem);
   rtx addr = XEXP (mem, 0);
-  if (GET_MODE (mem) == BLKmode)
+  if (mode == BLKmode)
     return 0;
+  if (GET_MODE_SIZE (mode) >= 16)
+    return 1;
   /* Only static objects. */
   if (GET_CODE (addr) == SYMBOL_REF)
     {
@@ -4169,6 +4217,22 @@
   return 0;
 }
 
+/* Return 1 when the address is not valid for a simple load and store as
+   required by the '_mov*' patterns.   We could make this less strict
+   for loads, but we prefer mem's to look the same so they are more
+   likely to be merged.  */
+static int
+address_needs_split (rtx mem)
+{
+  if (GET_MODE_SIZE (GET_MODE (mem)) < 16
+      && (GET_MODE_SIZE (GET_MODE (mem)) < 4
+	  || !(store_with_one_insn_p (mem)
+	       || mem_is_padded_component_ref (mem))))
+    return 1;
+
+  return 0;
+}
+
 int
 spu_expand_mov (rtx * ops, enum machine_mode mode)
 {
@@ -4213,54 +4277,63 @@
 	return spu_split_immediate (ops);
       return 0;
     }
-  else
+
+  /* Catch the SImode immediates greater than 0x7fffffff, and sign
+     extend them. */
+  if (GET_CODE (ops[1]) == CONST_INT)
     {
-      if (GET_CODE (ops[0]) == MEM)
+      HOST_WIDE_INT val = trunc_int_for_mode (INTVAL (ops[1]), mode);
+      if (val != INTVAL (ops[1]))
 	{
-	  if (!spu_valid_move (ops))
-	    {
-	      emit_insn (gen_store (ops[0], ops[1], gen_reg_rtx (TImode),
-				    gen_reg_rtx (TImode)));
-	      return 1;
-	    }
+	  emit_move_insn (ops[0], GEN_INT (val));
+	  return 1;
 	}
-      else if (GET_CODE (ops[1]) == MEM)
-	{
-	  if (!spu_valid_move (ops))
-	    {
-	      emit_insn (gen_load
-			 (ops[0], ops[1], gen_reg_rtx (TImode),
-			  gen_reg_rtx (SImode)));
-	      return 1;
-	    }
-	}
-      /* Catch the SImode immediates greater than 0x7fffffff, and sign
-         extend them. */
-      if (GET_CODE (ops[1]) == CONST_INT)
-	{
-	  HOST_WIDE_INT val = trunc_int_for_mode (INTVAL (ops[1]), mode);
-	  if (val != INTVAL (ops[1]))
-	    {
-	      emit_move_insn (ops[0], GEN_INT (val));
-	      return 1;
-	    }
-	}
     }
+  if (MEM_P (ops[0]))
+    return spu_split_store (ops);
+  if (MEM_P (ops[1]))
+    return spu_split_load (ops);
+
   return 0;
 }
 
-void
-spu_split_load (rtx * ops)
+static void
+spu_convert_move (rtx dst, rtx src)
 {
-  enum machine_mode mode = GET_MODE (ops[0]);
-  rtx addr, load, rot, mem, p0, p1;
+  enum machine_mode mode = GET_MODE (dst);
+  enum machine_mode int_mode = mode_for_size (GET_MODE_BITSIZE (mode), MODE_INT, 0);
+  rtx reg;
+  gcc_assert (GET_MODE (src) == TImode);
+  reg = int_mode != mode ? gen_reg_rtx (int_mode) : dst;
+  emit_insn (gen_rtx_SET (VOIDmode, reg,
+	       gen_rtx_TRUNCATE (int_mode,
+		 gen_rtx_LSHIFTRT (TImode, src,
+		   GEN_INT (int_mode == DImode ? 64 : 96)))));
+  if (int_mode != mode)
+    {
+      reg = simplify_gen_subreg (mode, reg, int_mode, 0);
+      emit_move_insn (dst, reg);
+    }
+}
+
+/* Load TImode values into DST0 and DST1 (when it is non-NULL) using
+   the address from SRC and SRC+16.  Return a REG or CONST_INT that
+   specifies how many bytes to rotate the loaded registers, plus any
+   extra from EXTRA_ROTQBY.  The address and rotate amounts are
+   normalized to improve merging of loads and rotate computations. */
+static rtx
+spu_expand_load (rtx dst0, rtx dst1, rtx src, int extra_rotby)
+{
+  rtx addr = XEXP (src, 0);
+  rtx p0, p1, rot, addr0, addr1;
   int rot_amt;
 
-  addr = XEXP (ops[1], 0);
-
   rot = 0;
   rot_amt = 0;
-  if (GET_CODE (addr) == PLUS)
+
+  if (MEM_ALIGN (src) >= 128)
+    /* Address is already aligned; simply perform a TImode load.  */ ;
+  else if (GET_CODE (addr) == PLUS)
     {
       /* 8 cases:
          aligned reg   + aligned reg     => lqx
@@ -4274,13 +4347,35 @@
        */
       p0 = XEXP (addr, 0);
       p1 = XEXP (addr, 1);
-      if (REG_P (p0) && !regno_aligned_for_load (REGNO (p0)))
+      if (!reg_aligned_for_addr (p0))
 	{
-	  if (REG_P (p1) && !regno_aligned_for_load (REGNO (p1)))
+	  if (REG_P (p1) && !reg_aligned_for_addr (p1))
 	    {
-	      emit_insn (gen_addsi3 (ops[3], p0, p1));
-	      rot = ops[3];
+	      rot = gen_reg_rtx (SImode);
+	      emit_insn (gen_addsi3 (rot, p0, p1));
 	    }
+	  else if (GET_CODE (p1) == CONST_INT && (INTVAL (p1) & 15))
+	    {
+	      if (INTVAL (p1) > 0
+		  && REG_POINTER (p0)
+		  && INTVAL (p1) * BITS_PER_UNIT
+		     < REGNO_POINTER_ALIGN (REGNO (p0)))
+		{
+		  rot = gen_reg_rtx (SImode);
+		  emit_insn (gen_addsi3 (rot, p0, p1));
+		  addr = p0;
+		}
+	      else
+		{
+		  rtx x = gen_reg_rtx (SImode);
+		  emit_move_insn (x, p1);
+		  if (!spu_arith_operand (p1, SImode))
+		    p1 = x;
+		  rot = gen_reg_rtx (SImode);
+		  emit_insn (gen_addsi3 (rot, p0, p1));
+		  addr = gen_rtx_PLUS (Pmode, p0, x);
+		}
+	    }
 	  else
 	    rot = p0;
 	}
@@ -4289,16 +4384,21 @@
 	  if (GET_CODE (p1) == CONST_INT && (INTVAL (p1) & 15))
 	    {
 	      rot_amt = INTVAL (p1) & 15;
-	      p1 = GEN_INT (INTVAL (p1) & -16);
-	      addr = gen_rtx_PLUS (SImode, p0, p1);
+	      if (INTVAL (p1) & -16)
+		{
+		  p1 = GEN_INT (INTVAL (p1) & -16);
+		  addr = gen_rtx_PLUS (SImode, p0, p1);
+		}
+	      else
+		addr = p0;
 	    }
-	  else if (REG_P (p1) && !regno_aligned_for_load (REGNO (p1)))
+	  else if (REG_P (p1) && !reg_aligned_for_addr (p1))
 	    rot = p1;
 	}
     }
-  else if (GET_CODE (addr) == REG)
+  else if (REG_P (addr))
     {
-      if (!regno_aligned_for_load (REGNO (addr)))
+      if (!reg_aligned_for_addr (addr))
 	rot = addr;
     }
   else if (GET_CODE (addr) == CONST)
@@ -4317,7 +4417,10 @@
 	    addr = XEXP (XEXP (addr, 0), 0);
 	}
       else
-	rot = addr;
+	{
+	  rot = gen_reg_rtx (Pmode);
+	  emit_move_insn (rot, addr);
+	}
     }
   else if (GET_CODE (addr) == CONST_INT)
     {
@@ -4325,50 +4428,97 @@
       addr = GEN_INT (rot_amt & -16);
     }
   else if (!ALIGNED_SYMBOL_REF_P (addr))
-    rot = addr;
+    {
+      rot = gen_reg_rtx (Pmode);
+      emit_move_insn (rot, addr);
+    }
 
-  if (GET_MODE_SIZE (mode) < 4)
-    rot_amt += GET_MODE_SIZE (mode) - 4;
+  rot_amt += extra_rotby;
 
   rot_amt &= 15;
 
   if (rot && rot_amt)
     {
-      emit_insn (gen_addsi3 (ops[3], rot, GEN_INT (rot_amt)));
-      rot = ops[3];
+      rtx x = gen_reg_rtx (SImode);
+      emit_insn (gen_addsi3 (x, rot, GEN_INT (rot_amt)));
+      rot = x;
       rot_amt = 0;
     }
+  if (!rot && rot_amt)
+    rot = GEN_INT (rot_amt);
 
-  load = ops[2];
+  addr0 = copy_rtx (addr);
+  addr0 = gen_rtx_AND (SImode, copy_rtx (addr), GEN_INT (-16));
+  emit_insn (gen__movti (dst0, change_address (src, TImode, addr0)));
 
-  addr = gen_rtx_AND (SImode, copy_rtx (addr), GEN_INT (-16));
-  mem = change_address (ops[1], TImode, addr);
+  if (dst1)
+    {
+      addr1 = plus_constant (copy_rtx (addr), 16);
+      addr1 = gen_rtx_AND (SImode, addr1, GEN_INT (-16));
+      emit_insn (gen__movti (dst1, change_address (src, TImode, addr1)));
+    }
 
-  emit_insn (gen_movti (load, mem));
+  return rot;
+}
 
+int
+spu_split_load (rtx * ops)
+{
+  enum machine_mode mode = GET_MODE (ops[0]);
+  rtx addr, load, rot;
+  int rot_amt;
+
+  if (GET_MODE_SIZE (mode) >= 16)
+    return 0;
+
+  addr = XEXP (ops[1], 0);
+  gcc_assert (GET_CODE (addr) != AND);
+
+  if (!address_needs_split (ops[1]))
+    {
+      ops[1] = change_address (ops[1], TImode, addr);
+      load = gen_reg_rtx (TImode);
+      emit_insn (gen__movti (load, ops[1]));
+      spu_convert_move (ops[0], load);
+      return 1;
+    }
+
+  rot_amt = GET_MODE_SIZE (mode) < 4 ? GET_MODE_SIZE (mode) - 4 : 0;
+
+  load = gen_reg_rtx (TImode);
+  rot = spu_expand_load (load, 0, ops[1], rot_amt);
+
   if (rot)
     emit_insn (gen_rotqby_ti (load, load, rot));
-  else if (rot_amt)
-    emit_insn (gen_rotlti3 (load, load, GEN_INT (rot_amt * 8)));
 
-  if (reload_completed)
-    emit_move_insn (ops[0], gen_rtx_REG (GET_MODE (ops[0]), REGNO (load)));
-  else
-    emit_insn (gen_spu_convert (ops[0], load));
+  spu_convert_move (ops[0], load);
+  return 1;
 }
 
-void
+int
 spu_split_store (rtx * ops)
 {
   enum machine_mode mode = GET_MODE (ops[0]);
-  rtx pat = ops[2];
-  rtx reg = ops[3];
+  rtx reg;
   rtx addr, p0, p1, p1_lo, smem;
   int aform;
   int scalar;
 
+  if (GET_MODE_SIZE (mode) >= 16)
+    return 0;
+
   addr = XEXP (ops[0], 0);
+  gcc_assert (GET_CODE (addr) != AND);
 
+  if (!address_needs_split (ops[0]))
+    {
+      reg = gen_reg_rtx (TImode);
+      emit_insn (gen_spu_convert (reg, ops[1]));
+      ops[0] = change_address (ops[0], TImode, addr);
+      emit_move_insn (ops[0], reg);
+      return 1;
+    }
+
   if (GET_CODE (addr) == PLUS)
     {
       /* 8 cases:
@@ -4379,19 +4529,31 @@
          unaligned reg + aligned reg     => lqx, c?x, shuf, stqx
          unaligned reg + unaligned reg   => lqx, c?x, shuf, stqx
          unaligned reg + aligned const   => lqd, c?d, shuf, stqx
-         unaligned reg + unaligned const -> not allowed by legitimate address
+         unaligned reg + unaligned const -> lqx, c?d, shuf, stqx
        */
       aform = 0;
       p0 = XEXP (addr, 0);
       p1 = p1_lo = XEXP (addr, 1);
-      if (GET_CODE (p0) == REG && GET_CODE (p1) == CONST_INT)
+      if (REG_P (p0) && GET_CODE (p1) == CONST_INT)
 	{
 	  p1_lo = GEN_INT (INTVAL (p1) & 15);
-	  p1 = GEN_INT (INTVAL (p1) & -16);
-	  addr = gen_rtx_PLUS (SImode, p0, p1);
+	  if (reg_aligned_for_addr (p0))
+	    {
+	      p1 = GEN_INT (INTVAL (p1) & -16);
+	      if (p1 == const0_rtx)
+		addr = p0;
+	      else
+		addr = gen_rtx_PLUS (SImode, p0, p1);
+	    }
+	  else
+	    {
+	      rtx x = gen_reg_rtx (SImode);
+	      emit_move_insn (x, p1);
+	      addr = gen_rtx_PLUS (SImode, p0, x);
+	    }
 	}
     }
-  else if (GET_CODE (addr) == REG)
+  else if (REG_P (addr))
     {
       aform = 0;
       p0 = addr;
@@ -4405,31 +4567,34 @@
       p1_lo = addr;
       if (ALIGNED_SYMBOL_REF_P (addr))
 	p1_lo = const0_rtx;
-      else if (GET_CODE (addr) == CONST)
+      else if (GET_CODE (addr) == CONST
+	       && GET_CODE (XEXP (addr, 0)) == PLUS
+	       && ALIGNED_SYMBOL_REF_P (XEXP (XEXP (addr, 0), 0))
+	       && GET_CODE (XEXP (XEXP (addr, 0), 1)) == CONST_INT)
 	{
-	  if (GET_CODE (XEXP (addr, 0)) == PLUS
-	      && ALIGNED_SYMBOL_REF_P (XEXP (XEXP (addr, 0), 0))
-	      && GET_CODE (XEXP (XEXP (addr, 0), 1)) == CONST_INT)
-	    {
-	      HOST_WIDE_INT v = INTVAL (XEXP (XEXP (addr, 0), 1));
-	      if ((v & -16) != 0)
-		addr = gen_rtx_CONST (Pmode,
-				      gen_rtx_PLUS (Pmode,
-						    XEXP (XEXP (addr, 0), 0),
-						    GEN_INT (v & -16)));
-	      else
-		addr = XEXP (XEXP (addr, 0), 0);
-	      p1_lo = GEN_INT (v & 15);
-	    }
+	  HOST_WIDE_INT v = INTVAL (XEXP (XEXP (addr, 0), 1));
+	  if ((v & -16) != 0)
+	    addr = gen_rtx_CONST (Pmode,
+				  gen_rtx_PLUS (Pmode,
+						XEXP (XEXP (addr, 0), 0),
+						GEN_INT (v & -16)));
+	  else
+	    addr = XEXP (XEXP (addr, 0), 0);
+	  p1_lo = GEN_INT (v & 15);
 	}
       else if (GET_CODE (addr) == CONST_INT)
 	{
 	  p1_lo = GEN_INT (INTVAL (addr) & 15);
 	  addr = GEN_INT (INTVAL (addr) & -16);
 	}
+      else
+	{
+	  p1_lo = gen_reg_rtx (SImode);
+	  emit_move_insn (p1_lo, addr);
+	}
     }
 
-  addr = gen_rtx_AND (SImode, copy_rtx (addr), GEN_INT (-16));
+  reg = gen_reg_rtx (TImode);
 
   scalar = store_with_one_insn_p (ops[0]);
   if (!scalar)
@@ -4439,11 +4604,12 @@
          possible, and copying the flags will prevent that in certain
          cases, e.g. consider the volatile flag. */
 
+      rtx pat = gen_reg_rtx (TImode);
       rtx lmem = change_address (ops[0], TImode, copy_rtx (addr));
       set_mem_alias_set (lmem, 0);
       emit_insn (gen_movti (reg, lmem));
 
-      if (!p0 || regno_aligned_for_load (REGNO (p0)))
+      if (!p0 || reg_aligned_for_addr (p0))
 	p0 = stack_pointer_rtx;
       if (!p1_lo)
 	p1_lo = const0_rtx;
@@ -4451,17 +4617,6 @@
       emit_insn (gen_cpat (pat, p0, p1_lo, GEN_INT (GET_MODE_SIZE (mode))));
       emit_insn (gen_shufb (reg, ops[1], reg, pat));
     }
-  else if (reload_completed)
-    {
-      if (GET_CODE (ops[1]) == REG)
-	emit_move_insn (reg, gen_rtx_REG (GET_MODE (reg), REGNO (ops[1])));
-      else if (GET_CODE (ops[1]) == SUBREG)
-	emit_move_insn (reg,
-			gen_rtx_REG (GET_MODE (reg),
-				     REGNO (SUBREG_REG (ops[1]))));
-      else
-	abort ();
-    }
   else
     {
       if (GET_CODE (ops[1]) == REG)
@@ -4473,15 +4628,16 @@
     }
 
   if (GET_MODE_SIZE (mode) < 4 && scalar)
-    emit_insn (gen_shlqby_ti
-	       (reg, reg, GEN_INT (4 - GET_MODE_SIZE (mode))));
+    emit_insn (gen_ashlti3
+	       (reg, reg, GEN_INT (32 - GET_MODE_BITSIZE (mode))));
 
-  smem = change_address (ops[0], TImode, addr);
+  smem = change_address (ops[0], TImode, copy_rtx (addr));
   /* We can't use the previous alias set because the memory has changed
      size and can potentially overlap objects of other types.  */
   set_mem_alias_set (smem, 0);
 
   emit_insn (gen_movti (smem, reg));
+  return 1;
 }
 
 /* Return TRUE if X is MEM which is a struct member reference
@@ -4580,37 +4736,6 @@
     }
 }
 
-int
-spu_valid_move (rtx * ops)
-{
-  enum machine_mode mode = GET_MODE (ops[0]);
-  if (!register_operand (ops[0], mode) && !register_operand (ops[1], mode))
-    return 0;
-
-  /* init_expr_once tries to recog against load and store insns to set
-     the direct_load[] and direct_store[] arrays.  We always want to
-     consider those loads and stores valid.  init_expr_once is called in
-     the context of a dummy function which does not have a decl. */
-  if (cfun->decl == 0)
-    return 1;
-
-  /* Don't allows loads/stores which would require more than 1 insn.
-     During and after reload we assume loads and stores only take 1
-     insn. */
-  if (GET_MODE_SIZE (mode) < 16 && !reload_in_progress && !reload_completed)
-    {
-      if (GET_CODE (ops[0]) == MEM
-	  && (GET_MODE_SIZE (mode) < 4
-	      || !(store_with_one_insn_p (ops[0])
-		   || mem_is_padded_component_ref (ops[0]))))
-	return 0;
-      if (GET_CODE (ops[1]) == MEM
-	  && (GET_MODE_SIZE (mode) < 4 || !aligned_mem_p (ops[1])))
-	return 0;
-    }
-  return 1;
-}
-
 /* Return TRUE if x is a CONST_INT, CONST_DOUBLE or CONST_VECTOR that
    can be generated using the fsmbi instruction. */
 int
@@ -6324,12 +6449,25 @@
 
 void
 spu_init_expanders (void)
-{   
-  /* HARD_FRAME_REGISTER is only 128 bit aligned when
-   * frame_pointer_needed is true.  We don't know that until we're
-   * expanding the prologue. */
+{
   if (cfun)
-    REGNO_POINTER_ALIGN (HARD_FRAME_POINTER_REGNUM) = 8;
+    {
+      rtx r0, r1;
+      /* HARD_FRAME_REGISTER is only 128 bit aligned when
+         frame_pointer_needed is true.  We don't know that until we're
+         expanding the prologue. */
+      REGNO_POINTER_ALIGN (HARD_FRAME_POINTER_REGNUM) = 8;
+
+      /* A number of passes use LAST_VIRTUAL_REGISTER+1 and
+	 LAST_VIRTUAL_REGISTER+2 to test the back-end.  We want them
+	 to be treated as aligned, so generate them here. */
+      r0 = gen_reg_rtx (SImode);
+      r1 = gen_reg_rtx (SImode);
+      mark_reg_pointer (r0, 128);
+      mark_reg_pointer (r1, 128);
+      gcc_assert (REGNO (r0) == LAST_VIRTUAL_REGISTER + 1
+		  && REGNO (r1) == LAST_VIRTUAL_REGISTER + 2);
+    }
 }
 
 static enum machine_mode
@@ -6372,5 +6510,53 @@
   return default_section_type_flags (decl, name, reloc);
 }
 
+/* Generate a constant or register which contains 2^SCALE.  We assume
+   the result is valid for MODE.  Currently, MODE must be V4SFmode and
+   SCALE must be SImode. */
+rtx
+spu_gen_exp2 (enum machine_mode mode, rtx scale)
+{
+  gcc_assert (mode == V4SFmode);
+  gcc_assert (GET_MODE (scale) == SImode || GET_CODE (scale) == CONST_INT);
+  if (GET_CODE (scale) != CONST_INT)
+    {
+      /* unsigned int exp = (127 + scale) << 23;
+	__vector float m = (__vector float) spu_splats (exp); */
+      rtx reg = force_reg (SImode, scale);
+      rtx exp = gen_reg_rtx (SImode);
+      rtx mul = gen_reg_rtx (mode);
+      emit_insn (gen_addsi3 (exp, reg, GEN_INT (127)));
+      emit_insn (gen_ashlsi3 (exp, exp, GEN_INT (23)));
+      emit_insn (gen_spu_splats (mul, gen_rtx_SUBREG (GET_MODE_INNER (mode), exp, 0)));
+      return mul;
+    }
+  else
+    {
+      HOST_WIDE_INT exp = 127 + INTVAL (scale);
+      unsigned char arr[16];
+      arr[0] = arr[4] = arr[8] = arr[12] = exp >> 1;
+      arr[1] = arr[5] = arr[9] = arr[13] = exp << 7;
+      arr[2] = arr[6] = arr[10] = arr[14] = 0;
+      arr[3] = arr[7] = arr[11] = arr[15] = 0;
+      return array_to_constant (mode, arr);
+    }
+}
+
+/* After reload, just change the convert into a move instruction
+   or a dead instruction. */
+void
+spu_split_convert (rtx ops[])
+{
+  if (REGNO (ops[0]) == REGNO (ops[1]))
+    emit_note (NOTE_INSN_DELETED);
+  else
+    {
+      /* Use TImode always as this might help hard reg copyprop.  */
+      rtx op0 = gen_rtx_REG (TImode, REGNO (ops[0]));
+      rtx op1 = gen_rtx_REG (TImode, REGNO (ops[1]));
+      emit_insn (gen_move_insn (op0, op1));
+    }
+}
+
 #include "gt-spu.h"
 
Index: gcc/config/spu/spu-builtins.def
===================================================================
--- gcc/config/spu/spu-builtins.def	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/config/spu/spu-builtins.def	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -235,8 +235,8 @@
 
 /* definitions to support generic builtin functions: */
 
-DEF_BUILTIN (SPU_CONVTS,     CODE_FOR_spu_cflts,      "spu_convts",     B_INSN,     _A3(SPU_BTI_V4SI,     SPU_BTI_V4SF,   SPU_BTI_U7))
-DEF_BUILTIN (SPU_CONVTU,     CODE_FOR_spu_cfltu,      "spu_convtu",     B_INSN,     _A3(SPU_BTI_UV4SI,    SPU_BTI_V4SF,   SPU_BTI_U7))
+DEF_BUILTIN (SPU_CONVTS,     CODE_FOR_spu_cflts,      "spu_convts",     B_INSN,     _A3(SPU_BTI_V4SI,     SPU_BTI_V4SF,   SPU_BTI_INTSI))
+DEF_BUILTIN (SPU_CONVTU,     CODE_FOR_spu_cfltu,      "spu_convtu",     B_INSN,     _A3(SPU_BTI_UV4SI,    SPU_BTI_V4SF,   SPU_BTI_INTSI))
 DEF_BUILTIN (SPU_ROUNDTF,    CODE_FOR_spu_frds,       "spu_roundtf",    B_INSN,     _A2(SPU_BTI_V4SF,     SPU_BTI_V2DF))
 DEF_BUILTIN (SPU_MULH,       CODE_FOR_spu_mpyh,       "spu_mulh",       B_INSN,     _A3(SPU_BTI_V4SI,     SPU_BTI_V8HI,   SPU_BTI_V8HI))
 DEF_BUILTIN (SPU_MULSR,      CODE_FOR_spu_mpys,       "spu_mulsr",      B_INSN,     _A3(SPU_BTI_V4SI,     SPU_BTI_V8HI,   SPU_BTI_V8HI))
@@ -257,8 +257,8 @@
 /* definitions to support overloaded generic builtin functions:  */
 
 DEF_BUILTIN (SPU_CONVTF,           CODE_FOR_nothing,       "spu_convtf",           B_OVERLOAD, _A1(SPU_BTI_VOID))
-DEF_BUILTIN (SPU_CONVTF_0,         CODE_FOR_spu_cuflt,     "spu_convtf_0",         B_INTERNAL, _A3(SPU_BTI_V4SF,   SPU_BTI_UV4SI,  SPU_BTI_U7))
-DEF_BUILTIN (SPU_CONVTF_1,         CODE_FOR_spu_csflt,     "spu_convtf_1",         B_INTERNAL, _A3(SPU_BTI_V4SF,   SPU_BTI_V4SI,   SPU_BTI_U7))
+DEF_BUILTIN (SPU_CONVTF_0,         CODE_FOR_spu_cuflt,     "spu_convtf_0",         B_INTERNAL, _A3(SPU_BTI_V4SF,   SPU_BTI_UV4SI,  SPU_BTI_UINTSI))
+DEF_BUILTIN (SPU_CONVTF_1,         CODE_FOR_spu_csflt,     "spu_convtf_1",         B_INTERNAL, _A3(SPU_BTI_V4SF,   SPU_BTI_V4SI,   SPU_BTI_UINTSI))
 DEF_BUILTIN (SPU_EXTEND,           CODE_FOR_nothing,       "spu_extend",           B_OVERLOAD, _A1(SPU_BTI_VOID))
 DEF_BUILTIN (SPU_EXTEND_0,         CODE_FOR_spu_xsbh,      "spu_extend_0",         B_INTERNAL, _A2(SPU_BTI_V8HI,   SPU_BTI_V16QI))
 DEF_BUILTIN (SPU_EXTEND_1,         CODE_FOR_spu_xshw,      "spu_extend_1",         B_INTERNAL, _A2(SPU_BTI_V4SI,   SPU_BTI_V8HI))
Index: gcc/config/spu/spu-builtins.md
===================================================================
--- gcc/config/spu/spu-builtins.md	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/config/spu/spu-builtins.md	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -527,37 +527,119 @@
   [(set_attr "type" "br")])
 
 ;; float convert
-(define_insn "spu_csflt"
-  [(set (match_operand:V4SF 0 "spu_reg_operand" "=r")
-	(unspec:V4SF [(match_operand:V4SI 1 "spu_reg_operand" "r")
-		      (match_operand:SI 2 "immediate_operand" "K")] UNSPEC_CSFLT ))]
+(define_expand "spu_csflt"
+  [(set (match_operand:V4SF 0 "spu_reg_operand")
+	(unspec:V4SF [(match_operand:V4SI 1 "spu_reg_operand")
+		      (match_operand:SI 2 "spu_nonmem_operand")] 0 ))]
   ""
-  "csflt\t%0,%1,%2"
-  [(set_attr "type" "fp7")])
+{
+  if (GET_CODE (operands[2]) == CONST_INT
+      && (INTVAL (operands[2]) < 0 || INTVAL (operands[2]) > 127))
+    {
+      error ("spu_convtf expects an integer literal in the range [0, 127].");
+      operands[2] = force_reg (SImode, operands[2]);
+    }
+  if (GET_CODE (operands[2]) != CONST_INT)
+    {
+      rtx exp2;
+      rtx cnv = gen_reg_rtx (V4SFmode);
+      rtx scale = gen_reg_rtx (SImode);
+      rtx op2 = force_reg (SImode, operands[2]);
+      rtx m1 = spu_gen_exp2 (V4SFmode, GEN_INT (-1));
+      emit_insn (gen_subsi3 (scale, const1_rtx, op2));
+      exp2 = spu_gen_exp2 (V4SFmode, scale);
+      emit_insn (gen_floatv4siv4sf2_mul (cnv, operands[1], m1));
+      emit_insn (gen_mulv4sf3 (operands[0], cnv, exp2));
+    }
+  else
+    {
+      rtx exp2 = spu_gen_exp2 (V4SFmode, operands[2]);
+      emit_insn (gen_floatv4siv4sf2_div (operands[0], operands[1], exp2));
+    }
+  DONE;
+})
 
-(define_insn "spu_cflts"
-  [(set (match_operand:V4SI 0 "spu_reg_operand" "=r")
-	(unspec:V4SI [(match_operand:V4SF 1 "spu_reg_operand" "r")
-                      (match_operand:SI 2 "immediate_operand" "J")] UNSPEC_CFLTS ))]
+(define_expand "spu_cflts"
+  [(set (match_operand:V4SI 0 "spu_reg_operand")
+	(unspec:V4SI [(match_operand:V4SF 1 "spu_reg_operand")
+                      (match_operand:SI 2 "spu_nonmem_operand")] 0 ))]
   ""
-  "cflts\t%0,%1,%2"
-  [(set_attr "type" "fp7")])
+{
+  rtx exp2;
+  if (GET_CODE (operands[2]) == CONST_INT
+      && (INTVAL (operands[2]) < 0 || INTVAL (operands[2]) > 127))
+    {
+      error ("spu_convts expects an integer literal in the range [0, 127].");
+      operands[2] = force_reg (SImode, operands[2]);
+    }
+  exp2 = spu_gen_exp2 (V4SFmode, operands[2]);
+  if (GET_CODE (operands[2]) != CONST_INT)
+    {
+      rtx mul = gen_reg_rtx (V4SFmode);
+      emit_insn (gen_mulv4sf3 (mul, operands[1], exp2));
+      emit_insn (gen_fix_truncv4sfv4si2 (operands[0], mul));
+    }
+  else
+    emit_insn (gen_fix_truncv4sfv4si2_mul (operands[0], operands[1], exp2));
+  DONE;
+})
 
-(define_insn "spu_cuflt"
+(define_expand "spu_cuflt"
   [(set (match_operand:V4SF 0 "spu_reg_operand" "=r")
-	(unspec:V4SF [(match_operand:V4SI 1 "spu_reg_operand" "r")
-		      (match_operand:SI 2 "immediate_operand" "K")] UNSPEC_CUFLT ))]
+	(unspec:V4SF [(match_operand:V4SI 1 "spu_reg_operand")
+		      (match_operand:SI 2 "spu_nonmem_operand")] 0 ))]
   ""
-  "cuflt\t%0,%1,%2"
-  [(set_attr "type" "fp7")])
+{
+  if (GET_CODE (operands[2]) == CONST_INT
+      && (INTVAL (operands[2]) < 0 || INTVAL (operands[2]) > 127))
+    {
+      error ("spu_convtf expects an integer literal in the range [0, 127].");
+      operands[2] = force_reg (SImode, operands[2]);
+    }
+  if (GET_CODE (operands[2]) != CONST_INT)
+    {
+      rtx exp2;
+      rtx cnv = gen_reg_rtx (V4SFmode);
+      rtx scale = gen_reg_rtx (SImode);
+      rtx op2 = force_reg (SImode, operands[2]);
+      rtx m1 = spu_gen_exp2 (V4SFmode, GEN_INT (-1));
+      emit_insn (gen_subsi3 (scale, const1_rtx, op2));
+      exp2 = spu_gen_exp2 (V4SFmode, scale);
+      emit_insn (gen_floatunsv4siv4sf2_mul (cnv, operands[1], m1));
+      emit_insn (gen_mulv4sf3 (operands[0], cnv, exp2));
+    }
+  else
+    {
+      rtx exp2 = spu_gen_exp2 (V4SFmode, operands[2]);
+      emit_insn (gen_floatunsv4siv4sf2_div (operands[0], operands[1], exp2));
+    }
+  DONE;
+})
 
-(define_insn "spu_cfltu"
-  [(set (match_operand:V4SI 0 "spu_reg_operand" "=r")
-	(unspec:V4SI [(match_operand:V4SF 1 "spu_reg_operand" "r")
-		      (match_operand:SI 2 "immediate_operand" "J")] UNSPEC_CFLTU ))]
+(define_expand "spu_cfltu"
+  [(set (match_operand:V4SI 0 "spu_reg_operand")
+	(unspec:V4SI [(match_operand:V4SF 1 "spu_reg_operand")
+		      (match_operand:SI 2 "spu_nonmem_operand")] 0 ))]
   ""
-  "cfltu\t%0,%1,%2"
-  [(set_attr "type" "fp7")])
+{
+  rtx exp2;
+  if (GET_CODE (operands[2]) == CONST_INT
+      && (INTVAL (operands[2]) < 0 || INTVAL (operands[2]) > 127))
+    {
+      error ("spu_convtu expects an integer literal in the range [0, 127].");
+      operands[2] = force_reg (SImode, operands[2]);
+    }
+  exp2 = spu_gen_exp2 (V4SFmode, operands[2]);
+  if (GET_CODE (operands[2]) != CONST_INT)
+    {
+      rtx mul = gen_reg_rtx (V4SFmode);
+      emit_insn (gen_mulv4sf3 (mul, operands[1], exp2));
+      emit_insn (gen_fixuns_truncv4sfv4si2 (operands[0], mul));
+    }
+  else
+    emit_insn (gen_fixuns_truncv4sfv4si2_mul (operands[0], operands[1], exp2));
+  DONE;
+})
 
 (define_expand "spu_frds"
    [(set (match_operand:V4SF 0 "spu_reg_operand" "")
Index: gcc/config/spu/constraints.md
===================================================================
--- gcc/config/spu/constraints.md	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/config/spu/constraints.md	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -16,8 +16,14 @@
 ;; <http://www.gnu.org/licenses/>.
 
 
-;; GCC standard constraints:  g, i, m, n, o, p, r, s, E-H, I-P, V, X
-;; unused for SPU:  E-H, L, Q, d, e, h, q, t-z
+;;       ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
+;; GCC:      ffffiiiiiiii     x x        x x   xxxx xx
+;; SPU:  xxxx    xxx xxxx xxxx x xxx xx x   xxx         xx
+;; FREE:     ffff   i    a          a  a  a        a  aa  aaa
+;; x - used
+;; a - available
+;; i - available for integer immediates
+;; f - available for floating point immediates
 
 ;; For most immediate constraints we have 3 variations to deal with the
 ;; fact const_int has no mode.  One variation treats const_int as 32 bit,
@@ -159,4 +165,15 @@
 		    && INTVAL (XEXP (op, 0)) >= 0
 		    && INTVAL (XEXP (op, 0)) <= 0x3ffff")))
 
+
+;; Floating-point constant constraints.
 
+(define_constraint "v"
+  "Floating point power of 2 with exponent in [0..127]"
+  (and (match_code "const_double,const_vector")
+       (match_test "exp2_immediate_p (op, VOIDmode, 0, 127)")))
+
+(define_constraint "w"
+  "Floating point power of 2 with exponent in [-126..0]"
+  (and (match_code "const_double,const_vector")
+       (match_test "exp2_immediate_p (op, VOIDmode, -126, 0)")))
Index: gcc/config/spu/spu.md
===================================================================
--- gcc/config/spu/spu.md	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/config/spu/spu.md	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -136,10 +136,6 @@
  (UNSPEC_HEQ            31)
  (UNSPEC_HGT            32)
  (UNSPEC_HLGT           33)
- (UNSPEC_CSFLT          34)
- (UNSPEC_CFLTS          35)
- (UNSPEC_CUFLT          36)
- (UNSPEC_CFLTU          37)
  (UNSPEC_STOP           38)
  (UNSPEC_STOPD          39)
  (UNSPEC_SET_INTR       40)
@@ -182,6 +178,8 @@
                         SF V4SF
                         DF V2DF])
 
+(define_mode_iterator QHSI  [QI HI SI])
+(define_mode_iterator QHSDI  [QI HI SI DI])
 (define_mode_iterator DTI  [DI TI])
 
 (define_mode_iterator VINT [QI V16QI
@@ -231,6 +229,10 @@
                        (DF "di") (V2DF "v2di")])
 (define_mode_attr F2I [(SF "SI") (V4SF "V4SI")
                        (DF "DI") (V2DF "V2DI")])
+(define_mode_attr i2f [(SI "sf") (V4SI "v4sf")
+                       (DI "df") (V2DI "v2df")])
+(define_mode_attr I2F [(SI "SF") (V4SI "V4SF")
+                       (DI "DF") (V2DI "V2DF")])
 
 (define_mode_attr DF2I [(DF "SI") (V2DF "V2DI")])
 
@@ -316,9 +318,10 @@
 ;; move internal
 
 (define_insn "_mov<mode>"
-  [(set (match_operand:MOV 0 "spu_nonimm_operand" "=r,r,r,r,r,m")
+  [(set (match_operand:MOV 0 "spu_dest_operand" "=r,r,r,r,r,m")
 	(match_operand:MOV 1 "spu_mov_operand" "r,A,f,j,m,r"))]
-  "spu_valid_move (operands)"
+  "register_operand(operands[0], <MODE>mode)
+   || register_operand(operands[1], <MODE>mode)"
   "@
    ori\t%0,%1,0
    il%s1\t%0,%S1
@@ -336,9 +339,10 @@
   "iohl\t%0,%2@l")
 
 (define_insn "_movdi"
-  [(set (match_operand:DI 0 "spu_nonimm_operand" "=r,r,r,r,r,m")
+  [(set (match_operand:DI 0 "spu_dest_operand" "=r,r,r,r,r,m")
 	(match_operand:DI 1 "spu_mov_operand" "r,a,f,k,m,r"))]
-  "spu_valid_move (operands)"
+  "register_operand(operands[0], DImode)
+   || register_operand(operands[1], DImode)"
   "@
    ori\t%0,%1,0
    il%d1\t%0,%D1
@@ -349,9 +353,10 @@
   [(set_attr "type" "fx2,fx2,shuf,shuf,load,store")])
 
 (define_insn "_movti"
-  [(set (match_operand:TI 0 "spu_nonimm_operand" "=r,r,r,r,r,m")
+  [(set (match_operand:TI 0 "spu_dest_operand" "=r,r,r,r,r,m")
 	(match_operand:TI 1 "spu_mov_operand" "r,U,f,l,m,r"))]
-  "spu_valid_move (operands)"
+  "register_operand(operands[0], TImode)
+   || register_operand(operands[1], TImode)"
   "@
    ori\t%0,%1,0
    il%t1\t%0,%T1
@@ -361,30 +366,29 @@
    stq%p0\t%1,%0"
   [(set_attr "type" "fx2,fx2,shuf,shuf,load,store")])
 
-(define_insn_and_split "load"
-  [(set (match_operand 0 "spu_reg_operand" "=r")
-	(match_operand 1 "memory_operand" "m"))
-   (clobber (match_operand:TI 2 "spu_reg_operand" "=&r"))
-   (clobber (match_operand:SI 3 "spu_reg_operand" "=&r"))]
-  "GET_MODE(operands[0]) == GET_MODE(operands[1])"
-  "#"
-  ""
+(define_split
+  [(set (match_operand 0 "spu_reg_operand")
+	(match_operand 1 "memory_operand"))]
+  "GET_MODE_SIZE (GET_MODE (operands[0])) < 16
+   && GET_MODE(operands[0]) == GET_MODE(operands[1])
+   && !reload_in_progress && !reload_completed"
   [(set (match_dup 0)
 	(match_dup 1))]
-  { spu_split_load(operands); DONE; })
+  { if (spu_split_load(operands))
+      DONE;
+  })
 
-(define_insn_and_split "store"
-  [(set (match_operand 0 "memory_operand" "=m")
-	(match_operand 1 "spu_reg_operand" "r"))
-   (clobber (match_operand:TI 2 "spu_reg_operand" "=&r"))
-   (clobber (match_operand:TI 3 "spu_reg_operand" "=&r"))]
-  "GET_MODE(operands[0]) == GET_MODE(operands[1])"
-  "#"
-  ""
+(define_split
+  [(set (match_operand 0 "memory_operand")
+	(match_operand 1 "spu_reg_operand"))]
+  "GET_MODE_SIZE (GET_MODE (operands[0])) < 16
+   && GET_MODE(operands[0]) == GET_MODE(operands[1])
+   && !reload_in_progress && !reload_completed"
   [(set (match_dup 0)
 	(match_dup 1))]
-  { spu_split_store(operands); DONE; })
-
+  { if (spu_split_store(operands))
+      DONE;
+  })
 ;; Operand 3 is the number of bytes. 1:b 2:h 4:w 8:d
 
 (define_expand "cpat"
@@ -462,34 +466,21 @@
   ""
   "xswd\t%0,%1");
 
-(define_expand "extendqiti2"
+;; By splitting this late we don't allow much opportunity for sharing of
+;; constants.  That's ok because this should really be optimized away.
+(define_insn_and_split "extend<mode>ti2"
   [(set (match_operand:TI 0 "register_operand" "")
-	(sign_extend:TI (match_operand:QI 1 "register_operand" "")))]
+	(sign_extend:TI (match_operand:QHSDI 1 "register_operand" "")))]
   ""
-  "spu_expand_sign_extend(operands);
-   DONE;")
-
-(define_expand "extendhiti2"
-  [(set (match_operand:TI 0 "register_operand" "")
-	(sign_extend:TI (match_operand:HI 1 "register_operand" "")))]
+  "#"
   ""
-  "spu_expand_sign_extend(operands);
-   DONE;")
+  [(set (match_dup:TI 0)
+	(sign_extend:TI (match_dup:QHSDI 1)))]
+  {
+    spu_expand_sign_extend(operands);
+    DONE;
+  })
 
-(define_expand "extendsiti2"
-  [(set (match_operand:TI 0 "register_operand" "")
-	(sign_extend:TI (match_operand:SI 1 "register_operand" "")))]
-  ""
-  "spu_expand_sign_extend(operands);
-   DONE;")
-
-(define_expand "extendditi2"
-  [(set (match_operand:TI 0 "register_operand" "")
-	(sign_extend:TI (match_operand:DI 1 "register_operand" "")))]
-  ""
-  "spu_expand_sign_extend(operands);
-   DONE;")
-
 
 ;; zero_extend
 
@@ -525,6 +516,22 @@
   "rotqmbyi\t%0,%1,-4"
   [(set_attr "type" "shuf")])
 
+(define_insn "zero_extendqiti2"
+  [(set (match_operand:TI 0 "spu_reg_operand" "=r")
+	(zero_extend:TI (match_operand:QI 1 "spu_reg_operand" "r")))]
+  ""
+  "andi\t%0,%1,0x00ff\;rotqmbyi\t%0,%0,-12"
+  [(set_attr "type" "multi0")
+   (set_attr "length" "8")])
+
+(define_insn "zero_extendhiti2"
+  [(set (match_operand:TI 0 "spu_reg_operand" "=r")
+	(zero_extend:TI (match_operand:HI 1 "spu_reg_operand" "r")))]
+  ""
+  "shli\t%0,%1,16\;rotqmbyi\t%0,%0,-14"
+  [(set_attr "type" "multi1")
+   (set_attr "length" "8")])
+
 (define_insn "zero_extendsiti2"
   [(set (match_operand:TI 0 "spu_reg_operand" "=r")
 	(zero_extend:TI (match_operand:SI 1 "spu_reg_operand" "r")))]
@@ -594,62 +601,83 @@
 
 ;; float conversions
 
-(define_insn "floatsisf2"
-  [(set (match_operand:SF 0 "spu_reg_operand" "=r")
-	(float:SF (match_operand:SI 1 "spu_reg_operand" "r")))]
+(define_insn "float<mode><i2f>2"
+  [(set (match_operand:<I2F> 0 "spu_reg_operand" "=r")
+	(float:<I2F> (match_operand:VSI 1 "spu_reg_operand" "r")))]
   ""
   "csflt\t%0,%1,0"
   [(set_attr "type" "fp7")])
 
-(define_insn "floatv4siv4sf2"
-  [(set (match_operand:V4SF 0 "spu_reg_operand" "=r")
-	(float:V4SF (match_operand:V4SI 1 "spu_reg_operand" "r")))]
+(define_insn "fix_trunc<mode><f2i>2"
+  [(set (match_operand:<F2I> 0 "spu_reg_operand" "=r")
+	(fix:<F2I> (match_operand:VSF 1 "spu_reg_operand" "r")))]
   ""
-  "csflt\t%0,%1,0"
+  "cflts\t%0,%1,0"
   [(set_attr "type" "fp7")])
 
-(define_insn "fix_truncsfsi2"
-  [(set (match_operand:SI 0 "spu_reg_operand" "=r")
-	(fix:SI (match_operand:SF 1 "spu_reg_operand" "r")))]
+(define_insn "floatuns<mode><i2f>2"
+  [(set (match_operand:<I2F> 0 "spu_reg_operand" "=r")
+	(unsigned_float:<I2F> (match_operand:VSI 1 "spu_reg_operand" "r")))]
   ""
-  "cflts\t%0,%1,0"
+  "cuflt\t%0,%1,0"
   [(set_attr "type" "fp7")])
 
-(define_insn "fix_truncv4sfv4si2"
-  [(set (match_operand:V4SI 0 "spu_reg_operand" "=r")
-	(fix:V4SI (match_operand:V4SF 1 "spu_reg_operand" "r")))]
+(define_insn "fixuns_trunc<mode><f2i>2"
+  [(set (match_operand:<F2I> 0 "spu_reg_operand" "=r")
+	(unsigned_fix:<F2I> (match_operand:VSF 1 "spu_reg_operand" "r")))]
   ""
-  "cflts\t%0,%1,0"
+  "cfltu\t%0,%1,0"
   [(set_attr "type" "fp7")])
 
-(define_insn "floatunssisf2"
-  [(set (match_operand:SF 0 "spu_reg_operand" "=r")
-	(unsigned_float:SF (match_operand:SI 1 "spu_reg_operand" "r")))]
+(define_insn "float<mode><i2f>2_mul"
+  [(set (match_operand:<I2F> 0 "spu_reg_operand" "=r")
+	(mult:<I2F> (float:<I2F> (match_operand:VSI 1 "spu_reg_operand" "r"))
+		    (match_operand:<I2F> 2 "spu_inv_exp2_operand" "w")))]
   ""
-  "cuflt\t%0,%1,0"
+  "csflt\t%0,%1,%w2"
   [(set_attr "type" "fp7")])
 
-(define_insn "floatunsv4siv4sf2"
-  [(set (match_operand:V4SF 0 "spu_reg_operand" "=r")
-	(unsigned_float:V4SF (match_operand:V4SI 1 "spu_reg_operand" "r")))]
+(define_insn "float<mode><i2f>2_div"
+  [(set (match_operand:<I2F> 0 "spu_reg_operand" "=r")
+	(div:<I2F> (float:<I2F> (match_operand:VSI 1 "spu_reg_operand" "r"))
+		   (match_operand:<I2F> 2 "spu_exp2_operand" "v")))]
   ""
-  "cuflt\t%0,%1,0"
+  "csflt\t%0,%1,%v2"
   [(set_attr "type" "fp7")])
 
-(define_insn "fixuns_truncsfsi2"
-  [(set (match_operand:SI 0 "spu_reg_operand" "=r")
-	(unsigned_fix:SI (match_operand:SF 1 "spu_reg_operand" "r")))]
+
+(define_insn "fix_trunc<mode><f2i>2_mul"
+  [(set (match_operand:<F2I> 0 "spu_reg_operand" "=r")
+	(fix:<F2I> (mult:VSF (match_operand:VSF 1 "spu_reg_operand" "r")
+			     (match_operand:VSF 2 "spu_exp2_operand" "v"))))]
   ""
-  "cfltu\t%0,%1,0"
+  "cflts\t%0,%1,%v2"
   [(set_attr "type" "fp7")])
 
-(define_insn "fixuns_truncv4sfv4si2"
-  [(set (match_operand:V4SI 0 "spu_reg_operand" "=r")
-	(unsigned_fix:V4SI (match_operand:V4SF 1 "spu_reg_operand" "r")))]
+(define_insn "floatuns<mode><i2f>2_mul"
+  [(set (match_operand:<I2F> 0 "spu_reg_operand" "=r")
+	(mult:<I2F> (unsigned_float:<I2F> (match_operand:VSI 1 "spu_reg_operand" "r"))
+		    (match_operand:<I2F> 2 "spu_inv_exp2_operand" "w")))]
   ""
-  "cfltu\t%0,%1,0"
+  "cuflt\t%0,%1,%w2"
   [(set_attr "type" "fp7")])
 
+(define_insn "floatuns<mode><i2f>2_div"
+  [(set (match_operand:<I2F> 0 "spu_reg_operand" "=r")
+	(div:<I2F> (unsigned_float:<I2F> (match_operand:VSI 1 "spu_reg_operand" "r"))
+		   (match_operand:<I2F> 2 "spu_exp2_operand" "v")))]
+  ""
+  "cuflt\t%0,%1,%v2"
+  [(set_attr "type" "fp7")])
+
+(define_insn "fixuns_trunc<mode><f2i>2_mul"
+  [(set (match_operand:<F2I> 0 "spu_reg_operand" "=r")
+	(unsigned_fix:<F2I> (mult:VSF (match_operand:VSF 1 "spu_reg_operand" "r")
+				      (match_operand:VSF 2 "spu_exp2_operand" "v"))))]
+  ""
+  "cfltu\t%0,%1,%v2"
+  [(set_attr "type" "fp7")])
+
 (define_insn "extendsfdf2"
   [(set (match_operand:DF 0 "spu_reg_operand" "=r")
 	(unspec:DF [(match_operand:SF 1 "spu_reg_operand" "r")]
@@ -2327,6 +2355,13 @@
   ""
   [(set_attr "type" "*,fx3")])
   
+(define_insn "<v>lshr<mode>3_imm"
+  [(set (match_operand:VHSI 0 "spu_reg_operand" "=r")
+	(lshiftrt:VHSI (match_operand:VHSI 1 "spu_reg_operand" "r")
+		       (match_operand:VHSI 2 "immediate_operand" "W")))]
+  ""
+  "rot<bh>mi\t%0,%1,-%<umask>2"
+  [(set_attr "type" "fx3")])
 
 (define_insn "rotm_<mode>"
   [(set (match_operand:VHSI 0 "spu_reg_operand" "=r,r")
@@ -2338,89 +2373,59 @@
    rot<bh>mi\t%0,%1,-%<nmask>2"
   [(set_attr "type" "fx3")])
  
-(define_expand "lshr<mode>3"
-  [(parallel [(set (match_operand:DTI 0 "spu_reg_operand" "")
-		   (lshiftrt:DTI (match_operand:DTI 1 "spu_reg_operand" "")
-			         (match_operand:SI 2 "spu_nonmem_operand" "")))
-	      (clobber (match_dup:DTI 3))
-	      (clobber (match_dup:SI 4))
-	      (clobber (match_dup:SI 5))])]
+(define_insn_and_split "lshr<mode>3"
+  [(set (match_operand:DTI 0 "spu_reg_operand" "=r,r,r")
+	(lshiftrt:DTI (match_operand:DTI 1 "spu_reg_operand" "r,r,r")
+		      (match_operand:SI 2 "spu_nonmem_operand" "r,O,P")))]
   ""
-  "if (GET_CODE (operands[2]) == CONST_INT)
-    {
-      emit_insn (gen_lshr<mode>3_imm(operands[0], operands[1], operands[2]));
-      DONE;
-    }
-   operands[3] = gen_reg_rtx (<MODE>mode);
-   operands[4] = gen_reg_rtx (SImode);
-   operands[5] = gen_reg_rtx (SImode);")
-
-(define_insn_and_split "lshr<mode>3_imm"
-  [(set (match_operand:DTI 0 "spu_reg_operand" "=r,r")
-	(lshiftrt:DTI (match_operand:DTI 1 "spu_reg_operand" "r,r")
-		      (match_operand:SI 2 "immediate_operand" "O,P")))]
-  ""
   "@
+   #
    rotqmbyi\t%0,%1,-%h2
    rotqmbii\t%0,%1,-%e2"
-  "!satisfies_constraint_O (operands[2]) && !satisfies_constraint_P (operands[2])"
-  [(set (match_dup:DTI 0)
+  "REG_P (operands[2]) || (!satisfies_constraint_O (operands[2]) && !satisfies_constraint_P (operands[2]))"
+  [(set (match_dup:DTI 3)
 	(lshiftrt:DTI (match_dup:DTI 1)
 		      (match_dup:SI 4)))
    (set (match_dup:DTI 0)
-	(lshiftrt:DTI (match_dup:DTI 0)
+	(lshiftrt:DTI (match_dup:DTI 3)
 		      (match_dup:SI 5)))]
   {
-    HOST_WIDE_INT val = INTVAL(operands[2]);
-    operands[4] = GEN_INT (val&7);
-    operands[5] = GEN_INT (val&-8);
+    operands[3] = gen_reg_rtx (<MODE>mode);
+    if (GET_CODE (operands[2]) == CONST_INT)
+      {
+	HOST_WIDE_INT val = INTVAL(operands[2]);
+	operands[4] = GEN_INT (val & 7);
+	operands[5] = GEN_INT (val & -8);
+      }
+    else
+      {
+        rtx t0 = gen_reg_rtx (SImode);
+        rtx t1 = gen_reg_rtx (SImode);
+	emit_insn (gen_subsi3(t0, GEN_INT(0), operands[2]));
+	emit_insn (gen_subsi3(t1, GEN_INT(7), operands[2]));
+        operands[4] = gen_rtx_AND (SImode, gen_rtx_NEG (SImode, t0), GEN_INT (7));
+        operands[5] = gen_rtx_AND (SImode, gen_rtx_NEG (SImode, gen_rtx_AND (SImode, t1, GEN_INT (-8))), GEN_INT (-8));
+      }
   }
-  [(set_attr "type" "shuf,shuf")])
+  [(set_attr "type" "*,shuf,shuf")])
 
-(define_insn_and_split "lshr<mode>3_reg"
-  [(set (match_operand:DTI 0 "spu_reg_operand" "=r")
-	(lshiftrt:DTI (match_operand:DTI 1 "spu_reg_operand" "r")
-		      (match_operand:SI 2 "spu_reg_operand" "r")))
-   (clobber (match_operand:DTI 3 "spu_reg_operand" "=&r"))
-   (clobber (match_operand:SI 4 "spu_reg_operand" "=&r"))
-   (clobber (match_operand:SI 5 "spu_reg_operand" "=&r"))]
-  ""
-  "#"
-  ""
-  [(set (match_dup:DTI 3)
-	(lshiftrt:DTI (match_dup:DTI 1)
-		     (and:SI (neg:SI (match_dup:SI 4))
-			     (const_int 7))))
-   (set (match_dup:DTI 0)
-	(lshiftrt:DTI (match_dup:DTI 3)
-		     (and:SI (neg:SI (and:SI (match_dup:SI 5)
-					     (const_int -8)))
-			     (const_int -8))))]
-  {
-    emit_insn (gen_subsi3(operands[4], GEN_INT(0), operands[2]));
-    emit_insn (gen_subsi3(operands[5], GEN_INT(7), operands[2]));
-  })
-
-(define_insn_and_split "shrqbybi_<mode>"
+(define_expand "shrqbybi_<mode>"
   [(set (match_operand:DTI 0 "spu_reg_operand" "=r,r")
 	(lshiftrt:DTI (match_operand:DTI 1 "spu_reg_operand" "r,r")
-		      (and:SI (match_operand:SI 2 "spu_nonmem_operand" "r,I")
-			      (const_int -8))))
-   (clobber (match_scratch:SI 3 "=&r,X"))]
+		      (and:SI (neg:SI (and:SI (match_operand:SI 2 "spu_nonmem_operand" "r,I")
+					      (const_int -8)))
+			      (const_int -8))))]
   ""
-  "#"
-  "reload_completed"
-  [(set (match_dup:DTI 0)
-	(lshiftrt:DTI (match_dup:DTI 1)
-		      (and:SI (neg:SI (and:SI (match_dup:SI 3) (const_int -8)))
-			      (const_int -8))))]
   {
     if (GET_CODE (operands[2]) == CONST_INT)
-      operands[3] = GEN_INT (7 - INTVAL (operands[2]));
+      operands[2] = GEN_INT (7 - INTVAL (operands[2]));
     else
-      emit_insn (gen_subsi3 (operands[3], GEN_INT (7), operands[2]));
-  }
-  [(set_attr "type" "shuf")])
+      {
+        rtx t0 = gen_reg_rtx (SImode);
+	emit_insn (gen_subsi3 (t0, GEN_INT (7), operands[2]));
+        operands[2] = t0;
+      }
+  })
 
 (define_insn "rotqmbybi_<mode>"
   [(set (match_operand:DTI 0 "spu_reg_operand" "=r,r")
@@ -2465,25 +2470,22 @@
    rotqmbii\t%0,%1,-%E2"
   [(set_attr "type" "shuf")])
 
-(define_insn_and_split "shrqby_<mode>"
+(define_expand "shrqby_<mode>"
   [(set (match_operand:DTI 0 "spu_reg_operand" "=r,r")
 	(lshiftrt:DTI (match_operand:DTI 1 "spu_reg_operand" "r,r")
-		      (mult:SI (match_operand:SI 2 "spu_nonmem_operand" "r,I")
-			       (const_int 8))))
-   (clobber (match_scratch:SI 3 "=&r,X"))]
+		      (mult:SI (neg:SI (match_operand:SI 2 "spu_nonmem_operand" "r,I"))
+			       (const_int 8))))]
   ""
-  "#"
-  "reload_completed"
-  [(set (match_dup:DTI 0)
-	(lshiftrt:DTI (match_dup:DTI 1)
-		      (mult:SI (neg:SI (match_dup:SI 3)) (const_int 8))))]
   {
     if (GET_CODE (operands[2]) == CONST_INT)
-      operands[3] = GEN_INT (-INTVAL (operands[2]));
+      operands[2] = GEN_INT (-INTVAL (operands[2]));
     else
-      emit_insn (gen_subsi3 (operands[3], GEN_INT (0), operands[2]));
-  }
-  [(set_attr "type" "shuf")])
+      {
+        rtx t0 = gen_reg_rtx (SImode);
+	emit_insn (gen_subsi3 (t0, GEN_INT (0), operands[2]));
+        operands[2] = t0;
+      }
+  })
 
 (define_insn "rotqmby_<mode>"
   [(set (match_operand:DTI 0 "spu_reg_operand" "=r,r")
@@ -2517,7 +2519,15 @@
   ""
   [(set_attr "type" "*,fx3")])
   
+(define_insn "<v>ashr<mode>3_imm"
+  [(set (match_operand:VHSI 0 "spu_reg_operand" "=r")
+	(ashiftrt:VHSI (match_operand:VHSI 1 "spu_reg_operand" "r")
+		       (match_operand:VHSI 2 "immediate_operand" "W")))]
+  ""
+  "rotma<bh>i\t%0,%1,-%<umask>2"
+  [(set_attr "type" "fx3")])
 
+
 (define_insn "rotma_<mode>"
   [(set (match_operand:VHSI 0 "spu_reg_operand" "=r,r")
 	(ashiftrt:VHSI (match_operand:VHSI 1 "spu_reg_operand" "r,r")
@@ -2601,11 +2611,16 @@
   })
 
 
-(define_expand "ashrti3"
-  [(set (match_operand:TI 0 "spu_reg_operand" "")
-	(ashiftrt:TI (match_operand:TI 1 "spu_reg_operand" "")
-		     (match_operand:SI 2 "spu_nonmem_operand" "")))]
+(define_insn_and_split "ashrti3"
+  [(set (match_operand:TI 0 "spu_reg_operand" "=r,r")
+	(ashiftrt:TI (match_operand:TI 1 "spu_reg_operand" "r,r")
+		     (match_operand:SI 2 "spu_nonmem_operand" "r,i")))]
   ""
+  "#"
+  ""
+  [(set (match_dup:TI 0)
+	(ashiftrt:TI (match_dup:TI 1)
+		     (match_dup:SI 2)))]
   {
     rtx sign_shift = gen_reg_rtx (SImode);
     rtx sign_mask = gen_reg_rtx (TImode);
@@ -2690,33 +2705,133 @@
 
 
 ;; struct extract/insert
-;; We have to handle mem's because GCC will generate invalid SUBREG's
-;; if it handles them.  We generate better code anyway.
+;; We handle mem's because GCC will generate invalid SUBREG's
+;; and inefficient code.
 
 (define_expand "extv"
-  [(set (match_operand 0 "register_operand" "")
-	(sign_extract (match_operand 1 "register_operand" "")
-		      (match_operand:SI 2 "const_int_operand" "")
-		      (match_operand:SI 3 "const_int_operand" "")))]
+  [(set (match_operand:TI 0 "register_operand" "")
+	(sign_extract:TI (match_operand 1 "nonimmediate_operand" "")
+			 (match_operand:SI 2 "const_int_operand" "")
+			 (match_operand:SI 3 "const_int_operand" "")))]
   ""
-  { spu_expand_extv(operands, 0); DONE; })
+  {
+    spu_expand_extv (operands, 0);
+    DONE;
+  })
 
 (define_expand "extzv"
-  [(set (match_operand 0 "register_operand" "")
-	(zero_extract (match_operand 1 "register_operand" "")
+  [(set (match_operand:TI 0 "register_operand" "")
+	(zero_extract:TI (match_operand 1 "nonimmediate_operand" "")
 			 (match_operand:SI 2 "const_int_operand" "")
 			 (match_operand:SI 3 "const_int_operand" "")))]
   ""
-  { spu_expand_extv(operands, 1); DONE; })
+  {
+    spu_expand_extv (operands, 1);
+    DONE;
+  })
 
 (define_expand "insv"
-  [(set (zero_extract (match_operand 0 "register_operand" "")
+  [(set (zero_extract (match_operand 0 "nonimmediate_operand" "")
 		      (match_operand:SI 1 "const_int_operand" "")
 		      (match_operand:SI 2 "const_int_operand" ""))
 	(match_operand 3 "nonmemory_operand" ""))]
   ""
   { spu_expand_insv(operands); DONE; })
 
+;; Simplify a number of patterns that get generated by extv, extzv,
+;; insv, and loads.
+(define_insn_and_split "trunc_shr_ti<mode>"
+  [(set (match_operand:QHSI 0 "spu_reg_operand" "=r")
+        (truncate:QHSI (match_operator:TI 2 "shiftrt_operator" [(match_operand:TI 1 "spu_reg_operand" "0")
+								(const_int 96)])))]
+  ""
+  "#"
+  "reload_completed"
+  [(const_int 0)]
+  {
+    spu_split_convert (operands);
+    DONE;
+  }
+  [(set_attr "type" "convert")
+   (set_attr "length" "0")])
+
+(define_insn_and_split "trunc_shr_tidi"
+  [(set (match_operand:DI 0 "spu_reg_operand" "=r")
+        (truncate:DI (match_operator:TI 2 "shiftrt_operator" [(match_operand:TI 1 "spu_reg_operand" "0")
+							      (const_int 64)])))]
+  ""
+  "#"
+  "reload_completed"
+  [(const_int 0)]
+  {
+    spu_split_convert (operands);
+    DONE;
+  }
+  [(set_attr "type" "convert")
+   (set_attr "length" "0")])
+
+(define_insn_and_split "shl_ext_<mode>ti"
+  [(set (match_operand:TI 0 "spu_reg_operand" "=r")
+        (ashift:TI (match_operator:TI 2 "extend_operator" [(match_operand:QHSI 1 "spu_reg_operand" "0")])
+		   (const_int 96)))]
+  ""
+  "#"
+  "reload_completed"
+  [(const_int 0)]
+  {
+    spu_split_convert (operands);
+    DONE;
+  }
+  [(set_attr "type" "convert")
+   (set_attr "length" "0")])
+
+(define_insn_and_split "shl_ext_diti"
+  [(set (match_operand:TI 0 "spu_reg_operand" "=r")
+        (ashift:TI (match_operator:TI 2 "extend_operator" [(match_operand:DI 1 "spu_reg_operand" "0")])
+		   (const_int 64)))]
+  ""
+  "#"
+  "reload_completed"
+  [(const_int 0)]
+  {
+    spu_split_convert (operands);
+    DONE;
+  }
+  [(set_attr "type" "convert")
+   (set_attr "length" "0")])
+
+(define_insn "sext_trunc_lshr_tiqisi"
+  [(set (match_operand:SI 0 "spu_reg_operand" "=r")
+        (sign_extend:SI (truncate:QI (match_operator:TI 2 "shiftrt_operator" [(match_operand:TI 1 "spu_reg_operand" "r")
+									      (const_int 120)]))))]
+  ""
+  "rotmai\t%0,%1,-24"
+  [(set_attr "type" "fx3")])
+
+(define_insn "zext_trunc_lshr_tiqisi"
+  [(set (match_operand:SI 0 "spu_reg_operand" "=r")
+        (zero_extend:SI (truncate:QI (match_operator:TI 2 "shiftrt_operator" [(match_operand:TI 1 "spu_reg_operand" "r")
+									      (const_int 120)]))))]
+  ""
+  "rotmi\t%0,%1,-24"
+  [(set_attr "type" "fx3")])
+
+(define_insn "sext_trunc_lshr_tihisi"
+  [(set (match_operand:SI 0 "spu_reg_operand" "=r")
+        (sign_extend:SI (truncate:HI (match_operator:TI 2 "shiftrt_operator" [(match_operand:TI 1 "spu_reg_operand" "r")
+									      (const_int 112)]))))]
+  ""
+  "rotmai\t%0,%1,-16"
+  [(set_attr "type" "fx3")])
+
+(define_insn "zext_trunc_lshr_tihisi"
+  [(set (match_operand:SI 0 "spu_reg_operand" "=r")
+        (zero_extend:SI (truncate:HI (match_operator:TI 2 "shiftrt_operator" [(match_operand:TI 1 "spu_reg_operand" "r")
+									      (const_int 112)]))))]
+  ""
+  "rotmi\t%0,%1,-16"
+  [(set_attr "type" "fx3")])
+
 
 ;; String/block move insn.
 ;; Argument 0 is the destination
@@ -4369,21 +4484,20 @@
     DONE;
   })
 
-(define_insn "_spu_convert"
+(define_insn_and_split "_spu_convert"
   [(set (match_operand 0 "spu_reg_operand" "=r")
 	(unspec [(match_operand 1 "spu_reg_operand" "0")] UNSPEC_CONVERT))]
-  "operands"
   ""
+  "#"
+  "reload_completed"
+  [(const_int 0)]
+  {
+    spu_split_convert (operands);
+    DONE;
+  }
   [(set_attr "type" "convert")
    (set_attr "length" "0")])
 
-(define_peephole2
-  [(set (match_operand 0 "spu_reg_operand")
-	(unspec [(match_operand 1 "spu_reg_operand")] UNSPEC_CONVERT))]
-  ""
-  [(use (const_int 0))]
-  "")
-
 
 ;;
 (include "spu-builtins.md")
@@ -5252,8 +5366,8 @@
 }")
 
 (define_insn "stack_protect_set"
-  [(set (match_operand:SI 0 "spu_mem_operand" "=m")
-        (unspec:SI [(match_operand:SI 1 "spu_mem_operand" "m")] UNSPEC_SP_SET))
+  [(set (match_operand:SI 0 "memory_operand" "=m")
+        (unspec:SI [(match_operand:SI 1 "memory_operand" "m")] UNSPEC_SP_SET))
    (set (match_scratch:SI 2 "=&r") (const_int 0))]
   ""
   "lq%p1\t%2,%1\;stq%p0\t%2,%0\;xor\t%2,%2,%2"
@@ -5262,8 +5376,8 @@
 )
 
 (define_expand "stack_protect_test"
-  [(match_operand 0 "spu_mem_operand" "")
-   (match_operand 1 "spu_mem_operand" "")
+  [(match_operand 0 "memory_operand" "")
+   (match_operand 1 "memory_operand" "")
    (match_operand 2 "" "")]
   ""
 {
@@ -5289,8 +5403,8 @@
 
 (define_insn "stack_protect_test_si"
   [(set (match_operand:SI 0 "spu_reg_operand" "=&r")
-        (unspec:SI [(match_operand:SI 1 "spu_mem_operand" "m")
-                    (match_operand:SI 2 "spu_mem_operand" "m")]
+        (unspec:SI [(match_operand:SI 1 "memory_operand" "m")
+                    (match_operand:SI 2 "memory_operand" "m")]
                    UNSPEC_SP_TEST))
    (set (match_scratch:SI 3 "=&r") (const_int 0))]
   ""
Index: gcc/config/spu/spu-c.c
===================================================================
--- gcc/config/spu/spu-c.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/config/spu/spu-c.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -161,8 +161,7 @@
 	  if ((!SCALAR_TYPE_P (param_type)
 	       || !SCALAR_TYPE_P (arg_type)
 	       || (all_scalar && p == 0))
-	      && !comptypes (TYPE_MAIN_VARIANT (param_type),
-			     TYPE_MAIN_VARIANT (arg_type)))
+	      && !lang_hooks.types_compatible_p (param_type, arg_type))
 	    break;
 	}
       if (param == void_list_node)
Index: gcc/config/sparc/sparc-protos.h
===================================================================
--- gcc/config/sparc/sparc-protos.h	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/config/sparc/sparc-protos.h	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -70,8 +70,6 @@
 extern bool constant_address_p (rtx);
 extern bool legitimate_pic_operand_p (rtx);
 extern int legitimate_address_p (enum machine_mode, rtx, int);
-extern rtx legitimize_pic_address (rtx, enum machine_mode, rtx);
-extern rtx legitimize_tls_address (rtx);
 extern rtx legitimize_address (rtx, rtx, enum machine_mode);
 extern void sparc_emit_call_insn (rtx, rtx);
 extern void sparc_defer_case_vector (rtx, rtx, int);
@@ -103,7 +101,6 @@
 extern int fp_sethi_p (rtx);
 extern int fp_mov_p (rtx);
 extern int fp_high_losum_p (rtx);
-extern bool sparc_tls_referenced_p (rtx);
 extern int mem_min_alignment (rtx, int);
 extern int pic_address_needs_scratch (rtx);
 extern int reg_unused_after (rtx, rtx);
Index: gcc/config/sparc/sparc.c
===================================================================
--- gcc/config/sparc/sparc.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/config/sparc/sparc.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,6 +1,6 @@
 /* Subroutines for insn-output.c for SPARC.
    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010
    Free Software Foundation, Inc.
    Contributed by Michael Tiemann (tiemann@cygnus.com)
    64-bit SPARC-V9 support by Michael Tiemann, Jim Wilson, and Doug Evans,
@@ -371,8 +371,9 @@
 static void emit_save_or_restore_regs (int);
 static void sparc_asm_function_prologue (FILE *, HOST_WIDE_INT);
 static void sparc_asm_function_epilogue (FILE *, HOST_WIDE_INT);
-#ifdef OBJECT_FORMAT_ELF
-static void sparc_elf_asm_named_section (const char *, unsigned int, tree);
+#if defined (OBJECT_FORMAT_ELF)
+static void sparc_elf_asm_named_section (const char *, unsigned int, tree)
+    ATTRIBUTE_UNUSED;
 #endif
 
 static int sparc_adjust_cost (rtx, rtx, rtx, int);
@@ -412,6 +413,9 @@
 static void sparc_va_start (tree, rtx);
 static tree sparc_gimplify_va_arg (tree, tree, gimple_seq *, gimple_seq *);
 static bool sparc_vector_mode_supported_p (enum machine_mode);
+static bool sparc_tls_referenced_p (rtx);
+static rtx legitimize_tls_address (rtx);
+static rtx legitimize_pic_address (rtx, rtx);
 static bool sparc_pass_by_reference (CUMULATIVE_ARGS *,
 				     enum machine_mode, const_tree, bool);
 static int sparc_arg_partial_bytes (CUMULATIVE_ARGS *,
@@ -986,34 +990,17 @@
   /* Fixup TLS cases.  */
   if (TARGET_HAVE_TLS
       && CONSTANT_P (operands[1])
-      && GET_CODE (operands[1]) != HIGH
       && sparc_tls_referenced_p (operands [1]))
     {
-      rtx sym = operands[1];
-      rtx addend = NULL;
-
-      if (GET_CODE (sym) == CONST && GET_CODE (XEXP (sym, 0)) == PLUS)
-	{
-	  addend = XEXP (XEXP (sym, 0), 1);
-	  sym = XEXP (XEXP (sym, 0), 0);
-	}
-
-      gcc_assert (SPARC_SYMBOL_REF_TLS_P (sym));
-
-      sym = legitimize_tls_address (sym);
-      if (addend)
-	{
-	  sym = gen_rtx_PLUS (mode, sym, addend);
-	  sym = force_operand (sym, operands[0]);
-	}
-      operands[1] = sym;
+      operands[1] = legitimize_tls_address (operands[1]);
+      return false;
     }
- 
+
   /* Fixup PIC cases.  */
   if (flag_pic && CONSTANT_P (operands[1]))
     {
       if (pic_address_needs_scratch (operands[1]))
-	operands[1] = legitimize_pic_address (operands[1], mode, 0);
+	operands[1] = legitimize_pic_address (operands[1], NULL_RTX);
 
       /* VxWorks does not impose a fixed gap between segments; the run-time
 	 gap can be different from the object-file gap.  We therefore can't
@@ -1041,10 +1028,8 @@
       if (symbolic_operand (operands[1], mode))
 	{
 	  operands[1] = legitimize_pic_address (operands[1],
-						mode,
-						(reload_in_progress ?
-						 operands[0] :
-						 NULL_RTX));
+						reload_in_progress
+						? operands[0] : NULL_RTX);
 	  return false;
 	}
     }
@@ -2865,26 +2850,14 @@
 bool
 legitimate_constant_p (rtx x)
 {
-  rtx inner;
-
   switch (GET_CODE (x))
     {
+    case CONST:
     case SYMBOL_REF:
-      /* TLS symbols are not constant.  */
-      if (SYMBOL_REF_TLS_MODEL (x))
+      if (sparc_tls_referenced_p (x))
 	return false;
       break;
 
-    case CONST:
-      inner = XEXP (x, 0);
-
-      /* Offsets of TLS symbols are never valid.
-	 Discourage CSE from creating them.  */
-      if (GET_CODE (inner) == PLUS
-	  && SPARC_SYMBOL_REF_TLS_P (XEXP (inner, 0)))
-	return false;
-      break;
-
     case CONST_DOUBLE:
       if (GET_MODE (x) == VOIDmode)
         return true;
@@ -2948,10 +2921,7 @@
 {
   if (pic_address_needs_scratch (x))
     return false;
-  if (SPARC_SYMBOL_REF_TLS_P (x)
-      || (GET_CODE (x) == CONST
-	  && GET_CODE (XEXP (x, 0)) == PLUS
-	  && SPARC_SYMBOL_REF_TLS_P (XEXP (XEXP (x, 0), 0))))
+  if (sparc_tls_referenced_p (x))
     return false;
   return true;
 }
@@ -2989,7 +2959,7 @@
 	   && GET_CODE (rs2) != SUBREG
 	   && GET_CODE (rs2) != LO_SUM
 	   && GET_CODE (rs2) != MEM
-	   && ! SPARC_SYMBOL_REF_TLS_P (rs2)
+	   && !(GET_CODE (rs2) == SYMBOL_REF && SYMBOL_REF_TLS_MODEL (rs2))
 	   && (! symbolic_operand (rs2, VOIDmode) || mode == Pmode)
 	   && (GET_CODE (rs2) != CONST_INT || SMALL_INT (rs2)))
 	  || ((REG_P (rs1)
@@ -3029,7 +2999,8 @@
 	  rs2 = NULL;
 	  imm1 = XEXP (rs1, 1);
 	  rs1 = XEXP (rs1, 0);
-	  if (! CONSTANT_P (imm1) || SPARC_SYMBOL_REF_TLS_P (rs1))
+	  if (!CONSTANT_P (imm1)
+	      || (GET_CODE (rs1) == SYMBOL_REF && SYMBOL_REF_TLS_MODEL (rs1)))
 	    return 0;
 	}
     }
@@ -3038,7 +3009,8 @@
       rs1 = XEXP (addr, 0);
       imm1 = XEXP (addr, 1);
 
-      if (! CONSTANT_P (imm1) || SPARC_SYMBOL_REF_TLS_P (rs1))
+      if (!CONSTANT_P (imm1)
+	  || (GET_CODE (rs1) == SYMBOL_REF && SYMBOL_REF_TLS_MODEL (rs1)))
 	return 0;
 
       /* We can't allow TFmode in 32-bit mode, because an offset greater
@@ -3114,29 +3086,28 @@
   return temp;
 }
 
-/* Return 1 if *X is a thread-local symbol.  */
+/* Return true if X contains a thread-local symbol.  */
 
-static int
-sparc_tls_symbol_ref_1 (rtx *x, void *data ATTRIBUTE_UNUSED)
-{
-  return SPARC_SYMBOL_REF_TLS_P (*x);
-}
-
-/* Return 1 if X contains a thread-local symbol.  */
-
-bool
+static bool
 sparc_tls_referenced_p (rtx x)
 {
   if (!TARGET_HAVE_TLS)
     return false;
 
-  return for_each_rtx (&x, &sparc_tls_symbol_ref_1, 0);
+  if (GET_CODE (x) == CONST && GET_CODE (XEXP (x, 0)) == PLUS)
+    x = XEXP (XEXP (x, 0), 0);
+
+  if (GET_CODE (x) == SYMBOL_REF && SYMBOL_REF_TLS_MODEL (x))
+    return true;
+
+  /* That's all we handle in legitimize_tls_address for now.  */
+  return false;
 }
 
 /* ADDR contains a thread-local SYMBOL_REF.  Generate code to compute
    this (thread-local) address.  */
 
-rtx
+static rtx
 legitimize_tls_address (rtx addr)
 {
   rtx temp1, temp2, temp3, ret, o0, got, insn;
@@ -3260,21 +3231,34 @@
 	gcc_unreachable ();
       }
 
+  else if (GET_CODE (addr) == CONST)
+    {
+      rtx base, offset;
+
+      gcc_assert (GET_CODE (XEXP (addr, 0)) == PLUS);
+
+      base = legitimize_tls_address (XEXP (XEXP (addr, 0), 0));
+      offset = XEXP (XEXP (addr, 0), 1);
+
+      base = force_operand (base, NULL_RTX);
+      if (!(GET_CODE (offset) == CONST_INT && SMALL_INT (offset)))
+	offset = force_reg (Pmode, offset);
+      ret = gen_rtx_PLUS (Pmode, base, offset);
+    }
+
   else
     gcc_unreachable ();  /* for now ... */
 
   return ret;
 }
 
-
 /* Legitimize PIC addresses.  If the address is already position-independent,
    we return ORIG.  Newly generated position-independent addresses go into a
    reg.  This is REG if nonzero, otherwise we allocate register(s) as
    necessary.  */
 
-rtx
-legitimize_pic_address (rtx orig, enum machine_mode mode ATTRIBUTE_UNUSED,
-			rtx reg)
+static rtx
+legitimize_pic_address (rtx orig, rtx reg)
 {
   if (GET_CODE (orig) == SYMBOL_REF
       /* See the comment in sparc_expand_move.  */
@@ -3341,9 +3325,9 @@
 	}
 
       gcc_assert (GET_CODE (XEXP (orig, 0)) == PLUS);
-      base = legitimize_pic_address (XEXP (XEXP (orig, 0), 0), Pmode, reg);
-      offset = legitimize_pic_address (XEXP (XEXP (orig, 0), 1), Pmode,
-			 	       base == reg ? 0 : reg);
+      base = legitimize_pic_address (XEXP (XEXP (orig, 0), 0), reg);
+      offset = legitimize_pic_address (XEXP (XEXP (orig, 0), 1),
+			 	       base == reg ? NULL_RTX : reg);
 
       if (GET_CODE (offset) == CONST_INT)
 	{
@@ -3395,10 +3379,10 @@
   if (x != orig_x && legitimate_address_p (mode, x, FALSE))
     return x;
 
-  if (SPARC_SYMBOL_REF_TLS_P (x))
+  if (sparc_tls_referenced_p (x))
     x = legitimize_tls_address (x);
   else if (flag_pic)
-    x = legitimize_pic_address (x, mode, 0);
+    x = legitimize_pic_address (x, NULL_RTX);
   else if (GET_CODE (x) == PLUS && CONSTANT_ADDRESS_P (XEXP (x, 1)))
     x = gen_rtx_PLUS (Pmode, XEXP (x, 0),
 		      copy_to_mode_reg (Pmode, XEXP (x, 1)));
@@ -3407,8 +3391,9 @@
 		      copy_to_mode_reg (Pmode, XEXP (x, 0)));
   else if (GET_CODE (x) == SYMBOL_REF
 	   || GET_CODE (x) == CONST
-           || GET_CODE (x) == LABEL_REF)
+	   || GET_CODE (x) == LABEL_REF)
     x = copy_to_suggested_reg (x, NULL_RTX, Pmode);
+
   return x;
 }
 
@@ -7863,19 +7848,11 @@
     }
 }
 
-#ifdef OBJECT_FORMAT_ELF
+#if defined (OBJECT_FORMAT_ELF)
 static void
 sparc_elf_asm_named_section (const char *name, unsigned int flags,
 			     tree decl)
 {
-  if (flags & SECTION_MERGE)
-    {
-      /* entsize cannot be expressed in this section attributes
-	 encoding style.  */
-      default_elf_asm_named_section (name, flags, decl);
-      return;
-    }
-
   fprintf (asm_out_file, "\t.section\t\"%s\"", name);
 
   if (!(flags & SECTION_DEBUG))
@@ -8758,7 +8735,7 @@
 	  /* Delay emitting the PIC helper function because it needs to
 	     change the section and we are emitting assembly code.  */
 	  load_pic_register (true);  /* clobbers %o7 */
-	  scratch = legitimize_pic_address (funexp, Pmode, scratch);
+	  scratch = legitimize_pic_address (funexp, scratch);
 	  seq = get_insns ();
 	  end_sequence ();
 	  emit_and_preserve (seq, spill_reg, spill_reg2);
Index: gcc/config/sparc/sparc.h
===================================================================
--- gcc/config/sparc/sparc.h	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/config/sparc/sparc.h	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -2297,9 +2297,6 @@
       }					\
   } while (0)
 
-#define SPARC_SYMBOL_REF_TLS_P(RTX) \
-  (GET_CODE (RTX) == SYMBOL_REF && SYMBOL_REF_TLS_MODEL (RTX) != 0)
-
 #define PRINT_OPERAND_PUNCT_VALID_P(CHAR) \
   ((CHAR) == '#' || (CHAR) == '*' || (CHAR) == '('		\
    || (CHAR) == ')' || (CHAR) == '_' || (CHAR) == '&')
Index: gcc/config/sparc/gas.h
===================================================================
--- gcc/config/sparc/gas.h	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/config/sparc/gas.h	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,6 @@
+/* Definitions of target machine for GCC, for SPARC
+   using the GNU assembler.  */
+
+/* Switch into a generic section.  */
+#undef TARGET_ASM_NAMED_SECTION
+#define TARGET_ASM_NAMED_SECTION  default_elf_asm_named_section
Index: gcc/config/sparc/sysv4.h
===================================================================
--- gcc/config/sparc/sysv4.h	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/config/sparc/sysv4.h	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,5 +1,6 @@
 /* Target definitions for GNU compiler for SPARC running System V.4
-   Copyright (C) 1991, 1992, 1995, 1996, 1997, 1998, 2000, 2002, 2007, 2009
+   Copyright (C) 1991, 1992, 1995, 1996, 1997, 1998, 2000, 2002, 2007, 2009,
+   2010
    Free Software Foundation, Inc.
    Contributed by Ron Guilmette (rfg@monkeys.com).
 
Index: gcc/config/t-slibgcc-libgcc
===================================================================
--- gcc/config/t-slibgcc-libgcc	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ gcc/config/t-slibgcc-libgcc	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,32 @@
+# Copyright (C) 2009 Free Software Foundation, Inc.
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+#
+# GCC is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+# Instead of creating $(SHLIB_SOLINK) symlink create a GNU ld
+# linker script which sources in both $(SHLIB_SONAME) and libgcc.a.
+# This is needed on targets where libgcc.a contains routines that aren't in
+# $(SHLIB_SONAME) and are needed for shared libraries.
+
+SHLIB_MAKE_SOLINK = \
+	(echo "/* GNU ld script"; \
+	 echo "   Use the shared library, but some functions are only in"; \
+	 echo "   the static library.  */"; \
+	 echo "GROUP ( $(SHLIB_SONAME) libgcc.a )" \
+	) > $(SHLIB_DIR)/$(SHLIB_SOLINK)
+SHLIB_INSTALL_SOLINK = \
+	$(INSTALL_DATA) $(SHLIB_DIR)/$(SHLIB_SOLINK) \
+	  $$(DESTDIR)$$(slibdir)$(SHLIB_SLIBDIR_QUAL)/$(SHLIB_SOLINK)
Index: gcc/config/i386/cygming.h
===================================================================
--- gcc/config/i386/cygming.h	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/config/i386/cygming.h	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -49,8 +49,9 @@
    target, always use the svr4_dbx_register_map for DWARF .eh_frame
    even if we don't use DWARF .debug_frame. */
 #undef DWARF_FRAME_REGNUM
-#define DWARF_FRAME_REGNUM(n) TARGET_64BIT \
-	? dbx64_register_map[(n)] : svr4_dbx_register_map[(n)] 
+#define DWARF_FRAME_REGNUM(n)					\
+  (TARGET_64BIT ? dbx64_register_map[(n)]			\
+		: svr4_dbx_register_map[(n)])
 
 #ifdef HAVE_GAS_PE_SECREL32_RELOC
 /* Use section relative relocations for debugging offsets.  Unlike
@@ -126,8 +127,6 @@
 
 /* Enable parsing of #pragma pack(push,<n>) and #pragma pack(pop).  */
 #define HANDLE_PRAGMA_PACK_PUSH_POP 1
-/* Enable push_macro & pop_macro */
-#define HANDLE_PRAGMA_PUSH_POP_MACRO 1
 
 union tree_node;
 #define TREE union tree_node *
Index: gcc/config/i386/cygwin.h
===================================================================
--- gcc/config/i386/cygwin.h	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/config/i386/cygwin.h	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -94,7 +94,7 @@
   %{shared|mdll: -e \
     %{mno-cygwin:_DllMainCRTStartup@12} \
     %{!mno-cygwin:__cygwin_dll_entry@12}}\
-  %{!mno-cygwin:--dll-search-prefix=cyg}"
+  %{!mno-cygwin:--dll-search-prefix=cyg -tsaware}"
 
 /* Allocate space for all of the machine-spec-specific stuff.
    Allocate enough space for cygwin -> mingw32  munging plus
Index: gcc/config/i386/i386.md
===================================================================
--- gcc/config/i386/i386.md	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/config/i386/i386.md	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -6487,7 +6487,7 @@
   switch (get_attr_type (insn))
     {
     case TYPE_LEA:
-      operands[2] = SET_SRC (XVECEXP (PATTERN (insn), 0, 0));
+      operands[2] = XEXP (SET_SRC (XVECEXP (PATTERN (insn), 0, 0)), 0);
       return "lea{l}\t{%a2, %k0|%k0, %a2}";
 
     case TYPE_INCDEC:
@@ -9880,7 +9880,7 @@
 			   (const_int 8))))
    (clobber (reg:CC FLAGS_REG))]
   "(!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))"
-  "ior{b}\t{%h2, %h0|%h0, %h2}"
+  "or{b}\t{%h2, %h0|%h0, %h2}"
   [(set_attr "type" "alu")
    (set_attr "length_immediate" "0")
    (set_attr "mode" "QI")])
@@ -14941,6 +14941,10 @@
 ;; checked for calls.  This is a bug in the generic code, but it isn't that
 ;; easy to fix.  Ignore it for now and be prepared to fix things up.
 
+;; P6 processors will jump to the address after the decrement when %esp
+;; is used as a call operand, so they will execute return address as a code.
+;; See Pentium Pro errata 70, Pentium 2 errata A33 and Pentium 3 errata E17.
+
 ;; Call subroutine returning no value.
 
 (define_expand "call_pop"
@@ -14970,11 +14974,11 @@
   [(set_attr "type" "call")])
 
 (define_insn "*call_pop_1"
-  [(call (mem:QI (match_operand:SI 0 "call_insn_operand" "rsm"))
+  [(call (mem:QI (match_operand:SI 0 "call_insn_operand" "lsm"))
 	 (match_operand:SI 1 "" ""))
    (set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG)
 			    (match_operand:SI 2 "immediate_operand" "i")))]
-  "!SIBLING_CALL_P (insn) && !TARGET_64BIT"
+  "!TARGET_64BIT && !SIBLING_CALL_P (insn)"
 {
   if (constant_call_address_operand (operands[0], Pmode))
     return "call\t%P0";
@@ -14987,7 +14991,7 @@
 	 (match_operand:SI 1 "" ""))
    (set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG)
 			    (match_operand:SI 2 "immediate_operand" "i,i")))]
-  "SIBLING_CALL_P (insn) && !TARGET_64BIT"
+  "!TARGET_64BIT && SIBLING_CALL_P (insn)"
   "@
    jmp\t%P0
    jmp\t%A0"
@@ -15026,9 +15030,9 @@
   [(set_attr "type" "call")])
 
 (define_insn "*call_1"
-  [(call (mem:QI (match_operand:SI 0 "call_insn_operand" "rsm"))
+  [(call (mem:QI (match_operand:SI 0 "call_insn_operand" "lsm"))
 	 (match_operand 1 "" ""))]
-  "!SIBLING_CALL_P (insn) && !TARGET_64BIT"
+  "!TARGET_64BIT && !SIBLING_CALL_P (insn)"
 {
   if (constant_call_address_operand (operands[0], Pmode))
     return "call\t%P0";
@@ -15039,7 +15043,7 @@
 (define_insn "*sibcall_1"
   [(call (mem:QI (match_operand:SI 0 "sibcall_insn_operand" "s,U"))
 	 (match_operand 1 "" ""))]
-  "SIBLING_CALL_P (insn) && !TARGET_64BIT"
+  "!TARGET_64BIT && SIBLING_CALL_P (insn)"
   "@
    jmp\t%P0
    jmp\t%A0"
@@ -15048,7 +15052,7 @@
 (define_insn "*call_1_rex64"
   [(call (mem:QI (match_operand:DI 0 "call_insn_operand" "rsm"))
 	 (match_operand 1 "" ""))]
-  "!SIBLING_CALL_P (insn) && TARGET_64BIT
+  "TARGET_64BIT && !SIBLING_CALL_P (insn)
    && ix86_cmodel != CM_LARGE && ix86_cmodel != CM_LARGE_PIC"
 {
   if (constant_call_address_operand (operands[0], Pmode))
@@ -15073,7 +15077,7 @@
    (clobber (reg:TI XMM15_REG))
    (clobber (reg:DI SI_REG))
    (clobber (reg:DI DI_REG))]
-  "!SIBLING_CALL_P (insn) && TARGET_64BIT"
+  "TARGET_64BIT && !SIBLING_CALL_P (insn)"
 {
   if (constant_call_address_operand (operands[0], Pmode))
     return "call\t%P0";
@@ -15084,14 +15088,14 @@
 (define_insn "*call_1_rex64_large"
   [(call (mem:QI (match_operand:DI 0 "call_insn_operand" "rm"))
 	 (match_operand 1 "" ""))]
-  "!SIBLING_CALL_P (insn) && TARGET_64BIT"
+  "TARGET_64BIT && !SIBLING_CALL_P (insn)"
   "call\t%A0"
   [(set_attr "type" "call")])
 
 (define_insn "*sibcall_1_rex64"
   [(call (mem:QI (match_operand:DI 0 "sibcall_insn_operand" "s,U"))
 	 (match_operand 1 "" ""))]
-  "SIBLING_CALL_P (insn) && TARGET_64BIT"
+  "TARGET_64BIT && SIBLING_CALL_P (insn)"
   "@
    jmp\t%P0
    jmp\t%A0"
@@ -21469,11 +21473,11 @@
 
 (define_insn "*call_value_pop_1"
   [(set (match_operand 0 "" "")
-	(call (mem:QI (match_operand:SI 1 "call_insn_operand" "rsm"))
+	(call (mem:QI (match_operand:SI 1 "call_insn_operand" "lsm"))
 	      (match_operand:SI 2 "" "")))
    (set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG)
 			    (match_operand:SI 3 "immediate_operand" "i")))]
-  "!SIBLING_CALL_P (insn) && !TARGET_64BIT"
+  "!TARGET_64BIT && !SIBLING_CALL_P (insn)"
 {
   if (constant_call_address_operand (operands[1], Pmode))
     return "call\t%P1";
@@ -21487,7 +21491,7 @@
 	      (match_operand:SI 2 "" "")))
    (set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG)
 			    (match_operand:SI 3 "immediate_operand" "i,i")))]
-  "SIBLING_CALL_P (insn) && !TARGET_64BIT"
+  "!TARGET_64BIT && SIBLING_CALL_P (insn)"
   "@
    jmp\t%P1
    jmp\t%A1"
@@ -21536,7 +21540,7 @@
    (clobber (reg:TI XMM15_REG))
    (clobber (reg:DI SI_REG))
    (clobber (reg:DI DI_REG))]
-  "!SIBLING_CALL_P (insn) && TARGET_64BIT"
+  "TARGET_64BIT && !SIBLING_CALL_P (insn)"
 {
   if (SIBLING_CALL_P (insn))
     return "jmp\t%P1";
@@ -21547,9 +21551,9 @@
 
 (define_insn "*call_value_1"
   [(set (match_operand 0 "" "")
-	(call (mem:QI (match_operand:SI 1 "call_insn_operand" "rsm"))
+	(call (mem:QI (match_operand:SI 1 "call_insn_operand" "lsm"))
 	      (match_operand:SI 2 "" "")))]
-  "!SIBLING_CALL_P (insn) && !TARGET_64BIT"
+  "!TARGET_64BIT && !SIBLING_CALL_P (insn)"
 {
   if (constant_call_address_operand (operands[1], Pmode))
     return "call\t%P1";
@@ -21561,7 +21565,7 @@
   [(set (match_operand 0 "" "")
 	(call (mem:QI (match_operand:SI 1 "sibcall_insn_operand" "s,U"))
 	      (match_operand:SI 2 "" "")))]
-  "SIBLING_CALL_P (insn) && !TARGET_64BIT"
+  "!TARGET_64BIT && SIBLING_CALL_P (insn)"
   "@
    jmp\t%P1
    jmp\t%A1"
@@ -21571,7 +21575,7 @@
   [(set (match_operand 0 "" "")
 	(call (mem:QI (match_operand:DI 1 "call_insn_operand" "rsm"))
 	      (match_operand:DI 2 "" "")))]
-  "!SIBLING_CALL_P (insn) && TARGET_64BIT
+  "TARGET_64BIT && !SIBLING_CALL_P (insn)
    && ix86_cmodel != CM_LARGE && ix86_cmodel != CM_LARGE_PIC"
 {
   if (constant_call_address_operand (operands[1], Pmode))
@@ -21609,7 +21613,7 @@
   [(set (match_operand 0 "" "")
 	(call (mem:QI (match_operand:DI 1 "call_insn_operand" "rm"))
 	      (match_operand:DI 2 "" "")))]
-  "!SIBLING_CALL_P (insn) && TARGET_64BIT"
+  "TARGET_64BIT && !SIBLING_CALL_P (insn)"
   "call\t%A1"
   [(set_attr "type" "callv")])
 
@@ -21617,7 +21621,7 @@
   [(set (match_operand 0 "" "")
 	(call (mem:QI (match_operand:DI 1 "sibcall_insn_operand" "s,U"))
 	      (match_operand:DI 2 "" "")))]
-  "SIBLING_CALL_P (insn) && TARGET_64BIT"
+  "TARGET_64BIT && SIBLING_CALL_P (insn)"
   "@
    jmp\t%P1
    jmp\t%A1"
@@ -21932,7 +21936,7 @@
   [(set_attr "type" "multi")])
 
 (define_mode_iterator CRC32MODE [QI HI SI])
-(define_mode_attr crc32modesuffix [(QI "b") (HI "w") (SI "l")])
+(define_mode_attr crc32modesuffix [(QI "{b}") (HI "{w}") (SI "{l}")])
 (define_mode_attr crc32modeconstraint [(QI "qm") (HI "rm") (SI "rm")])
 
 (define_insn "sse4_2_crc32<mode>"
@@ -21955,7 +21959,7 @@
 	   (match_operand:DI 2 "nonimmediate_operand" "rm")]
 	  UNSPEC_CRC32))]
   "TARGET_SSE4_2 && TARGET_64BIT"
-  "crc32q\t{%2, %0|%0, %2}"
+  "crc32{q}\t{%2, %0|%0, %2}"
   [(set_attr "type" "sselog1")
    (set_attr "prefix_rep" "1")
    (set_attr "prefix_extra" "1")
Index: gcc/config/i386/mmx.md
===================================================================
--- gcc/config/i386/mmx.md	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/config/i386/mmx.md	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -336,7 +336,7 @@
   "TARGET_3DNOW && !(MEM_P (operands[0]) && MEM_P (operands[1]))"
   "@
    pfsub\t{%2, %0|%0, %2}
-   pfsubr\t{%2, %0|%0, %2}"
+   pfsubr\t{%1, %0|%0, %1}"
   [(set_attr "type" "mmxadd")
    (set_attr "mode" "V2SF")])
 
@@ -1202,7 +1202,10 @@
   "TARGET_SSE || TARGET_3DNOW_A"
 {
   operands[3] = GEN_INT (exact_log2 (INTVAL (operands[3])));
-  return "pinsrw\t{%3, %k2, %0|%0, %k2, %3}";
+  if (MEM_P (operands[2]))
+    return "pinsrw\t{%3, %2, %0|%0, %2, %3}";
+  else
+    return "pinsrw\t{%3, %k2, %0|%0, %k2, %3}";
 }
   [(set_attr "type" "mmxcvt")
    (set_attr "mode" "DI")])
Index: gcc/config/i386/predicates.md
===================================================================
--- gcc/config/i386/predicates.md	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/config/i386/predicates.md	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -519,6 +519,22 @@
 			FIRST_PSEUDO_REGISTER, LAST_VIRTUAL_REGISTER));
 })
 
+;; P6 processors will jump to the address after the decrement when %esp
+;; is used as a call operand, so they will execute return address as a code.
+;; See Pentium Pro errata 70, Pentium 2 errata A33 and Pentium 3 errata E17.
+
+(define_predicate "call_register_no_elim_operand"
+  (match_operand 0 "register_operand")
+{
+  if (GET_CODE (op) == SUBREG)
+    op = SUBREG_REG (op);
+
+  if (!TARGET_64BIT && op == stack_pointer_rtx)
+    return 0;
+
+  return register_no_elim_operand (op, mode);
+})
+
 ;; Similarly, but include the stack pointer.  This is used to prevent esp
 ;; from being used as an index reg.
 (define_predicate "index_register_operand"
@@ -547,7 +563,7 @@
 ;; Test for a valid operand for a call instruction.
 (define_predicate "call_insn_operand"
   (ior (match_operand 0 "constant_call_address_operand")
-       (ior (match_operand 0 "register_no_elim_operand")
+       (ior (match_operand 0 "call_register_no_elim_operand")
 	    (match_operand 0 "memory_operand"))))
 
 ;; Similarly, but for tail calls, in which we cannot allow memory references.
Index: gcc/config/i386/sse.md
===================================================================
--- gcc/config/i386/sse.md	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/config/i386/sse.md	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -2307,7 +2307,7 @@
 	     (parallel [(const_int 0)]))]
 	  UNSPEC_FIX_NOTRUNC))]
   "TARGET_SSE && TARGET_64BIT"
-  "%vcvtss2siq\t{%1, %0|%0, %1}"
+  "%vcvtss2si{q}\t{%1, %0|%0, %1}"
   [(set_attr "type" "sseicvt")
    (set_attr "athlon_decode" "double,vector")
    (set_attr "prefix_rep" "1")
@@ -2319,7 +2319,7 @@
 	(unspec:DI [(match_operand:SF 1 "nonimmediate_operand" "x,m")]
 		   UNSPEC_FIX_NOTRUNC))]
   "TARGET_SSE && TARGET_64BIT"
-  "%vcvtss2siq\t{%1, %0|%0, %1}"
+  "%vcvtss2si{q}\t{%1, %0|%0, %1}"
   [(set_attr "type" "sseicvt")
    (set_attr "athlon_decode" "double,vector")
    (set_attr "amdfam10_decode" "double,double")
@@ -2349,7 +2349,7 @@
 	    (match_operand:V4SF 1 "nonimmediate_operand" "x,m")
 	    (parallel [(const_int 0)]))))]
   "TARGET_SSE && TARGET_64BIT"
-  "%vcvttss2siq\t{%1, %0|%0, %1}"
+  "%vcvttss2si{q}\t{%1, %0|%0, %1}"
   [(set_attr "type" "sseicvt")
    (set_attr "athlon_decode" "double,vector")
    (set_attr "amdfam10_decode" "double,double")
@@ -6590,7 +6590,10 @@
   "TARGET_AVX"
 {
   operands[3] = GEN_INT (exact_log2 (INTVAL (operands[3])));
-  return "vpinsr<avxmodesuffixs>\t{%3, %k2, %1, %0|%0, %1, %k2, %3}";
+  if (MEM_P (operands[2]))
+    return "vpinsr<avxmodesuffixs>\t{%3, %2, %1, %0|%0, %1, %2, %3}";
+  else
+    return "vpinsr<avxmodesuffixs>\t{%3, %k2, %1, %0|%0, %1, %k2, %3}";
 }
   [(set_attr "type" "sselog")
    (set_attr "prefix" "vex")
@@ -6606,7 +6609,10 @@
   "TARGET_SSE4_1"
 {
   operands[3] = GEN_INT (exact_log2 (INTVAL (operands[3])));
-  return "pinsrb\t{%3, %k2, %0|%0, %k2, %3}";
+  if (MEM_P (operands[2]))
+    return "pinsrb\t{%3, %2, %0|%0, %2, %3}";
+  else
+    return "pinsrb\t{%3, %k2, %0|%0, %k2, %3}";
 }
   [(set_attr "type" "sselog")
    (set_attr "prefix_extra" "1")
@@ -6622,7 +6628,10 @@
   "TARGET_SSE2"
 {
   operands[3] = GEN_INT (exact_log2 (INTVAL (operands[3])));
-  return "pinsrw\t{%3, %k2, %0|%0, %k2, %3}";
+  if (MEM_P (operands[2]))
+    return "pinsrw\t{%3, %2, %0|%0, %2, %3}";
+  else
+    return "pinsrw\t{%3, %k2, %0|%0, %k2, %3}";
 }
   [(set_attr "type" "sselog")
    (set_attr "prefix_data16" "1")
Index: gcc/config/i386/i386.c
===================================================================
--- gcc/config/i386/i386.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/config/i386/i386.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -10379,7 +10379,7 @@
 static bool
 ix86_pic_register_p (rtx x)
 {
-  if (GET_CODE (x) == VALUE)
+  if (GET_CODE (x) == VALUE && CSELIB_VAL_PTR (x))
     return (pic_offset_table_rtx
 	    && rtx_equal_for_cselib_p (x, pic_offset_table_rtx));
   else
@@ -11313,13 +11313,14 @@
 	    case 2: size = "WORD"; break;
 	    case 4: size = "DWORD"; break;
 	    case 8: size = "QWORD"; break;
-	    case 12: size = "XWORD"; break;
+	    case 12: size = "TBYTE"; break;
 	    case 16:
 	      if (GET_MODE (x) == XFmode)
-		size = "XWORD";
+		size = "TBYTE";
               else
 		size = "XMMWORD";
               break;
+	    case 32: size = "YMMWORD"; break;
 	    default:
 	      gcc_unreachable ();
 	    }
@@ -15674,8 +15675,9 @@
 	    }
 	}
 
-      /* Unsigned parallel compare is not supported by the hardware.  Play some
-	 tricks to turn this into a signed comparison against 0.  */
+      /* Unsigned parallel compare is not supported by the hardware.
+	 Play some tricks to turn this into a signed comparison
+	 against 0.  */
       if (code == GTU)
 	{
 	  cop0 = force_reg (mode, cop0);
@@ -15684,32 +15686,26 @@
 	    {
 	    case V4SImode:
 	    case V2DImode:
-	      {
-		rtx t1, t2, mask;
+		{
+		  rtx t1, t2, mask;
+		  rtx (*gen_sub3) (rtx, rtx, rtx);
 
-		/* Perform a parallel modulo subtraction.  */
-		t1 = gen_reg_rtx (mode);
-		emit_insn ((mode == V4SImode
-			    ? gen_subv4si3
-			    : gen_subv2di3) (t1, cop0, cop1));
+		  /* Subtract (-(INT MAX) - 1) from both operands to make
+		     them signed.  */
+		  mask = ix86_build_signbit_mask (GET_MODE_INNER (mode),
+						  true, false);
+		  gen_sub3 = (mode == V4SImode
+			      ? gen_subv4si3 : gen_subv2di3);
+		  t1 = gen_reg_rtx (mode);
+		  emit_insn (gen_sub3 (t1, cop0, mask));
 
-		/* Extract the original sign bit of op0.  */
-		mask = ix86_build_signbit_mask (GET_MODE_INNER (mode),
-						true, false);
-		t2 = gen_reg_rtx (mode);
-		emit_insn ((mode == V4SImode
-			    ? gen_andv4si3
-			    : gen_andv2di3) (t2, cop0, mask));
+		  t2 = gen_reg_rtx (mode);
+		  emit_insn (gen_sub3 (t2, cop1, mask));
 
-		/* XOR it back into the result of the subtraction.  This results
-		   in the sign bit set iff we saw unsigned underflow.  */
-		x = gen_reg_rtx (mode);
-		emit_insn ((mode == V4SImode
-			    ? gen_xorv4si3
-			    : gen_xorv2di3) (x, t1, t2));
-
-		code = GT;
-	      }
+		  cop0 = t1;
+		  cop1 = t2;
+		  code = GT;
+		}
 	      break;
 
 	    case V16QImode:
@@ -15719,6 +15715,8 @@
 	      emit_insn (gen_rtx_SET (VOIDmode, x,
 				      gen_rtx_US_MINUS (mode, cop0, cop1)));
 
+	      cop0 = x;
+	      cop1 = CONST0_RTX (mode);
 	      code = EQ;
 	      negate = !negate;
 	      break;
@@ -15726,9 +15724,6 @@
 	    default:
 	      gcc_unreachable ();
 	    }
-
-	  cop0 = x;
-	  cop1 = CONST0_RTX (mode);
 	}
     }
 
Index: gcc/config/sh/sh.c
===================================================================
--- gcc/config/sh/sh.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/config/sh/sh.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -4061,6 +4061,13 @@
 	       && ! TARGET_SMALLCODE)
 	new_align = 4;
 
+      /* There is a possibility that a bf is transformed into a bf/s by the
+	 delay slot scheduler.  */
+      if (JUMP_P (from) && !JUMP_TABLE_DATA_P (from) 
+	  && get_attr_type (from) == TYPE_CBRANCH
+	  && GET_CODE (PATTERN (NEXT_INSN (PREV_INSN (from)))) != SEQUENCE)
+	inc += 2;
+
       if (found_si)
 	{
 	  count_si += inc;
@@ -8721,9 +8728,7 @@
 	&& GET_CODE (PATTERN (insn)) != USE
 	&& GET_CODE (PATTERN (insn)) != CLOBBER)
        || GET_CODE (insn) == CALL_INSN
-       || (GET_CODE (insn) == JUMP_INSN
-	   && GET_CODE (PATTERN (insn)) != ADDR_DIFF_VEC
-	   && GET_CODE (PATTERN (insn)) != ADDR_VEC))
+       || (JUMP_P (insn) && !JUMP_TABLE_DATA_P (insn)))
       && GET_CODE (PATTERN (NEXT_INSN (PREV_INSN (insn)))) != SEQUENCE
       && get_attr_needs_delay_slot (insn) == NEEDS_DELAY_SLOT_YES)
     return 2;
@@ -8731,9 +8736,7 @@
   /* SH2e has a bug that prevents the use of annulled branches, so if
      the delay slot is not filled, we'll have to put a NOP in it.  */
   if (sh_cpu == CPU_SH2E
-      && GET_CODE (insn) == JUMP_INSN
-      && GET_CODE (PATTERN (insn)) != ADDR_DIFF_VEC
-      && GET_CODE (PATTERN (insn)) != ADDR_VEC
+      && JUMP_P (insn) && !JUMP_TABLE_DATA_P (insn)
       && get_attr_type (insn) == TYPE_CBRANCH
       && GET_CODE (PATTERN (NEXT_INSN (PREV_INSN (insn)))) != SEQUENCE)
     return 2;
Index: gcc/config/t-slibgcc-elf-ver
===================================================================
--- gcc/config/t-slibgcc-elf-ver	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/config/t-slibgcc-elf-ver	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -10,6 +10,9 @@
 SHLIB_DIR = @multilib_dir@
 SHLIB_SLIBDIR_QUAL = @shlib_slibdir_qual@
 SHLIB_LC = -lc
+SHLIB_MAKE_SOLINK = $(LN_S) $(SHLIB_SONAME) $(SHLIB_DIR)/$(SHLIB_SOLINK)
+SHLIB_INSTALL_SOLINK = $(LN_S) $(SHLIB_SONAME) \
+	$$(DESTDIR)$$(slibdir)$(SHLIB_SLIBDIR_QUAL)/$(SHLIB_SOLINK)
 
 SHLIB_LINK = $(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) -shared -nodefaultlibs \
 	-Wl,--soname=$(SHLIB_SONAME) \
@@ -22,7 +25,7 @@
 		$(SHLIB_DIR)/$(SHLIB_SONAME).backup; \
 	else true; fi && \
 	mv $(SHLIB_DIR)/$(SHLIB_SONAME).tmp $(SHLIB_DIR)/$(SHLIB_SONAME) && \
-	$(LN_S) $(SHLIB_SONAME) $(SHLIB_DIR)/$(SHLIB_SOLINK)
+	$(SHLIB_MAKE_SOLINK)
 # $(slibdir) double quoted to protect it from expansion while building
 # libgcc.mk.  We want this delayed until actual install time.
 SHLIB_INSTALL = \
@@ -30,7 +33,6 @@
 	$(INSTALL_DATA) $(SHLIB_DIR)/$(SHLIB_SONAME) \
 	  $$(DESTDIR)$$(slibdir)$(SHLIB_SLIBDIR_QUAL)/$(SHLIB_SONAME); \
 	rm -f $$(DESTDIR)$$(slibdir)$(SHLIB_SLIBDIR_QUAL)/$(SHLIB_SOLINK); \
-	$(LN_S) $(SHLIB_SONAME) \
-	  $$(DESTDIR)$$(slibdir)$(SHLIB_SLIBDIR_QUAL)/$(SHLIB_SOLINK)
+	$(SHLIB_INSTALL_SOLINK)
 SHLIB_MKMAP = $(srcdir)/mkmap-symver.awk
 SHLIB_MAPFILES = $(srcdir)/libgcc-std.ver
Index: gcc/config/ia64/ia64.c
===================================================================
--- gcc/config/ia64/ia64.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/config/ia64/ia64.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1628,25 +1628,18 @@
 	  {
 	    rtx t1, t2, mask;
 
-	    /* Perform a parallel modulo subtraction.  */
-	    t1 = gen_reg_rtx (V2SImode);
-	    emit_insn (gen_subv2si3 (t1, op0, op1));
-
-	    /* Extract the original sign bit of op0.  */
-	    mask = GEN_INT (-0x80000000);
+	    /* Subtract (-(INT MAX) - 1) from both operands to make
+	       them signed.  */
+	    mask = GEN_INT (0x80000000);
 	    mask = gen_rtx_CONST_VECTOR (V2SImode, gen_rtvec (2, mask, mask));
-	    mask = force_reg (V2SImode, mask);
-	    t2 = gen_reg_rtx (V2SImode);
-	    emit_insn (gen_andv2si3 (t2, op0, mask));
-
-	    /* XOR it back into the result of the subtraction.  This results
-	       in the sign bit set iff we saw unsigned underflow.  */
-	    x = gen_reg_rtx (V2SImode);
-	    emit_insn (gen_xorv2si3 (x, t1, t2));
-
+	    mask = force_reg (mode, mask);
+	    t1 = gen_reg_rtx (mode);
+	    emit_insn (gen_subv2si3 (t1, op0, mask));
+	    t2 = gen_reg_rtx (mode);
+	    emit_insn (gen_subv2si3 (t2, op1, mask));
+	    op0 = t1;
+	    op1 = t2;
 	    code = GT;
-	    op0 = x;
-	    op1 = CONST0_RTX (mode);
 	  }
 	  break;
 
Index: gcc/config/rs6000/rs6000.c
===================================================================
--- gcc/config/rs6000/rs6000.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/config/rs6000/rs6000.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,6 +1,6 @@
 /* Subroutines used for code generation on IBM RS/6000.
    Copyright (C) 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
-   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
+   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
    Free Software Foundation, Inc.
    Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)
 
@@ -15534,7 +15534,7 @@
 
   do_compare_rtx_and_jump (opcode, tocompare, EQ, 1,
 			   SImode, NULL_RTX, NULL_RTX,
-			   no_toc_save_needed);
+			   no_toc_save_needed, -1);
 
   mem = gen_frame_mem (Pmode,
 		       gen_rtx_PLUS (Pmode, stack_top,
Index: gcc/config/arm/linux-atomic.c
===================================================================
--- gcc/config/arm/linux-atomic.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/config/arm/linux-atomic.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -266,8 +266,10 @@
   void HIDDEN								\
   __sync_lock_release_##WIDTH (TYPE *ptr)				\
   {									\
+    /* All writes before this point must be seen before we release	\
+       the lock itself.  */						\
+    __kernel_dmb ();							\
     *ptr = 0;								\
-    __kernel_dmb ();							\
   }
 
 SYNC_LOCK_RELEASE (int,   4)
Index: gcc/config/arm/ieee754-df.S
===================================================================
--- gcc/config/arm/ieee754-df.S	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/config/arm/ieee754-df.S	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1117,7 +1117,7 @@
 ARM_FUNC_ALIAS eqdf2 cmpdf2
 	mov	ip, #1			@ how should we specify unordered here?
 
-1:	str	ip, [sp, #-4]
+1:	str	ip, [sp, #-4]!
 
 	@ Trap any INF/NAN first.
 	mov	ip, xh, lsl #1
@@ -1129,7 +1129,8 @@
 
 	@ Test for equality.
 	@ Note that 0.0 is equal to -0.0.
-2:	orrs	ip, xl, xh, lsl #1	@ if x == 0.0 or -0.0
+2:	add	sp, sp, #4
+	orrs	ip, xl, xh, lsl #1	@ if x == 0.0 or -0.0
 	do_it	eq, e
 	COND(orr,s,eq)	ip, yl, yh, lsl #1	@ and y == 0.0 or -0.0
 	teqne	xh, yh			@ or xh == yh
@@ -1168,7 +1169,7 @@
 	bne	2b
 	orrs	ip, yl, yh, lsl #12
 	beq	2b			@ y is not NAN
-5:	ldr	r0, [sp, #-4]		@ unordered return code
+5:	ldr	r0, [sp], #4		@ unordered return code
 	RET
 
 	FUNC_END gedf2
Index: gcc/config/arm/arm.c
===================================================================
--- gcc/config/arm/arm.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/config/arm/arm.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -53,6 +53,7 @@
 #include "debug.h"
 #include "langhooks.h"
 #include "df.h"
+#include "libfuncs.h"
 
 /* Forward definitions of types.  */
 typedef struct minipool_node    Mnode;
@@ -922,6 +923,9 @@
   set_optab_libfunc (umod_optab, DImode, NULL);
   set_optab_libfunc (smod_optab, SImode, NULL);
   set_optab_libfunc (umod_optab, SImode, NULL);
+
+  if (TARGET_AAPCS_BASED)
+    synchronize_libfunc = init_one_libfunc ("__sync_synchronize");
 }
 
 /* On AAPCS systems, this is the "struct __va_list".  */
@@ -10269,11 +10273,14 @@
   return "";
 }
 
-/* Output a 'call' insn that is a reference in memory.  */
+/* Output a 'call' insn that is a reference in memory. This is
+   disabled for ARMv5 and we prefer a blx instead because otherwise
+   there's a significant performance overhead.  */
 const char *
 output_call_mem (rtx *operands)
 {
-  if (TARGET_INTERWORK && !arm_arch5)
+  gcc_assert (!arm_arch5);
+  if (TARGET_INTERWORK)
     {
       output_asm_insn ("ldr%?\t%|ip, %0", operands);
       output_asm_insn ("mov%?\t%|lr, %|pc", operands);
@@ -10285,16 +10292,11 @@
 	 first instruction.  It's safe to use IP as the target of the
 	 load since the call will kill it anyway.  */
       output_asm_insn ("ldr%?\t%|ip, %0", operands);
-      if (arm_arch5)
-	output_asm_insn ("blx%?\t%|ip", operands);
+      output_asm_insn ("mov%?\t%|lr, %|pc", operands);
+      if (arm_arch4t)
+	output_asm_insn ("bx%?\t%|ip", operands);
       else
-	{
-	  output_asm_insn ("mov%?\t%|lr, %|pc", operands);
-	  if (arm_arch4t)
-	    output_asm_insn ("bx%?\t%|ip", operands);
-	  else
-	    output_asm_insn ("mov%?\t%|pc, %|ip", operands);
-	}
+	output_asm_insn ("mov%?\t%|pc, %|ip", operands);
     }
   else
     {
@@ -10975,7 +10977,7 @@
 	  {
 	    /* We're only using DImode here because it's a convenient size.  */
 	    ops[0] = gen_rtx_REG (DImode, REGNO (reg) + 2 * i);
-	    ops[1] = adjust_address (mem, SImode, 8 * i);
+	    ops[1] = adjust_address (mem, DImode, 8 * i);
 	    if (reg_overlap_mentioned_p (ops[0], mem))
 	      {
 		gcc_assert (overlap == -1);
Index: gcc/config/arm/thumb2.md
===================================================================
--- gcc/config/arm/thumb2.md	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/config/arm/thumb2.md	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -57,7 +57,7 @@
 			 [(match_operand:SI 2 "s_register_operand" "r")
 			  (match_operand:SI 3 "const_int_operand" "M")]))
 		(match_operand:SI 1 "s_register_operand" "r")))]
-  "TARGET_ARM"
+  "TARGET_THUMB2"
   "bic%?\\t%0, %1, %2%S4"
   [(set_attr "predicable" "yes")
    (set_attr "shift" "2")
@@ -1108,9 +1108,9 @@
 )
 
 (define_insn "*thumb2_addsi_short"
-  [(set (match_operand:SI 0 "low_register_operand" "=l")
-	(plus:SI (match_operand:SI 1 "low_register_operand" "l")
-		 (match_operand:SI 2 "low_reg_or_int_operand" "lIL")))
+  [(set (match_operand:SI 0 "low_register_operand" "=l,l")
+	(plus:SI (match_operand:SI 1 "low_register_operand" "l,0")
+		 (match_operand:SI 2 "low_reg_or_int_operand" "lPt,Ps")))
    (clobber (reg:CC CC_REGNUM))]
   "TARGET_THUMB2 && reload_completed"
   "*
@@ -1171,7 +1171,7 @@
    (clobber (reg:CC CC_REGNUM))]
   "TARGET_THUMB2"
   "*
-  if (get_attr_length (insn) == 2 && which_alternative == 0)
+  if (get_attr_length (insn) == 2)
     return \"cbz\\t%0, %l1\";
   else
     return \"cmp\\t%0, #0\;beq\\t%l1\";
@@ -1179,7 +1179,8 @@
   [(set (attr "length") 
         (if_then_else
 	    (and (ge (minus (match_dup 1) (pc)) (const_int 2))
-	         (le (minus (match_dup 1) (pc)) (const_int 128)))
+	         (le (minus (match_dup 1) (pc)) (const_int 128))
+	         (eq (symbol_ref ("which_alternative")) (const_int 0)))
 	    (const_int 2)
 	    (const_int 8)))]
 )
@@ -1193,7 +1194,7 @@
    (clobber (reg:CC CC_REGNUM))]
   "TARGET_THUMB2"
   "*
-  if (get_attr_length (insn) == 2 && which_alternative == 0)
+  if (get_attr_length (insn) == 2)
     return \"cbnz\\t%0, %l1\";
   else
     return \"cmp\\t%0, #0\;bne\\t%l1\";
@@ -1201,7 +1202,8 @@
   [(set (attr "length") 
         (if_then_else
 	    (and (ge (minus (match_dup 1) (pc)) (const_int 2))
-	         (le (minus (match_dup 1) (pc)) (const_int 128)))
+	         (le (minus (match_dup 1) (pc)) (const_int 128))
+	         (eq (symbol_ref ("which_alternative")) (const_int 0)))
 	    (const_int 2)
 	    (const_int 8)))]
 )
Index: gcc/config/arm/lib1funcs.asm
===================================================================
--- gcc/config/arm/lib1funcs.asm	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/config/arm/lib1funcs.asm	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -95,7 +95,8 @@
 #endif
 
 #if defined(__ARM_ARCH_7__) || defined(__ARM_ARCH_7A__) \
-	|| defined(__ARM_ARCH_7R__) || defined(__ARM_ARCH_7M__)
+	|| defined(__ARM_ARCH_7R__) || defined(__ARM_ARCH_7M__) \
+	|| defined(__ARM_ARCH_7EM__)
 # define __ARM_ARCH__ 7
 #endif
 
Index: gcc/config/arm/neon-schedgen.ml
===================================================================
--- gcc/config/arm/neon-schedgen.ml	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/config/arm/neon-schedgen.ml	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -48,7 +48,14 @@
      and at present we do not emit specific guards.)
 *)
 
-open Utils
+let find_with_result fn lst =
+  let rec scan = function
+      [] -> raise Not_found
+    | l::ls -> 
+      match fn l with
+          Some result -> result
+       | _ -> scan ls in
+    scan lst
 
 let n1 = 1 and n2 = 2 and n3 = 3 and n4 = 4 and n5 = 5 and n6 = 6
     and n7 = 7 and n8 = 8 and n9 = 9
Index: gcc/config/arm/neon.md
===================================================================
--- gcc/config/arm/neon.md	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/config/arm/neon.md	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -3611,7 +3611,8 @@
 			  UNSPEC_VSHLL_N))]
   "TARGET_NEON"
 {
-  neon_const_bounds (operands[2], 0, neon_element_bits (<MODE>mode));
+  /* The boundaries are: 0 < imm <= size.  */
+  neon_const_bounds (operands[2], 0, neon_element_bits (<MODE>mode) + 1);
   return "vshll.%T3%#<V_sz_elem>\t%q0, %P1, %2";
 }
   [(set_attr "neon_type" "neon_shift_1")]
Index: gcc/config/arm/constraints.md
===================================================================
--- gcc/config/arm/constraints.md	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/config/arm/constraints.md	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -30,6 +30,7 @@
 
 ;; The following multi-letter normal constraints have been used:
 ;; in ARM/Thumb-2 state: Da, Db, Dc, Dn, Dl, DL, Dv
+;; in Thumb-2 state: Ps, Pt
 
 ;; The following memory constraints have been used:
 ;; in ARM/Thumb-2 state: Q, Ut, Uv, Uy, Un, Us
@@ -129,6 +130,16 @@
       (match_test "TARGET_THUMB1 && ival >= -508 && ival <= 508
 		   && ((ival & 3) == 0)")))
 
+(define_constraint "Ps"
+  "@internal In Thumb-2 state a constant in the range -255 to +255"
+  (and (match_code "const_int")
+       (match_test "TARGET_THUMB2 && ival >= -255 && ival <= 255")))
+
+(define_constraint "Pt"
+  "@internal In Thumb-2 state a constant in the range -7 to +7"
+  (and (match_code "const_int")
+       (match_test "TARGET_THUMB2 && ival >= -7 && ival <= 7")))
+
 (define_constraint "G"
  "In ARM/Thumb-2 state a valid FPA immediate constant."
  (and (match_code "const_double")
Index: gcc/config/arm/neon.ml
===================================================================
--- gcc/config/arm/neon.ml	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/config/arm/neon.ml	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,7 +1,7 @@
 (* Common code for ARM NEON header file, documentation and test case
    generators.
 
-   Copyright (C) 2006, 2007 Free Software Foundation, Inc.
+   Copyright (C) 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
    Contributed by CodeSourcery.
 
    This file is part of GCC.
@@ -233,6 +233,7 @@
        cases.  The function supplied must return the integer to be written
        into the testcase for the argument number (0-based) supplied to it.  *)
   | Const_valuator of (int -> int)
+  | Fixed_return_reg
 
 exception MixedMode of elts * elts
 
@@ -1076,9 +1077,13 @@
       Use_operands [| Dreg; Qreg |], "vget_high",
       notype_1, pf_su_8_64;
     Vget_low, [Instruction_name ["vmov"];
-               Disassembles_as [Use_operands [| Dreg; Dreg |]]],
+               Disassembles_as [Use_operands [| Dreg; Dreg |]];
+	       Fixed_return_reg],
       Use_operands [| Dreg; Qreg |], "vget_low",
-      notype_1, pf_su_8_64;
+      notype_1, pf_su_8_32;
+     Vget_low, [No_op],
+      Use_operands [| Dreg; Qreg |], "vget_low",
+      notype_1, [S64; U64];
 
     (* Conversions.  *)
     Vcvt, [InfoWord], All (2, Dreg), "vcvt", conv_1,
Index: gcc/config/arm/ieee754-sf.S
===================================================================
--- gcc/config/arm/ieee754-sf.S	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/config/arm/ieee754-sf.S	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -822,7 +822,7 @@
 ARM_FUNC_ALIAS eqsf2 cmpsf2
 	mov	ip, #1			@ how should we specify unordered here?
 
-1:	str	ip, [sp, #-4]
+1:	str	ip, [sp, #-4]!
 
 	@ Trap any INF/NAN first.
 	mov	r2, r0, lsl #1
@@ -834,7 +834,8 @@
 
 	@ Compare values.
 	@ Note that 0.0 is equal to -0.0.
-2:	orrs	ip, r2, r3, lsr #1	@ test if both are 0, clear C flag
+2:	add	sp, sp, #4
+	orrs	ip, r2, r3, lsr #1	@ test if both are 0, clear C flag
 	do_it	ne
 	teqne	r0, r1			@ if not 0 compare sign
 	do_it	pl
@@ -858,7 +859,7 @@
 	bne	2b
 	movs	ip, r1, lsl #9
 	beq	2b			@ r1 is not NAN
-5:	ldr	r0, [sp, #-4]		@ return unordered code.
+5:	ldr	r0, [sp], #4		@ return unordered code.
 	RET
 
 	FUNC_END gesf2
Index: gcc/config/arm/neon-testgen.ml
===================================================================
--- gcc/config/arm/neon-testgen.ml	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/config/arm/neon-testgen.ml	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,5 +1,5 @@
 (* Auto-generate ARM Neon intrinsics tests.
-   Copyright (C) 2006, 2007 Free Software Foundation, Inc.
+   Copyright (C) 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
    Contributed by CodeSourcery.
 
    This file is part of GCC.
@@ -58,7 +58,7 @@
 
 (* Emit declarations of local variables that are going to be passed
    to an intrinsic, together with one to take a returned value if needed.  *)
-let emit_automatics chan c_types =
+let emit_automatics chan c_types features =
   let emit () =
     ignore (
       List.fold_left (fun arg_number -> fun (flags, ty) ->
@@ -75,11 +75,17 @@
   in
     match c_types with
       (_, return_ty) :: tys ->
-        if return_ty <> "void" then
-          (* The intrinsic returns a value.  *)
-          (Printf.fprintf chan "  %s out_%s;\n" return_ty return_ty;
-           emit ())
-        else
+        if return_ty <> "void" then begin
+          (* The intrinsic returns a value.  We need to do explict register
+             allocation for vget_low tests or they fail because of copy
+             elimination.  *)
+          ((if List.mem Fixed_return_reg features then
+              Printf.fprintf chan "  register %s out_%s asm (\"d18\");\n"
+                             return_ty return_ty
+            else
+              Printf.fprintf chan "  %s out_%s;\n" return_ty return_ty);
+	   emit ())
+        end else
           (* The intrinsic does not return a value.  *)
           emit ()
     | _ -> assert false
@@ -256,7 +262,7 @@
     (* Emit file and function prologues.  *)
     emit_prologue chan test_name;
     (* Emit local variable declarations.  *)
-    emit_automatics chan c_types;
+    emit_automatics chan c_types features;
     Printf.fprintf chan "\n";
     (* Emit the call to the intrinsic.  *)
     emit_call chan const_valuator c_types name elt_ty;
Index: gcc/config/arm/arm.md
===================================================================
--- gcc/config/arm/arm.md	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/config/arm/arm.md	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -8441,12 +8441,17 @@
    (set_attr "type" "call")]
 )
 
+
+;; Note: not used for armv5+ because the sequence used (ldr pc, ...) is not
+;; considered a function call by the branch predictor of some cores (PR40887).
+;; Falls back to blx rN (*call_reg_armv5).
+
 (define_insn "*call_mem"
   [(call (mem:SI (match_operand:SI 0 "call_memory_operand" "m"))
 	 (match_operand 1 "" ""))
    (use (match_operand 2 "" ""))
    (clobber (reg:SI LR_REGNUM))]
-  "TARGET_ARM"
+  "TARGET_ARM && !arm_arch5"
   "*
   return output_call_mem (operands);
   "
@@ -8548,13 +8553,15 @@
    (set_attr "type" "call")]
 )
 
+;; Note: see *call_mem
+
 (define_insn "*call_value_mem"
   [(set (match_operand 0 "" "")
 	(call (mem:SI (match_operand:SI 1 "call_memory_operand" "m"))
 	      (match_operand 2 "" "")))
    (use (match_operand 3 "" ""))
    (clobber (reg:SI LR_REGNUM))]
-  "TARGET_ARM && (!CONSTANT_ADDRESS_P (XEXP (operands[1], 0)))"
+  "TARGET_ARM && !arm_arch5 && (!CONSTANT_ADDRESS_P (XEXP (operands[1], 0)))"
   "*
   return output_call_mem (&operands[1]);
   "
Index: gcc/config/pa/t-hpux-shlib
===================================================================
--- gcc/config/pa/t-hpux-shlib	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/config/pa/t-hpux-shlib	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -8,6 +8,7 @@
 SHLIB_SLIBDIR_QUAL = @shlib_slibdir_qual@
 
 SHLIB_LINK = $(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) -shared  -nodefaultlibs \
+	-Wl,+h -Wl,$(SHLIB_SONAME) \
 	-o $(SHLIB_DIR)/$(SHLIB_NAME).tmp @multilib_flags@ $(SHLIB_OBJS) && \
         rm -f $(SHLIB_DIR)/$(SHLIB_SONAME) && \
 	if [ -f $(SHLIB_DIR)/$(SHLIB_NAME) ]; then \
Index: gcc/config/pa/linux-atomic.c
===================================================================
--- gcc/config/pa/linux-atomic.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/config/pa/linux-atomic.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -24,14 +24,9 @@
 see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 <http://www.gnu.org/licenses/>.  */
 
-/* FIXME: work around build failure for hppa64-linux-gnu target. */
-#ifndef _LP64
-#include <errno.h>
-#else 
 #define EFAULT  14 
 #define EBUSY   16
 #define ENOSYS 251 
-#endif 
 
 /* All PA-RISC implementations supported by linux have strongly
    ordered loads and stores.  Only cache flushes and purges can be
Index: gcc/config/pa/pa.md
===================================================================
--- gcc/config/pa/pa.md	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/config/pa/pa.md	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -3191,6 +3191,40 @@
     DONE;
 }")
 
+;; Handle HImode input reloads requiring a general register as a
+;; scratch register.
+(define_expand "reload_inhi"
+  [(set (match_operand:HI 0 "register_operand" "=Z")
+	(match_operand:HI 1 "non_hard_reg_operand" ""))
+   (clobber (match_operand:HI 2 "register_operand" "=&r"))]
+  ""
+  "
+{
+  if (emit_move_sequence (operands, HImode, operands[2]))
+    DONE;
+
+  /* We don't want the clobber emitted, so handle this ourselves.  */
+  emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[1]));
+  DONE;
+}")
+
+;; Handle HImode output reloads requiring a general register as a
+;; scratch register.
+(define_expand "reload_outhi"
+  [(set (match_operand:HI 0 "non_hard_reg_operand" "")
+	(match_operand:HI 1  "register_operand" "Z"))
+   (clobber (match_operand:HI 2 "register_operand" "=&r"))]
+  ""
+  "
+{
+  if (emit_move_sequence (operands, HImode, operands[2]))
+    DONE;
+
+  /* We don't want the clobber emitted, so handle this ourselves.  */
+  emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[1]));
+  DONE;
+}")
+
 (define_insn ""
   [(set (match_operand:HI 0 "move_dest_operand"
 	 		  "=r,r,r,r,r,Q,!*q,!r")
@@ -3315,6 +3349,40 @@
     DONE;
 }")
 
+;; Handle QImode input reloads requiring a general register as a
+;; scratch register.
+(define_expand "reload_inqi"
+  [(set (match_operand:QI 0 "register_operand" "=Z")
+	(match_operand:QI 1 "non_hard_reg_operand" ""))
+   (clobber (match_operand:QI 2 "register_operand" "=&r"))]
+  ""
+  "
+{
+  if (emit_move_sequence (operands, QImode, operands[2]))
+    DONE;
+
+  /* We don't want the clobber emitted, so handle this ourselves.  */
+  emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[1]));
+  DONE;
+}")
+
+;; Handle QImode output reloads requiring a general register as a
+;; scratch register.
+(define_expand "reload_outqi"
+  [(set (match_operand:QI 0 "non_hard_reg_operand" "")
+	(match_operand:QI 1  "register_operand" "Z"))
+   (clobber (match_operand:QI 2 "register_operand" "=&r"))]
+  ""
+  "
+{
+  if (emit_move_sequence (operands, QImode, operands[2]))
+    DONE;
+
+  /* We don't want the clobber emitted, so handle this ourselves.  */
+  emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[1]));
+  DONE;
+}")
+
 (define_insn ""
   [(set (match_operand:QI 0 "move_dest_operand"
 			  "=r,r,r,r,r,Q,!*q,!r")
@@ -7503,17 +7571,6 @@
       operands[0] = index;
     }
 
-  /* In 64bit mode we must make sure to wipe the upper bits of the register
-     just in case the addition overflowed or we had random bits in the
-     high part of the register.  */
-  if (TARGET_64BIT)
-    {
-      rtx index = gen_reg_rtx (DImode);
-
-      emit_insn (gen_extendsidi2 (index, operands[0]));
-      operands[0] = gen_rtx_SUBREG (SImode, index, 4);
-    }
-
   if (!INT_5_BITS (operands[2]))
     operands[2] = force_reg (SImode, operands[2]);
 
@@ -7530,6 +7587,17 @@
   emit_insn (gen_cmpsi (operands[0], operands[2]));
   emit_jump_insn (gen_bgtu (operands[4]));
 
+  /* In 64bit mode we must make sure to wipe the upper bits of the register
+     just in case the addition overflowed or we had random bits in the
+     high part of the register.  */
+  if (TARGET_64BIT)
+    {
+      rtx index = gen_reg_rtx (DImode);
+
+      emit_insn (gen_extendsidi2 (index, operands[0]));
+      operands[0] = index;
+    }
+
   if (TARGET_BIG_SWITCH)
     {
       if (TARGET_64BIT)
@@ -7590,8 +7658,7 @@
 ;;; 64-bit code, 32-bit relative branch table.
 (define_insn "casesi64p"
   [(set (pc) (mem:DI (plus:DI
-		       (mult:DI (sign_extend:DI
-				  (match_operand:SI 0 "register_operand" "r"))
+		       (mult:DI (match_operand:DI 0 "register_operand" "r")
 				(const_int 8))
 		       (label_ref (match_operand 1 "" "")))))
    (clobber (match_scratch:DI 2 "=&r"))
Index: gcc/config/pa/pa.c
===================================================================
--- gcc/config/pa/pa.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/config/pa/pa.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1620,7 +1620,7 @@
       /* D might not fit in 14 bits either; for such cases load D into
 	 scratch reg.  */
       if (GET_CODE (operand1) == MEM
-	  && !memory_address_p (Pmode, XEXP (operand1, 0)))
+	  && !memory_address_p (GET_MODE (operand0), XEXP (operand1, 0)))
 	{
 	  /* We are reloading the address into the scratch register, so we
 	     want to make sure the scratch register is a full register.  */
@@ -7437,7 +7437,7 @@
     {
       length += 20;
 
-      if (!TARGET_PA_20 && !TARGET_NO_SPACE_REGS && flag_pic)
+      if (!TARGET_PA_20 && !TARGET_NO_SPACE_REGS && (!local_call || flag_pic))
 	length += 8;
     }
 
@@ -7457,7 +7457,7 @@
 	  if (!sibcall)
 	    length += 8;
 
-	  if (!TARGET_NO_SPACE_REGS && flag_pic)
+	  if (!TARGET_NO_SPACE_REGS && (!local_call || flag_pic))
 	    length += 8;
 	}
     }
@@ -7654,7 +7654,7 @@
 		  if (!sibcall && !TARGET_PA_20)
 		    {
 		      output_asm_insn ("{bl|b,l} .+8,%%r2", xoperands);
-		      if (TARGET_NO_SPACE_REGS)
+		      if (TARGET_NO_SPACE_REGS || (local_call && !flag_pic))
 			output_asm_insn ("addi 8,%%r2,%%r2", xoperands);
 		      else
 			output_asm_insn ("addi 16,%%r2,%%r2", xoperands);
@@ -7679,20 +7679,20 @@
 		}
 	      else
 		{
-		  if (!TARGET_NO_SPACE_REGS && flag_pic)
+		  if (!TARGET_NO_SPACE_REGS && (!local_call || flag_pic))
 		    output_asm_insn ("ldsid (%%r1),%%r31\n\tmtsp %%r31,%%sr0",
 				     xoperands);
 
 		  if (sibcall)
 		    {
-		      if (TARGET_NO_SPACE_REGS || !flag_pic)
+		      if (TARGET_NO_SPACE_REGS || (local_call && !flag_pic))
 			output_asm_insn ("be 0(%%sr4,%%r1)", xoperands);
 		      else
 			output_asm_insn ("be 0(%%sr0,%%r1)", xoperands);
 		    }
 		  else
 		    {
-		      if (TARGET_NO_SPACE_REGS || !flag_pic)
+		      if (TARGET_NO_SPACE_REGS || (local_call && !flag_pic))
 			output_asm_insn ("ble 0(%%sr4,%%r1)", xoperands);
 		      else
 			output_asm_insn ("ble 0(%%sr0,%%r1)", xoperands);
Index: gcc/config/mips/mips-dsp.md
===================================================================
--- gcc/config/mips/mips-dsp.md	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/config/mips/mips-dsp.md	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1048,7 +1048,7 @@
 
 (define_insn "mips_lhx_<mode>"
   [(set (match_operand:SI 0 "register_operand" "=d")
-	(zero_extend:SI
+	(sign_extend:SI
 	  (mem:HI (plus:P (match_operand:P 1 "register_operand" "d")
 			  (match_operand:P 2 "register_operand" "d")))))]
   "ISA_HAS_DSP"
Index: gcc/config/mips/mips.c
===================================================================
--- gcc/config/mips/mips.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/config/mips/mips.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -2328,6 +2328,28 @@
 	  : emit_move_insn_1 (dest, src));
 }
 
+/* Emit an instruction of the form (set TARGET (CODE OP0)).  */
+
+static void
+mips_emit_unary (enum rtx_code code, rtx target, rtx op0)
+{
+  emit_insn (gen_rtx_SET (VOIDmode, target,
+			  gen_rtx_fmt_e (code, GET_MODE (op0), op0)));
+}
+
+/* Compute (CODE OP0) and store the result in a new register of mode MODE.
+   Return that new register.  */
+
+static rtx
+mips_force_unary (enum machine_mode mode, enum rtx_code code, rtx op0)
+{
+  rtx reg;
+
+  reg = gen_reg_rtx (mode);
+  mips_emit_unary (code, reg, op0);
+  return reg;
+}
+
 /* Emit an instruction of the form (set TARGET (CODE OP0 OP1)).  */
 
 static void
@@ -6399,26 +6421,51 @@
 void
 mips_expand_synci_loop (rtx begin, rtx end)
 {
-  rtx inc, label, cmp, cmp_result;
+  rtx inc, label, end_label, cmp_result, mask, length;
 
+  /* Create end_label.  */
+  end_label = gen_label_rtx ();
+
+  /* Check if begin equals end.  */
+  cmp_result = gen_rtx_EQ (VOIDmode, begin, end);
+  emit_jump_insn (gen_condjump (cmp_result, end_label));
+
   /* Load INC with the cache line size (rdhwr INC,$1).  */
   inc = gen_reg_rtx (Pmode);
   emit_insn (Pmode == SImode
 	     ? gen_rdhwr_synci_step_si (inc)
 	     : gen_rdhwr_synci_step_di (inc));
 
+  /* Check if inc is 0.  */
+  cmp_result = gen_rtx_EQ (VOIDmode, inc, const0_rtx);
+  emit_jump_insn (gen_condjump (cmp_result, end_label));
+
+  /* Calculate mask.  */
+  mask = mips_force_unary (Pmode, NEG, inc);
+
+  /* Mask out begin by mask.  */
+  begin = mips_force_binary (Pmode, AND, begin, mask);
+
+  /* Calculate length.  */
+  length = mips_force_binary (Pmode, MINUS, end, begin);
+
   /* Loop back to here.  */
   label = gen_label_rtx ();
   emit_label (label);
 
   emit_insn (gen_synci (begin));
 
-  cmp = mips_force_binary (Pmode, GTU, begin, end);
+  /* Update length.  */
+  mips_emit_binary (MINUS, length, length, inc);
 
+  /* Update begin.  */
   mips_emit_binary (PLUS, begin, begin, inc);
 
-  cmp_result = gen_rtx_EQ (VOIDmode, cmp, const0_rtx);
+  /* Check if length is greater than 0.  */
+  cmp_result = gen_rtx_GT (VOIDmode, length, const0_rtx);
   emit_jump_insn (gen_condjump (cmp_result, label));
+
+  emit_label (end_label);
 }
 
 /* Expand a QI or HI mode atomic memory operation.
Index: gcc/cfgrtl.c
===================================================================
--- gcc/cfgrtl.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/cfgrtl.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,6 +1,6 @@
 /* Control flow graph manipulation code for GNU compiler.
    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010
    Free Software Foundation, Inc.
 
 This file is part of GCC.
@@ -2951,7 +2951,7 @@
   op0 = force_operand (op0, NULL_RTX);
   op1 = force_operand (op1, NULL_RTX);
   do_compare_rtx_and_jump (op0, op1, comp, 0,
-			   mode, NULL_RTX, NULL_RTX, label);
+			   mode, NULL_RTX, NULL_RTX, label, -1);
   jump = get_last_insn ();
   JUMP_LABEL (jump) = label;
   LABEL_NUSES (label)++;
Index: gcc/stmt.c
===================================================================
--- gcc/stmt.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/stmt.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,6 +1,6 @@
 /* Expands front end tree to back end RTL for GCC
-   Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997,
-   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
+   Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
    Free Software Foundation, Inc.
 
 This file is part of GCC.
@@ -2472,7 +2472,7 @@
 		  int unsignedp)
 {
   do_compare_rtx_and_jump (op0, op1, EQ, unsignedp, mode,
-			   NULL_RTX, NULL_RTX, label);
+			   NULL_RTX, NULL_RTX, label, -1);
 }
 
 /* Not all case values are encountered equally.  This function
Index: gcc/gcov-dump.c
===================================================================
--- gcc/gcov-dump.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gcc/gcov-dump.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,5 +1,5 @@
 /* Dump a gcov file, for debugging use.
-   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
    Free Software Foundation, Inc.
    Contributed by Nathan Sidwell <nathan@codesourcery.com>
 
@@ -121,7 +121,7 @@
 print_version (void)
 {
   printf ("gcov-dump %s%s\n", pkgversion_string, version_string);
-  printf ("Copyright (C) 2009 Free Software Foundation, Inc.\n");
+  printf ("Copyright (C) 2010 Free Software Foundation, Inc.\n");
   printf ("This is free software; see the source for copying conditions.\n"
   	  "There is NO warranty; not even for MERCHANTABILITY or \n"
 	  "FITNESS FOR A PARTICULAR PURPOSE.\n\n");
Index: config.sub
===================================================================
--- config.sub	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ config.sub	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,10 +1,10 @@
 #! /bin/sh
 # Configuration validation subroutine script.
 #   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
-#   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
+#   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
 #   Free Software Foundation, Inc.
 
-timestamp='2008-12-11'
+timestamp='2009-11-07'
 
 # This file is (in principle) common to ALL GNU software.
 # The presence of a machine in this file suggests that SOME GNU software
@@ -32,13 +32,16 @@
 
 
 # Please send patches to <config-patches@gnu.org>.  Submit a context
-# diff and a properly formatted ChangeLog entry.
+# diff and a properly formatted GNU ChangeLog entry.
 #
 # Configuration subroutine to validate and canonicalize a configuration type.
 # Supply the specified configuration type as an argument.
 # If it is invalid, we print an error message on stderr and exit with code 1.
 # Otherwise, we print the canonical config type on stdout and succeed.
 
+# You can get the latest version of this script from:
+# http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub;hb=HEAD
+
 # This file is supposed to be the same for all GNU packages
 # and recognize all the CPU types, system types and aliases
 # that are meaningful with *any* GNU software.
@@ -122,6 +125,7 @@
 case $maybe_os in
   nto-qnx* | linux-gnu* | linux-dietlibc | linux-newlib* | linux-uclibc* | \
   uclinux-uclibc* | uclinux-gnu* | kfreebsd*-gnu* | knetbsd*-gnu* | netbsd*-gnu* | \
+  kopensolaris*-gnu* | \
   storm-chaos* | os2-emx* | rtmk-nova*)
     os=-$maybe_os
     basic_machine=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`
@@ -148,10 +152,13 @@
 	-convergent* | -ncr* | -news | -32* | -3600* | -3100* | -hitachi* |\
 	-c[123]* | -convex* | -sun | -crds | -omron* | -dg | -ultra | -tti* | \
 	-harris | -dolphin | -highlevel | -gould | -cbm | -ns | -masscomp | \
-	-apple | -axis | -knuth | -cray)
+	-apple | -axis | -knuth | -cray | -microblaze)
 		os=
 		basic_machine=$1
 		;;
+        -bluegene*)
+	        os=-cnk
+		;;
 	-sim | -cisco | -oki | -wec | -winbond)
 		os=
 		basic_machine=$1
@@ -271,6 +278,7 @@
 	| mipsisa64sr71k | mipsisa64sr71kel \
 	| mipstx39 | mipstx39el \
 	| mn10200 | mn10300 \
+	| moxie \
 	| mt \
 	| msp430 \
 	| nios | nios2 \
@@ -279,6 +287,7 @@
 	| pdp10 | pdp11 | pj | pjl \
 	| powerpc | powerpc64 | powerpc64le | powerpcle | ppcbe \
 	| pyramid \
+	| rx \
 	| score \
 	| sh | sh[1234] | sh[24]a | sh[24]aeb | sh[23]e | sh[34]eb | sheb | shbe | shle | sh[1234]le | sh3ele \
 	| sh64 | sh64le \
@@ -286,13 +295,14 @@
 	| sparcv8 | sparcv9 | sparcv9b | sparcv9v \
 	| spu | strongarm \
 	| tahoe | thumb | tic4x | tic80 | tron \
+	| ubicom32 \
 	| v850 | v850e \
 	| we32k \
 	| x86 | xc16x | xscale | xscalee[bl] | xstormy16 | xtensa \
 	| z8k | z80)
 		basic_machine=$basic_machine-unknown
 		;;
-	m6811 | m68hc11 | m6812 | m68hc12)
+	m6811 | m68hc11 | m6812 | m68hc12 | picochip)
 		# Motorola 68HC11/12.
 		basic_machine=$basic_machine-unknown
 		os=-none
@@ -335,7 +345,7 @@
 	| lm32-* \
 	| m32c-* | m32r-* | m32rle-* \
 	| m68000-* | m680[012346]0-* | m68360-* | m683?2-* | m68k-* \
-	| m88110-* | m88k-* | maxq-* | mcore-* | metag-* \
+	| m88110-* | m88k-* | maxq-* | mcore-* | metag-* | microblaze-* \
 	| mips-* | mipsbe-* | mipseb-* | mipsel-* | mipsle-* \
 	| mips16-* \
 	| mips64-* | mips64el-* \
@@ -363,7 +373,7 @@
 	| pdp10-* | pdp11-* | pj-* | pjl-* | pn-* | power-* \
 	| powerpc-* | powerpc64-* | powerpc64le-* | powerpcle-* | ppcbe-* \
 	| pyramid-* \
-	| romp-* | rs6000-* \
+	| romp-* | rs6000-* | rx-* \
 	| sh-* | sh[1234]-* | sh[24]a-* | sh[24]aeb-* | sh[23]e-* | sh[34]eb-* | sheb-* | shbe-* \
 	| shle-* | sh[1234]le-* | sh3ele-* | sh64-* | sh64le-* \
 	| sparc-* | sparc64-* | sparc64b-* | sparc64v-* | sparc86x-* | sparclet-* \
@@ -372,6 +382,7 @@
 	| tahoe-* | thumb-* \
 	| tic30-* | tic4x-* | tic54x-* | tic55x-* | tic6x-* | tic80-* | tile-* \
 	| tron-* \
+	| ubicom32-* \
 	| v850-* | v850e-* | vax-* \
 	| we32k-* \
 	| x86-* | x86_64-* | xc16x-* | xps100-* | xscale-* | xscalee[bl]-* \
@@ -445,6 +456,10 @@
 		basic_machine=m68k-apollo
 		os=-bsd
 		;;
+	aros)
+		basic_machine=i386-pc
+		os=-aros
+		;;
 	aux)
 		basic_machine=m68k-apple
 		os=-aux
@@ -461,6 +476,10 @@
 		basic_machine=bfin-`echo $basic_machine | sed 's/^[^-]*-//'`
 		os=-linux
 		;;
+	bluegene*)
+		basic_machine=powerpc-ibm
+		os=-cnk
+		;;
 	c90)
 		basic_machine=c90-cray
 		os=-unicos
@@ -713,6 +732,9 @@
 		basic_machine=ns32k-utek
 		os=-sysv
 		;;
+        microblaze)
+		basic_machine=microblaze-xilinx
+		;;
 	mingw32)
 		basic_machine=i386-pc
 		os=-mingw32
@@ -1254,10 +1276,11 @@
 	# Each alternative MUST END IN A *, to match a version number.
 	# -sysv* is not here because it comes later, after sysvr4.
 	-gnu* | -bsd* | -mach* | -minix* | -genix* | -ultrix* | -irix* \
-	      | -*vms* | -sco* | -esix* | -isc* | -aix* | -sunos | -sunos[34]*\
+	      | -*vms* | -sco* | -esix* | -isc* | -aix* | -cnk* | -sunos | -sunos[34]*\
 	      | -hpux* | -unos* | -osf* | -luna* | -dgux* | -solaris* | -sym* \
+	      | -kopensolaris* \
 	      | -amigaos* | -amigados* | -msdos* | -newsos* | -unicos* | -aof* \
-	      | -aos* \
+	      | -aos* | -aros* \
 	      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \
 	      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \
 	      | -hiux* | -386bsd* | -knetbsd* | -mirbsd* | -netbsd* \
@@ -1276,7 +1299,7 @@
 	      | -os2* | -vos* | -palmos* | -uclinux* | -nucleus* \
 	      | -morphos* | -superux* | -rtmk* | -rtmk-nova* | -windiss* \
 	      | -powermax* | -dnix* | -nx6 | -nx7 | -sei* | -dragonfly* \
-	      | -skyos* | -haiku* | -rdos* | -toppers* | -drops*)
+	      | -skyos* | -haiku* | -rdos* | -toppers* | -drops* | -es*)
 	# Remember, each alternative MUST END IN *, to match a version number.
 		;;
 	-qnx*)
@@ -1606,7 +1629,7 @@
 			-sunos*)
 				vendor=sun
 				;;
-			-aix*)
+			-cnk*|-aix*)
 				vendor=ibm
 				;;
 			-beos*)
Index: zlib/ChangeLog
===================================================================
--- zlib/ChangeLog	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ zlib/ChangeLog	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,3 +1,7 @@
+2010-01-21  Release Manager
+
+	* GCC 4.4.3 released.
+
 2009-10-15  Release Manager
 
 	* GCC 4.4.2 released.
Index: libstdc++-v3/include/bits/atomic_0.h
===================================================================
--- libstdc++-v3/include/bits/atomic_0.h	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libstdc++-v3/include/bits/atomic_0.h	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -82,14 +82,15 @@
     __r; })
 
   /// atomic_flag
-  struct atomic_flag : private __atomic_flag_base
+  struct atomic_flag : public __atomic_flag_base
   {
     atomic_flag() = default;
     ~atomic_flag() = default;
     atomic_flag(const atomic_flag&) = delete;
     atomic_flag& operator=(const atomic_flag&) = delete;
 
-    atomic_flag(bool __i) { _M_i = __i; } // XXX deleted copy ctor != agg
+    // Conversion to ATOMIC_FLAG_INIT.
+    atomic_flag(bool __i): __atomic_flag_base({ __i }) { }
 
     bool
     test_and_set(memory_order __m = memory_order_seq_cst) volatile;
Index: libstdc++-v3/include/bits/atomic_2.h
===================================================================
--- libstdc++-v3/include/bits/atomic_2.h	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libstdc++-v3/include/bits/atomic_2.h	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -44,14 +44,15 @@
 namespace __atomic2
 {
   /// atomic_flag
-  struct atomic_flag : private __atomic_flag_base
+  struct atomic_flag : public __atomic_flag_base
   {
     atomic_flag() = default;
     ~atomic_flag() = default;
     atomic_flag(const atomic_flag&) = delete;
     atomic_flag& operator=(const atomic_flag&) = delete;
 
-    atomic_flag(bool __i) { _M_i = __i; } // XXX deleted copy ctor != agg
+    // Conversion to ATOMIC_FLAG_INIT.
+    atomic_flag(bool __i): __atomic_flag_base({ __i }) { }
 
     bool
     test_and_set(memory_order __m = memory_order_seq_cst) volatile
@@ -107,7 +108,7 @@
 	{
 	  // write_mem_barrier();
 	  _M_i = __v;
-	  if (__m = memory_order_seq_cst)
+	  if (__m == memory_order_seq_cst)
 	    __sync_synchronize();
 	}
     }
@@ -298,7 +299,7 @@
 	  {
 	    // write_mem_barrier();
 	    _M_i = __i;
-	    if (__m = memory_order_seq_cst)
+	    if (__m == memory_order_seq_cst)
 	      __sync_synchronize();
 	  }
       }
Index: libstdc++-v3/include/c_compatibility/stdatomic.h
===================================================================
--- libstdc++-v3/include/c_compatibility/stdatomic.h	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libstdc++-v3/include/c_compatibility/stdatomic.h	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -186,8 +186,11 @@
 _GLIBCXX_END_EXTERN_C
 _GLIBCXX_END_NAMESPACE
 
-// Inject into global namespace. XXX
-#if defined(__cplusplus) && !defined(_GLIBCXX_STDATOMIC)
+// Inject into global namespace.
+#ifdef __cplusplus
+
+#include <cstdatomic>
+
 using std::memory_order;
 using std::memory_order_relaxed;
 using std::memory_order_consume;
Index: libstdc++-v3/include/parallel/multiseq_selection.h
===================================================================
--- libstdc++-v3/include/parallel/multiseq_selection.h	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libstdc++-v3/include/parallel/multiseq_selection.h	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -183,9 +183,6 @@
       // equality iff nmax = 2^k - 1.
       l = (1ULL << r) - 1;
 
-      // From now on, including padding.
-      N = l * m;
-
       for (int i = 0; i < m; i++)
 	{
 	  a[i] = 0;
@@ -210,7 +207,7 @@
 	if (n >= ns[i])	//sequence too short, conceptual infinity
 	  sample.push_back(std::make_pair(S(i)[0] /*dummy element*/, i));
 
-      difference_type localrank = rank * m / N ;
+      difference_type localrank = rank / l;
 
       int j;
       for (j = 0; j < localrank && ((n + 1) <= ns[sample[j].second]); ++j)
@@ -258,15 +255,11 @@
 		b[i] -= n + 1;
 	    }
 
-	  difference_type leftsize = 0, total = 0;
+	  difference_type leftsize = 0;
 	  for (int i = 0; i < m; i++)
-	    {
 	      leftsize += a[i] / (n + 1);
-	      total += l / (n + 1);
-	    }
 	  
-	  difference_type skew = static_cast<difference_type>
-	    (static_cast<uint64>(total) * rank / N - leftsize);
+	  difference_type skew = rank / (n + 1) - leftsize;
 
 	  if (skew > 0)
 	    {
@@ -429,9 +422,6 @@
       // equality iff nmax = 2^k - 1
       l = pow2(r) - 1;
 
-      // From now on, including padding.
-      N = l * m;
-
       for (int i = 0; i < m; ++i)
 	{
 	  a[i] = 0;
@@ -458,7 +448,7 @@
 	if (n >= ns[i])
 	  sample.push_back(std::make_pair(S(i)[0] /*dummy element*/, i));
 
-      difference_type localrank = rank * m / N ;
+      difference_type localrank = rank / l;
 
       int j;
       for (j = 0; j < localrank && ((n + 1) <= ns[sample[j].second]); ++j)
@@ -496,15 +486,11 @@
 		b[i] -= n + 1;
 	    }
 
-	  difference_type leftsize = 0, total = 0;
+	  difference_type leftsize = 0;
 	  for (int i = 0; i < m; ++i)
-	    {
 	      leftsize += a[i] / (n + 1);
-	      total += l / (n + 1);
-	    }
 
-	  difference_type skew = ((unsigned long long)total * rank / N
-				  - leftsize);
+	  difference_type skew = rank / (n + 1) - leftsize;
 
 	  if (skew > 0)
 	    {
Index: libstdc++-v3/include/parallel/partition.h
===================================================================
--- libstdc++-v3/include/parallel/partition.h	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libstdc++-v3/include/parallel/partition.h	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -72,7 +72,7 @@
 
     bool* reserved_left = NULL, * reserved_right = NULL;
 
-    difference_type chunk_size;
+    difference_type chunk_size = __s.partition_chunk_size;
 
     omp_lock_t result_lock;
     omp_init_lock(&result_lock);
@@ -339,15 +339,16 @@
     RandomAccessIterator split;
     random_number rng;
 
-    difference_type minimum_length =
-      std::max<difference_type>(2, _Settings::get().partition_minimal_n);
+    const _Settings& __s = _Settings::get();
+    difference_type minimum_length = std::max<difference_type>(2,
+        std::max(__s.nth_element_minimal_n, __s.partition_minimal_n));
 
     // Break if input range to small.
     while (static_cast<sequence_index_t>(end - begin) >= minimum_length)
       {
         difference_type n = end - begin;
 
-        RandomAccessIterator pivot_pos = begin +  rng(n);
+        RandomAccessIterator pivot_pos = begin + rng(n);
 
         // Swap pivot_pos value to end.
         if (pivot_pos != (end - 1))
@@ -404,7 +405,7 @@
       }
 
     // Only at most _Settings::partition_minimal_n elements left.
-    __gnu_sequential::sort(begin, end, comp);
+    __gnu_sequential::nth_element(begin, nth, end, comp);
   }
 
 /** @brief Parallel implementation of std::partial_sort().
Index: libstdc++-v3/src/atomic.cc
===================================================================
--- libstdc++-v3/src/atomic.cc	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libstdc++-v3/src/atomic.cc	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -80,16 +80,16 @@
     atomic_flag_test_and_set_explicit(volatile __atomic_flag_base* __a,
 				      memory_order __m)
     {
-      volatile atomic_flag d(__a->_M_i);
-      return d.test_and_set(__m);
+      volatile atomic_flag* d = static_cast<volatile atomic_flag*>(__a);
+      return d->test_and_set(__m);
     }
 
     void
     atomic_flag_clear_explicit(volatile __atomic_flag_base* __a,
 			       memory_order __m)
     {
-      volatile atomic_flag d(__a->_M_i);
-      return d.clear(__m);
+      volatile atomic_flag* d = static_cast<volatile atomic_flag*>(__a);
+      return d->clear(__m);
     }
 
     void
Index: libstdc++-v3/ChangeLog
===================================================================
--- libstdc++-v3/ChangeLog	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libstdc++-v3/ChangeLog	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,3 +1,82 @@
+2010-02-23  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
+
+	Backport:
+	2010-01-20  Janis Johnson  <janis187@us.ibm.com>
+		    Paolo Carlini  <paolo.carlini@oracle.com>
+
+	PR libstdc++/21769
+	* testsuite/lib/dg-options.exp (add_options_for_no_pch): Add.
+	* testsuite/26_numerics/headers/cmath/c99_classification_macros_c.cc:
+	Use it.
+
+2010-01-21  Release Manager
+
+	* GCC 4.4.3 released.
+
+2009-12-10  Paolo Carlini  <paolo.carlini@oracle.com>
+
+	Revert:
+        2009-12-04  Paolo Carlini  <paolo.carlini@oracle.com>
+
+	PR libstdc++/42261
+	* include/bits/basic_string.h (_S_construct_aux(_Integer, _Integer,
+	const _Alloc&, __true_type)): Cast the second argument to value_type.
+	* include/ext/sso_string_base.h (_M_construct_aux(_Integer, _Integer,
+	std::__true_type)): Likewise.
+	* include/ext/rc_string_base.h (_S_construct_aux(_Integer, _Integer,
+	const _Alloc&, std::__true_type)): Likewise.
+	* testsuite/21_strings/basic_string/cons/char/42261.cc: New.
+	* testsuite/21_strings/basic_string/cons/wchar_t/42261.cc: Likewise.
+
+2009-12-09  Roman Odaisky  <to.roma.from.bugcc@qwertty.com>
+
+	PR libstdc++/42273
+	* include/bits/atomic_2.h: Fix typo.
+
+2009-12-04  Paolo Carlini  <paolo.carlini@oracle.com>
+
+	PR libstdc++/42261
+	* include/bits/basic_string.h (_S_construct_aux(_Integer, _Integer,
+	const _Alloc&, __true_type)): Cast the second argument to value_type.
+	* include/ext/sso_string_base.h (_M_construct_aux(_Integer, _Integer,
+	std::__true_type)): Likewise.
+	* include/ext/rc_string_base.h (_S_construct_aux(_Integer, _Integer,
+	const _Alloc&, std::__true_type)): Likewise.
+	* testsuite/21_strings/basic_string/cons/char/42261.cc: New.
+	* testsuite/21_strings/basic_string/cons/wchar_t/42261.cc: Likewise.
+
+2009-11-19  Johannes Singler  <singler@kit.edu>
+
+        * include/parallel/partition.h (__parallel_partition): Correctly
+        initialize chunk size.
+        (__parallel_nth_element): Respect nth_element_minimal_n.  Use
+        sequential nth_element as base case, instead of sequential sort.
+
+2009-10-28  Johannes Singler  <singler@kit.edu>
+
+        PR libstdc++/40852
+        * include/parallel/multiseq_selection.h
+        (multiseq_partition, multiseq_selection):  Avoid intermediate
+	values exceeding the integer type range for very large inputs.
+
+2009-10-16  Benjamin Kosnik  <bkoz@redhat.com>
+
+        * include/c_compatibility/stdatomic.h: Include cstdatomic if
+        __cplusplus.
+
+2009-10-15  Benjamin Kosnik  <bkoz@redhat.com>
+
+        PR libstdc++/40654
+        PR libstdc++/40826
+        * src/atomic.cc (atomic_flag_test_and_set_explicit): Add
+        static_cast from base to derived.
+        (atomic_flag_clear_explicit): Same.
+        * include/bits/atomic_2.h (__atomic2::atomic_flag): Public derivation.
+        Remove value type constructor.
+        * include/bits/atomic_0.h (__atomic0::atomic_flag): Same.
+        * include/std/future (_Future_state): Use ATOMIC_FLAG_INIT to
+        initialized the atomic_flag member.
+
 2009-10-15  Release Manager
 
 	* GCC 4.4.2 released.
Index: libstdc++-v3/testsuite/26_numerics/headers/cmath/c99_classification_macros_c.cc
===================================================================
--- libstdc++-v3/testsuite/26_numerics/headers/cmath/c99_classification_macros_c.cc	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libstdc++-v3/testsuite/26_numerics/headers/cmath/c99_classification_macros_c.cc	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,6 +1,6 @@
 // 2001-04-06 gdr
 
-// Copyright (C) 2001, 2005, 2009 Free Software Foundation, Inc.
+// Copyright (C) 2001, 2005, 2009, 2010 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -17,8 +17,9 @@
 // with this library; see the file COPYING3.  If not see
 // <http://www.gnu.org/licenses/>.
 
+// { dg-do compile }
+// { dg-add-options no_pch }
 
-// { dg-do compile }
 // { dg-xfail-if "" { { *-*-linux* *-*-darwin[3-7]* } || { uclibc || newlib } } { "*" } { "" } }
 // { dg-excess-errors "" { target { { *-*-linux* *-*-darwin[3-7]* } || { uclibc || newlib } } } }
 
Index: libstdc++-v3/testsuite/lib/dg-options.exp
===================================================================
--- libstdc++-v3/testsuite/lib/dg-options.exp	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libstdc++-v3/testsuite/lib/dg-options.exp	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,6 +1,6 @@
 # Handlers for additional dg-xxx keywords in tests.
 
-# Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009
+# Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010
 # Free Software Foundation, Inc.
 #
 # This program is free software; you can redistribute it and/or modify
@@ -142,3 +142,8 @@
     }
     return
 }
+
+proc add_options_for_no_pch { flags } {
+    # This forces any generated and possibly included PCH to be invalid.
+    return "-D__GLIBCXX__=99999999"
+}
Index: libstdc++-v3/testsuite/29_atomics/atomic_flag/cons/1.cc
===================================================================
--- libstdc++-v3/testsuite/29_atomics/atomic_flag/cons/1.cc	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ libstdc++-v3/testsuite/29_atomics/atomic_flag/cons/1.cc	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,27 @@
+// { dg-options "-std=gnu++0x" }
+// { dg-do compile }
+
+// Copyright (C) 2008, 2009 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <stdatomic.h>
+
+void test01()
+{
+  using namespace std;
+  atomic_flag af = ATOMIC_FLAG_INIT;
+}
Index: libstdc++-v3/testsuite/29_atomics/atomic_flag/clear/1.c
===================================================================
--- libstdc++-v3/testsuite/29_atomics/atomic_flag/clear/1.c	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ libstdc++-v3/testsuite/29_atomics/atomic_flag/clear/1.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,34 @@
+// { dg-options "-x c -shared-libgcc -lstdc++" }
+
+// Copyright (C) 2009 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <cassert>
+#include <stdatomic.h>
+
+// libstdc++/40826
+// libstdc++/40654
+int main()
+{
+  atomic_flag f = ATOMIC_FLAG_INIT;
+
+  atomic_flag_clear(&f); // set to false
+  assert( false == atomic_flag_test_and_set(&f) ); // return previous false, set to true
+  assert( true == atomic_flag_test_and_set(&f) ); // return true
+
+  return 0;
+}
Index: libstdc++-v3/testsuite/29_atomics/atomic_flag/clear/1.cc
===================================================================
--- libstdc++-v3/testsuite/29_atomics/atomic_flag/clear/1.cc	(.../tags/gcc_4_4_2_release)	(wersja 0)
+++ libstdc++-v3/testsuite/29_atomics/atomic_flag/clear/1.cc	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -0,0 +1,33 @@
+// { dg-options "-std=gnu++0x" }
+
+// Copyright (C) 2009 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <cstdatomic>
+#include <testsuite_hooks.h>
+
+int main()
+{
+  bool test __attribute__((unused)) = true;
+  std::atomic_flag f = ATOMIC_FLAG_INIT;
+
+  f.clear(); // set to false
+  VERIFY( false == f.test_and_set() ); // return previous false, set to true
+  VERIFY( true == f.test_and_set() ); // return true
+
+  return 0;
+}
Index: libobjc/ChangeLog
===================================================================
--- libobjc/ChangeLog	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libobjc/ChangeLog	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,3 +1,7 @@
+2010-01-21  Release Manager
+
+	* GCC 4.4.3 released.
+
 2009-10-15  Release Manager
 
 	* GCC 4.4.2 released.
Index: intl/ChangeLog
===================================================================
--- intl/ChangeLog	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ intl/ChangeLog	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,3 +1,7 @@
+2010-01-21  Release Manager
+
+	* GCC 4.4.3 released.
+
 2009-10-15  Release Manager
 
 	* GCC 4.4.2 released.
Index: libgfortran/intrinsics/pack_generic.c
===================================================================
--- libgfortran/intrinsics/pack_generic.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libgfortran/intrinsics/pack_generic.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -403,7 +403,7 @@
 
     case GFC_DTYPE_DERIVED_2:
       if (GFC_UNALIGNED_2(ret->data) || GFC_UNALIGNED_2(array->data)
-	  || GFC_UNALIGNED_2(vector->data))
+	  || (vector && GFC_UNALIGNED_2(vector->data)))
 	break;
       else
 	{
@@ -414,7 +414,7 @@
 
     case GFC_DTYPE_DERIVED_4:
       if (GFC_UNALIGNED_4(ret->data) || GFC_UNALIGNED_4(array->data)
-	  || GFC_UNALIGNED_4(vector->data))
+	  || (vector && GFC_UNALIGNED_4(vector->data)))
 	break;
       else
 	{
@@ -425,7 +425,7 @@
 
     case GFC_DTYPE_DERIVED_8:
       if (GFC_UNALIGNED_8(ret->data) || GFC_UNALIGNED_8(array->data)
-	  || GFC_UNALIGNED_8(vector->data))
+	  || (vector && GFC_UNALIGNED_8(vector->data)))
 	break;
       else
 	{
@@ -436,7 +436,7 @@
 #ifdef HAVE_GFC_INTEGER_16
     case GFC_DTYPE_DERIVED_16:
       if (GFC_UNALIGNED_16(ret->data) || GFC_UNALIGNED_16(array->data)
-	  || GFC_UNALIGNED_16(vector->data))
+	  || (vector && GFC_UNALIGNED_16(vector->data)))
 	break;
       else
 	{
Index: libgfortran/ChangeLog
===================================================================
--- libgfortran/ChangeLog	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libgfortran/ChangeLog	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,3 +1,29 @@
+2010-02-04  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR libfortran/42901
+	* io/list_read.c (nml_get_obj_data): Add new qualifier flag, clean up
+	code, and adjust logic to set namelist info pointer correctly for array
+	qualifiers of derived type components.
+
+2010-01-21  Release Manager
+
+	* GCC 4.4.3 released.
+
+2009-12-10  Janus Weil  <janus@gcc.gnu.org>
+
+	PR fortran/42268
+	* intrinsics/pack_generic.c (pack): Add safety checks for the case that
+	'vector' is NULL.
+
+2009-11-19  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR libgfortran/42090
+	Backport from trunk.
+	* io/transfer.c (skip_record): Set bytes_left_subrecord to zero after
+	skipping the remaining bytes in the record.
+	(next_record_r): Call skip_record with the number of bytes_left to be
+	skipped.
+
 2009-10-15  Release Manager
 
 	* GCC 4.4.2 released.
Index: libgfortran/io/list_read.c
===================================================================
--- libgfortran/io/list_read.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libgfortran/io/list_read.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -287,10 +287,10 @@
 eat_line (st_parameter_dt *dtp)
 {
   char c;
-  if (!is_internal_unit (dtp))
-    do
-      c = next_char (dtp);
-    while (c != '\n');
+
+  do
+    c = next_char (dtp);
+  while (c != '\n');
 }
 
 
@@ -2563,7 +2563,7 @@
   namelist_info * first_nl = NULL;
   namelist_info * root_nl = NULL;
   int dim, parsed_rank;
-  int component_flag;
+  int component_flag, qualifier_flag;
   index_type clow, chigh;
   int non_zero_rank_count;
 
@@ -2612,11 +2612,12 @@
       break;
     }
 
-  /* Untouch all nodes of the namelist and reset the flag that is set for
+  /* Untouch all nodes of the namelist and reset the flags that are set for
      derived type components.  */
 
   nml_untouch_nodes (dtp);
   component_flag = 0;
+  qualifier_flag = 0;
   non_zero_rank_count = 0;
 
   /* Get the object name - should '!' and '\n' be permitted separators?  */
@@ -2698,10 +2699,11 @@
 		    " for namelist variable %s", nl->var_name);
 	  goto nml_err_ret;
 	}
-
       if (parsed_rank > 0)
 	non_zero_rank_count++;
 
+      qualifier_flag = 1;
+
       c = next_char (dtp);
       unget_char (dtp, c);
     }
@@ -2726,6 +2728,7 @@
 
       root_nl = nl;
       component_flag = 1;
+
       c = next_char (dtp);
       goto get_name;
     }
@@ -2766,15 +2769,6 @@
       unget_char (dtp, c);
     }
 
-  /* If a derived type touch its components and restore the root
-     namelist_info if we have parsed a qualified derived type
-     component.  */
-
-  if (nl->type == GFC_DTYPE_DERIVED)
-    nml_touch_nodes (nl);
-  if (component_flag && nl->var_rank > 0 && nl->next)
-    nl = first_nl;
-
   /* Make sure no extraneous qualifiers are there.  */
 
   if (c == '(')
@@ -2819,10 +2813,24 @@
 		nl->var_name);
       goto nml_err_ret;
     }
+  /* If a derived type, touch its components and restore the root
+     namelist_info if we have parsed a qualified derived type
+     component.  */
 
-  if (first_nl != NULL && first_nl->var_rank > 0)
-    nl = first_nl;
-  
+  if (nl->type == GFC_DTYPE_DERIVED)
+    nml_touch_nodes (nl);
+
+  if (first_nl)
+    {
+      if (first_nl->var_rank == 0)
+	{
+	  if (component_flag && qualifier_flag)
+	    nl = first_nl;
+	}
+      else
+	nl = first_nl;
+    }
+
   if (nml_read_obj (dtp, nl, 0, pprev_nl, nml_err_msg, nml_err_msg_size,
 		    clow, chigh) == FAILURE)
     goto nml_err_ret;
Index: libgfortran/io/transfer.c
===================================================================
--- libgfortran/io/transfer.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libgfortran/io/transfer.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -2579,6 +2579,8 @@
       if (sseek (dtp->u.p.current_unit->s, 
 		 dtp->u.p.current_unit->bytes_left_subrecord, SEEK_CUR) < 0)
 	generate_error (&dtp->common, LIBERROR_OS, NULL);
+
+      dtp->u.p.current_unit->bytes_left_subrecord = 0;
     }
   else
     {			/* Seek by reading data.  */
@@ -2659,7 +2661,7 @@
 
     case FORMATTED_DIRECT:
     case UNFORMATTED_DIRECT:
-      skip_record (dtp, 0);
+      skip_record (dtp, dtp->u.p.current_unit->bytes_left);
       break;
 
     case FORMATTED_STREAM:
Index: libada/configure
===================================================================
--- libada/configure	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libada/configure	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -272,7 +272,7 @@
 PACKAGE_BUGREPORT=
 
 ac_unique_file="Makefile.in"
-ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os target_noncanonical build_libsubdir build_subdir host_subdir target_subdir MAINT multi_basedir toolexecdir toolexeclibdir CC ac_ct_CC EXEEXT OBJEXT CFLAGS enable_shared LN_S default_gnatlib_target LDFLAGS CPPFLAGS warn_cflags LIBOBJS LTLIBOBJS'
+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os target_noncanonical build_libsubdir build_subdir host_subdir target_subdir MAINT multi_basedir toolexecdir toolexeclibdir CC ac_ct_CC EXEEXT OBJEXT CFLAGS enable_shared LN_S default_gnatlib_target have_getipinfo LDFLAGS CPPFLAGS warn_cflags LIBOBJS LTLIBOBJS'
 ac_subst_files=''
 ac_pwd=`pwd`
 
@@ -815,6 +815,7 @@
   --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
   --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
   --with-build-libsubdir=DIR  Directory where to find libraries for build system
+  --with-system-libunwind use installed libunwind
 
 Some influential environment variables:
   CC          C compiler command
@@ -2527,6 +2528,51 @@
 fi
 
 
+# Check for _Unwind_GetIPInfo
+
+
+# Check whether --with-system-libunwind or --without-system-libunwind was given.
+if test "${with_system_libunwind+set}" = set; then
+  withval="$with_system_libunwind"
+
+fi;
+  # If system-libunwind was not specifically set, pick a default setting.
+  if test x$with_system_libunwind = x; then
+    case ${target} in
+      ia64-*-hpux*) with_system_libunwind=yes ;;
+      *) with_system_libunwind=no ;;
+    esac
+  fi
+  # Based on system-libunwind and target, do we have ipinfo?
+  if  test x$with_system_libunwind = xyes; then
+    case ${target} in
+      ia64-*-*) have_unwind_getipinfo=no ;;
+      *) have_unwind_getipinfo=yes ;;
+    esac
+  else
+    # Darwin before version 9 does not have _Unwind_GetIPInfo.
+
+    case ${target} in
+      *-*-darwin[3-8]|*-*-darwin[3-8].*) have_unwind_getipinfo=no ;;
+      *) have_unwind_getipinfo=yes ;;
+    esac
+
+  fi
+
+  if test x$have_unwind_getipinfo = xyes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_GETIPINFO 1
+_ACEOF
+
+  fi
+
+have_getipinfo=
+if test x$have_unwind_getipinfo = xyes; then
+  have_getipinfo=-DHAVE_GETIPINFO
+fi
+
+
 ac_ext=c
 ac_cpp='$CPP $CPPFLAGS'
 ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
@@ -3953,6 +3999,7 @@
 s,@enable_shared@,$enable_shared,;t t
 s,@LN_S@,$LN_S,;t t
 s,@default_gnatlib_target@,$default_gnatlib_target,;t t
+s,@have_getipinfo@,$have_getipinfo,;t t
 s,@LDFLAGS@,$LDFLAGS,;t t
 s,@CPPFLAGS@,$CPPFLAGS,;t t
 s,@warn_cflags@,$warn_cflags,;t t
Index: libada/Makefile.in
===================================================================
--- libada/Makefile.in	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libada/Makefile.in	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -56,6 +56,8 @@
 
 TARGET_LIBGCC2_CFLAGS=
 GNATLIBCFLAGS= -g -O2
+GNATLIBCFLAGS_FOR_C = $(GNATLIBCFLAGS) $(TARGET_LIBGCC2_CFLAGS) -fexceptions \
+	-DIN_RTS @have_getipinfo@
 
 # Get target-specific overrides for TARGET_LIBGCC2_CFLAGS.
 host_subdir = @host_subdir@
@@ -78,6 +80,7 @@
         "SHELL=$(SHELL)" \
         "GNATLIBFLAGS=$(GNATLIBFLAGS) $(MULTIFLAGS)" \
         "GNATLIBCFLAGS=$(GNATLIBCFLAGS) $(MULTIFLAGS)" \
+        "GNATLIBCFLAGS_FOR_C=$(GNATLIBCFLAGS_FOR_C) $(MULTIFLAGS)" \
         "TARGET_LIBGCC2_CFLAGS=$(TARGET_LIBGCC2_CFLAGS)" \
         "THREAD_KIND=$(THREAD_KIND)" \
         "TRACE=$(TRACE)" \
Index: libada/configure.ac
===================================================================
--- libada/configure.ac	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libada/configure.ac	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -18,6 +18,7 @@
 sinclude(../config/acx.m4)
 sinclude(../config/multi.m4)
 sinclude(../config/override.m4)
+sinclude(../config/unwind_ipinfo.m4)
 
 AC_INIT
 AC_PREREQ([2.59])
@@ -130,6 +131,14 @@
 fi
 AC_SUBST([default_gnatlib_target])
 
+# Check for _Unwind_GetIPInfo
+GCC_CHECK_UNWIND_GETIPINFO
+have_getipinfo=
+if test x$have_unwind_getipinfo = xyes; then
+  have_getipinfo=-DHAVE_GETIPINFO
+fi
+AC_SUBST(have_getipinfo)
+
 AC_PROG_CC
 warn_cflags=
 if test "x$GCC" = "xyes"; then
Index: libada/ChangeLog
===================================================================
--- libada/ChangeLog	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libada/ChangeLog	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,3 +1,15 @@
+2010-01-21  Release Manager
+
+	* GCC 4.4.3 released.
+
+2009-10-24  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* Makefile.in (GNATLIBCFLAGS_FOR_C): New variable.
+	(LIBADA_FLAGS_TO_PASS): Add GNATLIBCFLAGS_FOR_C.
+	* configure.ac: Include config/unwind_ipinfo.m4.
+	Check for _Unwind_GetIPInfo.
+	* configure: Regenerate.
+
 2009-10-15  Release Manager
 
 	* GCC 4.4.2 released.
Index: libmudflap/ChangeLog
===================================================================
--- libmudflap/ChangeLog	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libmudflap/ChangeLog	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,3 +1,11 @@
+2010-01-21  Release Manager
+
+	* GCC 4.4.3 released.
+
+2010-01-09  Jakub Jelinek  <jakub@redhat.com>
+
+	* mf-runtime.c (__mf_usage): Update copyright notice dates.
+
 2009-10-15  Release Manager
 
 	* GCC 4.4.2 released.
Index: libmudflap/mf-runtime.c
===================================================================
--- libmudflap/mf-runtime.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libmudflap/mf-runtime.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,5 +1,5 @@
 /* Mudflap: narrow-pointer bounds-checking by tree rewriting.
-   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2008, 2009
+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2008, 2009, 2010
    Free Software Foundation, Inc.
    Contributed by Frank Ch. Eigler <fche@redhat.com>
    and Graydon Hoare <graydon@redhat.com>
@@ -440,7 +440,7 @@
 
   fprintf (stderr,
            "This is a %s%sGCC \"mudflap\" memory-checked binary.\n"
-           "Mudflap is Copyright (C) 2002-2009 Free Software Foundation, Inc.\n"
+           "Mudflap is Copyright (C) 2002-2010 Free Software Foundation, Inc.\n"
            "\n"
            "The mudflap code can be controlled by an environment variable:\n"
            "\n"
Index: boehm-gc/ChangeLog
===================================================================
--- boehm-gc/ChangeLog	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ boehm-gc/ChangeLog	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,3 +1,7 @@
+2010-01-21  Release Manager
+
+	* GCC 4.4.3 released.
+
 2009-10-15  Release Manager
 
 	* GCC 4.4.2 released.
Index: include/ChangeLog
===================================================================
--- include/ChangeLog	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ include/ChangeLog	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,3 +1,7 @@
+2010-01-21  Release Manager
+
+	* GCC 4.4.3 released.
+
 2009-10-15  Release Manager
 
 	* GCC 4.4.2 released.
Index: libiberty/ChangeLog
===================================================================
--- libiberty/ChangeLog	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libiberty/ChangeLog	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,3 +1,13 @@
+2010-01-25  Ian Lance Taylor  <iant@google.com>
+
+	* cp-demangle.c (cplus_demangle_type): Check for invalid type
+	after "DF".
+	* testsuite/demangle-expected: Add test.
+
+2010-01-21  Release Manager
+
+	* GCC 4.4.3 released.
+
 2009-10-15  Release Manager
 
 	* GCC 4.4.2 released.
Index: libiberty/testsuite/demangle-expected
===================================================================
--- libiberty/testsuite/demangle-expected	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libiberty/testsuite/demangle-expected	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -3910,3 +3910,8 @@
 --format=gnu-v3
 _Z1gIIidEEDTclL_Z1fEspplfp_Li1EEEDpT_
 decltype (f((parm#1+(1))...)) g<int, double>(int, double)
+#
+# Used to crash the demangler.
+--format=gnu-v3
+DFA
+DFA
Index: libiberty/cp-demangle.c
===================================================================
--- libiberty/cp-demangle.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libiberty/cp-demangle.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,5 +1,5 @@
 /* Demangler for g++ V3 ABI.
-   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008
+   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
    Free Software Foundation, Inc.
    Written by Ian Lance Taylor <ian@wasabisystems.com>.
 
@@ -2149,6 +2149,8 @@
 	    /* For demangling we don't care about the bits.  */
 	    d_number (di);
 	  ret->u.s_fixed.length = cplus_demangle_type (di);
+	  if (ret->u.s_fixed.length == NULL)
+	    return NULL;
 	  d_number (di);
 	  peek = d_next_char (di);
 	  ret->u.s_fixed.sat = (peek == 's');
Index: ChangeLog
===================================================================
--- ChangeLog	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ ChangeLog	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,3 +1,11 @@
+2010-01-21  Release Manager
+
+	* GCC 4.4.3 released.
+
+2009-11-23  Ben Elliston  <bje@au.ibm.com>
+
+	* config.sub, config.guess: Update from upstream sources.
+
 2009-10-15  Release Manager
 
 	* GCC 4.4.2 released.
Index: libffi/ChangeLog
===================================================================
--- libffi/ChangeLog	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libffi/ChangeLog	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,3 +1,12 @@
+2010-02-15  Matthias Klose  <doko@ubuntu.com>
+
+	* src/arm/sysv.S (__ARM_ARCH__): Define for processor
+	__ARM_ARCH_7EM__.
+
+2010-01-21  Release Manager
+
+	* GCC 4.4.3 released.
+
 2009-10-15  Release Manager
 
 	* GCC 4.4.2 released.
Index: libffi/src/arm/sysv.S
===================================================================
--- libffi/src/arm/sysv.S	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libffi/src/arm/sysv.S	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -73,7 +73,8 @@
 #endif
 
 #if defined(__ARM_ARCH_7__) || defined(__ARM_ARCH_7A__) \
-        || defined(__ARM_ARCH_7R__) || defined(__ARM_ARCH_7M__)
+        || defined(__ARM_ARCH_7R__) || defined(__ARM_ARCH_7M__) \
+	|| defined(__ARM_ARCH_7EM__)
 # undef __ARM_ARCH__
 # define __ARM_ARCH__ 7
 #endif
Index: libssp/ChangeLog
===================================================================
--- libssp/ChangeLog	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libssp/ChangeLog	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,3 +1,7 @@
+2010-01-21  Release Manager
+
+	* GCC 4.4.3 released.
+
 2009-10-15  Release Manager
 
 	* GCC 4.4.2 released.
Index: contrib/regression/ChangeLog
===================================================================
--- contrib/regression/ChangeLog	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ contrib/regression/ChangeLog	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,3 +1,7 @@
+2010-01-21  Release Manager
+
+	* GCC 4.4.3 released.
+
 2009-10-15  Release Manager
 
 	* GCC 4.4.2 released.
Index: contrib/reghunt/ChangeLog
===================================================================
--- contrib/reghunt/ChangeLog	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ contrib/reghunt/ChangeLog	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,3 +1,7 @@
+2010-01-21  Release Manager
+
+	* GCC 4.4.3 released.
+
 2009-10-15  Release Manager
 
 	* GCC 4.4.2 released.
Index: contrib/ChangeLog
===================================================================
--- contrib/ChangeLog	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ contrib/ChangeLog	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,3 +1,7 @@
+2010-01-21  Release Manager
+
+	* GCC 4.4.3 released.
+
 2009-10-15  Release Manager
 
 	* GCC 4.4.2 released.
Index: config/ChangeLog
===================================================================
--- config/ChangeLog	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ config/ChangeLog	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,3 +1,7 @@
+2010-01-21  Release Manager
+
+	* GCC 4.4.3 released.
+
 2009-10-15  Release Manager
 
 	* GCC 4.4.2 released.
Index: libjava/Makefile.in
===================================================================
--- libjava/Makefile.in	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libjava/Makefile.in	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -838,7 +838,6 @@
 datadir = @datadir@
 dbexecdir = @dbexecdir@
 exec_prefix = @exec_prefix@
-extra_gij_ldflags = @extra_gij_ldflags@
 extra_ldflags = @extra_ldflags@
 extra_ldflags_libjava = @extra_ldflags_libjava@ $(am__append_8)
 gcc_suffix = @gcc_suffix@
@@ -8354,8 +8353,7 @@
 gc_analyze_DEPENDENCIES = libgcj-tools.la libgcj.la libgcj.spec
 gij_SOURCES = 
 gij_LDFLAGS = -rpath $(dbexecdir) -rpath $(toolexeclibdir) \
-	-shared-libgcc $(THREADLDFLAGS) $(extra_ldflags) \
-	$(extra_gij_ldflags) 
+	-shared-libgcc $(THREADLDFLAGS) $(extra_ldflags)
 
 gij_LINK = $(GCJLINK)
 gij_LDADD = -L$(here)/.libs libgij.la
Index: libjava/libltdl/ltdl.c
===================================================================
--- libjava/libltdl/ltdl.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libjava/libltdl/ltdl.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -2175,7 +2175,8 @@
 static	int	try_dlopen	      LT_PARAMS((lt_dlhandle *handle,
 						 const char *filename));
 static	int	tryall_dlopen	      LT_PARAMS((lt_dlhandle *handle,
-						 const char *filename));
+						 const char *filename,
+						 const char * useloader));
 static	int	unload_deplibs	      LT_PARAMS((lt_dlhandle handle));
 static	int	lt_argz_insert	      LT_PARAMS((char **pargz,
 						 size_t *pargz_len,
@@ -2361,9 +2362,10 @@
 }
 
 static int
-tryall_dlopen (handle, filename)
+tryall_dlopen (handle, filename, useloader)
      lt_dlhandle *handle;
      const char *filename;
+     const char *useloader;
 {
   lt_dlhandle	 cur;
   lt_dlloader   *loader;
@@ -2430,6 +2432,11 @@
 
   while (loader)
     {
+      if (useloader && strcmp(loader->loader_name, useloader))
+	{
+	  loader = loader->next;
+	  continue;
+	}
       lt_user_data data = loader->dlloader_data;
 
       cur->module = loader->module_open (data, filename);
@@ -2499,7 +2506,7 @@
       error += tryall_dlopen_module (handle,
 				     (const char *) 0, prefix, filename);
     }
-  else if (tryall_dlopen (handle, filename) != 0)
+  else if (tryall_dlopen (handle, filename, NULL) != 0)
     {
       ++error;
     }
@@ -2520,7 +2527,7 @@
   /* Try to open the old library first; if it was dlpreopened,
      we want the preopened version of it, even if a dlopenable
      module is available.  */
-  if (old_name && tryall_dlopen (handle, old_name) == 0)
+  if (old_name && tryall_dlopen (handle, old_name, "dlpreload") == 0)
     {
       return 0;
     }
@@ -2784,7 +2791,7 @@
 
   /* Try to dlopen the file, but do not continue searching in any
      case.  */
-  if (tryall_dlopen (handle, filename) != 0)
+  if (tryall_dlopen (handle, filename,NULL) != 0)
     *handle = 0;
 
   return 1;
@@ -3072,7 +3079,7 @@
       /* lt_dlclose()ing yourself is very bad!  Disallow it.  */
       LT_DLSET_FLAG (*phandle, LT_DLRESIDENT_FLAG);
 
-      if (tryall_dlopen (&newhandle, 0) != 0)
+      if (tryall_dlopen (&newhandle, 0, NULL) != 0)
 	{
 	  LT_DLFREE (*phandle);
 	  return 1;
@@ -3194,7 +3201,7 @@
 	    }
 #endif
 	}
-      if (!file)
+      else
 	{
 	  file = fopen (filename, LT_READTEXT_MODE);
 	}
@@ -3378,7 +3385,7 @@
 #endif
 		   )))
 	{
-          if (tryall_dlopen (&newhandle, filename) != 0)
+          if (tryall_dlopen (&newhandle, filename, NULL) != 0)
             {
               newhandle = NULL;
             }
Index: libjava/libltdl/configure
===================================================================
--- libjava/libltdl/configure	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libjava/libltdl/configure	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -8628,7 +8628,7 @@
 
   # Append ld.so.conf contents to the search path
   if test -f /etc/ld.so.conf; then
-    lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s", \$2)); skip = 1; } { if (!skip) print \$0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;s/[:,\t]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;/^$/d' | tr '\n' ' '`
+    lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s 2>/dev/null", \$2)); skip = 1; } { if (!skip) print \$0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[	 ]*hwcap[	 ]/d;s/[:,	]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;/^$/d' | tr '\n' ' '`
     sys_lib_dlsearch_path_spec="/lib${libsuff} /usr/lib${libsuff} $lt_ld_extra"
   fi
 
@@ -12426,7 +12426,7 @@
 
   # Append ld.so.conf contents to the search path
   if test -f /etc/ld.so.conf; then
-    lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s", \$2)); skip = 1; } { if (!skip) print \$0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;s/[:,\t]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;/^$/d' | tr '\n' ' '`
+    lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s 2>/dev/null", \$2)); skip = 1; } { if (!skip) print \$0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[	 ]*hwcap[	 ]/d;s/[:,	]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;/^$/d' | tr '\n' ' '`
     sys_lib_dlsearch_path_spec="/lib${libsuff} /usr/lib${libsuff} $lt_ld_extra"
   fi
 
@@ -15707,7 +15707,7 @@
 
   # Append ld.so.conf contents to the search path
   if test -f /etc/ld.so.conf; then
-    lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s", \$2)); skip = 1; } { if (!skip) print \$0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;s/[:,\t]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;/^$/d' | tr '\n' ' '`
+    lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s 2>/dev/null", \$2)); skip = 1; } { if (!skip) print \$0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[	 ]*hwcap[	 ]/d;s/[:,	]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;/^$/d' | tr '\n' ' '`
     sys_lib_dlsearch_path_spec="/lib${libsuff} /usr/lib${libsuff} $lt_ld_extra"
   fi
 
@@ -18193,7 +18193,7 @@
 
   # Append ld.so.conf contents to the search path
   if test -f /etc/ld.so.conf; then
-    lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s", \$2)); skip = 1; } { if (!skip) print \$0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;s/[:,\t]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;/^$/d' | tr '\n' ' '`
+    lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s 2>/dev/null", \$2)); skip = 1; } { if (!skip) print \$0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[	 ]*hwcap[	 ]/d;s/[:,	]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;/^$/d' | tr '\n' ' '`
     sys_lib_dlsearch_path_spec="/lib${libsuff} /usr/lib${libsuff} $lt_ld_extra"
   fi
 
Index: libjava/libltdl/ChangeLog
===================================================================
--- libjava/libltdl/ChangeLog	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libjava/libltdl/ChangeLog	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,3 +1,22 @@
+2010-01-21  Release Manager
+
+	* GCC 4.4.3 released.
+
+2009-12-03  Jakub Jelinek  <jakub@redhat.com>
+
+	* acinclude.m4: Regenerated to pick:
+	2007-06-22 Ralf Wildenhues <Ralf.Wildenhues@gmx.de>
+
+	* libtool.m4 (AC_LIBTOOL_SYS_DYNAMIC_LINKER) [linux]:
+	Ignore lines in ld.so.conf starting with 'hwcap '.
+
+	* configure: Regenerated.
+
+	2009-11-24  Peter O'Gorman  <peter@pogma.com>
+
+	Backport of libltdl changes from the 2.26b release.
+	* ltdl.c: Backport changes.
+
 2009-10-15  Release Manager
 
 	* GCC 4.4.2 released.
Index: libjava/libltdl/acinclude.m4
===================================================================
--- libjava/libltdl/acinclude.m4	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libjava/libltdl/acinclude.m4	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1527,7 +1527,7 @@
 
   # Append ld.so.conf contents to the search path
   if test -f /etc/ld.so.conf; then
-    lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s", \[$]2)); skip = 1; } { if (!skip) print \[$]0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;s/[:,\t]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;/^$/d' | tr '\n' ' '`
+    lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s 2>/dev/null", \[$]2)); skip = 1; } { if (!skip) print \[$]0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[	 ]*hwcap[	 ]/d;s/[:,	]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;/^$/d' | tr '\n' ' '`
     sys_lib_dlsearch_path_spec="/lib${libsuff} /usr/lib${libsuff} $lt_ld_extra"
   fi
 
Index: libjava/configure.host
===================================================================
--- libjava/configure.host	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libjava/configure.host	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -87,6 +87,7 @@
 	libgcj_interpreter=yes
 	sysdeps_dir=arm
 	fallback_backtrace_h=sysdep/arm/backtrace.h
+	libgcj_cxxflags=-Wno-abi
 	;;
   mips-tx39-*|mipstx39-unknown-*)
 	libgcj_flags="${libgcj_flags} -G 0"
Index: libjava/configure.ac
===================================================================
--- libjava/configure.ac	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libjava/configure.ac	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -846,6 +846,9 @@
         SYSTEMSPEC="-lunicows $SYSTEMSPEC"
       fi
     ;;
+    *-*-darwin[[912]]*)
+      SYSTEMSPEC="-allow_stack_execute"
+    ;;
     *)
       SYSTEMSPEC=
     ;;
@@ -876,9 +879,6 @@
     # on Darwin -single_module speeds up loading of the dynamic libraries.
     extra_ldflags_libjava=-Wl,-single_module
     ;;
-*-*-darwin[[912]]*)
-    extra_gij_ldflags=-Wl,-allow_stack_execute
-    ;;
 arm*linux*eabi)
     # Some of the ARM unwinder code is actually in libstdc++.  We
     # could in principle replicate it in libgcj, but it's better to
@@ -889,7 +889,6 @@
     ;;
 esac
 AC_SUBST(extra_ldflags_libjava)
-AC_SUBST(extra_gij_ldflags)
 AC_SUBST(extra_ldflags)
 AC_SUBST(LIBSTDCXXSPEC)
 
Index: libjava/classpath/tools/gnu/classpath/tools/orbd/Main.java
===================================================================
--- libjava/classpath/tools/gnu/classpath/tools/orbd/Main.java	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libjava/classpath/tools/gnu/classpath/tools/orbd/Main.java	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,5 +1,5 @@
 /* NamingServicePersistent.java -- The persistent naming service.
-   Copyright (C) 2006, 2008, 2009 Free Software Foundation, Inc.
+   Copyright (C) 2006, 2008, 2009, 2010 Free Software Foundation, Inc.
 
 This file is part of GNU Classpath.
 
@@ -179,7 +179,7 @@
         System.out.println("GNU Classpath persistent naming service "
                            + "started at " + iorr.Internet.host + ":"
                            + iorr.Internet.port + " key 'NameService'.\n\n"
-                           + "Copyright (C) 2009 Free Software Foundation\n"
+                           + "Copyright (C) 2010 Free Software Foundation\n"
                            + "This tool comes with ABSOLUTELY NO WARRANTY. "
                            + "This is free software, and you are\nwelcome to "
                            + "redistribute it under conditions, defined in "
Index: libjava/classpath/tools/gnu/classpath/tools/jar/Creator.java
===================================================================
--- libjava/classpath/tools/gnu/classpath/tools/jar/Creator.java	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libjava/classpath/tools/gnu/classpath/tools/jar/Creator.java	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -216,11 +216,14 @@
     manifest = createManifest(parameters);
     /* If no version is specified, provide the same manifest version default
      * as Sun's jar tool */
-    Attributes attr = manifest.getMainAttributes();
-    if (attr.getValue(Attributes.Name.MANIFEST_VERSION) == null)
-      attr.putValue(Attributes.Name.MANIFEST_VERSION.toString(), "1.0");
-    attr.putValue("Created-By", System.getProperty("java.version") +
+    if (parameters.wantManifest)
+      {
+	  Attributes attr = manifest.getMainAttributes();
+	  if (attr.getValue(Attributes.Name.MANIFEST_VERSION) == null)
+	      attr.putValue(Attributes.Name.MANIFEST_VERSION.toString(), "1.0");
+	  attr.putValue("Created-By", System.getProperty("java.version") +
 		  " (" + System.getProperty("java.vendor") + ")");
+      }
     outputStream = new JarOutputStream(os, manifest);
     // FIXME: this sets the method too late for the manifest file.
     outputStream.setMethod(parameters.storageMode);
Index: libjava/classpath/tools/classes/gnu/classpath/tools/orbd/Main.class
===================================================================
Nie można wyświetlić: plik binarny.
svn:mime-type = application/octet-stream
Index: libjava/classpath/tools/classes/gnu/classpath/tools/jar/Creator.class
===================================================================
Nie można wyświetlić: plik binarny.
svn:mime-type = application/octet-stream
Index: libjava/classpath/ChangeLog
===================================================================
--- libjava/classpath/ChangeLog	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libjava/classpath/ChangeLog	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,3 +1,14 @@
+2010-01-21  Release Manager
+
+	* GCC 4.4.3 released.
+
+2009-10-22  Richard Guenther  <rguenther@suse.de>
+
+	PR cp-tools/39177
+	* tools/gnu/classpath/tools/jar/Creator.java (writeCommandLineEntries):
+	Do not use uninitialized manifest.
+	* tools/classes/gnu/classpath/tools/jar/Creator.class: Re-generated.
+
 2009-10-15  Release Manager
 
 	* GCC 4.4.2 released.
Index: libjava/classpath/gnu/java/rmi/registry/RegistryImpl.java
===================================================================
--- libjava/classpath/gnu/java/rmi/registry/RegistryImpl.java	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libjava/classpath/gnu/java/rmi/registry/RegistryImpl.java	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,5 +1,5 @@
 /* RegistryImpl.java --
-   Copyright (c) 1996, 1997, 1998, 1999, 2002, 2005, 2008, 2009
+   Copyright (c) 1996, 1997, 1998, 1999, 2002, 2005, 2008, 2009, 2010
    Free Software Foundation, Inc.
 
 This file is part of GNU Classpath.
@@ -111,7 +111,7 @@
 			   + System.getProperty("java.vm.name")
 			   + ") "
 			   + System.getProperty("java.vm.version"));
-	System.out.println("Copyright 2009 Free Software Foundation, Inc.");
+	System.out.println("Copyright 2010 Free Software Foundation, Inc.");
 	System.out.println("This is free software; see the source for copying conditions.  There is NO");
 	System.out.println("warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.");
 	System.exit(0);
Index: libjava/classpath/lib/gnu/java/rmi/registry/RegistryImpl.class
===================================================================
Nie można wyświetlić: plik binarny.
svn:mime-type = application/octet-stream
Index: libjava/classpath/lib/gnu/gcj/convert/Convert.class
===================================================================
Nie można wyświetlić: plik binarny.
svn:mime-type = application/octet-stream
Index: libjava/classpath/lib/gnu/gcj/tools/gcj_dbtool/Fileset.class
===================================================================
Nie można wyświetlić: plik binarny.
svn:mime-type = application/octet-stream
Index: libjava/classpath/lib/gnu/gcj/tools/gcj_dbtool/Main.class
===================================================================
Nie można wyświetlić: plik binarny.
svn:mime-type = application/octet-stream
Index: libjava/classpath/lib/gnu/gcj/tools/gcj_dbtool/Tokenizer.class
===================================================================
Nie można wyświetlić: plik binarny.
svn:mime-type = application/octet-stream
Index: libjava/classpath/ChangeLog.gcj
===================================================================
--- libjava/classpath/ChangeLog.gcj	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libjava/classpath/ChangeLog.gcj	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,3 +1,9 @@
+2010-01-09  Jakub Jelinek  <jakub@redhat.com>
+
+	* gnu/java/rmi/registry/RegistryImpl.java (version): Update
+	copyright notice dates.
+	* tools/gnu/classpath/tools/orbd/Main.java (run): Likewise.
+
 2009-06-16  Matthias Klose  <doko@ubuntu.com>
 
 	* tools/gnu/classpath/tools/gjdoc/Main.java (getGjdocVersion): Use
Index: libjava/include/Makefile.in
===================================================================
--- libjava/include/Makefile.in	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libjava/include/Makefile.in	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -333,7 +333,6 @@
 datadir = @datadir@
 dbexecdir = @dbexecdir@
 exec_prefix = @exec_prefix@
-extra_gij_ldflags = @extra_gij_ldflags@
 extra_ldflags = @extra_ldflags@
 extra_ldflags_libjava = @extra_ldflags_libjava@
 gcc_suffix = @gcc_suffix@
Index: libjava/include/posix-threads.h
===================================================================
--- libjava/include/posix-threads.h	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libjava/include/posix-threads.h	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -375,13 +375,6 @@
 };
 
 inline void
-ParkHelper::init ()
-{
-  pthread_mutex_init (&mutex, NULL);
-  pthread_cond_init (&cond, NULL);
-}
-
-inline void
 ParkHelper::destroy ()
 {
   pthread_mutex_destroy (&mutex);
Index: libjava/ChangeLog
===================================================================
--- libjava/ChangeLog	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libjava/ChangeLog	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,3 +1,46 @@
+2010-01-21  Release Manager
+
+	* GCC 4.4.3 released.
+
+2010-01-19  Matthias Klose  <doko@ubuntu.com>
+
+	* Regenerate .class files.
+
+2010-01-12  Matthias Klose  <doko@ubuntu.com>
+
+	PR libjava/40859, backported from:
+
+	2009-08-12  Andrew Haley  <aph@redhat.com>
+	* configure.host (arm*-linux*): Add -Wno-abi to cxxflags.
+	(testsuite/libjava.jvmti/jvmti-interp.exp): Likewise.
+	(testsuite/libjava.jvmti/jvmti.exp): Likewise.
+	(testsuite/libjava.jni/jni.exp): Likewise.
+
+2010-01-09  Jakub Jelinek  <jakub@redhat.com>
+
+	* gnu/gcj/convert/Convert.java (version): Update copyright notice
+	dates.
+	* gnu/gcj/tools/gcj_dbtool/Main.java (main): Likewise.
+
+2009-12-09  Bryce McKinlay  <bmckinlay@gmail.com>
+
+	PR java/41991
+	* configure.ac (SYSTEMSPEC): Pass -allow_stack_execute to Darwin
+	linker.
+	* Makefile.am (gij_LDFLAGS): Remove extra_gij_ldflags.
+	* configure: Regenerate.
+	* Makefile.in: Regenerate.
+
+2009-11-17  Andrew Haley  <aph@redhat.com>
+
+	* posix-threads.cc (park): Rewrite code to handle time.
+	Move mutex lock before the call to compare_and_swap to avoid a
+	race condition.
+	Add some assertions.
+	(unpark): Add an assertion.
+	(init): Move here from posix-threads.h.
+	* include/posix-threads.h (destroy): removed.
+
 2009-10-15  Release Manager
 
 	* GCC 4.4.2 released.
Index: libjava/testsuite/libjava.jvmti/jvmti-interp.exp
===================================================================
--- libjava/testsuite/libjava.jvmti/jvmti-interp.exp	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libjava/testsuite/libjava.jvmti/jvmti-interp.exp	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -29,7 +29,12 @@
       set so_extension "so"
       set so_flag "-shared"
   }
-    
+
+  # ARM C++ emits an ABI warning for varargs.
+  if { [istarget "arm*"] } {
+      lappend options "additional_flags=-Wno-abi"
+  }
+
   set filename [file tail $file]
   set name [file rootname $filename]
   set soname lib${name}.${so_extension}
Index: libjava/testsuite/libjava.jvmti/jvmti.exp
===================================================================
--- libjava/testsuite/libjava.jvmti/jvmti.exp	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libjava/testsuite/libjava.jvmti/jvmti.exp	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -16,6 +16,10 @@
   lappend options "additional_flags=-I$srcdir/.."
   # Find jvmti.h, jvmti_md.h, jvmti-int.h, jvm.h requirements
   lappend options "additional_flags=-I$srcdir/../include -I$srcdir/../classpath/include -I$objdir/../include -I$objdir/../../boehm-gc/include "
+  # ARM C++ emits an ABI warning for varargs.
+  if { [istarget "arm*"] } {
+      lappend options "additional_flags=-Wno-abi"
+  }
 
   set x [libjava_prune_warnings \
 	   [target_compile $file $oname object $options]]
Index: libjava/testsuite/Makefile.in
===================================================================
--- libjava/testsuite/Makefile.in	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libjava/testsuite/Makefile.in	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -322,7 +322,6 @@
 datadir = @datadir@
 dbexecdir = @dbexecdir@
 exec_prefix = @exec_prefix@
-extra_gij_ldflags = @extra_gij_ldflags@
 extra_ldflags = @extra_ldflags@
 extra_ldflags_libjava = @extra_ldflags_libjava@
 gcc_suffix = @gcc_suffix@
Index: libjava/testsuite/libjava.jni/jni.exp
===================================================================
--- libjava/testsuite/libjava.jni/jni.exp	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libjava/testsuite/libjava.jni/jni.exp	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -160,6 +160,11 @@
 	lappend cxxflaglist "-lstdc++"
     }
 
+    # ARM C++ emits an ABI warning for varargs.
+    if { [istarget "arm*"] } {
+	lappend cxxflaglist "-Wno-abi"
+    }
+    
     set cxxflags [join $cxxflaglist]
   }
 
Index: libjava/posix-threads.cc
===================================================================
--- libjava/posix-threads.cc	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libjava/posix-threads.cc	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -359,15 +359,16 @@
   if (compare_and_swap 
       (ptr, Thread::THREAD_PARK_RUNNING, Thread::THREAD_PARK_PERMIT))
     return;
-  
+
   /* If this thread is parked, put it into state RUNNING and send it a
      signal.  */
-  if (compare_and_swap 
+  if (compare_and_swap
       (ptr, Thread::THREAD_PARK_PARKED, Thread::THREAD_PARK_RUNNING))
     {
       pthread_mutex_lock (&mutex);
-      pthread_cond_signal (&cond);
+      int result = pthread_cond_signal (&cond);
       pthread_mutex_unlock (&mutex);
+      JvAssert (result == 0);
     }
 }
 
@@ -380,6 +381,14 @@
   permit = ::java::lang::Thread::THREAD_PARK_DEAD;
 }
 
+void
+ParkHelper::init ()
+{
+  pthread_mutex_init (&mutex, NULL);
+  pthread_cond_init (&cond, NULL);
+  permit = ::java::lang::Thread::THREAD_PARK_RUNNING;
+}
+
 /**
  * Blocks the thread until a matching _Jv_ThreadUnpark() occurs, the
  * thread is interrupted or the optional timeout expires.  If an
@@ -407,32 +416,44 @@
     return;
 
   struct timespec ts;
-  jlong millis = 0, nanos = 0;
 
   if (time)
     {
+      unsigned long long seconds;
+      unsigned long usec;
+
       if (isAbsolute)
 	{
-	  millis = time;
-	  nanos = 0;
+	  ts.tv_sec = time / 1000;
+	  ts.tv_nsec = (time % 1000) * 1000 * 1000;
 	}
       else
 	{
-	  millis = java::lang::System::currentTimeMillis();
-	  nanos = time;
-	}
-
-      if (millis > 0 || nanos > 0)
-	{
 	  // Calculate the abstime corresponding to the timeout.
-	  // Everything is in milliseconds.
-	  //
-	  // We use `unsigned long long' rather than jlong because our
-	  // caller may pass up to Long.MAX_VALUE millis.  This would
-	  // overflow the range of a timespec.
+	  jlong nanos = time;
+	  jlong millis = 0;
 
-	  unsigned long long m = (unsigned long long)millis;
-	  unsigned long long seconds = m / 1000; 
+	  // For better accuracy, should use pthread_condattr_setclock
+	  // and clock_gettime.
+#ifdef HAVE_GETTIMEOFDAY
+	  timeval tv;
+	  gettimeofday (&tv, NULL);
+	  usec = tv.tv_usec;
+	  seconds = tv.tv_sec;
+#else
+	  unsigned long long startTime
+	    = java::lang::System::currentTimeMillis();
+	  seconds = startTime / 1000;
+	  /* Assume we're about half-way through this millisecond.  */
+	  usec = (startTime % 1000) * 1000 + 500;
+#endif
+	  /* These next two statements cannot overflow.  */
+	  usec += nanos / 1000;
+	  usec += (millis % 1000) * 1000;
+	  /* These two statements could overflow only if tv.tv_sec was
+	     insanely large.  */
+	  seconds += millis / 1000;
+	  seconds += usec / 1000000;
 
 	  ts.tv_sec = seconds;
 	  if (ts.tv_sec < 0 || (unsigned long long)ts.tv_sec != seconds)
@@ -442,29 +463,30 @@
 	      millis = nanos = 0;
 	    }
 	  else
-	    {
-	      m %= 1000;
-	      ts.tv_nsec = m * 1000000 + (unsigned long long)nanos;
-	    }
+	    /* This next statement also cannot overflow.  */
+	    ts.tv_nsec = (usec % 1000000) * 1000 + (nanos % 1000);
 	}
     }
-      
+
+  pthread_mutex_lock (&mutex);
   if (compare_and_swap 
       (ptr, Thread::THREAD_PARK_RUNNING, Thread::THREAD_PARK_PARKED))
     {
-      pthread_mutex_lock (&mutex);
-      if (millis == 0 && nanos == 0)
-	pthread_cond_wait (&cond, &mutex);
+      int result = 0;
+
+      if (! time)
+	result = pthread_cond_wait (&cond, &mutex);
       else
-	pthread_cond_timedwait (&cond, &mutex, &ts);
-      pthread_mutex_unlock (&mutex);
-      
+	result = pthread_cond_timedwait (&cond, &mutex, &ts);
+
+      JvAssert (result == 0 || result == ETIMEDOUT);
+
       /* If we were unparked by some other thread, this will already
-	 be in state THREAD_PARK_RUNNING.  If we timed out, we have to
-	 do it ourself.  */
-      compare_and_swap 
-	(ptr, Thread::THREAD_PARK_PARKED, Thread::THREAD_PARK_RUNNING);
+	 be in state THREAD_PARK_RUNNING.  If we timed out or were
+	 interrupted, we have to do it ourself.  */
+      permit = Thread::THREAD_PARK_RUNNING;
     }
+  pthread_mutex_unlock (&mutex);
 }
 
 static void
Index: libjava/configure
===================================================================
--- libjava/configure	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libjava/configure	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -459,7 +459,7 @@
 #endif"
 
 ac_subdirs_all="$ac_subdirs_all classpath libltdl"
-ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS build build_cpu build_vendor build_os build_libsubdir build_subdir host_subdir target_subdir multi_basedir host host_cpu host_vendor host_os target target_cpu target_vendor target_os target_noncanonical LN_S mkinstalldirs ANTLR_JAR CREATE_GJDOC_TRUE CREATE_GJDOC_FALSE JAVA_MAINTAINER_MODE_TRUE JAVA_MAINTAINER_MODE_FALSE CC ac_ct_CC EXEEXT OBJEXT CXX ac_ct_CXX CFLAGS CXXFLAGS LDFLAGS INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CYGPATH_W PACKAGE VERSION ACLOCAL AUTOCONF AUTOMAKE AUTOHEADER MAKEINFO install_sh STRIP ac_ct_STRIP INSTALL_STRIP_PROGRAM mkdir_p AWK SET_MAKE am__leading_dot AMTAR am__tar am__untar DEPDIR am__include am__quote AMDEP_TRUE AMDEP_FALSE AMDEPBACKSLASH CCDEPMODE am__fastdepCC_TRUE am__fastdepCC_FALSE CXXDEPMODE am__fastdepCXX_TRUE am__fastdepCXX_FALSE AS ac_ct_AS LD ac_ct_LD AR ac_ct_AR RANLIB ac_ct_RANLIB JAR ZIP UNZIP MAINTAINER_MODE_TRUE MAINTAINER_MODE_FALSE MAINT LIBGCJ_CFLAGS LIBGCJ_CXXFLAGS LIBGCJ_JAVAFLAGS LIBGCJ_LD_SYMBOLIC LIBGCJ_LD_SYMBOLIC_FUNCTIONS LIBGCJDEBUG TOOLKIT XLIB_AWT_TRUE XLIB_AWT_FALSE X_AWT_TRUE X_AWT_FALSE GCJ_FOR_ECJX GCJH host_exeext INCLTDL LIBLTDL DIRLTDL LIBTOOL SED EGREP FGREP GREP DUMPBIN ac_ct_DUMPBIN NM OBJDUMP ac_ct_OBJDUMP lt_ECHO DSYMUTIL ac_ct_DSYMUTIL NMEDIT ac_ct_NMEDIT LIPO ac_ct_LIPO OTOOL ac_ct_OTOOL OTOOL64 ac_ct_OTOOL64 CPP CPPFLAGS CXXCPP GCJ GCJFLAGS GCJDEPMODE am__fastdepGCJ_TRUE am__fastdepGCJ_FALSE subdirs TESTSUBDIR_TRUE TESTSUBDIR_FALSE ECJ_BUILD_JAR ECJ_JAR BUILD_ECJ1_TRUE BUILD_ECJ1_FALSE INSTALL_ECJ_JAR_TRUE INSTALL_ECJ_JAR_FALSE JAVA_HOME_SET_TRUE JAVA_HOME_SET_FALSE JAVA_HOME SUPPRESS_LIBGCJ_BC_TRUE SUPPRESS_LIBGCJ_BC_FALSE BUILD_LIBGCJ_REDUCED_REFLECTION_TRUE BUILD_LIBGCJ_REDUCED_REFLECTION_FALSE INTERPRETER INTERPRETER_TRUE INTERPRETER_FALSE LIBFFI LIBFFIINCS PLATFORM USING_WIN32_PLATFORM_TRUE USING_WIN32_PLATFORM_FALSE USING_POSIX_PLATFORM_TRUE USING_POSIX_PLATFORM_FALSE USING_DARWIN_CRT_TRUE USING_DARWIN_CRT_FALSE SYSTEMSPEC ZLIBSPEC ZLIBTESTSPEC X_CFLAGS X_PRE_LIBS X_LIBS X_EXTRA_LIBS extra_ldflags_libjava extra_gij_ldflags extra_ldflags LIBSTDCXXSPEC LIBGCJTESTSPEC GCLIBS GCINCS GCDEPS GCSPEC JC1GCSPEC GCTESTSPEC USING_BOEHMGC_TRUE USING_BOEHMGC_FALSE USING_NOGC_TRUE USING_NOGC_FALSE THREADLIBS THREADINCS THREADDEPS THREADSPEC THREADSTARTFILESPEC THREADLDFLAGS THREADCXXFLAGS USING_POSIX_THREADS_TRUE USING_POSIX_THREADS_FALSE USING_WIN32_THREADS_TRUE USING_WIN32_THREADS_FALSE USING_NO_THREADS_TRUE USING_NO_THREADS_FALSE USE_LIBGCJ_BC_TRUE USE_LIBGCJ_BC_FALSE LIBGCJ_SPEC HASH_SYNC_SPEC USING_GCC_TRUE USING_GCC_FALSE LIBICONV LTLIBICONV PKG_CONFIG GTK_CFLAGS GTK_LIBS GLIB_CFLAGS GLIB_LIBS LIBART_CFLAGS LIBART_LIBS CLASSPATH_SEPARATOR ZLIBS SYS_ZLIBS ZINCS DIVIDESPEC CHECKREFSPEC EXCEPTIONSPEC BACKTRACESPEC IEEESPEC NATIVE_TRUE NATIVE_FALSE ENABLE_SHARED_TRUE ENABLE_SHARED_FALSE NEEDS_DATA_START_TRUE NEEDS_DATA_START_FALSE INSTALL_BINARIES_TRUE INSTALL_BINARIES_FALSE GCC_UNWIND_INCLUDE toolexecdir toolexecmainlibdir toolexeclibdir GCJVERSION dbexecdir gcjsubdir gxx_include_dir libstdcxx_incdir PERL SYSDEP_SOURCES ANONVERSCRIPT_TRUE ANONVERSCRIPT_FALSE LD_START_STATIC_SPEC LD_FINISH_STATIC_SPEC here python_mod_dir python_mod_dir_expanded MAKE INSTALL_AOT_RPM_TRUE INSTALL_AOT_RPM_FALSE CREATE_JAVA_HOME_TRUE CREATE_JAVA_HOME_FALSE gcc_suffix JAVA_VERSION BUILD_VERSION JVM_ROOT_DIR JVM_JAR_ROOT_DIR JVM_JAR_DIR JRE_DIR JRE_LNK SDK_LNK SDK_BIN_DIR SDK_LIB_DIR SDK_INCLUDE_DIR JRE_BIN_DIR JRE_LIB_DIR GCJ_BIN_DIR CPU OS LIBDIR LIBOBJS LTLIBOBJS'
+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS build build_cpu build_vendor build_os build_libsubdir build_subdir host_subdir target_subdir multi_basedir host host_cpu host_vendor host_os target target_cpu target_vendor target_os target_noncanonical LN_S mkinstalldirs ANTLR_JAR CREATE_GJDOC_TRUE CREATE_GJDOC_FALSE JAVA_MAINTAINER_MODE_TRUE JAVA_MAINTAINER_MODE_FALSE CC ac_ct_CC EXEEXT OBJEXT CXX ac_ct_CXX CFLAGS CXXFLAGS LDFLAGS INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CYGPATH_W PACKAGE VERSION ACLOCAL AUTOCONF AUTOMAKE AUTOHEADER MAKEINFO install_sh STRIP ac_ct_STRIP INSTALL_STRIP_PROGRAM mkdir_p AWK SET_MAKE am__leading_dot AMTAR am__tar am__untar DEPDIR am__include am__quote AMDEP_TRUE AMDEP_FALSE AMDEPBACKSLASH CCDEPMODE am__fastdepCC_TRUE am__fastdepCC_FALSE CXXDEPMODE am__fastdepCXX_TRUE am__fastdepCXX_FALSE AS ac_ct_AS LD ac_ct_LD AR ac_ct_AR RANLIB ac_ct_RANLIB JAR ZIP UNZIP MAINTAINER_MODE_TRUE MAINTAINER_MODE_FALSE MAINT LIBGCJ_CFLAGS LIBGCJ_CXXFLAGS LIBGCJ_JAVAFLAGS LIBGCJ_LD_SYMBOLIC LIBGCJ_LD_SYMBOLIC_FUNCTIONS LIBGCJDEBUG TOOLKIT XLIB_AWT_TRUE XLIB_AWT_FALSE X_AWT_TRUE X_AWT_FALSE GCJ_FOR_ECJX GCJH host_exeext INCLTDL LIBLTDL DIRLTDL LIBTOOL SED EGREP FGREP GREP DUMPBIN ac_ct_DUMPBIN NM OBJDUMP ac_ct_OBJDUMP lt_ECHO DSYMUTIL ac_ct_DSYMUTIL NMEDIT ac_ct_NMEDIT LIPO ac_ct_LIPO OTOOL ac_ct_OTOOL OTOOL64 ac_ct_OTOOL64 CPP CPPFLAGS CXXCPP GCJ GCJFLAGS GCJDEPMODE am__fastdepGCJ_TRUE am__fastdepGCJ_FALSE subdirs TESTSUBDIR_TRUE TESTSUBDIR_FALSE ECJ_BUILD_JAR ECJ_JAR BUILD_ECJ1_TRUE BUILD_ECJ1_FALSE INSTALL_ECJ_JAR_TRUE INSTALL_ECJ_JAR_FALSE JAVA_HOME_SET_TRUE JAVA_HOME_SET_FALSE JAVA_HOME SUPPRESS_LIBGCJ_BC_TRUE SUPPRESS_LIBGCJ_BC_FALSE BUILD_LIBGCJ_REDUCED_REFLECTION_TRUE BUILD_LIBGCJ_REDUCED_REFLECTION_FALSE INTERPRETER INTERPRETER_TRUE INTERPRETER_FALSE LIBFFI LIBFFIINCS PLATFORM USING_WIN32_PLATFORM_TRUE USING_WIN32_PLATFORM_FALSE USING_POSIX_PLATFORM_TRUE USING_POSIX_PLATFORM_FALSE USING_DARWIN_CRT_TRUE USING_DARWIN_CRT_FALSE SYSTEMSPEC ZLIBSPEC ZLIBTESTSPEC X_CFLAGS X_PRE_LIBS X_LIBS X_EXTRA_LIBS extra_ldflags_libjava extra_ldflags LIBSTDCXXSPEC LIBGCJTESTSPEC GCLIBS GCINCS GCDEPS GCSPEC JC1GCSPEC GCTESTSPEC USING_BOEHMGC_TRUE USING_BOEHMGC_FALSE USING_NOGC_TRUE USING_NOGC_FALSE THREADLIBS THREADINCS THREADDEPS THREADSPEC THREADSTARTFILESPEC THREADLDFLAGS THREADCXXFLAGS USING_POSIX_THREADS_TRUE USING_POSIX_THREADS_FALSE USING_WIN32_THREADS_TRUE USING_WIN32_THREADS_FALSE USING_NO_THREADS_TRUE USING_NO_THREADS_FALSE USE_LIBGCJ_BC_TRUE USE_LIBGCJ_BC_FALSE LIBGCJ_SPEC HASH_SYNC_SPEC USING_GCC_TRUE USING_GCC_FALSE LIBICONV LTLIBICONV PKG_CONFIG GTK_CFLAGS GTK_LIBS GLIB_CFLAGS GLIB_LIBS LIBART_CFLAGS LIBART_LIBS CLASSPATH_SEPARATOR ZLIBS SYS_ZLIBS ZINCS DIVIDESPEC CHECKREFSPEC EXCEPTIONSPEC BACKTRACESPEC IEEESPEC NATIVE_TRUE NATIVE_FALSE ENABLE_SHARED_TRUE ENABLE_SHARED_FALSE NEEDS_DATA_START_TRUE NEEDS_DATA_START_FALSE INSTALL_BINARIES_TRUE INSTALL_BINARIES_FALSE GCC_UNWIND_INCLUDE toolexecdir toolexecmainlibdir toolexeclibdir GCJVERSION dbexecdir gcjsubdir gxx_include_dir libstdcxx_incdir PERL SYSDEP_SOURCES ANONVERSCRIPT_TRUE ANONVERSCRIPT_FALSE LD_START_STATIC_SPEC LD_FINISH_STATIC_SPEC here python_mod_dir python_mod_dir_expanded MAKE INSTALL_AOT_RPM_TRUE INSTALL_AOT_RPM_FALSE CREATE_JAVA_HOME_TRUE CREATE_JAVA_HOME_FALSE gcc_suffix JAVA_VERSION BUILD_VERSION JVM_ROOT_DIR JVM_JAR_ROOT_DIR JVM_JAR_DIR JRE_DIR JRE_LNK SDK_LNK SDK_BIN_DIR SDK_LIB_DIR SDK_INCLUDE_DIR JRE_BIN_DIR JRE_LIB_DIR GCJ_BIN_DIR CPU OS LIBDIR LIBOBJS LTLIBOBJS'
 ac_subst_files=''
 ac_pwd=`pwd`
 
@@ -19154,6 +19154,9 @@
         SYSTEMSPEC="-lunicows $SYSTEMSPEC"
       fi
     ;;
+    *-*-darwin[912]*)
+      SYSTEMSPEC="-allow_stack_execute"
+    ;;
     *)
       SYSTEMSPEC=
     ;;
@@ -20654,9 +20657,6 @@
     # on Darwin -single_module speeds up loading of the dynamic libraries.
     extra_ldflags_libjava=-Wl,-single_module
     ;;
-*-*-darwin[912]*)
-    extra_gij_ldflags=-Wl,-allow_stack_execute
-    ;;
 arm*linux*eabi)
     # Some of the ARM unwinder code is actually in libstdc++.  We
     # could in principle replicate it in libgcj, but it's better to
@@ -20672,7 +20672,6 @@
 
 
 
-
 # Allow the GC to be disabled.  Can be useful when debugging.
 echo "$as_me:$LINENO: checking for garbage collector to use" >&5
 echo $ECHO_N "checking for garbage collector to use... $ECHO_C" >&6
@@ -29838,7 +29837,6 @@
 s,@X_LIBS@,$X_LIBS,;t t
 s,@X_EXTRA_LIBS@,$X_EXTRA_LIBS,;t t
 s,@extra_ldflags_libjava@,$extra_ldflags_libjava,;t t
-s,@extra_gij_ldflags@,$extra_gij_ldflags,;t t
 s,@extra_ldflags@,$extra_ldflags,;t t
 s,@LIBSTDCXXSPEC@,$LIBSTDCXXSPEC,;t t
 s,@LIBGCJTESTSPEC@,$LIBGCJTESTSPEC,;t t
Index: libjava/gnu/gcj/convert/Convert.java
===================================================================
--- libjava/gnu/gcj/convert/Convert.java	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libjava/gnu/gcj/convert/Convert.java	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,4 +1,4 @@
-/* Copyright (C) 1999, 2002, 2005, 2006, 2007, 2008, 2009
+/* Copyright (C) 1999, 2002, 2005, 2006, 2007, 2008, 2009, 2010
    Free Software Foundation
 
    This file is part of libgcj.
@@ -46,7 +46,7 @@
 		       + ") "
 		       + System.getProperty("java.vm.version"));
     System.out.println();
-    System.out.println("Copyright (C) 2009 Free Software Foundation, Inc.");
+    System.out.println("Copyright (C) 2010 Free Software Foundation, Inc.");
     System.out.println("This is free software; see the source for copying conditions.  There is NO");
     System.out.println("warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.");
     System.exit(0);
Index: libjava/gnu/gcj/tools/gcj_dbtool/Main.java
===================================================================
--- libjava/gnu/gcj/tools/gcj_dbtool/Main.java	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libjava/gnu/gcj/tools/gcj_dbtool/Main.java	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,4 +1,5 @@
-/* Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation
+/* Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010
+   Free Software Foundation
 
    This file is part of libgcj.
 
@@ -46,7 +47,7 @@
 			   + ") "
 			   + System.getProperty("java.vm.version"));
 	System.out.println();
-	System.out.println("Copyright 2009 Free Software Foundation, Inc.");
+	System.out.println("Copyright 2010 Free Software Foundation, Inc.");
 	System.out.println("This is free software; see the source for copying conditions.  There is NO");
 	System.out.println("warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.");
 	return;
Index: libjava/gcj/Makefile.in
===================================================================
--- libjava/gcj/Makefile.in	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libjava/gcj/Makefile.in	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -334,7 +334,6 @@
 datadir = @datadir@
 dbexecdir = @dbexecdir@
 exec_prefix = @exec_prefix@
-extra_gij_ldflags = @extra_gij_ldflags@
 extra_ldflags = @extra_ldflags@
 extra_ldflags_libjava = @extra_ldflags_libjava@
 gcc_suffix = @gcc_suffix@
Index: libjava/Makefile.am
===================================================================
--- libjava/Makefile.am	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libjava/Makefile.am	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -865,8 +865,7 @@
 ## need this because we are explicitly using libtool to link using the
 ## `.la' file.
 gij_LDFLAGS = -rpath $(dbexecdir) -rpath $(toolexeclibdir) \
-	-shared-libgcc $(THREADLDFLAGS) $(extra_ldflags) \
-	$(extra_gij_ldflags) 
+	-shared-libgcc $(THREADLDFLAGS) $(extra_ldflags)
 gij_LINK = $(GCJLINK)
 ## See jv_convert_LDADD.
 gij_LDADD = -L$(here)/.libs libgij.la
Index: libcpp/directives.c
===================================================================
--- libcpp/directives.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libcpp/directives.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -125,6 +125,8 @@
 static cpp_hashnode *parse_assertion (cpp_reader *, struct answer **, int);
 static struct answer ** find_answer (cpp_hashnode *, const struct answer *);
 static void handle_assertion (cpp_reader *, const char *, int);
+static void do_pragma_push_macro (cpp_reader *);
+static void do_pragma_pop_macro (cpp_reader *);
 
 /* This is the table of directive handlers.  It is ordered by
    frequency of occurrence; the numbers at the end are directive
@@ -1226,6 +1228,8 @@
 {
   /* Pragmas in the global namespace.  */
   register_pragma_internal (pfile, 0, "once", do_pragma_once);
+  register_pragma_internal (pfile, 0, "push_macro", do_pragma_push_macro);
+  register_pragma_internal (pfile, 0, "pop_macro", do_pragma_pop_macro);
 
   /* New GCC-specific pragmas should be put in the GCC namespace.  */
   register_pragma_internal (pfile, "GCC", "poison", do_pragma_poison);
@@ -1405,6 +1409,96 @@
   _cpp_mark_file_once_only (pfile, pfile->buffer->file);
 }
 
+/* Handle #pragma push_macro(STRING).  */
+static void
+do_pragma_push_macro (cpp_reader *pfile)
+{
+  char *macroname, *dest;
+  const char *limit, *src;
+  const cpp_token *txt;
+  struct def_pragma_macro *c;
+
+  txt = get__Pragma_string (pfile);
+  if (!txt)
+    {
+      source_location src_loc = pfile->cur_token[-1].src_loc;
+      cpp_error_with_line (pfile, CPP_DL_ERROR, src_loc, 0,
+		 "invalid #pragma push_macro directive");
+      check_eol (pfile);
+      skip_rest_of_line (pfile);
+      return;
+    }
+  dest = macroname = (char *) alloca (txt->val.str.len + 2);
+  src = (const char *) (txt->val.str.text + 1 + (txt->val.str.text[0] == 'L'));
+  limit = (const char *) (txt->val.str.text + txt->val.str.len - 1);
+  while (src < limit)
+    {
+      /* We know there is a character following the backslash.  */
+      if (*src == '\\' && (src[1] == '\\' || src[1] == '"'))
+	src++;
+      *dest++ = *src++;
+    }
+  *dest = 0;
+  check_eol (pfile);
+  skip_rest_of_line (pfile);
+  c = XNEW (struct def_pragma_macro);
+  c->name = XNEWVAR (char, strlen (macroname) + 1);
+  strcpy (c->name, macroname);
+  c->next = pfile->pushed_macros;
+  c->value = cpp_push_definition (pfile, c->name);
+  pfile->pushed_macros = c;
+}
+
+/* Handle #pragma pop_macro(STRING).  */
+static void
+do_pragma_pop_macro (cpp_reader *pfile)
+{
+  char *macroname, *dest;
+  const char *limit, *src;
+  const cpp_token *txt;
+  struct def_pragma_macro *l = NULL, *c = pfile->pushed_macros;
+  txt = get__Pragma_string (pfile);
+  if (!txt)
+    {
+      source_location src_loc = pfile->cur_token[-1].src_loc;
+      cpp_error_with_line (pfile, CPP_DL_ERROR, src_loc, 0,
+		 "invalid #pragma pop_macro directive");
+      check_eol (pfile);
+      skip_rest_of_line (pfile);
+      return;
+    }
+  dest = macroname = (char *) alloca (txt->val.str.len + 2);
+  src = (const char *) (txt->val.str.text + 1 + (txt->val.str.text[0] == 'L'));
+  limit = (const char *) (txt->val.str.text + txt->val.str.len - 1);
+  while (src < limit)
+    {
+      /* We know there is a character following the backslash.  */
+      if (*src == '\\' && (src[1] == '\\' || src[1] == '"'))
+	src++;
+      *dest++ = *src++;
+    }
+  *dest = 0;
+  check_eol (pfile);
+  skip_rest_of_line (pfile);
+
+  while (c != NULL)
+    {
+      if (!strcmp (c->name, macroname))
+	{
+	  if (!l)
+	    pfile->pushed_macros = c->next;
+	  else
+	    l->next = c->next;
+	  cpp_pop_definition (pfile, c->name, c->value);
+	  free (c->name);
+	  free (c);
+	  break;
+	}
+      l = c;
+      c = c->next;
+    }
+}
+
 /* Handle #pragma GCC poison, to poison one or more identifiers so
    that the lexer produces a hard error for each subsequent usage.  */
 static void
@@ -2200,28 +2294,11 @@
   run_directive (pfile, T_UNDEF, buf, len);
 }
 
-/* Like lex_macro_node, but read the input from STR.  */
-static cpp_hashnode *
-lex_macro_node_from_str (cpp_reader *pfile, const char *str)
-{
-  size_t len = strlen (str);
-  uchar *buf = (uchar *) alloca (len + 1);
-  cpp_hashnode *node;
-
-  memcpy (buf, str, len);
-  buf[len] = '\n';
-  cpp_push_buffer (pfile, buf, len, true);
-  node = lex_macro_node (pfile, true);
-  _cpp_pop_buffer (pfile);
-
-  return node;
-}
-
 /* If STR is a defined macro, return its definition node, else return NULL.  */
 cpp_macro *
 cpp_push_definition (cpp_reader *pfile, const char *str)
 {
-  cpp_hashnode *node = lex_macro_node_from_str (pfile, str);
+  cpp_hashnode *node = _cpp_lex_identifier (pfile, str);
   if (node && node->type == NT_MACRO)
     return node->value.macro;
   else
@@ -2233,7 +2310,7 @@
 void
 cpp_pop_definition (cpp_reader *pfile, const char *str, cpp_macro *dfn)
 {
-  cpp_hashnode *node = lex_macro_node_from_str (pfile, str);
+  cpp_hashnode *node = _cpp_lex_identifier (pfile, str);
   if (node == NULL)
     return;
 
Index: libcpp/init.c
===================================================================
--- libcpp/init.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libcpp/init.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,6 +1,6 @@
 /* CPP Library.
    Copyright (C) 1986, 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2009
+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2009, 2010
    Free Software Foundation, Inc.
    Contributed by Per Bothner, 1994-95.
    Based on CCCP program by Paul Rubin, June 1986
@@ -216,6 +216,9 @@
   pfile->a_buff = _cpp_get_buff (pfile, 0);
   pfile->u_buff = _cpp_get_buff (pfile, 0);
 
+  /* Initialize table for push_macro/pop_macro.  */
+  pfile->pushed_macros = 0;
+
   /* The expression parser stack.  */
   _cpp_expand_op_stack (pfile);
 
@@ -245,6 +248,7 @@
 cpp_destroy (cpp_reader *pfile)
 {
   cpp_context *context, *contextn;
+  struct def_pragma_macro *pmacro;
   tokenrun *run, *runn;
   int i;
 
@@ -296,6 +300,17 @@
 
       free (pfile->comments.entries);
     }
+  if (pfile->pushed_macros)
+    {
+      do
+	{
+	  pmacro = pfile->pushed_macros;
+	  pfile->pushed_macros = pmacro->next;
+	  free (pmacro->name);
+	  free (pmacro);
+	}
+      while (pfile->pushed_macros);
+    }
 
   free (pfile);
 }
@@ -555,9 +570,9 @@
       pfile->state.in_directive = 0;
 
       /* If it's a #line directive, handle it.  */
-      if (token1->type == CPP_NUMBER)
+      if (token1->type == CPP_NUMBER
+	  && _cpp_handle_directive (pfile, token->flags & PREV_WHITE))
 	{
-	  _cpp_handle_directive (pfile, token->flags & PREV_WHITE);
 	  read_original_directory (pfile);
 	  return;
 	}
Index: libcpp/ChangeLog
===================================================================
--- libcpp/ChangeLog	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libcpp/ChangeLog	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,3 +1,36 @@
+2010-02-11  Jakub Jelinek  <jakub@redhat.com>
+
+	* init.c (read_original_filename): Don't call read_original_directory
+	if _cpp_handle_directive returns 0.
+
+2010-01-21  Release Manager
+
+	* GCC 4.4.3 released.
+
+2009-11-11  Kai Tietz  <kai.tietz@onevision.com>
+
+	Backported from trunk
+	* directives.c (do_pragma_push_macro): New pragma handler.
+	(do_pragma_pop_macro): Likewise.
+	(_cpp_init_internal_pragmas): Add push_macro and
+	pop_macro handler to internal pragmas.
+	(lex_macro_node_from_str): Removed.
+	(cpp_push_definition): Replace lex_macro_node_from_str
+	by _cpp_lex_identifier.
+	(cpp_pop_definition): Likewise.
+	* internal.h (_cpp_lex_identifier): New prototype.
+	(def_pragma_macro): New structure.
+	(cpp_reader): New member pushed_macros.
+	* lex.c (_cpp_lex_identifier): New function.
+	(lex_identifier_intern): New function.
+	* init.c (cpp_create_reader): Initialize pushed_macros
+	member.
+	(cpp_destroy): Free elements in pushed_macros member.
+	* pch.c (_cpp_save_pushed_macros): New function.
+	(_cpp_restore_pushed_macros): Likewise.
+	(_cpp_restore_pushed_macros): Use _cpp_save_pushed_macros.
+	(cpp_read_state): Use _cpp_restore_pushed_macros.
+
 2009-10-15  Release Manager
 
 	* GCC 4.4.2 released.
Index: libcpp/pch.c
===================================================================
--- libcpp/pch.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libcpp/pch.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -33,6 +33,8 @@
 static int collect_ht_nodes (cpp_reader *, cpp_hashnode *, void *);
 static int write_defs (cpp_reader *, cpp_hashnode *, void *);
 static int save_macros (cpp_reader *, cpp_hashnode *, void *);
+static int _cpp_save_pushed_macros (cpp_reader *, FILE *);
+static int _cpp_restore_pushed_macros (cpp_reader *, FILE *);
 
 /* This structure represents a macro definition on disk.  */
 struct macrodef_struct
@@ -378,10 +380,141 @@
       return -1;
     }
 
+  /* Write saved macros.  */
+  if (! _cpp_save_pushed_macros (r, f))
+    {
+      cpp_errno (r, CPP_DL_ERROR, "while writing precompiled header");
+      return -1;
+    }
+
   return 0;
 }
 
+static int
+_cpp_restore_pushed_macros (cpp_reader *r, FILE *f)
+{
+  size_t count_saved = 0;
+  size_t i;
+  struct def_pragma_macro *p;
+  size_t nlen;
+  cpp_hashnode *h = NULL;
+  cpp_macro *m;
+  uchar *defn;
+  size_t defnlen;
 
+  if (fread (&count_saved, sizeof (count_saved), 1, f) != 1)
+    return 0;
+  if (! count_saved)
+    return 1;
+  for (i = 0; i < count_saved; i++)
+    {
+      if (fread (&nlen, sizeof (nlen), 1, f) != 1)
+	return 0;
+      p = XNEW (struct def_pragma_macro);
+      p->name = XNEWVAR (char, nlen + 1);
+      p->name[nlen] = 0;
+      if (fread (p->name, nlen, 1, f) != 1)
+	return 0;
+      /* Save old state.  */
+      m = cpp_push_definition (r, p->name);
+      if (fread (&defnlen, sizeof (defnlen), 1, f) != 1)
+	return 0;
+      defn = XNEWVAR (uchar, defnlen + 2);
+      defn[defnlen] = '\n';
+      defn[defnlen + 1] = 0;
+
+      if (fread (defn, defnlen, 1, f) != 1)
+	return 0;
+      cpp_pop_definition (r, p->name, NULL);
+      {
+	size_t namelen;
+	uchar *dn;
+
+	namelen = ustrcspn (defn, "( \n");
+	h = cpp_lookup (r, defn, namelen);
+	dn = defn + namelen;
+
+	h->type = NT_VOID;
+	h->flags &= ~(NODE_POISONED|NODE_BUILTIN|NODE_DISABLED|NODE_USED);
+	if (cpp_push_buffer (r, dn, ustrchr (dn, '\n') - dn, true)
+	    != NULL)
+	  {
+	    _cpp_clean_line (r);
+	    if (!_cpp_create_definition (r, h))
+	      abort ();
+	    _cpp_pop_buffer (r);
+	  }
+	else
+	  abort ();
+      }
+      p->value = cpp_push_definition (r, p->name);
+
+      free (defn);
+      p->next = r->pushed_macros;
+      r->pushed_macros = p;
+      /* Restore current state.  */
+      cpp_pop_definition (r, p->name, m);
+    }
+  return 1;
+}
+
+static int
+_cpp_save_pushed_macros (cpp_reader *r, FILE *f)
+{
+  size_t count_saved = 0;
+  size_t i;
+  struct def_pragma_macro *p,**pp;
+  cpp_hashnode *node;
+  cpp_macro *m;
+  size_t defnlen;
+  const uchar *defn;
+
+  /* Get count. */
+  p = r->pushed_macros;
+  while (p != NULL)
+    {
+      count_saved++;
+      p = p->next;
+    }
+  if (fwrite (&count_saved, sizeof (count_saved), 1, f) != 1)
+    return 0;
+  if (!count_saved)
+    return 1;
+
+  pp = (struct def_pragma_macro **) alloca (sizeof (struct def_pragma_macro *)
+					    * count_saved);
+  /* Store them in reverse order.  */
+  p = r->pushed_macros;
+  i = count_saved;
+  while (p != NULL)
+    {
+      --i;
+      pp[i] = p;
+      p = p->next;
+    }
+  for (i = 0; i < count_saved; i++)
+    {
+      /* Save old state.  */
+      m = cpp_push_definition (r, pp[i]->name);
+      /* Set temporary macro name to saved state.  */
+      cpp_pop_definition (r, pp[i]->name, pp[i]->value);
+      node = _cpp_lex_identifier (r, pp[i]->name);
+      defnlen = strlen (pp[i]->name);
+      if (fwrite (&defnlen, sizeof (size_t), 1, f) != 1
+	  || fwrite (pp[i]->name, defnlen, 1, f) != 1)
+	return 0;
+      defn = cpp_macro_definition (r, node);
+      defnlen = ustrlen (defn);
+      if (fwrite (&defnlen, sizeof (size_t), 1, f) != 1
+	  || fwrite (defn, defnlen, 1, f) != 1)
+	return 0;
+      /* Restore current state.  */
+      cpp_pop_definition (r, pp[i]->name, m);
+    }
+  return 1;
+}
+
+
 /* Data structure to transform hash table nodes into a sorted list */
 
 struct ht_node_list
@@ -752,6 +885,9 @@
   if (!r->counter)
     r->counter = counter;
 
+  /* Read pushed macros. */
+  if (! _cpp_restore_pushed_macros (r, f))
+    goto error;
   return 0;
 
  error:
Index: libcpp/internal.h
===================================================================
--- libcpp/internal.h	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libcpp/internal.h	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -305,6 +305,16 @@
   struct cset_converter input_cset_desc;
 };
 
+/* The list of saved macros by push_macro pragma.  */
+struct def_pragma_macro {
+  /* Chain element to previous saved macro.  */
+  struct def_pragma_macro *next;
+  /* Name of the macro.  */
+  char *name;
+  /* The stored macro content.  */
+  cpp_macro *value;
+};
+
 /* A cpp_reader encapsulates the "state" of a pre-processor run.
    Applying cpp_get_token repeatedly yields a stream of pre-processor
    tokens.  Usually, there is only one cpp_reader object active.  */
@@ -474,6 +484,9 @@
 
   /* Table of comments, when state.save_comments is true.  */
   cpp_comment_table comments;
+
+  /* List of saved macros by push_macro.  */
+  struct def_pragma_macro *pushed_macros;
 };
 
 /* Character classes.  Based on the more primitive macros in safe-ctype.h.
@@ -574,6 +587,7 @@
 extern cpp_token *_cpp_lex_direct (cpp_reader *);
 extern int _cpp_equiv_tokens (const cpp_token *, const cpp_token *);
 extern void _cpp_init_tokenrun (tokenrun *, unsigned int);
+extern cpp_hashnode *_cpp_lex_identifier (cpp_reader *, const char *);
 
 /* In init.c.  */
 extern void _cpp_maybe_push_include_file (cpp_reader *);
Index: libcpp/lex.c
===================================================================
--- libcpp/lex.c	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libcpp/lex.c	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -504,6 +504,57 @@
   return false;
 }
 
+/* Helper function to get the cpp_hashnode of the identifier BASE.  */
+static cpp_hashnode *
+lex_identifier_intern (cpp_reader *pfile, const uchar *base)
+{
+  cpp_hashnode *result;
+  const uchar *cur;
+  unsigned int len;
+  unsigned int hash = HT_HASHSTEP (0, *base);
+
+  cur = base + 1;
+  while (ISIDNUM (*cur))
+    {
+      hash = HT_HASHSTEP (hash, *cur);
+      cur++;
+    }
+  len = cur - base;
+  hash = HT_HASHFINISH (hash, len);
+  result = CPP_HASHNODE (ht_lookup_with_hash (pfile->hash_table,
+					      base, len, hash, HT_ALLOC));
+
+  /* Rarely, identifiers require diagnostics when lexed.  */
+  if (__builtin_expect ((result->flags & NODE_DIAGNOSTIC)
+			&& !pfile->state.skipping, 0))
+    {
+      /* It is allowed to poison the same identifier twice.  */
+      if ((result->flags & NODE_POISONED) && !pfile->state.poisoned_ok)
+	cpp_error (pfile, CPP_DL_ERROR, "attempt to use poisoned \"%s\"",
+		   NODE_NAME (result));
+
+      /* Constraint 6.10.3.5: __VA_ARGS__ should only appear in the
+	 replacement list of a variadic macro.  */
+      if (result == pfile->spec_nodes.n__VA_ARGS__
+	  && !pfile->state.va_args_ok)
+	cpp_error (pfile, CPP_DL_PEDWARN,
+		   "__VA_ARGS__ can only appear in the expansion"
+		   " of a C99 variadic macro");
+    }
+
+  return result;
+}
+
+/* Get the cpp_hashnode of an identifier specified by NAME in
+   the current cpp_reader object.  If none is found, NULL is returned.  */
+cpp_hashnode *
+_cpp_lex_identifier (cpp_reader *pfile, const char *name)
+{
+  cpp_hashnode *result;
+  result = lex_identifier_intern (pfile, (uchar *) name);
+  return result;
+}
+
 /* Lex an identifier starting at BUFFER->CUR - 1.  */
 static cpp_hashnode *
 lex_identifier (cpp_reader *pfile, const uchar *base, bool starts_ucn,
Index: libcpp/po/ChangeLog
===================================================================
--- libcpp/po/ChangeLog	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ libcpp/po/ChangeLog	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,3 +1,7 @@
+2010-01-21  Release Manager
+
+	* GCC 4.4.3 released.
+
 2009-10-15  Release Manager
 
 	* GCC 4.4.2 released.
Index: gnattools/ChangeLog
===================================================================
--- gnattools/ChangeLog	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ gnattools/ChangeLog	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,3 +1,7 @@
+2010-01-21  Release Manager
+
+	* GCC 4.4.3 released.
+
 2009-10-15  Release Manager
 
 	* GCC 4.4.2 released.
Index: maintainer-scripts/ChangeLog
===================================================================
--- maintainer-scripts/ChangeLog	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ maintainer-scripts/ChangeLog	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,3 +1,7 @@
+2010-01-21  Release Manager
+
+	* GCC 4.4.3 released.
+
 2009-10-15  Release Manager
 
 	* GCC 4.4.2 released.
Index: fixincludes/ChangeLog
===================================================================
--- fixincludes/ChangeLog	(.../tags/gcc_4_4_2_release)	(wersja 157390)
+++ fixincludes/ChangeLog	(.../branches/gcc-4_4-branch)	(wersja 157390)
@@ -1,3 +1,7 @@
+2010-01-21  Release Manager
+
+	* GCC 4.4.3 released.
+
 2009-10-15  Release Manager
 
 	* GCC 4.4.2 released.

Zmiany atrybutów dla: .
___________________________________________________________________
Dodane: svn:mergeinfo
   Połączono zmiany /trunk:r155835,156042

