Index: libgomp/configure.tgt
===================================================================
--- libgomp/configure.tgt	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ libgomp/configure.tgt	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -125,6 +125,10 @@
 	config_path="bsd posix"
 	;;
 
+  mips-sgi-irix6*)
+	# Need to link with -lpthread so libgomp.so is self-contained.
+	XLDFLAGS="${XLDFLAGS} -lpthread"
+	;;
   *)
 	;;
 
Index: libgomp/ChangeLog
===================================================================
--- libgomp/ChangeLog	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ libgomp/ChangeLog	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -1,3 +1,18 @@
+2011-01-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline
+	2010-12-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/46874
+	* libgomp.fortran/allocatable6.f90: New test.
+
+2010-12-17  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	Backport from mainline:
+	2010-12-01  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* configure.tgt (mips-sgi-irix6*): Add -lpthread to XLDFLAGS.
+
 2010-12-16  Release Manager
 
 	* GCC 4.5.2 released.
Index: libgomp/testsuite/libgomp.fortran/allocatable6.f90
===================================================================
--- libgomp/testsuite/libgomp.fortran/allocatable6.f90	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ libgomp/testsuite/libgomp.fortran/allocatable6.f90	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -0,0 +1,45 @@
+! PR fortran/46874
+! { dg-do run }
+
+  interface
+    subroutine sub (a, b, c, d, n)
+      integer :: n
+      integer, allocatable :: a(:), b(:), c(:), d(:)
+    end subroutine
+  end interface
+
+  integer, allocatable :: a(:), b(:), c(:), d(:)
+  integer :: i, j
+  allocate (a(50), b(50), c(50), d(50))
+  do i = 1, 50
+    a(i) = 2 + modulo (i, 7)
+    b(i) = 179 - modulo (i, 11)
+  end do
+  c = 0
+  d = 2147483647
+  call sub (a, b, c, d, 50)
+  do i = 1, 50
+    j = 0
+    if (i .eq. 3) then
+      j = 8
+    else if (i .gt. 1 .and. i .lt. 9) then
+      j = 7
+    end if
+    if (c(i) .ne. j) call abort
+    j = 179 - modulo (i, 11)
+    if (i .gt. 1 .and. i .lt. 9) j = i
+    if (d(i) .ne. j) call abort
+  end do
+  deallocate (a, b, c, d)
+end
+
+subroutine sub (a, b, c, d, n)
+  integer :: n
+  integer, allocatable :: a(:), b(:), c(:), d(:)
+!$omp parallel do shared(a, b) reduction(+:c) reduction(min:d)
+  do i = 1, n
+    c(a(i)) = c(a(i)) + 1
+    d(i) = min(d(i), b(i))
+    d(a(i)) = min(d(a(i)), a(i))
+  end do
+end
Index: gcc/tree-ssa-loop-im.c
===================================================================
--- gcc/tree-ssa-loop-im.c	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/tree-ssa-loop-im.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -2139,7 +2139,7 @@
   edge ex;
 
   for (i = 0; VEC_iterate (edge, exits, i, ex); i++)
-    if (ex->flags & EDGE_ABNORMAL)
+    if (ex->flags & (EDGE_ABNORMAL | EDGE_EH))
       return false;
 
   return true;
Index: gcc/tree-loop-distribution.c
===================================================================
--- gcc/tree-loop-distribution.c	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/tree-loop-distribution.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -251,7 +251,7 @@
 
 /* Generate a call to memset.  Return true when the operation succeeded.  */
 
-static bool
+static void
 generate_memset_zero (gimple stmt, tree op0, tree nb_iter,
 		      gimple_stmt_iterator bsi)
 {
@@ -265,45 +265,27 @@
 
   DR_STMT (dr) = stmt;
   DR_REF (dr) = op0;
-  if (!dr_analyze_innermost (dr))
-    goto end;
+  res = dr_analyze_innermost (dr);
+  gcc_assert (res && stride_of_unit_type_p (DR_STEP (dr), TREE_TYPE (op0)));
 
-  /* Test for a positive stride, iterating over every element.  */
-  if (integer_zerop (size_binop (MINUS_EXPR,
-				 fold_convert (sizetype, DR_STEP (dr)),
-				 TYPE_SIZE_UNIT (TREE_TYPE (op0)))))
-    {
-      addr_base = fold_convert_loc (loc, sizetype,
-				    size_binop_loc (loc, PLUS_EXPR,
-						    DR_OFFSET (dr),
-						    DR_INIT (dr)));
-      addr_base = fold_build2_loc (loc, POINTER_PLUS_EXPR,
-				   TREE_TYPE (DR_BASE_ADDRESS (dr)),
-				   DR_BASE_ADDRESS (dr), addr_base);
+  nb_bytes = build_size_arg_loc (loc, nb_iter, op0, &stmt_list);
+  addr_base = size_binop_loc (loc, PLUS_EXPR, DR_OFFSET (dr), DR_INIT (dr));
+  addr_base = fold_convert_loc (loc, sizetype, addr_base);
 
-      nb_bytes = build_size_arg_loc (loc, nb_iter, op0, &stmt_list);
-    }
-
   /* Test for a negative stride, iterating over every element.  */
-  else if (integer_zerop (size_binop (PLUS_EXPR,
-				      TYPE_SIZE_UNIT (TREE_TYPE (op0)),
-				      fold_convert (sizetype, DR_STEP (dr)))))
+  if (integer_zerop (size_binop (PLUS_EXPR,
+				 TYPE_SIZE_UNIT (TREE_TYPE (op0)),
+				 fold_convert (sizetype, DR_STEP (dr)))))
     {
-      nb_bytes = build_size_arg_loc (loc, nb_iter, op0, &stmt_list);
-
-      addr_base = size_binop_loc (loc, PLUS_EXPR, DR_OFFSET (dr), DR_INIT (dr));
-      addr_base = fold_convert_loc (loc, sizetype, addr_base);
       addr_base = size_binop_loc (loc, MINUS_EXPR, addr_base,
 				  fold_convert_loc (loc, sizetype, nb_bytes));
       addr_base = size_binop_loc (loc, PLUS_EXPR, addr_base,
 				  TYPE_SIZE_UNIT (TREE_TYPE (op0)));
-      addr_base = fold_build2_loc (loc, POINTER_PLUS_EXPR,
-				   TREE_TYPE (DR_BASE_ADDRESS (dr)),
-				   DR_BASE_ADDRESS (dr), addr_base);
     }
-  else
-    goto end;
 
+  addr_base = fold_build2_loc (loc, POINTER_PLUS_EXPR,
+			       TREE_TYPE (DR_BASE_ADDRESS (dr)),
+			       DR_BASE_ADDRESS (dr), addr_base);
   mem = force_gimple_operand (addr_base, &stmts, true, NULL);
   gimple_seq_add_seq (&stmt_list, stmts);
 
@@ -311,14 +293,11 @@
   fn_call = gimple_build_call (fn, 3, mem, integer_zero_node, nb_bytes);
   gimple_seq_add_stmt (&stmt_list, fn_call);
   gsi_insert_seq_after (&bsi, stmt_list, GSI_CONTINUE_LINKING);
-  res = true;
 
   if (dump_file && (dump_flags & TDF_DETAILS))
     fprintf (dump_file, "generated memset zero\n");
 
- end:
   free_data_ref (dr);
-  return res;
 }
 
 /* Tries to generate a builtin function for the instructions of LOOP
@@ -332,7 +311,6 @@
   unsigned i, x = 0;
   basic_block *bbs;
   gimple write = NULL;
-  tree op0, op1;
   gimple_stmt_iterator bsi;
   tree nb_iter = number_of_exit_cond_executions (loop);
 
@@ -368,26 +346,17 @@
 	}
     }
 
-  if (!write)
+  if (!stmt_with_adjacent_zero_store_dr_p (write))
     goto end;
 
-  op0 = gimple_assign_lhs (write);
-  op1 = gimple_assign_rhs1 (write);
-
-  if (!(TREE_CODE (op0) == ARRAY_REF
-	|| TREE_CODE (op0) == INDIRECT_REF))
-    goto end;
-
   /* The new statements will be placed before LOOP.  */
   bsi = gsi_last_bb (loop_preheader_edge (loop)->src);
+  generate_memset_zero (write, gimple_assign_lhs (write), nb_iter, bsi);
+  res = true;
 
-  if (gimple_assign_rhs_code (write) == INTEGER_CST
-      && (integer_zerop (op1) || real_zerop (op1)))
-    res = generate_memset_zero (write, op0, nb_iter, bsi);
-
   /* If this is the last partition for which we generate code, we have
      to destroy the loop.  */
-  if (res && !copy_p)
+  if (!copy_p)
     {
       unsigned nbbs = loop->num_nodes;
       edge exit = single_exit (loop);
@@ -531,24 +500,6 @@
 static void rdg_flag_vertex_and_dependent (struct graph *, int, bitmap, bitmap,
 					   bitmap, bool *);
 
-/* Flag all the uses of U.  */
-
-static void
-rdg_flag_all_uses (struct graph *rdg, int u, bitmap partition, bitmap loops,
-		   bitmap processed, bool *part_has_writes)
-{
-  struct graph_edge *e;
-
-  for (e = rdg->vertices[u].succ; e; e = e->succ_next)
-    if (!bitmap_bit_p (processed, e->dest))
-      {
-	rdg_flag_vertex_and_dependent (rdg, e->dest, partition, loops,
-				       processed, part_has_writes);
-	rdg_flag_all_uses (rdg, e->dest, partition, loops, processed,
-			   part_has_writes);
-      }
-}
-
 /* Flag the uses of U stopping following the information from
    upstream_mem_writes.  */
 
@@ -720,68 +671,13 @@
     }
 }
 
-/* Flag all the nodes of RDG containing memory accesses that could
-   potentially belong to arrays already accessed in the current
-   PARTITION.  */
-
-static void
-rdg_flag_similar_memory_accesses (struct graph *rdg, bitmap partition,
-				  bitmap loops, bitmap processed,
-				  VEC (int, heap) **other_stores)
-{
-  bool foo;
-  unsigned i, n;
-  int j, k, kk;
-  bitmap_iterator ii;
-  struct graph_edge *e;
-
-  EXECUTE_IF_SET_IN_BITMAP (partition, 0, i, ii)
-    if (RDG_MEM_WRITE_STMT (rdg, i)
-	|| RDG_MEM_READS_STMT (rdg, i))
-      {
-	for (j = 0; j < rdg->n_vertices; j++)
-	  if (!bitmap_bit_p (processed, j)
-	      && (RDG_MEM_WRITE_STMT (rdg, j)
-		  || RDG_MEM_READS_STMT (rdg, j))
-	      && rdg_has_similar_memory_accesses (rdg, i, j))
-	    {
-	      /* Flag first the node J itself, and all the nodes that
-		 are needed to compute J.  */
-	      rdg_flag_vertex_and_dependent (rdg, j, partition, loops,
-					     processed, &foo);
-
-	      /* When J is a read, we want to coalesce in the same
-		 PARTITION all the nodes that are using J: this is
-		 needed for better cache locality.  */
-	      rdg_flag_all_uses (rdg, j, partition, loops, processed, &foo);
-
-	      /* Remove from OTHER_STORES the vertex that we flagged.  */
-	      if (RDG_MEM_WRITE_STMT (rdg, j))
-		for (k = 0; VEC_iterate (int, *other_stores, k, kk); k++)
-		  if (kk == j)
-		    {
-		      VEC_unordered_remove (int, *other_stores, k);
-		      break;
-		    }
-	    }
-
-	/* If the node I has two uses, then keep these together in the
-	   same PARTITION.  */
-	for (n = 0, e = rdg->vertices[i].succ; e; e = e->succ_next, n++);
-
-	if (n > 1)
-	  rdg_flag_all_uses (rdg, i, partition, loops, processed, &foo);
-      }
-}
-
 /* Returns a bitmap in which all the statements needed for computing
    the strongly connected component C of the RDG are flagged, also
    including the loop exit conditions.  */
 
 static bitmap
 build_rdg_partition_for_component (struct graph *rdg, rdgc c,
-				   bool *part_has_writes,
-				   VEC (int, heap) **other_stores)
+				   bool *part_has_writes)
 {
   int i, v;
   bitmap partition = BITMAP_ALLOC (NULL);
@@ -793,13 +689,6 @@
       rdg_flag_vertex_and_dependent (rdg, v, partition, loops, processed,
 				     part_has_writes);
 
-  /* Also iterate on the array of stores not in the starting vertices,
-     and determine those vertices that have some memory affinity with
-     the current nodes in the component: these are stores to the same
-     arrays, i.e. we're taking care of cache locality.  */
-  rdg_flag_similar_memory_accesses (rdg, partition, loops, processed,
-				    other_stores);
-
   rdg_flag_loop_exits (rdg, loops, partition, processed, part_has_writes);
 
   BITMAP_FREE (processed);
@@ -863,6 +752,79 @@
   BITMAP_FREE (saved_components);
 }
 
+/* Returns true when it is possible to generate a builtin pattern for
+   the PARTITION of RDG.  For the moment we detect only the memset
+   zero pattern.  */
+
+static bool
+can_generate_builtin (struct graph *rdg, bitmap partition)
+{
+  unsigned i;
+  bitmap_iterator bi;
+  int nb_reads = 0;
+  int nb_writes = 0;
+  int stores_zero = 0;
+
+  EXECUTE_IF_SET_IN_BITMAP (partition, 0, i, bi)
+    if (RDG_MEM_READS_STMT (rdg, i))
+      nb_reads++;
+    else if (RDG_MEM_WRITE_STMT (rdg, i))
+      {
+	nb_writes++;
+	if (stmt_with_adjacent_zero_store_dr_p (RDG_STMT (rdg, i)))
+	  stores_zero++;
+      }
+
+  return stores_zero == 1 && nb_writes == 1 && nb_reads == 0;
+}
+
+/* Returns true when PARTITION1 and PARTITION2 have similar memory
+   accesses in RDG.  */
+
+static bool
+similar_memory_accesses (struct graph *rdg, bitmap partition1,
+			 bitmap partition2)
+{
+  unsigned i, j;
+  bitmap_iterator bi, bj;
+
+  EXECUTE_IF_SET_IN_BITMAP (partition1, 0, i, bi)
+    if (RDG_MEM_WRITE_STMT (rdg, i)
+	|| RDG_MEM_READS_STMT (rdg, i))
+      EXECUTE_IF_SET_IN_BITMAP (partition2, 0, j, bj)
+	if (RDG_MEM_WRITE_STMT (rdg, j)
+	    || RDG_MEM_READS_STMT (rdg, j))
+	  if (rdg_has_similar_memory_accesses (rdg, i, j))
+	    return true;
+
+  return false;
+}
+
+/* Fuse all the partitions from PARTITIONS that contain similar memory
+   references, i.e., we're taking care of cache locality.  This
+   function does not fuse those partitions that contain patterns that
+   can be code generated with builtins.  */
+
+static void
+fuse_partitions_with_similar_memory_accesses (struct graph *rdg,
+					      VEC (bitmap, heap) **partitions)
+{
+  int p1, p2;
+  bitmap partition1, partition2;
+
+  for (p1 = 0; VEC_iterate (bitmap, *partitions, p1, partition1); p1++)
+    if (!can_generate_builtin (rdg, partition1))
+      for (p2 = 0; VEC_iterate (bitmap, *partitions, p2, partition2); p2++)
+	if (p1 != p2
+	    && !can_generate_builtin (rdg, partition2)
+	    && similar_memory_accesses (rdg, partition1, partition2))
+	  {
+	    bitmap_ior_into (partition1, partition2);
+	    VEC_ordered_remove (bitmap, *partitions, p2);
+	    p2--;
+	  }
+}
+
 /* Aggregate several components into a useful partition that is
    registered in the PARTITIONS vector.  Partitions will be
    distributed in different loops.  */
@@ -885,8 +847,7 @@
       if (bitmap_bit_p (processed, v))
 	continue;
 
-      np = build_rdg_partition_for_component (rdg, x, &part_has_writes,
-					      other_stores);
+      np = build_rdg_partition_for_component (rdg, x, &part_has_writes);
       bitmap_ior_into (partition, np);
       bitmap_ior_into (processed, np);
       BITMAP_FREE (np);
@@ -932,6 +893,8 @@
     VEC_safe_push (bitmap, heap, *partitions, partition);
   else
     BITMAP_FREE (partition);
+
+  fuse_partitions_with_similar_memory_accesses (rdg, partitions);
 }
 
 /* Dump to FILE the PARTITIONS.  */
Index: gcc/DATESTAMP
===================================================================
--- gcc/DATESTAMP	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/DATESTAMP	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -1 +1 @@
-20101216
+20110124
Index: gcc/DEV-PHASE
===================================================================
--- gcc/DEV-PHASE	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/DEV-PHASE	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -0,0 +1 @@
+prerelease
Index: gcc/tree-ssa-sccvn.c
===================================================================
--- gcc/tree-ssa-sccvn.c	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/tree-ssa-sccvn.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -988,6 +988,7 @@
 }
 
 static tree *last_vuse_ptr;
+static vn_lookup_kind vn_walk_kind;
 
 /* Callback for walk_non_aliased_vuses.  Adjusts the vn_reference_t VR_
    with the current VUSE and performs the expression lookup.  */
@@ -1063,6 +1064,7 @@
       size2 = TREE_INT_CST_LOW (gimple_call_arg (def_stmt, 2)) * 8;
       if ((unsigned HOST_WIDE_INT)size2 / 8
 	  == TREE_INT_CST_LOW (gimple_call_arg (def_stmt, 2))
+	  && maxsize2 != -1
 	  && operand_equal_p (base, base2, 0)
 	  && offset2 <= offset
 	  && offset2 + size2 >= offset + maxsize)
@@ -1086,7 +1088,8 @@
       HOST_WIDE_INT offset2, size2, maxsize2;
       base2 = get_ref_base_and_extent (gimple_assign_lhs (def_stmt),
 				       &offset2, &size2, &maxsize2);
-      if (operand_equal_p (base, base2, 0)
+      if (maxsize2 != -1
+	  && operand_equal_p (base, base2, 0)
 	  && offset2 <= offset
 	  && offset2 + size2 >= offset + maxsize)
 	{
@@ -1101,7 +1104,8 @@
 
   /* For aggregate copies translate the reference through them if
      the copy kills ref.  */
-  else if (gimple_assign_single_p (def_stmt)
+  else if (vn_walk_kind == VN_WALKREWRITE
+	   && gimple_assign_single_p (def_stmt)
 	   && (DECL_P (gimple_assign_rhs1 (def_stmt))
 	       || INDIRECT_REF_P (gimple_assign_rhs1 (def_stmt))
 	       || handled_component_p (gimple_assign_rhs1 (def_stmt))))
@@ -1116,7 +1120,8 @@
       /* See if the assignment kills REF.  */
       base2 = get_ref_base_and_extent (gimple_assign_lhs (def_stmt),
 				       &offset2, &size2, &maxsize2);
-      if (!operand_equal_p (base, base2, 0)
+      if (maxsize2 == -1
+	  || !operand_equal_p (base, base2, 0)
 	  || offset2 > offset
 	  || offset2 + size2 < offset + maxsize)
 	return (void *)-1;
@@ -1190,7 +1195,7 @@
 tree
 vn_reference_lookup_pieces (tree vuse, alias_set_type set, tree type,
 			    VEC (vn_reference_op_s, heap) *operands,
-			    vn_reference_t *vnresult, bool maywalk)
+			    vn_reference_t *vnresult, vn_lookup_kind kind)
 {
   struct vn_reference_s vr1;
   vn_reference_t tmp;
@@ -1215,10 +1220,11 @@
   vn_reference_lookup_1 (&vr1, vnresult);
 
   if (!*vnresult
-      && maywalk
+      && kind != VN_NOWALK
       && vr1.vuse)
     {
       ao_ref r;
+      vn_walk_kind = kind;
       if (ao_ref_init_from_vn_reference (&r, set, type, vr1.operands))
 	*vnresult =
 	  (vn_reference_t)walk_non_aliased_vuses (&r, vr1.vuse,
@@ -1241,7 +1247,7 @@
    stored in the hashtable if one exists.  */
 
 tree
-vn_reference_lookup (tree op, tree vuse, bool maywalk,
+vn_reference_lookup (tree op, tree vuse, vn_lookup_kind kind,
 		     vn_reference_t *vnresult)
 {
   VEC (vn_reference_op_s, heap) *operands;
@@ -1256,12 +1262,13 @@
   vr1.set = get_alias_set (op);
   vr1.hashcode = vn_reference_compute_hash (&vr1);
 
-  if (maywalk
+  if (kind != VN_NOWALK
       && vr1.vuse)
     {
       vn_reference_t wvnresult;
       ao_ref r;
       ao_ref_init (&r, op);
+      vn_walk_kind = kind;
       wvnresult =
 	(vn_reference_t)walk_non_aliased_vuses (&r, vr1.vuse,
 						vn_reference_lookup_2,
@@ -1980,14 +1987,14 @@
 
   last_vuse = gimple_vuse (stmt);
   last_vuse_ptr = &last_vuse;
-  result = vn_reference_lookup (op, gimple_vuse (stmt), true, NULL);
+  result = vn_reference_lookup (op, gimple_vuse (stmt), VN_WALKREWRITE, NULL);
   last_vuse_ptr = NULL;
 
   /* If we have a VCE, try looking up its operand as it might be stored in
      a different type.  */
   if (!result && TREE_CODE (op) == VIEW_CONVERT_EXPR)
     result = vn_reference_lookup (TREE_OPERAND (op, 0), gimple_vuse (stmt),
-    				  true, NULL);
+    				  VN_WALKREWRITE, NULL);
 
   /* We handle type-punning through unions by value-numbering based
      on offset and size of the access.  Be prepared to handle a
@@ -2098,7 +2105,7 @@
      Otherwise, the vdefs for the store are used when inserting into
      the table, since the store generates a new memory state.  */
 
-  result = vn_reference_lookup (lhs, gimple_vuse (stmt), false, NULL);
+  result = vn_reference_lookup (lhs, gimple_vuse (stmt), VN_NOWALK, NULL);
 
   if (result)
     {
Index: gcc/tree-ssa-sccvn.h
===================================================================
--- gcc/tree-ssa-sccvn.h	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/tree-ssa-sccvn.h	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -185,10 +185,11 @@
 void copy_reference_ops_from_call (gimple, VEC(vn_reference_op_s, heap) **);
 bool ao_ref_init_from_vn_reference (ao_ref *, alias_set_type, tree,
 				    VEC (vn_reference_op_s, heap) *);
+typedef enum { VN_NOWALK, VN_WALK, VN_WALKREWRITE } vn_lookup_kind;
 tree vn_reference_lookup_pieces (tree, alias_set_type, tree,
 				 VEC (vn_reference_op_s, heap) *,
-				 vn_reference_t *, bool);
-tree vn_reference_lookup (tree, tree, bool, vn_reference_t *);
+				 vn_reference_t *, vn_lookup_kind);
+tree vn_reference_lookup (tree, tree, vn_lookup_kind, vn_reference_t *);
 vn_reference_t vn_reference_insert (tree, tree, tree);
 vn_reference_t vn_reference_insert_pieces (tree, alias_set_type, tree,
 					   VEC (vn_reference_op_s, heap) *,
Index: gcc/ChangeLog
===================================================================
--- gcc/ChangeLog	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/ChangeLog	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -1,3 +1,306 @@
+2011-01-21  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/47365
+	* tree-ssa-sccvn.h (vn_lookup_kind): Declare.
+	(vn_reference_lookup_pieces): Adjust.
+	(vn_reference_lookup): Likewise.
+	* tree-ssa-sccvn.c (vn_walk_kind): New static global.
+	(vn_reference_lookup_3): Only look through kills if in
+	VN_WALKREWRITE mode.
+	(vn_reference_lookup_pieces): Adjust.
+	(vn_reference_lookup): Likewise.
+	(visit_reference_op_load): Likewise.
+	(visit_reference_op_store): Likewise.
+	* tree-ssa-pre.c (phi_translate_1): Use VN_WALK mode.
+	(compute_avail): Likewise.
+	(eliminate): Likewise.
+
+2011-01-20  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/47167
+	* tree-ssa-copyrename.c (copy_rename_partition_coalesce):
+	Revert previous change, only avoid enumeral type changes.
+
+2011-01-17  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2011-01-17  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/47318
+	* config/i386/avxintrin.h (_mm_maskload_pd): Change mask to
+	__m128i.
+	(_mm_maskstore_pd): Likewise.
+	(_mm_maskload_ps): Likewise.
+	(_mm_maskstore_ps): Likewise.
+	(_mm256_maskload_pd): Change mask to __m256i.
+	(_mm256_maskstore_pd): Likewise.
+	(_mm256_maskload_ps): Likewise.
+	(_mm256_maskstore_ps): Likewise.
+
+	* config/i386/i386-builtin-types.def: Updated.
+	(ix86_expand_special_args_builtin): Likewise.
+
+	* config/i386/i386.c (bdesc_special_args): Update
+	__builtin_ia32_maskloadpd, __builtin_ia32_maskloadps,
+	__builtin_ia32_maskloadpd256, __builtin_ia32_maskloadps256,
+	__builtin_ia32_maskstorepd, __builtin_ia32_maskstoreps,
+	__builtin_ia32_maskstorepd256 and __builtin_ia32_maskstoreps256.
+
+	* config/i386/sse.md (avx_maskload<ssemodesuffix><avxmodesuffix>):
+	Use <avxpermvecmode> on mask register.
+	(avx_maskstore<ssemodesuffix><avxmodesuffix>): Likewise.
+
+2011-01-17  Olivier Hainque  <hainque@adacore.com>
+            Michael Haubenwallner  <michael.haubenwallner@salomon.at>
+            Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/46655
+	* xcoffout.c (ASM_OUTPUT_LINE): Output line only if positive, and only
+	if <= USHRT_MAX in 32-bit mode.
+
+2011-01-17  Richard Guenther  <rguenther@suse.de>
+
+	Backport from mainline
+	PR tree-optimization/47286
+	* tree-ssa-structalias.c (new_var_info): Register variables
+	are global.
+
+	PR tree-optimization/44592
+	* tree-ssa-ccp.c (gimplify_and_update_call_from_tree): Copy
+	from trunk.
+
+2011-01-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline
+	2011-01-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/47201
+	* config/i386/i386.c (ix86_delegitimize_address): If
+	simplify_gen_subreg fails, return orig_x.
+
+	2011-01-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/47150
+	* c-convert.c (convert): When converting a complex expression
+	other than COMPLEX_EXPR to a different complex type, ensure
+	c_save_expr is called instead of save_expr, unless in_late_binary_op.
+	* c-typeck.c (convert_for_assignment): Set in_late_binary_op also
+	when converting COMPLEX_TYPE.
+
+	2010-12-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/46880
+	* config/i386/sse.md (sse2_loadlpd, sse2_movsd): Fix shufpd source
+	operand.
+
+	PR middle-end/45852
+	* expr.c (store_expr): Ignore alt_rtl if equal to target,
+	but has side-effects.
+
+	2010-12-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/43655
+	* tree-ssa-ter.c (is_replaceable_p): Don't use
+	gimple_references_memory_p for -O0, instead check for load
+	by looking at rhs.
+
+	PR debug/46893
+	* cfgexpand.c (expand_debug_expr): If GET_MODE (op0) is VOIDmode,
+	use TYPE_MODE (TREE_TYPE (tem)) instead of mode1.
+
+	2010-12-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/46804
+	* regmove.c (optimize_reg_copy_3): Look for REG_EQUAL note
+	on the setter of src_reg rather than on insn.  If it is
+	equal to the setter's original SET_SRC, replace it with its
+	zero or sign extension instead of dropping it.
+
+	PR rtl-optimization/46865
+	* rtl.c (rtx_equal_p_cb, rtx_equal_p): For last operand of
+	ASM_OPERANDS and ASM_INPUT if integers are different,
+	call locator_eq.
+	* jump.c (rtx_renumbered_equal_p): Likewise.
+
+	PR tree-optimization/46864
+	* tree-ssa-loop-im.c (loop_suitable_for_sm): Return false even
+	when there are EDGE_EH exit edges.
+
+	2010-12-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/41082
+	* config/rs6000/rs6000.c (rs6000_expand_vector_extract): Use stvx
+	instead of stve*x.
+	(altivec_expand_stv_builtin): For op0 use mode of operand 1 instead
+	of operand 0.
+	* config/rs6000/altivec.md (VI_scalar): New mode attr.
+	(altivec_stve<VI_char>x, *altivec_stvesfx): Use scalar instead of
+	vector mode for operand 0, put operand 1 into UNSPEC.
+
+2011-01-13  Nick Clifton  <nickc@redhat.com>
+
+	Import this fix from the mainline:
+	2010-10-19  Nick Clifton  <nickc@redhat.com>
+
+	* config/rx/rx.c (rx_function_value): Small integer types are
+	promoted to SImode.
+	(rx_promote_function_mode): New function.
+	(TARGET_PROMOTE_FUNCTION_MODE): Define.
+
+2011-01-07  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	Backport from mainline:
+	2011-01-06  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	PR target/43309
+	* config/i386/i386.c (legitimize_tls_address)
+	<TLS_MODEL_INITIAL_EXEC>: Handle TARGET_64BIT && TARGET_SUN_TLS.
+	* config/i386/i386.md (UNSPEC_TLS_IE_SUN): Declare.
+	(tls_initial_exec_64_sun): New pattern.
+
+2011-01-03  Eric Botcazou  <ebotcazou@adacore.com>
+
+	Backport from mainline
+	2010-12-30  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/47038
+	* config/sparc/sparc.c (sparc_file_end): Call resolve_unique_section
+	on the GOT helper if USE_HIDDEN_LINKONCE.
+
+	2010-12-02  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/46685
+	* config/sparc/sparc.c (can_use_mov_pic_label_ref): New predicate.
+	(sparc_expand_move): Call it to decide whether to emit the special
+	mov{si,di}_pic_label_ref patterns.
+	(sparc_legitimize_pic_address): Call it to decide whether to emit
+	the regular PIC sequence for labels.  Fix long line.
+	(sparc_file_end): Set is_thunk for the PIC helper.
+
+2010-12-30  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	* config/pa/pa.md: Add ",*" condition to 64-bit add/subtract boolean
+	patterns.
+
+2010-12-27  Yao Qi  <yao@codesourcery.com>
+
+	Backport from mainline:
+	2010-10-14  Yao Qi  <yao@codesourcery.com>
+
+	PR target/45447
+	* config/arm/arm.c (arm_build_builtin_va_list): Assign
+	va_list_name to TYPE_STUB_DECL (va_list_type).
+
+2010-12-23  Sebastian Pop  <sebastian.pop@amd.com>
+	    Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/46758
+	* graphite-sese-to-poly.c (scan_tree_for_params_right_scev): Use
+	tree_int_to_gmp instead of int_cst_value.
+	(scan_tree_for_params_int): Same.
+	(scan_tree_for_params): Same.
+	(pdr_add_data_dimensions): Use ppl_set_inhomogeneous_tree.
+
+2010-12-23  Sebastian Pop  <sebastian.pop@amd.com>
+
+	Backport from mainline
+	Fix PR45758: reset scevs before Graphite.
+        2010-09-24  Sebastian Pop  <sebastian.pop@amd.com>
+
+	PR tree-optimization/45552
+	* graphite.c (graphite_initialize): Call scev_reset.
+
+2010-12-23  Sebastian Pop  <sebastian.pop@amd.com>
+
+	PR tree-optimization/43023
+	* tree-data-ref.c (mem_write_stride_of_same_size_as_unit_type_p):
+	Removed.
+	(stores_zero_from_loop): Call stmt_stores_zero.
+	(stmt_with_adjacent_zero_store_dr_p): New.
+	* tree-data-ref.h (stmt_with_adjacent_zero_store_dr_p): Declared.
+	(stride_of_unit_type_p): New.
+	* tree-loop-distribution.c (generate_memset_zero): Do not return a
+	boolean.  Call gcc_assert on stride_of_unit_type_p.
+	(generate_builtin): Call stmt_stores_zero.
+	(rdg_flag_all_uses): Removed.
+	(rdg_flag_similar_memory_accesses): Removed.
+	(build_rdg_partition_for_component): Removed parameter
+	other_stores.  Removed call to rdg_flag_similar_memory_accesses.
+	(can_generate_builtin): New.
+	(similar_memory_accesses): New.
+	(fuse_partitions_with_similar_memory_accesses): New.
+	(rdg_build_partitions): Call
+	fuse_partitions_with_similar_memory_accesses.
+
+2010-12-21  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline:
+	2010-12-09  Martin Jambor  <mjambor@suse.cz>
+
+	PR middle-end/46734
+	* tree-sra.c (splice_param_accesses): Check that there are not
+	multiple ADDRESSABLE types.
+
+2010-12-19  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	Backport from mainline:
+	2010-12-18  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	PR target/46915
+	* config/pa/pa.c (branch_to_delay_slot_p): Use next_active_insn instead
+	of next_real_insn.  Search forward checking for both ASM_INPUT and
+	ASM_OPERANDS asms until exit condition is found.
+	(branch_needs_nop_p): Likewise.
+	(use_skip_p): New function.
+	(output_cbranch): Use use_skip_p.
+	(output_bb, output_bvb): Likewise.
+
+2010-12-19  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/46729
+	* config/sparc/sparc.h (GLOBAL_OFFSET_TABLE_REGNUM): New macro.
+	(PIC_OFFSET_TABLE_REGNUM): Rewrite in terms of above macro.
+	* config/sparc/sparc.c (pic_helper_needed): Delete.
+	(global_offset_table): Likewise.
+	(pic_helper_symbol): Rename to...
+	(got_helper_rtx): ...this.
+	(global_offset_table_rtx): New global variable.
+	(sparc_got_symbol): Likewise.
+	(sparc_got): New static function.
+	(check_pic): Use local variable and call sparc_got.
+	(sparc_tls_symbol): Initialize to NULL_RTX.
+	(sparc_tls_got): In non-PIC mode, reload the GOT register for Sun TLS
+	and 32-bit ABI and copy the GOT symbol to a new register otherwise.
+	(get_pc_thunk_name): Rename local variable.
+	(gen_load_pcrel_sym): New wrapper around load_pcrel_sym{si,di}.
+	(load_pic_register): Rename to...
+	(load_got_register): ...this.  Adjust and call gen_load_pcrel_sym.
+	(sparc_expand_prologue): Do not test flag_pic.
+	(sparc_output_mi_thunk): Use pic_offset_table_rtx directly.
+	(sparc_file_end): Test got_helper_rtx instead of pic_helper_needed.
+	Rename local variable and do not call get_pc_thunk_name again.
+	* config/sparc/sparc.md (load_pcrel_sym): Add operand #3.
+
+2010-12-18  Alexandre Oliva  <aoliva@redhat.com>
+
+	PR debug/46756
+	* jump.c (mark_all_labels): Skip debug insns.
+
+2010-12-18  Alexandre Oliva  <aoliva@redhat.com>
+
+	PR debug/46782
+	* cfgcleanup.c (try_forward_edges): Skip debug insns.
+
+2010-12-16  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* tree-ssa-sccvn.c (vn_reference_lookup_3): Always punt if the call to
+	get_ref_base_and_extent returns -1 as the max size.
+
+2010-12-16  Richard Guenther  <rguenther@suse.de>
+
+	* DEV-PHASE: Set back to prerelease.
+	* BASE-VER: Bump to 4.5.3.
+
 2010-12-16  Release Manager
 
 	* GCC 4.5.2 released.
Index: gcc/testsuite/gcc.c-torture/compile/pr47150.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr47150.c	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr47150.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -0,0 +1,11 @@
+/* PR c/47150 */
+
+float _Complex foo (float, float);
+
+void
+bar ()
+{
+  float w = 2;
+  float _Complex b;
+  b = 0.5 * (foo (0, w) + foo (1, w) / w);
+}
Index: gcc/testsuite/gcc.target/arm/pr45447.c
===================================================================
--- gcc/testsuite/gcc.target/arm/pr45447.c	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/arm/pr45447.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -0,0 +1,3 @@
+/* { dg-do compile } */
+/* { dg-options "-g -femit-struct-debug-baseonly" } */
+typedef __builtin_va_list x;
Index: gcc/testsuite/gcc.target/i386/avx-vmaskmovps-256-1.c
===================================================================
--- gcc/testsuite/gcc.target/i386/avx-vmaskmovps-256-1.c	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/testsuite/gcc.target/i386/avx-vmaskmovps-256-1.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -16,10 +16,11 @@
   int i;
   int m[8] = {mask_v(0), mask_v(1), mask_v(2), mask_v(3), mask_v(4), mask_v(5), mask_v(6), mask_v(7)};
   float s[8] = {1,2,3,4,5,6,7,8};
-  union256 u, mask;
+  union256 u;
+  union256i_d mask;
   float e [8] = {0.0};
 
-  mask.x = _mm256_loadu_ps ((float*)m);
+  mask.x = _mm256_loadu_si256 ((__m256i *)m);
   u.x = _mm256_maskload_ps (s, mask.x);
 
   for (i = 0 ; i < 8; i++) 
Index: gcc/testsuite/gcc.target/i386/pr46880.c
===================================================================
--- gcc/testsuite/gcc.target/i386/pr46880.c	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/i386/pr46880.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -0,0 +1,28 @@
+/* PR target/46880 */
+/* { dg-do run } */
+/* { dg-options "-O2 -fno-strict-aliasing -msse2" } */
+/* { dg-require-effective-target sse2_runtime } */
+
+typedef double __m128d __attribute__ ((__vector_size__ (16), __may_alias__));
+typedef double (*T)[2];
+
+static __attribute__ ((noinline, noclone)) __m128d
+foo (__m128d c, __m128d d)
+{
+  T cp = (T) &c;
+  T dp = (T) &d;
+  __m128d e = { (*cp)[1], (*dp)[1] };
+  return e;
+}
+
+int
+main ()
+{
+  __m128d c = { 1.0, 2.0 };
+  __m128d d = { 3.0, 4.0 };
+  union { __m128d x; double d[2]; } u;
+  u.x = foo (c, d);
+  if (u.d[0] != 2.0 || u.d[1] != 4.0)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.target/i386/avx-vmaskmovps-1.c
===================================================================
--- gcc/testsuite/gcc.target/i386/avx-vmaskmovps-1.c	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/i386/avx-vmaskmovps-1.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -0,0 +1,31 @@
+/* { dg-do run } */
+/* { dg-require-effective-target avx } */
+/* { dg-options "-O2 -mavx" } */
+
+#include "avx-check.h"
+
+#ifndef MASK
+#define MASK 134
+#endif
+
+#define mask_v(pos) (((MASK & (0x1 << (pos))) >> (pos)) << 31)
+
+void static
+avx_test (void)
+{
+  int i;
+  int m[4] = {mask_v(0), mask_v(1), mask_v(2), mask_v(3)};
+  float s[4] = {1,2,3,4};
+  union128 u;
+  union128i_d mask;
+  float e[4] = {0.0};
+
+  mask.x = _mm_loadu_si128 ((__m128i *)m);
+  u.x = _mm_maskload_ps (s, mask.x);
+
+  for (i = 0 ; i < 4; i++) 
+    e[i] = m[i] ? s[i] : 0;
+   
+  if (check_union128 (u, e))
+    abort ();
+}
Index: gcc/testsuite/gcc.target/i386/avx-vmaskmovpd-256-1.c
===================================================================
--- gcc/testsuite/gcc.target/i386/avx-vmaskmovpd-256-1.c	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/testsuite/gcc.target/i386/avx-vmaskmovpd-256-1.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -14,12 +14,13 @@
 avx_test (void)
 {
   int i;
-  long long m[8] = {mask_v(0), mask_v(1), mask_v(2), mask_v(3)};
+  long long m[4] = {mask_v(0), mask_v(1), mask_v(2), mask_v(3)};
   double s[4] = {1.1, 2.2, 3.3, 4.4};
-  union256d u, mask;
+  union256d u;
+  union256i_q mask;
   double e [4] = {0.0};
 
-  mask.x = _mm256_loadu_pd ((double*)m);
+  mask.x = _mm256_loadu_si256 ((__m256i *)m);
   u.x = _mm256_maskload_pd (s, mask.x);
 
   for (i = 0 ; i < 4; i++) 
Index: gcc/testsuite/gcc.target/i386/avx-vmaskmovpd-1.c
===================================================================
--- gcc/testsuite/gcc.target/i386/avx-vmaskmovpd-1.c	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/i386/avx-vmaskmovpd-1.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -0,0 +1,31 @@
+/* { dg-do run } */
+/* { dg-require-effective-target avx } */
+/* { dg-options "-O2 -mavx" } */
+
+#include "avx-check.h"
+
+#ifndef MASK
+#define MASK 7
+#endif
+
+#define mask_v(pos) (((MASK & (0x1ULL << (pos))) >> (pos)) << 63)
+
+void static
+avx_test (void)
+{
+  int i;
+  long long m[2] = {mask_v(0), mask_v(1)};
+  double s[2] = {1.1, 2.2};
+  union128d u;
+  union128i_q mask;
+  double e[2] = {0.0};
+
+  mask.x = _mm_loadu_si128 ((__m128i *)m);
+  u.x = _mm_maskload_pd (s, mask.x);
+
+  for (i = 0 ; i < 2; i++) 
+    e[i] = m[i] ? s[i] : 0;
+   
+  if (check_union128d (u, e))
+    abort ();
+}
Index: gcc/testsuite/gcc.target/i386/pr46865-1.c
===================================================================
--- gcc/testsuite/gcc.target/i386/pr46865-1.c	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/i386/pr46865-1.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -0,0 +1,31 @@
+/* PR rtl-optimization/46865 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+extern unsigned long f;
+
+#define m1(f)							\
+  if (f & 1)							\
+    asm volatile ("nop /* asmnop */\n");			\
+  else								\
+    asm volatile ("nop /* asmnop */\n");
+
+#define m2(f)							\
+  if (f & 1)							\
+    asm volatile ("nop /* asmnop */\n" : : "i" (6) : "cx");	\
+  else								\
+    asm volatile ("nop /* asmnop */\n" : : "i" (6) : "cx");
+
+void
+foo (void)
+{
+  m1 (f);
+}
+
+void
+bar (void)
+{
+  m2 (f);
+}
+
+/* { dg-final { scan-assembler-times "asmnop" 2 } } */
Index: gcc/testsuite/gcc.target/i386/pr45852.c
===================================================================
--- gcc/testsuite/gcc.target/i386/pr45852.c	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/i386/pr45852.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -0,0 +1,16 @@
+/* PR middle-end/45852 */
+/* { dg-options "-O2 -mcmodel=small" } */
+/* { dg-do compile { target { { i?86-*-linux* x86_64-*-linux* } && lp64 } } } */
+/* { dg-require-visibility "" } */
+
+struct S { int s; };
+
+volatile struct S globvar __attribute__((visibility ("hidden"))) = { -6 };
+
+void
+foo (void)
+{
+  globvar = globvar;
+}
+
+/* { dg-final { scan-assembler-times "globvar.%?rip" 2 } } */
Index: gcc/testsuite/gcc.target/i386/avx-vmaskmovps-256-2.c
===================================================================
--- gcc/testsuite/gcc.target/i386/avx-vmaskmovps-256-2.c	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/testsuite/gcc.target/i386/avx-vmaskmovps-256-2.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -16,12 +16,13 @@
   int i;
   int m[8] = {mask_v(0), mask_v(1), mask_v(2), mask_v(3), mask_v(4), mask_v(5), mask_v(6), mask_v(7)};
   float s[8] = {1,2,3,4,5,6,7,8};
-  union256 src, mask;
+  union256 src;
+  union256i_d mask;
   float e [8] = {0.0};
   float d [8] = {0.0};
 
   src.x = _mm256_loadu_ps (s);
-  mask.x = _mm256_loadu_ps ((float *)m);
+  mask.x = _mm256_loadu_si256 ((__m256i *)m);
   _mm256_maskstore_ps (d, mask.x, src.x);
 
   for (i = 0 ; i < 8; i++) 
Index: gcc/testsuite/gcc.target/i386/avx-vmaskmovps-2.c
===================================================================
--- gcc/testsuite/gcc.target/i386/avx-vmaskmovps-2.c	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/i386/avx-vmaskmovps-2.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -0,0 +1,33 @@
+/* { dg-do run } */
+/* { dg-require-effective-target avx } */
+/* { dg-options "-O2 -mavx" } */
+
+#include "avx-check.h"
+
+#ifndef MASK
+#define MASK 214
+#endif
+
+#define mask_v(pos) (((MASK & (0x1 << (pos))) >> (pos)) << 31)
+
+void static
+avx_test (void)
+{
+  int i;
+  int m[4] = {mask_v(0), mask_v(1), mask_v(2), mask_v(3)};
+  float s[4] = {1,2,3,4};
+  union128 src;
+  union128i_d mask;
+  float e[4] = {0.0};
+  float d[4] = {0.0};
+
+  src.x = _mm_loadu_ps (s);
+  mask.x = _mm_loadu_si128 ((__m128i *)m);
+  _mm_maskstore_ps (d, mask.x, src.x);
+
+  for (i = 0 ; i < 4; i++) 
+    e[i] = m[i] ? s[i] : 0;
+   
+  if (checkVf (d, e, 4))
+    abort ();
+}
Index: gcc/testsuite/gcc.target/i386/avx-vmaskmovpd-256-2.c
===================================================================
--- gcc/testsuite/gcc.target/i386/avx-vmaskmovpd-256-2.c	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/testsuite/gcc.target/i386/avx-vmaskmovpd-256-2.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -18,10 +18,11 @@
   double s[4] = {1.1, 2.2, 3.3, 4.4};
   double e [4] = {0.0};
   double d [4] = {0.0};
-  union256d src, mask;
+  union256d src;
+  union256i_q mask;
   
   src.x = _mm256_loadu_pd (s);
-  mask.x = _mm256_loadu_pd ((double*)m);
+  mask.x = _mm256_loadu_si256 ((__m256i *)m);
   _mm256_maskstore_pd (d, mask.x, src.x);
 
   for (i = 0 ; i < 4; i++) 
Index: gcc/testsuite/gcc.target/i386/avx-vmaskmovpd-2.c
===================================================================
--- gcc/testsuite/gcc.target/i386/avx-vmaskmovpd-2.c	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/i386/avx-vmaskmovpd-2.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -0,0 +1,33 @@
+/* { dg-do run } */
+/* { dg-require-effective-target avx } */
+/* { dg-options "-O2 -mavx" } */
+
+#include "avx-check.h"
+
+#ifndef MASK
+#define MASK 6
+#endif
+
+#define mask_v(pos) (((MASK & (0x1ULL << (pos))) >> (pos)) << 63)
+
+void static
+avx_test (void)
+{
+  int i;
+  long long m[2] = {mask_v(0), mask_v(1)};
+  double s[2] = {1.1, 2.2};
+  double e[2] = {0.0};
+  double d[2] = {0.0};
+  union128d src;
+  union128i_q mask;
+  
+  src.x = _mm_loadu_pd (s);
+  mask.x = _mm_loadu_si128 ((__m128i *)m);
+  _mm_maskstore_pd (d, mask.x, src.x);
+
+  for (i = 0 ; i < 2; i++) 
+    e[i] = m[i] ? s[i] : 0;
+   
+  if (checkVd (d, e, 2))
+    abort ();
+}
Index: gcc/testsuite/gcc.target/i386/pr46865-2.c
===================================================================
--- gcc/testsuite/gcc.target/i386/pr46865-2.c	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/i386/pr46865-2.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -0,0 +1,32 @@
+/* PR rtl-optimization/46865 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -save-temps" } */
+
+extern unsigned long f;
+
+#define m1(f)							\
+  if (f & 1)							\
+    asm volatile ("nop /* asmnop */\n");			\
+  else								\
+    asm volatile ("nop /* asmnop */\n");
+
+#define m2(f)							\
+  if (f & 1)							\
+    asm volatile ("nop /* asmnop */\n" : : "i" (6) : "cx");	\
+  else								\
+    asm volatile ("nop /* asmnop */\n" : : "i" (6) : "cx");
+
+void
+foo (void)
+{
+  m1 (f);
+}
+
+void
+bar (void)
+{
+  m2 (f);
+}
+
+/* { dg-final { scan-assembler-times "asmnop" 2 } } */
+/* { dg-final { cleanup-saved-temps } } */
Index: gcc/testsuite/gnat.dg/opt13.adb
===================================================================
--- gcc/testsuite/gnat.dg/opt13.adb	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gnat.dg/opt13.adb	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -0,0 +1,13 @@
+-- { dg-do run }
+-- { dg-options "-O" }
+
+with Opt13_Pkg; use Opt13_Pkg;
+
+procedure Opt13 is
+  T : My_Type;
+begin
+  Allocate (T);
+  if N /= 1 then
+    raise Program_Error;
+  end if;
+end;
Index: gcc/testsuite/gnat.dg/opt13_pkg.adb
===================================================================
--- gcc/testsuite/gnat.dg/opt13_pkg.adb	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gnat.dg/opt13_pkg.adb	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -0,0 +1,31 @@
+package body Opt13_Pkg is
+
+  subtype Index_Type is Natural range 0 .. 16;
+
+  type Arr is array (Index_Type range <>) of Integer;
+
+  type Rec is record
+    F1, F2, F3 : Float;
+    N : Natural;
+    B1, B2 : Boolean;
+    F4 : Float;
+  end record;
+
+  type Data (D : Index_Type) is record
+    A : Arr (1 .. D);
+    R : Rec;
+  end record;
+
+  Zero : constant Rec := (0.0, 0.0, 0.0, 0, False, False, 0.0);
+
+  procedure Allocate (T : out My_Type) is
+  begin
+    T := new Data (Index_Type'last);
+    T.R := Zero;
+
+    for I in 1 .. T.A'last loop
+      N := 1;
+    end loop;
+  end;
+
+end Opt13_Pkg;
Index: gcc/testsuite/gnat.dg/opt13_pkg.ads
===================================================================
--- gcc/testsuite/gnat.dg/opt13_pkg.ads	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gnat.dg/opt13_pkg.ads	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -0,0 +1,15 @@
+package Opt13_Pkg is
+
+    N : Natural := 0;
+
+    type My_Type is private;
+
+    procedure Allocate (T : out My_Type);
+
+private
+
+    type Data;
+
+    type My_Type is access Data;
+
+end Opt13_Pkg;
Index: gcc/testsuite/gcc.dg/pr47201.c
===================================================================
--- gcc/testsuite/gcc.dg/pr47201.c	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/pr47201.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -0,0 +1,18 @@
+/* PR target/47201 */
+/* { dg-do compile } */
+/* { dg-options "-O -fpic -g" { target fpic } } */
+
+union U
+{
+  __UINTPTR_TYPE__ m;
+  float d;
+} u;
+
+int
+foo (void)
+{
+  union U v = {
+    (__UINTPTR_TYPE__)&u
+  };
+  return u.d == v.d;
+}
Index: gcc/testsuite/gcc.dg/pr46893.c
===================================================================
--- gcc/testsuite/gcc.dg/pr46893.c	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/pr46893.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -0,0 +1,13 @@
+/* PR debug/46893 */
+/* { dg-do compile } */
+/* { dg-options "-O -g" } */
+
+void
+foo (void)
+{
+  union { unsigned long long l; double d; } u = { 0x7ff0000000000000ULL };
+  double v = 0, w = -u.d;
+
+  if (w)
+    w = v;
+}
Index: gcc/testsuite/gcc.dg/20061124-1.c
===================================================================
--- gcc/testsuite/gcc.dg/20061124-1.c	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/testsuite/gcc.dg/20061124-1.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -1,5 +1,6 @@
 /* { dg-do run } */
 /* { dg-require-effective-target sync_char_short } */
+/* { dg-options "-mcpu=v9" { target sparc*-*-* } } */
 
 /* This testcase failed on s390 because no compare instruction for
    the check of FLAG was emitted.  */
Index: gcc/testsuite/gcc.dg/debug/pr46782.c
===================================================================
--- gcc/testsuite/gcc.dg/debug/pr46782.c	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/debug/pr46782.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -0,0 +1,11 @@
+/* PR debug/46782 */
+/* { dg-do compile } */
+/* { dg-options "-w -O0 -fvar-tracking -fcompare-debug" } */
+
+void foo (int i)
+{
+  if (i)
+    i++;
+  while (i)
+    ;
+}
Index: gcc/testsuite/gcc.dg/graphite/run-id-pr46758.c
===================================================================
--- gcc/testsuite/gcc.dg/graphite/run-id-pr46758.c	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/graphite/run-id-pr46758.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -0,0 +1,18 @@
+int
+movegt (int y, long long a)
+{
+  int i;
+  int ret = 0;
+  for (i = 0; i < y; i++)
+    if (a == -1LL << 33)
+      ret = -1;
+  return ret;
+}
+
+int
+main ()
+{
+  if (movegt (1, -1LL << 33) != -1)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/graphite/pr45552.c
===================================================================
--- gcc/testsuite/gcc.dg/graphite/pr45552.c	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/graphite/pr45552.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -0,0 +1,46 @@
+typedef struct
+{
+  double z;
+} Vector;
+typedef struct
+{
+  float *vertex;
+  float *normal;
+} VertexArray;
+typedef struct
+{
+  Vector *vertex;
+  int num_vertex;
+} ObjectSmooth;
+typedef struct
+{
+  int num_cells;
+} State;
+static void *array_from_ObjectSmooth( ObjectSmooth *obj )
+{
+  int i, j;
+  VertexArray *array = (VertexArray *) __builtin_malloc( sizeof( VertexArray ) );
+  array->vertex = (float *) __builtin_malloc( 3*sizeof(float)*obj->num_vertex );
+  array->normal = (float *) __builtin_malloc( 3*sizeof(float)*obj->num_vertex );
+  for (i=0, j=0; i<obj->num_vertex; ++i) {
+    array->normal[j++] = 9;
+    array->vertex[j] = obj->vertex[i].z;
+    array->normal[j++] = 1;
+  }
+}
+static void draw_cell( void )
+{
+  glCallList( array_from_ObjectSmooth( (ObjectSmooth *) __builtin_malloc(10) ));
+}
+static int render( State *st)
+{
+  int b;
+  for (b=0; b<st->num_cells; ++b) {
+    draw_cell();
+    draw_cell();
+  }
+}
+reshape_glcells( int width, int height )
+{
+  render( 0 );
+}
Index: gcc/testsuite/gcc.dg/torture/pr47365.c
===================================================================
--- gcc/testsuite/gcc.dg/torture/pr47365.c	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/torture/pr47365.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -0,0 +1,39 @@
+/* { dg-do run } */
+
+struct A
+{
+  int i;
+};
+
+struct B
+{
+  struct A a[2];
+};
+
+int i = 1;
+struct B b = { 0, 3 };
+
+static void
+test ()
+{
+  if (b.a[0].i != i)
+    {
+      int t = b.a[0].i;
+      b.a[0] = b.a[1];
+      b.a[1].i = t;
+    }
+
+  if (b.a[1].i == i)
+    __builtin_abort ();
+
+  if (b.a[0].i == 0)
+    __builtin_abort ();
+}
+
+int
+main ()
+{
+  test ();
+  return 0;
+}
+
Index: gcc/testsuite/gcc.dg/tree-ssa/pr47392.c
===================================================================
--- gcc/testsuite/gcc.dg/tree-ssa/pr47392.c	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/tree-ssa/pr47392.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -0,0 +1,42 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -fdump-tree-pre-stats" } */
+
+struct A
+{
+  int i;
+};
+
+struct B
+{
+  struct A a[2];
+};
+
+int i = 1;
+struct B b = { 0, 3 };
+
+static void
+test ()
+{
+  if (b.a[0].i != i)
+    {
+      int t = b.a[0].i;
+      b.a[0] = b.a[1];
+      b.a[1].i = t;
+    }
+
+  if (b.a[1].i == i)
+    __builtin_abort ();
+
+  if (b.a[0].i == 0)
+    __builtin_abort ();
+}
+
+int
+main ()
+{
+  test ();
+  return 0;
+}
+
+/* { dg-final { scan-tree-dump "Eliminated: 1" "pre" } } */
+/* { dg-final { cleanup-tree-dump "pre" } } */
Index: gcc/testsuite/gcc.dg/tree-ssa/pr47286.c
===================================================================
--- gcc/testsuite/gcc.dg/tree-ssa/pr47286.c	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/tree-ssa/pr47286.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -0,0 +1,20 @@
+/* { dg-do compile } */
+/* { dg-skip-if "" { ! { i?86-*-* x86_64-*-* } } { "*" } { "" } } */
+/* { dg-options "-O2 -fdump-tree-optimized" } */
+
+struct thread_info { int preempt_count; };
+static inline struct thread_info *current_thread_info(void)
+{
+  register struct thread_info *sp asm("esp");
+  return sp;
+}
+void testcase(void)
+{
+  current_thread_info()->preempt_count += 1;
+}
+
+/* We have to make sure that alias analysis treats sp as pointing
+   to globals and thus the store not optimized away.  */
+
+/* { dg-final { scan-tree-dump "->preempt_count =" "optimized" } } */
+/* { dg-final { cleanup-tree-dump "optimized" } } */
Index: gcc/testsuite/gcc.dg/pr28796-2.c
===================================================================
--- gcc/testsuite/gcc.dg/pr28796-2.c	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/testsuite/gcc.dg/pr28796-2.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -2,6 +2,7 @@
 /* { dg-options "-O2 -funsafe-math-optimizations -fno-finite-math-only -DUNSAFE" } */
 /* { dg-add-options ieee } */
 /* { dg-skip-if "No Inf/NaN support" { spu-*-* } } */
+/* { dg-skip-if "Bug in _Q_dtoq" { sparc*-sun-solaris2.8 } } */
 
 #include "tg-tests.h"
 
Index: gcc/testsuite/gcc.dg/vect/pr43430-1.c
===================================================================
--- gcc/testsuite/gcc.dg/vect/pr43430-1.c	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/testsuite/gcc.dg/vect/pr43430-1.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -35,5 +35,5 @@
   return foo (data_ch1, data_ch2, 1);
 }
 
-/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_condition } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
Index: gcc/testsuite/gcc.dg/vect/slp-multitypes-2.c
===================================================================
--- gcc/testsuite/gcc.dg/vect/slp-multitypes-2.c	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/testsuite/gcc.dg/vect/slp-multitypes-2.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -1,4 +1,5 @@
 /* { dg-require-effective-target vect_int } */
+/* { dg-do run { xfail { sparc*-*-* && ilp32 } } } PR rtl-opt/46603 */
 
 #include <stdarg.h>
 #include <stdio.h>
Index: gcc/testsuite/ChangeLog
===================================================================
--- gcc/testsuite/ChangeLog	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/testsuite/ChangeLog	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -1,3 +1,176 @@
+2011-01-24  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* gfortran.dg/cray_pointers_2.f90: Avoid cycling through
+	optimization options.
+
+2011-01-24  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* gfortran.dg/array_constructor_33.f90: Use dg-timeout-factor 4.
+
+2011-01-21  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/47365
+	* gcc.dg/torture/pr47365.c: New testcase.
+	* gcc.dg/tree-ssa/pr47392.c: Likewise.
+
+2011-01-21  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* g++.dg/other/anon5.C: Skip on mips-sgi-irix*.
+
+2011-01-17  Eric Botcazou  <ebotcazou@adacore.com>
+
+	Backport from mainline
+	2010-11-22  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.dg/pr28796-2.c: SKIP on SPARC/Solaris 8.
+
+	PR rtl-optimization/46603
+	* gcc.dg/vect/slp-multitypes-2.c: XFAIL execution on SPARC 32-bit.
+
+	2010-08-31  Bingfeng Mei  <bmei@broadcom.com>
+
+	* gcc.dg/vect/pr43430-1.c: Requires vect_condition target.
+
+2011-01-17  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* g++.old-deja/g++.other/init19.C: Don't XFAIL on mips-sgi-irix*.
+
+2011-01-17  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2011-01-17  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/47318
+	* gcc.target/i386/avx-vmaskmovpd-1.c: New.
+	* gcc.target/i386/avx-vmaskmovpd-2.c: Likewise.
+	* gcc.target/i386/avx-vmaskmovps-1.c: Likewise.
+	* gcc.target/i386/avx-vmaskmovps-1.c: Likewise.
+
+	* gcc.target/i386/avx-vmaskmovpd-256-1.c (avx_test): Load mask
+	as __m256i.
+	* gcc.target/i386/avx-vmaskmovpd-256-2.c (avx_test): Likewise.
+	* gcc.target/i386/avx-vmaskmovps-256-1.c (avx_test): Likewise.
+	* gcc.target/i386/avx-vmaskmovps-256-2.c (avx_test): Likewise.
+
+2011-01-17  Richard Guenther  <rguenther@suse.de>
+
+	Backport from mainline
+	PR tree-optimization/47286
+	* gcc.dg/tree-ssa/pr47286.c: New testcase.
+
+	PR tree-optimization/44592
+	* gfortran.dg/pr44592.f90: New testcase.
+
+2011-01-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline
+	2011-01-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/47201
+	* gcc.dg/pr47201.c: New test.
+
+	2011-01-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/47150
+	* gcc.c-torture/compile/pr47150.c: New test.
+
+	2010-12-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/46880
+	* gcc.target/i386/pr46880.c: New test.
+
+	PR middle-end/45852
+	* gcc.target/i386/pr45852.c: New test.
+
+	2010-12-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/43655
+	* g++.dg/opt/pr43655.C: New test.
+
+	PR debug/46893
+	* gcc.dg/pr46893.c: New test.
+
+	2010-12-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/46804
+	* gfortran.dg/pr46804.f90: New test.
+
+	PR rtl-optimization/46865
+	* gcc.target/i386/pr46865-1.c: New test.
+	* gcc.target/i386/pr46865-2.c: New test.
+
+	PR tree-optimization/46864
+	* g++.dg/opt/pr46864.C: New test.
+
+2011-01-13  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* gfortran.dg/cray_pointers_2.f90: Use dg-timeout-factor 4.
+
+2011-01-12  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR testsuite/33033
+	* gcc.dg/20061124-1.c: Pass -mcpu=v9 on the SPARC.
+
+2011-02-01  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from mainline
+	PR fortran/45338
+	* gfortran.dg/userdef_operator_2.f90:  New test case.
+
+2010-12-27  Yao Qi  <yao@codesourcery.com>
+
+	Backport from mainline:
+	2010-10-14  Yao Qi  <yao@codesourcery.com>
+
+	PR target/45447
+	* gcc.target/arm/pr45447.c: New test.
+
+2010-12-24  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/opt13_pkg.ad[sb]: Fix line ending.
+
+2010-12-22  Sebastian Pop  <sebastian.pop@amd.com>
+
+	PR tree-optimization/46758
+	* gcc.dg/graphite/run-id-pr46758.c: New.
+
+2010-12-23  Sebastian Pop  <sebastian.pop@amd.com>
+
+	PR tree-optimization/45552
+	* gcc.dg/graphite/pr45552.c
+
+
+2010-12-23  Sebastian Pop  <sebastian.pop@amd.com>
+
+	PR tree-optimization/43023
+	* gfortran.dg/ldist-1.f90: Adjust pattern.
+	* gfortran.dg/ldist-pr43023.f90: New.
+
+2010-12-21  Martin Jambor  <mjambor@suse.cz>
+
+	PR middle-end/46734
+	* g++.dg/tree-ssa/pr46734.C: New test.
+
+2010-12-18  Alexandre Oliva  <aoliva@redhat.com>
+
+	PR debug/46756
+	* gfortran.dg/debug/pr46756.f: New.
+
+2010-12-18  Alexandre Oliva  <aoliva@redhat.com>
+
+	PR debug/46782
+	* gcc.dg/debug/pr46782.c: New.
+
+2010-12-17  Daniel Kraft  <d@domob.eu>
+
+	PR fortran/46794
+	* gfortran.dg/power2.f90: Initialize variables.
+
+2010-12-16  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/opt13.adb: New test.
+	* gnat.dg/opt13_pkg.ad[sb]: New helper.
+
 2010-12-16  Release Manager
 
 	* GCC 4.5.2 released.
Index: gcc/testsuite/g++.old-deja/g++.other/init19.C
===================================================================
--- gcc/testsuite/g++.old-deja/g++.other/init19.C	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/testsuite/g++.old-deja/g++.other/init19.C	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -1,4 +1,4 @@
-// { dg-do run { xfail { { ! cxa_atexit } && { ! *-*-solaris2* } } } }
+// { dg-do run { xfail { { ! cxa_atexit } && { ! { mips-sgi-irix* *-*-solaris2* } } } } }
 #include <stdlib.h>
 
 #define assert(x) do { if (! (x)) abort(); } while (0)
Index: gcc/testsuite/g++.dg/other/anon5.C
===================================================================
--- gcc/testsuite/g++.dg/other/anon5.C	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/testsuite/g++.dg/other/anon5.C	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -1,5 +1,5 @@
 // PR c++/34094
-// { dg-do link { target { ! { *-*-darwin* *-*-hpux* *-*-solaris2.* alpha*-dec-osf* } } } }
+// { dg-do link { target { ! { *-*-darwin* *-*-hpux* *-*-solaris2.* alpha*-dec-osf* mips-sgi-irix* } } } }
 // { dg-options "-g" }
 
 namespace {
Index: gcc/testsuite/g++.dg/tree-ssa/pr46734.C
===================================================================
--- gcc/testsuite/g++.dg/tree-ssa/pr46734.C	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/tree-ssa/pr46734.C	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -0,0 +1,34 @@
+/* { dg-do compile } */
+/* { dg-options "-O -fipa-sra" } */
+
+struct A
+{
+  int *p;
+  A() {p = (int *) -1;}
+  ~A() {if (p && p != (int *) -1) *p = 0;}
+};
+
+struct B
+{
+  A a;
+  char data[23];
+  B() : a() {data[0] = 0;}
+};
+
+extern A ga;
+extern int *gi;
+extern void *gz;
+extern B *gb;
+
+static int * __attribute__ ((noinline)) foo (B *b, void *z)
+{
+  __builtin_memcpy (gz, z, 28);
+  ga = b->a;
+  return b->a.p;
+}
+
+int *bar (B *b, void *z)
+{
+  gb = b;
+  return foo (b, z);
+}
Index: gcc/testsuite/g++.dg/opt/pr43655.C
===================================================================
--- gcc/testsuite/g++.dg/opt/pr43655.C	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/opt/pr43655.C	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -0,0 +1,34 @@
+// PR tree-optimization/43655
+// { dg-do run }
+// { dg-options "-O0 -ftree-ter" }
+
+extern "C" void abort ();
+
+struct C
+{
+  C (int i) : val(i) { }
+  C (const C& c) : val(c.val) { }
+  ~C (void) { val = 999; }
+  C& operator = (const C& c) { val = c.val; return *this; }
+  C& inc (int i) { val += i; return *this; }
+  int val;
+};
+
+C
+f ()
+{
+  return C (3);
+}
+
+C
+f (int i)
+{
+  return f ().inc (i);
+}
+
+int
+main ()
+{
+  if (f (2).val != 5)
+    abort ();
+}
Index: gcc/testsuite/g++.dg/opt/pr46864.C
===================================================================
--- gcc/testsuite/g++.dg/opt/pr46864.C	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/opt/pr46864.C	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -0,0 +1,26 @@
+// PR tree-optimization/46864
+// { dg-do compile }
+// { dg-options "-O -fnon-call-exceptions" }
+
+int baz ();
+
+struct S
+{
+  int k;
+  bool bar () throw ()
+  {
+    int m = baz ();
+    for (int i = 0; i < m; i++)
+      k = i;
+    return m;
+  }
+};
+
+extern S *s;
+
+void
+foo ()
+{
+  while (baz () && s->bar ())
+    ;
+}
Index: gcc/testsuite/gfortran.dg/ldist-1.f90
===================================================================
--- gcc/testsuite/gfortran.dg/ldist-1.f90	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/testsuite/gfortran.dg/ldist-1.f90	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -29,5 +29,8 @@
   return
 end Subroutine PADEC
 
-! { dg-final { scan-tree-dump-times "distributed: split to 4 loops" 1 "ldist" } }
+! There are 5 legal partitions in this code.  Based on the data
+! locality heuristic, this loop should not be split.
+
+! { dg-final { scan-tree-dump-not "distributed: split to" "ldist" } }
 ! { dg-final { cleanup-tree-dump "ldist" } }
Index: gcc/testsuite/gfortran.dg/debug/pr46756.f
===================================================================
--- gcc/testsuite/gfortran.dg/debug/pr46756.f	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/debug/pr46756.f	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -0,0 +1,29 @@
+C PR debug/46756, reduced from ../20010519-1.f
+C { dg-do compile }
+C { dg-options "-O -fcompare-debug" }
+      LOGICAL QDISK,QDW,QCMPCT
+      LOGICAL LNOMA,LRAISE,LSCI,LBIG
+      ASSIGN 801 TO I800 ! { dg-warning "Deleted feature: ASSIGN" "Deleted feature: ASSIGN" }
+      GOTO 800
+ 801  CONTINUE
+      ASSIGN 761 TO I760 ! { dg-warning "Deleted feature: ASSIGN" "Deleted feature: ASSIGN" }
+ 761  CONTINUE
+      IF(LSCI) THEN
+         DO I=1,LENCM
+         ENDDO
+      ENDIF
+      DO WHILE((CVGMX.GT.TOLDIM).AND.(ITER.LT.ITMX))
+         IF(.NOT.QDW) THEN
+            ASSIGN 641 to I640 ! { dg-warning "Deleted feature: ASSIGN" "Deleted feature: ASSIGN" }
+            GOTO 640
+ 641        CONTINUE
+         ENDIF
+      ENDDO
+      GOTO 700
+ 640  CONTINUE
+      GOTO I640 ! { dg-warning "Deleted feature: Assigned" "Assigned GO TO" }
+ 700  CONTINUE
+      GOTO I760 ! { dg-warning "Deleted feature: Assigned" "Assigned GO TO" }
+ 800  CONTINUE
+      GOTO I800 ! { dg-warning "Deleted feature: Assigned" "Assigned GO TO" }
+      END
Index: gcc/testsuite/gfortran.dg/cray_pointers_2.f90
===================================================================
--- gcc/testsuite/gfortran.dg/cray_pointers_2.f90	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/testsuite/gfortran.dg/cray_pointers_2.f90	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -1,5 +1,8 @@
-! { dg-do run }
-! { dg-options "-fcray-pointer -fbounds-check" }
+! Using two spaces between dg-do and run is a hack to keep gfortran-dg-runtest
+! from cycling through optimization options for this expensive test.
+! { dg-do  run }
+! { dg-options "-O3 -fcray-pointer -fbounds-check" }
+! { dg-timeout-factor 4 }
 ! Series of routines for testing a Cray pointer implementation
 program craytest
   common /errors/errors(400)
Index: gcc/testsuite/gfortran.dg/dependency_39.f90
===================================================================
--- gcc/testsuite/gfortran.dg/dependency_39.f90	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/dependency_39.f90	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -0,0 +1,37 @@
+! { dg-do run }
+! PR 45777 - component ref aliases when both are pointers
+module m1
+  type t1
+     integer, dimension(:), allocatable :: data
+  end type t1
+contains
+  subroutine s1(t,d)
+    integer, dimension(:), pointer :: d
+    type(t1), pointer :: t
+    d(1:5)=t%data(3:7)
+  end subroutine s1
+  subroutine s2(d,t)
+    integer, dimension(:), pointer :: d
+    type(t1), pointer :: t
+    t%data(3:7) = d(1:5)
+  end subroutine s2
+end module m1
+
+program main
+  use m1
+  type(t1), pointer :: t
+  integer, dimension(:), pointer :: d
+  allocate(t)
+  allocate(t%data(10))
+  t%data=(/(i,i=1,10)/)
+  d=>t%data(5:9)
+  call s1(t,d)
+  if (any(d.ne.(/3,4,5,6,7/))) call abort()
+  t%data=(/(i,i=1,10)/)
+  d=>t%data(1:5)
+  call s2(d,t)
+  if (any(t%data.ne.(/1,2,1,2,3,4,5,8,9,10/))) call abort
+  deallocate(t%data)
+  deallocate(t)
+end program main
+! { dg-final { cleanup-modules "m1" } }
Index: gcc/testsuite/gfortran.dg/ldist-pr43023.f90
===================================================================
--- gcc/testsuite/gfortran.dg/ldist-pr43023.f90	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/ldist-pr43023.f90	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -0,0 +1,31 @@
+! { dg-do compile }
+! { dg-options "-O2 -ftree-loop-distribution" }
+
+MODULE NFT_mod
+
+implicit none
+integer :: Nangle
+real:: Z0
+real, dimension(:,:), allocatable :: Angle
+real, dimension(:), allocatable :: exth, ezth, hxth, hyth, hyphi
+
+CONTAINS
+
+SUBROUTINE NFT_Init()
+
+real :: th, fi
+integer :: n
+
+do n = 1,Nangle
+  th = Angle(n,1)
+  fi = Angle(n,2)
+
+  exth(n) =  cos(fi)*cos(th)
+  ezth(n) = -sin(th)
+  hxth(n) = -sin(fi)
+  hyth(n) =  cos(fi)
+  hyphi(n) = -sin(fi)
+end do
+END SUBROUTINE NFT_Init
+
+END MODULE NFT_mod
Index: gcc/testsuite/gfortran.dg/pr44592.f90
===================================================================
--- gcc/testsuite/gfortran.dg/pr44592.f90	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/pr44592.f90	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -0,0 +1,20 @@
+! { dg-do run }
+! { dg-options "-O3" }
+! From forall_12.f90
+! Fails with loop reversal at -O3
+!
+  character(len=1) :: b(4) = (/"1","2","3","4"/), c(4)
+  c = b
+  i = 1
+  ! This statement must be here for the abort below
+  b(1:3)(i:i) = b(2:4)(i:i)
+
+  b = c
+  b(4:2:-1)(i:i) = b(3:1:-1)(i:i)
+
+  ! This fails.  If the condition is printed, the result is F F F F
+  if (any (b .ne. (/"1","1","2","3"/))) i = 2
+  print *, b
+  print *, b .ne. (/"1","1","2","3"/)
+  if (i == 2) call abort
+end
Index: gcc/testsuite/gfortran.dg/userdef_operator_2.f90
===================================================================
--- gcc/testsuite/gfortran.dg/userdef_operator_2.f90	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/userdef_operator_2.f90	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -0,0 +1,17 @@
+! { dg-do compile }
+! PR 45338 - no ICE when cmp is not used explicitly.
+! Test case by Simon Smart 
+module test_mod
+  implicit none
+contains
+  subroutine test_fn (cmp)
+    interface operator(.myop.)
+       pure function cmp (a, b) result(ret)
+         integer, intent(in) :: a, b
+         logical ret
+       end function cmp
+    end interface
+    integer :: a, b
+    print*, a .myop. b
+  end subroutine test_fn
+end module test_mod
Index: gcc/testsuite/gfortran.dg/array_constructor_33.f90
===================================================================
--- gcc/testsuite/gfortran.dg/array_constructor_33.f90	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/testsuite/gfortran.dg/array_constructor_33.f90	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -1,4 +1,5 @@
 ! { dg-do compile }
+! { dg-timeout-factor 4 }
 ! PR20923 gfortran slow for large array constructors.
 ! Test case prepared from PR by Jerry DeLisle <jvdelisle@gcc.gnu.org>
 program sel
Index: gcc/testsuite/gfortran.dg/pr46804.f90
===================================================================
--- gcc/testsuite/gfortran.dg/pr46804.f90	(.../tags/gcc_4_5_2_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/pr46804.f90	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -0,0 +1,36 @@
+! PR rtl-optimization/46804
+! { dg-do run }
+! { dg-options "-O -fPIC -fexpensive-optimizations -fgcse -foptimize-register-move -fpeel-loops -fno-tree-loop-optimize" }
+
+program main
+  integer, parameter :: n1 = 2, n2 = 3, n3 = 4, slen = 3
+  character (len = slen), dimension (n1, n2, n3) :: a
+  integer (kind = 1), dimension (2, 4) :: shift1
+  integer (kind = 2), dimension (2, 4) :: shift2
+  integer (kind = 4), dimension (2, 4) :: shift3
+  do i3 = 1, n3
+    do i2 = 1, n2
+      do i1 = 1, n1
+        a (i1, i2, i3) = 'ab'(i1:i1) // 'cde'(i2:i2) // 'fghi'(i3:i3)
+      end do
+    end do
+  end do
+  shift1 (1, :) = (/ 4, 11, 19, 20 /)
+  shift1 (2, :) = (/ 55, 5, 1, 2 /)
+  shift2 = shift1
+  shift3 = shift1
+  call test (cshift (a, shift2, 2))
+  call test (cshift (a, shift3, 2))
+contains
+  subroutine test (b)
+    character (len = slen), dimension (n1, n2, n3) :: b
+    do i3 = 1, n3
+      do i2 = 1, n2
+        do i1 = 1, n1
+          i2p = mod (shift1 (i1, i3) + i2 - 1, n2) + 1
+          if (b (i1, i2, i3) .ne. a (i1, i2p, i3)) call abort
+        end do
+      end do
+    end do
+  end subroutine test
+end program main
Index: gcc/testsuite/gfortran.dg/power2.f90
===================================================================
--- gcc/testsuite/gfortran.dg/power2.f90	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/testsuite/gfortran.dg/power2.f90	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -13,6 +13,9 @@
   INTEGER(KIND=1) :: k1
   INTEGER(KIND=2) :: k2
 
+  k1 = 1_1
+  k2 = 1_2
+
   k1 = 1_1 + 1_1**k1
   k2 = 1_2 + 1_2**k2
 
Index: gcc/tree-ssa-copyrename.c
===================================================================
--- gcc/tree-ssa-copyrename.c	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/tree-ssa-copyrename.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -225,11 +225,16 @@
       ign2 = false;
     }
 
-  /* Don't coalesce if the two variables are not of the same type.  */
-  if (TREE_TYPE (root1) != TREE_TYPE (root2))
+  /* Don't coalesce if the two variables aren't type compatible .  */
+  if (!types_compatible_p (TREE_TYPE (root1), TREE_TYPE (root2))
+      /* There is a disconnect between the middle-end type-system and
+         VRP, avoid coalescing enum types with different bounds.  */
+      || ((TREE_CODE (TREE_TYPE (root1)) == ENUMERAL_TYPE
+	   || TREE_CODE (TREE_TYPE (root2)) == ENUMERAL_TYPE)
+	  && TREE_TYPE (root1) != TREE_TYPE (root2)))
     {
       if (debug)
-	fprintf (debug, " : Different types.  No coalesce.\n");
+	fprintf (debug, " : Incompatible types.  No coalesce.\n");
       return false;
     }
 
Index: gcc/tree-ssa-ccp.c
===================================================================
--- gcc/tree-ssa-ccp.c	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/tree-ssa-ccp.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -3355,7 +3355,9 @@
    is replaced.  If the call is expected to produces a result, then it
    is replaced by an assignment of the new RHS to the result variable.
    If the result is to be ignored, then the call is replaced by a
-   GIMPLE_NOP.  */
+   GIMPLE_NOP.  A proper VDEF chain is retained by making the first
+   VUSE and the last VDEF of the whole sequence be the same as the replaced
+   statement and using new SSA names for stores in between.  */
 
 static void
 gimplify_and_update_call_from_tree (gimple_stmt_iterator *si_p, tree expr)
@@ -3366,17 +3368,36 @@
   gimple_stmt_iterator i;
   gimple_seq stmts = gimple_seq_alloc();
   struct gimplify_ctx gctx;
+  gimple last = NULL;
+  gimple laststore = NULL;
+  tree reaching_vuse;
 
   stmt = gsi_stmt (*si_p);
 
   gcc_assert (is_gimple_call (stmt));
 
   lhs = gimple_call_lhs (stmt);
+  reaching_vuse = gimple_vuse (stmt);
 
   push_gimplify_context (&gctx);
 
   if (lhs == NULL_TREE)
-    gimplify_and_add (expr, &stmts);
+    {
+      gimplify_and_add (expr, &stmts);
+      /* We can end up with folding a memcpy of an empty class assignment
+	 which gets optimized away by C++ gimplification.  */
+      if (gimple_seq_empty_p (stmts))
+	{
+	  pop_gimplify_context (NULL);
+	  if (gimple_in_ssa_p (cfun))
+	    {
+	      unlink_stmt_vdef (stmt);
+	      release_defs (stmt);
+	    }
+	  gsi_remove (si_p, true);
+	  return;
+	}
+    }
   else
     tmp = get_initialized_tmp_var (expr, &stmts, NULL);
 
@@ -3387,26 +3408,95 @@
 
   /* The replacement can expose previously unreferenced variables.  */
   for (i = gsi_start (stmts); !gsi_end_p (i); gsi_next (&i))
-  {
-    new_stmt = gsi_stmt (i);
-    find_new_referenced_vars (new_stmt);
-    gsi_insert_before (si_p, new_stmt, GSI_NEW_STMT);
-    mark_symbols_for_renaming (new_stmt);
-    gsi_next (si_p);
-  }
+    {
+      if (last)
+	{
+	  gsi_insert_before (si_p, last, GSI_NEW_STMT);
+	  gsi_next (si_p);
+	}
+      new_stmt = gsi_stmt (i);
+      if (gimple_in_ssa_p (cfun))
+	{
+	  find_new_referenced_vars (new_stmt);
+	  mark_symbols_for_renaming (new_stmt);
+	}
+      /* If the new statement has a VUSE, update it with exact SSA name we
+         know will reach this one.  */
+      if (gimple_vuse (new_stmt))
+	{
+	  /* If we've also seen a previous store create a new VDEF for
+	     the latter one, and make that the new reaching VUSE.  */
+	  if (laststore)
+	    {
+	      reaching_vuse = make_ssa_name (gimple_vop (cfun), laststore);
+	      gimple_set_vdef (laststore, reaching_vuse);
+	      update_stmt (laststore);
+	      laststore = NULL;
+	    }
+	  gimple_set_vuse (new_stmt, reaching_vuse);
+	  gimple_set_modified (new_stmt, true);
+	}
+      if (gimple_assign_single_p (new_stmt)
+	  && !is_gimple_reg (gimple_assign_lhs (new_stmt)))
+	{
+	  laststore = new_stmt;
+	}
+      last = new_stmt;
+    }
 
   if (lhs == NULL_TREE)
     {
-      new_stmt = gimple_build_nop ();
-      unlink_stmt_vdef (stmt);
-      release_defs (stmt);
+      /* If we replace a call without LHS that has a VDEF and our new
+         sequence ends with a store we must make that store have the same
+	 vdef in order not to break the sequencing.  This can happen
+	 for instance when folding memcpy calls into assignments.  */
+      if (gimple_vdef (stmt) && laststore)
+	{
+	  gimple_set_vdef (laststore, gimple_vdef (stmt));
+	  if (TREE_CODE (gimple_vdef (stmt)) == SSA_NAME)
+	    SSA_NAME_DEF_STMT (gimple_vdef (stmt)) = laststore;
+	  update_stmt (laststore);
+	}
+      else if (gimple_in_ssa_p (cfun))
+	{
+	  unlink_stmt_vdef (stmt);
+	  release_defs (stmt);
+	}
+      new_stmt = last;
     }
   else
     {
+      if (last)
+	{
+	  gsi_insert_before (si_p, last, GSI_NEW_STMT);
+	  gsi_next (si_p);
+	}
+      if (laststore && is_gimple_reg (lhs))
+	{
+	  gimple_set_vdef (laststore, gimple_vdef (stmt));
+	  update_stmt (laststore);
+	  if (TREE_CODE (gimple_vdef (stmt)) == SSA_NAME)
+	    SSA_NAME_DEF_STMT (gimple_vdef (stmt)) = laststore;
+	  laststore = NULL;
+	}
+      else if (laststore)
+	{
+	  reaching_vuse = make_ssa_name (gimple_vop (cfun), laststore);
+	  gimple_set_vdef (laststore, reaching_vuse);
+	  update_stmt (laststore);
+	  laststore = NULL;
+	}
       new_stmt = gimple_build_assign (lhs, tmp);
-      gimple_set_vuse (new_stmt, gimple_vuse (stmt));
-      gimple_set_vdef (new_stmt, gimple_vdef (stmt));
-      move_ssa_defining_stmt_for_defs (new_stmt, stmt);
+      if (!is_gimple_reg (tmp))
+	gimple_set_vuse (new_stmt, reaching_vuse);
+      if (!is_gimple_reg (lhs))
+	{
+	  gimple_set_vdef (new_stmt, gimple_vdef (stmt));
+	  if (TREE_CODE (gimple_vdef (stmt)) == SSA_NAME)
+	    SSA_NAME_DEF_STMT (gimple_vdef (stmt)) = new_stmt;
+	}
+      else if (reaching_vuse == gimple_vuse (stmt))
+	unlink_stmt_vdef (stmt);
     }
 
   gimple_set_location (new_stmt, gimple_location (stmt));
Index: gcc/xcoffout.c
===================================================================
--- gcc/xcoffout.c	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/xcoffout.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -81,8 +81,15 @@
 #define ASM_OUTPUT_LINE(FILE,LINENUM)					   \
   do									   \
     {									   \
+      /* Make sure we're in a function and prevent output of .line 0, as   \
+	 line # 0 is meant for symbol addresses in xcoff.  Additionally,   \
+	 line numbers are 'unsigned short' in 32-bit mode.  */		   \
       if (xcoff_begin_function_line >= 0)				   \
-	fprintf (FILE, "\t.line\t%d\n", ABS_OR_RELATIVE_LINENO (LINENUM)); \
+	{								   \
+	  int lno = ABS_OR_RELATIVE_LINENO (LINENUM);			   \
+	  if (lno > 0 && (TARGET_64BIT || lno <= (int)USHRT_MAX))	   \
+	    fprintf (FILE, "\t.line\t%d\n", lno);			   \
+	}								   \
     }									   \
   while (0)
 
Index: gcc/jump.c
===================================================================
--- gcc/jump.c	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/jump.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -194,7 +194,7 @@
   rtx prev_nonjump_insn = NULL;
 
   for (insn = f; insn; insn = NEXT_INSN (insn))
-    if (INSN_P (insn))
+    if (NONDEBUG_INSN_P (insn))
       {
 	mark_jump_label (PATTERN (insn), insn, 0);
 
@@ -1728,7 +1728,13 @@
 
 	case 'i':
 	  if (XINT (x, i) != XINT (y, i))
-	    return 0;
+	    {
+	      if (((code == ASM_OPERANDS && i == 6)
+		   || (code == ASM_INPUT && i == 1))
+		  && locator_eq (XINT (x, i), XINT (y, i)))
+		break;
+	      return 0;
+	    }
 	  break;
 
 	case 't':
Index: gcc/expr.c
===================================================================
--- gcc/expr.c	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/expr.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -4730,7 +4730,10 @@
       /* If store_expr stores a DECL whose DECL_RTL(exp) == TARGET,
 	 but TARGET is not valid memory reference, TEMP will differ
 	 from TARGET although it is really the same location.  */
-      && !(alt_rtl && rtx_equal_p (alt_rtl, target))
+      && !(alt_rtl
+	   && rtx_equal_p (alt_rtl, target)
+	   && !side_effects_p (alt_rtl)
+	   && !side_effects_p (target))
       /* If there's nothing to copy, don't bother.  Don't call
 	 expr_size unless necessary, because some front-ends (C++)
 	 expr_size-hook must not be given objects that are not
Index: gcc/ada/ChangeLog
===================================================================
--- gcc/ada/ChangeLog	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/ada/ChangeLog	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -1,3 +1,9 @@
+2011-01-04  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/trans.c (Subprogram_Body_to_gnu): Evaluate the
+	expressions of the parameter cache within the statement group of
+	the CICO mechanism.
+
 2010-12-16  Release Manager
 
 	* GCC 4.5.2 released.
Index: gcc/ada/gcc-interface/trans.c
===================================================================
--- gcc/ada/gcc-interface/trans.c	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/ada/gcc-interface/trans.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -2303,6 +2303,31 @@
   gnat_poplevel ();
   gnu_result = end_stmt_group ();
 
+  /* If we populated the parameter attributes cache, we need to make sure that
+     the cached expressions are evaluated on all the possible paths leading to
+     their uses.  So we force their evaluation on entry of the function.  */
+  cache = DECL_STRUCT_FUNCTION (gnu_subprog_decl)->language->parm_attr_cache;
+  if (cache)
+    {
+      struct parm_attr_d *pa;
+      int i;
+
+      start_stmt_group ();
+
+      for (i = 0; VEC_iterate (parm_attr, cache, i, pa); i++)
+	{
+	  if (pa->first)
+	    add_stmt_with_node (pa->first, gnat_node);
+	  if (pa->last)
+	    add_stmt_with_node (pa->last, gnat_node);
+	  if (pa->length)
+	    add_stmt_with_node (pa->length, gnat_node);
+	}
+
+      add_stmt (gnu_result);
+      gnu_result = end_stmt_group ();
+    }
+
   /* If we are dealing with a return from an Ada procedure with parameters
      passed by copy-in/copy-out, we need to return a record containing the
      final values of these parameters.  If the list contains only one entry,
@@ -2341,30 +2366,6 @@
 
   pop_stack (&gnu_return_label_stack);
 
-  /* If we populated the parameter attributes cache, we need to make sure
-     that the cached expressions are evaluated on all possible paths.  */
-  cache = DECL_STRUCT_FUNCTION (gnu_subprog_decl)->language->parm_attr_cache;
-  if (cache)
-    {
-      struct parm_attr_d *pa;
-      int i;
-
-      start_stmt_group ();
-
-      for (i = 0; VEC_iterate (parm_attr, cache, i, pa); i++)
-	{
-	  if (pa->first)
-	    add_stmt_with_node (pa->first, gnat_node);
-	  if (pa->last)
-	    add_stmt_with_node (pa->last, gnat_node);
-	  if (pa->length)
-	    add_stmt_with_node (pa->length, gnat_node);
-	}
-
-      add_stmt (gnu_result);
-      gnu_result = end_stmt_group ();
-    }
-
   /* Set the end location.  */
   Sloc_to_locus
     ((Present (End_Label (Handled_Statement_Sequence (gnat_node)))
Index: gcc/fortran/trans-array.c
===================================================================
--- gcc/fortran/trans-array.c	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/fortran/trans-array.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -3389,7 +3389,38 @@
     }
 }
 
+/* Return true if both symbols could refer to the same data object.  Does
+   not take account of aliasing due to equivalence statements.  */
 
+static int
+symbols_could_alias (gfc_symbol *lsym, gfc_symbol *rsym, bool lsym_pointer,
+		     bool lsym_target, bool rsym_pointer, bool rsym_target)
+{
+  /* Aliasing isn't possible if the symbols have different base types.  */
+  if (gfc_compare_types (&lsym->ts, &rsym->ts) == 0)
+    return 0;
+
+  /* Pointers can point to other pointers and target objects.  */
+
+  if ((lsym_pointer && (rsym_pointer || rsym_target))
+      || (rsym_pointer && (lsym_pointer || lsym_target)))
+    return 1;
+
+  /* Special case: Argument association, cf. F90 12.4.1.6, F2003 12.4.1.7
+     and F2008 12.5.2.13 items 3b and 4b. The pointer case (a) is already
+     checked above.  */
+  if (lsym->attr.target && rsym->attr.target
+      && ((lsym->attr.dummy
+	   && (!lsym->attr.dimension || lsym->as->type == AS_ASSUMED_SHAPE))
+	  || (rsym->attr.dummy
+	      && (!rsym->attr.dimension
+		  || rsym->as->type == AS_ASSUMED_SHAPE))))
+    return 1;
+
+  return 0;
+}
+
+
 /* Return true if the two SS could be aliased, i.e. both point to the same data
    object.  */
 /* TODO: resolve aliases based on frontend expressions.  */
@@ -3401,10 +3432,18 @@
   gfc_ref *rref;
   gfc_symbol *lsym;
   gfc_symbol *rsym;
+  bool lsym_pointer, lsym_target, rsym_pointer, rsym_target;
 
   lsym = lss->expr->symtree->n.sym;
   rsym = rss->expr->symtree->n.sym;
-  if (gfc_symbols_could_alias (lsym, rsym))
+
+  lsym_pointer = lsym->attr.pointer;
+  lsym_target = lsym->attr.target;
+  rsym_pointer = rsym->attr.pointer;
+  rsym_target = rsym->attr.target;
+
+  if (symbols_could_alias (lsym, rsym, lsym_pointer, lsym_target,
+			   rsym_pointer, rsym_target))
     return 1;
 
   if (rsym->ts.type != BT_DERIVED
@@ -3419,27 +3458,75 @@
       if (lref->type != REF_COMPONENT)
 	continue;
 
-      if (gfc_symbols_could_alias (lref->u.c.sym, rsym))
+      lsym_pointer = lsym_pointer || lref->u.c.sym->attr.pointer;
+      lsym_target  = lsym_target  || lref->u.c.sym->attr.target;
+
+      if (symbols_could_alias (lref->u.c.sym, rsym, lsym_pointer, lsym_target,
+			       rsym_pointer, rsym_target))
 	return 1;
 
+      if ((lsym_pointer && (rsym_pointer || rsym_target))
+	  || (rsym_pointer && (lsym_pointer || lsym_target)))
+	{
+	  if (gfc_compare_types (&lref->u.c.component->ts,
+				 &rsym->ts))
+	    return 1;
+	}
+
       for (rref = rss->expr->ref; rref != rss->data.info.ref;
 	   rref = rref->next)
 	{
 	  if (rref->type != REF_COMPONENT)
 	    continue;
 
-	  if (gfc_symbols_could_alias (lref->u.c.sym, rref->u.c.sym))
+	  rsym_pointer = rsym_pointer || rref->u.c.sym->attr.pointer;
+	  rsym_target  = lsym_target  || rref->u.c.sym->attr.target;
+
+	  if (symbols_could_alias (lref->u.c.sym, rref->u.c.sym,
+				   lsym_pointer, lsym_target,
+				   rsym_pointer, rsym_target))
 	    return 1;
+
+	  if ((lsym_pointer && (rsym_pointer || rsym_target))
+	      || (rsym_pointer && (lsym_pointer || lsym_target)))
+	    {
+	      if (gfc_compare_types (&lref->u.c.component->ts,
+				     &rref->u.c.sym->ts))
+		return 1;
+	      if (gfc_compare_types (&lref->u.c.sym->ts,
+				     &rref->u.c.component->ts))
+		return 1;
+	      if (gfc_compare_types (&lref->u.c.component->ts,
+				     &rref->u.c.component->ts))
+		return 1;
+	    }
 	}
     }
 
+  lsym_pointer = lsym->attr.pointer;
+  lsym_target = lsym->attr.target;
+  lsym_pointer = lsym->attr.pointer;
+  lsym_target = lsym->attr.target;
+
   for (rref = rss->expr->ref; rref != rss->data.info.ref; rref = rref->next)
     {
       if (rref->type != REF_COMPONENT)
 	break;
 
-      if (gfc_symbols_could_alias (rref->u.c.sym, lsym))
+      rsym_pointer = rsym_pointer || rref->u.c.sym->attr.pointer;
+      rsym_target  = lsym_target  || rref->u.c.sym->attr.target;
+
+      if (symbols_could_alias (rref->u.c.sym, lsym,
+			       lsym_pointer, lsym_target,
+			       rsym_pointer, rsym_target))
 	return 1;
+
+      if ((lsym_pointer && (rsym_pointer || rsym_target))
+	  || (rsym_pointer && (lsym_pointer || lsym_target)))
+	{
+	  if (gfc_compare_types (&lsym->ts, &rref->u.c.component->ts))
+	    return 1;
+	}
     }
 
   return 0;
Index: gcc/fortran/symbol.c
===================================================================
--- gcc/fortran/symbol.c	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/fortran/symbol.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -2733,41 +2733,6 @@
   return i;
 }
 
-/* Return true if both symbols could refer to the same data object.  Does
-   not take account of aliasing due to equivalence statements.  */
-
-int
-gfc_symbols_could_alias (gfc_symbol *lsym, gfc_symbol *rsym)
-{
-  /* Aliasing isn't possible if the symbols have different base types.  */
-  if (gfc_compare_types (&lsym->ts, &rsym->ts) == 0)
-    return 0;
-
-  /* Pointers can point to other pointers, target objects and allocatable
-     objects.  Two allocatable objects cannot share the same storage.  */
-  if (lsym->attr.pointer
-      && (rsym->attr.pointer || rsym->attr.allocatable || rsym->attr.target))
-    return 1;
-  if (lsym->attr.target && rsym->attr.pointer)
-    return 1;
-  if (lsym->attr.allocatable && rsym->attr.pointer)
-    return 1;
-
-  /* Special case: Argument association, cf. F90 12.4.1.6, F2003 12.4.1.7
-     and F2008 12.5.2.13 items 3b and 4b. The pointer case (a) is already
-     checked above.  */
-  if (lsym->attr.target && rsym->attr.target
-      && ((lsym->attr.dummy
-	   && (!lsym->attr.dimension || lsym->as->type == AS_ASSUMED_SHAPE))
-	  || (rsym->attr.dummy
-	      && (!rsym->attr.dimension
-		  || rsym->as->type == AS_ASSUMED_SHAPE))))
-    return 1;
-
-  return 0;
-}
-
-
 /* Undoes all the changes made to symbols in the current statement.
    This subroutine is made simpler due to the fact that attributes are
    never removed once added.  */
Index: gcc/fortran/trans-openmp.c
===================================================================
--- gcc/fortran/trans-openmp.c	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/fortran/trans-openmp.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -480,13 +480,23 @@
   gfc_symbol init_val_sym, outer_sym, intrinsic_sym;
   gfc_expr *e1, *e2, *e3, *e4;
   gfc_ref *ref;
-  tree decl, backend_decl, stmt;
+  tree decl, backend_decl, stmt, type, outer_decl;
   locus old_loc = gfc_current_locus;
   const char *iname;
   gfc_try t;
 
   decl = OMP_CLAUSE_DECL (c);
   gfc_current_locus = where;
+  type = TREE_TYPE (decl);
+  outer_decl = create_tmp_var_raw (type, NULL);
+  if (TREE_CODE (decl) == PARM_DECL
+      && TREE_CODE (type) == REFERENCE_TYPE
+      && GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (type))
+      && GFC_TYPE_ARRAY_AKIND (TREE_TYPE (type)) == GFC_ARRAY_ALLOCATABLE)
+    {
+      decl = build_fold_indirect_ref (decl);
+      type = TREE_TYPE (type);
+    }
 
   /* Create a fake symbol for init value.  */
   memset (&init_val_sym, 0, sizeof (init_val_sym));
@@ -505,7 +515,9 @@
   outer_sym.attr.dummy = 0;
   outer_sym.attr.result = 0;
   outer_sym.attr.flavor = FL_VARIABLE;
-  outer_sym.backend_decl = create_tmp_var_raw (TREE_TYPE (decl), NULL);
+  outer_sym.backend_decl = outer_decl;
+  if (decl != OMP_CLAUSE_DECL (c))
+    outer_sym.backend_decl = build_fold_indirect_ref (outer_decl);
 
   /* Create fake symtrees for it.  */
   symtree1 = gfc_new_symtree (&root1, sym->name);
@@ -622,12 +634,12 @@
 
   /* Create the init statement list.  */
   pushlevel (0);
-  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (decl))
-      && GFC_TYPE_ARRAY_AKIND (TREE_TYPE (decl)) == GFC_ARRAY_ALLOCATABLE)
+  if (GFC_DESCRIPTOR_TYPE_P (type)
+      && GFC_TYPE_ARRAY_AKIND (type) == GFC_ARRAY_ALLOCATABLE)
     {
       /* If decl is an allocatable array, it needs to be allocated
 	 with the same bounds as the outer var.  */
-      tree type = TREE_TYPE (decl), rank, size, esize, ptr;
+      tree rank, size, esize, ptr;
       stmtblock_t block;
 
       gfc_start_block (&block);
@@ -663,8 +675,8 @@
 
   /* Create the merge statement list.  */
   pushlevel (0);
-  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (decl))
-      && GFC_TYPE_ARRAY_AKIND (TREE_TYPE (decl)) == GFC_ARRAY_ALLOCATABLE)
+  if (GFC_DESCRIPTOR_TYPE_P (type)
+      && GFC_TYPE_ARRAY_AKIND (type) == GFC_ARRAY_ALLOCATABLE)
     {
       /* If decl is an allocatable array, it needs to be deallocated
 	 afterwards.  */
@@ -684,7 +696,7 @@
   OMP_CLAUSE_REDUCTION_MERGE (c) = stmt;
 
   /* And stick the placeholder VAR_DECL into the clause as well.  */
-  OMP_CLAUSE_REDUCTION_PLACEHOLDER (c) = outer_sym.backend_decl;
+  OMP_CLAUSE_REDUCTION_PLACEHOLDER (c) = outer_decl;
 
   gfc_current_locus = old_loc;
 
Index: gcc/fortran/gfortran.h
===================================================================
--- gcc/fortran/gfortran.h	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/fortran/gfortran.h	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -2483,8 +2483,6 @@
 int gfc_get_ha_symbol (const char *, gfc_symbol **);
 int gfc_get_ha_sym_tree (const char *, gfc_symtree **);
 
-int gfc_symbols_could_alias (gfc_symbol *, gfc_symbol *);
-
 void gfc_undo_symbols (void);
 void gfc_commit_symbols (void);
 void gfc_commit_symbol (gfc_symbol *);
Index: gcc/fortran/error.c
===================================================================
--- gcc/fortran/error.c	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/fortran/error.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -939,7 +939,7 @@
   buffer_flag = i;
 
   if (flag_fatal_errors)
-    exit (1);
+    exit (FATAL_EXIT_CODE);
 }
 
 
@@ -956,7 +956,7 @@
   error_print (_("Fatal Error:"), _(gmsgid), argp);
   va_end (argp);
 
-  exit (3);
+  exit (FATAL_EXIT_CODE);
 }
 
 
@@ -1019,7 +1019,7 @@
       gfc_increment_error_count();
 
       if (flag_fatal_errors)
-	exit (1);
+	exit (FATAL_EXIT_CODE);
     }
 
   return rc;
Index: gcc/fortran/ChangeLog
===================================================================
--- gcc/fortran/ChangeLog	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/fortran/ChangeLog	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -1,3 +1,42 @@
+2011-01-21  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/47394
+	* error.c (gfc_error_now, gfc_fatal_error, gfc_error_check):
+	Use defined instead of magic number exit status codes.
+	* scanner.c (include_line, gfc_new_file): Ditto.
+	* gfortranspec.c (lang_specific_driver): Ditto.
+
+2011-01-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline
+	2010-12-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/46874
+	* trans-openmp.c (gfc_trans_omp_array_reduction): Handle allocatable
+	dummy variables.
+
+2011-01-16  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/45777
+	* symbol.c (gfc_symbols_could_alias):  Strip gfc_ prefix,
+	make static and move in front of its only caller, to ...
+	* trans-array.c (symbols_could_alias): ... here.
+	Pass information about pointer and target status as
+	arguments.  Allocatable arrays don't alias anything
+	unless they have the POINTER attribute.
+	(gfc_could_be_alias):  Keep track of pointer and target
+	status when following references.  Also check if typespecs
+	of components match those of other components or symbols.
+	* gfortran.h:  Remove prototype for gfc_symbols_could_alias.
+
+2011-01-02  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from mainline
+	PR fortran/45338
+	* resolve.c (resolve_operator):  Mark function for user-defined
+	operator as referenced.
+
 2010-12-16  Release Manager
 
 	* GCC 4.5.2 released.
Index: gcc/fortran/scanner.c
===================================================================
--- gcc/fortran/scanner.c	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/fortran/scanner.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -1841,7 +1841,7 @@
 
   filename = gfc_widechar_to_char (begin, -1);
   if (load_file (filename, NULL, false) == FAILURE)
-    exit (1);
+    exit (FATAL_EXIT_CODE);
 
   gfc_free (filename);
   return true;
@@ -2045,7 +2045,7 @@
     printf ("%s:%3d %s\n", LOCATION_FILE (line_head->location),
 	    LOCATION_LINE (line_head->location), line_head->line);
 
-  exit (0);
+  exit (SUCCESS_EXIT_CODE);
 #endif
 
   return result;
Index: gcc/fortran/gfortranspec.c
===================================================================
--- gcc/fortran/gfortranspec.c	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/fortran/gfortranspec.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -375,7 +375,7 @@
 You may redistribute copies of GNU Fortran\n\
 under the terms of the GNU General Public License.\n\
 For more information about these matters, see the file named COPYING\n\n"));
-	  exit (0);
+	  exit (SUCCESS_EXIT_CODE);
 	  break;
 
 	case OPTION_help:
Index: gcc/fortran/resolve.c
===================================================================
--- gcc/fortran/resolve.c	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/fortran/resolve.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -3577,9 +3577,12 @@
 	sprintf (msg, _("Operand of user operator '%s' at %%L is %s"),
 		 e->value.op.uop->name, gfc_typename (&op1->ts));
       else
-	sprintf (msg, _("Operands of user operator '%s' at %%L are %s/%s"),
-		 e->value.op.uop->name, gfc_typename (&op1->ts),
-		 gfc_typename (&op2->ts));
+	{
+	  sprintf (msg, _("Operands of user operator '%s' at %%L are %s/%s"),
+		   e->value.op.uop->name, gfc_typename (&op1->ts),
+		   gfc_typename (&op2->ts));
+	  e->value.op.uop->op->sym->attr.referenced = 1;
+	}
 
       goto bad_op;
 
Index: gcc/regmove.c
===================================================================
--- gcc/regmove.c	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/regmove.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -513,7 +513,7 @@
   rtx src_reg = XEXP (src, 0);
   int src_no = REGNO (src_reg);
   int dst_no = REGNO (dest);
-  rtx p, set;
+  rtx p, set, set_insn;
   enum machine_mode old_mode;
   basic_block bb = BLOCK_FOR_INSN (insn);
 
@@ -551,6 +551,7 @@
 				 GET_MODE_BITSIZE (GET_MODE (src_reg))))
     return;
 
+  set_insn = p;
   old_mode = GET_MODE (src_reg);
   PUT_MODE (src_reg, GET_MODE (src));
   XEXP (src, 0) = SET_SRC (set);
@@ -583,9 +584,19 @@
     }
   else
     {
-      rtx note = find_reg_note (p, REG_EQUAL, NULL_RTX);
+      rtx note = find_reg_note (set_insn, REG_EQUAL, NULL_RTX);
       if (note)
-	remove_note (p, note);
+	{
+	  if (rtx_equal_p (XEXP (note, 0), XEXP (src, 0)))
+	    {
+	      XEXP (note, 0)
+		= gen_rtx_fmt_e (GET_CODE (src), GET_MODE (src),
+				 XEXP (note, 0));
+	      df_notes_rescan (set_insn);
+	    }
+	  else
+	    remove_note (set_insn, note);
+	}
     }
 }
 
Index: gcc/BASE-VER
===================================================================
--- gcc/BASE-VER	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/BASE-VER	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -1 +1 @@
-4.5.2
+4.5.3
Index: gcc/tree-data-ref.c
===================================================================
--- gcc/tree-data-ref.c	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/tree-data-ref.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -4594,7 +4594,7 @@
     for (e = v->succ; e; e = e->succ_next)
       fprintf (file, " %d", e->dest);
 
-  fprintf (file, ") \n");
+  fprintf (file, ")\n");
   print_gimple_stmt (file, RDGV_STMT (v), 0, TDF_VOPS|TDF_MEMSYMS);
   fprintf (file, ")\n");
 }
@@ -4991,6 +4991,38 @@
   free (bbs);
 }
 
+/* Returns true when the statement at STMT is of the form "A[i] = 0"
+   that contains a data reference on its LHS with a stride of the same
+   size as its unit type.  */
+
+bool
+stmt_with_adjacent_zero_store_dr_p (gimple stmt)
+{
+  tree op0, op1;
+  bool res;
+  struct data_reference *dr;
+
+  if (!stmt
+      || !gimple_vdef (stmt)
+      || !is_gimple_assign (stmt)
+      || !gimple_assign_single_p (stmt)
+      || !(op1 = gimple_assign_rhs1 (stmt))
+      || !(integer_zerop (op1) || real_zerop (op1)))
+    return false;
+
+  dr = XCNEW (struct data_reference);
+  op0 = gimple_assign_lhs (stmt);
+
+  DR_STMT (dr) = stmt;
+  DR_REF (dr) = op0;
+
+  res = dr_analyze_innermost (dr)
+    && stride_of_unit_type_p (DR_STEP (dr), TREE_TYPE (op0));
+
+  free_data_ref (dr);
+  return res;
+}
+
 /* For a data reference REF, return the declaration of its base
    address or NULL_TREE if the base is not determined.  */
 
Index: gcc/tree-data-ref.h
===================================================================
--- gcc/tree-data-ref.h	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/tree-data-ref.h	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -567,7 +567,19 @@
 void remove_similar_memory_refs (VEC (gimple, heap) **);
 bool rdg_defs_used_in_other_loops_p (struct graph *, int);
 bool have_similar_memory_accesses (gimple, gimple);
+bool stmt_with_adjacent_zero_store_dr_p (gimple);
 
+/* Returns true when STRIDE is equal in absolute value to the size of
+   the unit type of TYPE.  */
+
+static inline bool
+stride_of_unit_type_p (tree stride, tree type)
+{
+  return tree_int_cst_equal (fold_unary (ABS_EXPR, TREE_TYPE (stride),
+					 stride),
+			     TYPE_SIZE_UNIT (type));
+}
+
 /* Determines whether RDG vertices V1 and V2 access to similar memory
    locations, in which case they have to be in the same partition.  */
 
Index: gcc/c-typeck.c
===================================================================
--- gcc/c-typeck.c	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/c-typeck.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -5025,10 +5025,10 @@
     {
       tree ret;
       bool save = in_late_binary_op;
-      if (codel == BOOLEAN_TYPE)
+      if (codel == BOOLEAN_TYPE || codel == COMPLEX_TYPE)
 	in_late_binary_op = true;
       ret = convert_and_check (type, orig_rhs);
-      if (codel == BOOLEAN_TYPE)
+      if (codel == BOOLEAN_TYPE || codel == COMPLEX_TYPE)
 	in_late_binary_op = save;
       return ret;
     }
Index: gcc/cfgexpand.c
===================================================================
--- gcc/cfgexpand.c	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/cfgexpand.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -2578,7 +2578,7 @@
 	    enum machine_mode opmode = GET_MODE (op0);
 
 	    if (opmode == VOIDmode)
-	      opmode = mode1;
+	      opmode = TYPE_MODE (TREE_TYPE (tem));
 
 	    /* This condition may hold if we're expanding the address
 	       right past the end of an array that turned out not to
@@ -2599,7 +2599,8 @@
 				     ? SIGN_EXTRACT
 				     : ZERO_EXTRACT, mode,
 				     GET_MODE (op0) != VOIDmode
-				     ? GET_MODE (op0) : mode1,
+				     ? GET_MODE (op0)
+				     : TYPE_MODE (TREE_TYPE (tem)),
 				     op0, GEN_INT (bitsize), GEN_INT (bitpos));
       }
 
Index: gcc/graphite.c
===================================================================
--- gcc/graphite.c	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/graphite.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -210,6 +210,7 @@
       return false;
     }
 
+  scev_reset ();
   recompute_all_dominators ();
   initialize_original_copy_tables ();
   cloog_initialize ();
Index: gcc/tree-ssa-pre.c
===================================================================
--- gcc/tree-ssa-pre.c	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/tree-ssa-pre.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -1701,7 +1701,7 @@
 	    tree result = vn_reference_lookup_pieces (newvuse, ref->set,
 						      ref->type,
 						      newoperands,
-						      &newref, true);
+						      &newref, VN_WALK);
 	    if (newref)
 	      VEC_free (vn_reference_op_s, heap, newoperands);
 
@@ -2558,6 +2558,10 @@
     {
       if (dump_file && (dump_flags & TDF_DETAILS))
 	fprintf (dump_file, "Starting iteration %d\n", num_iterations);
+      /* ???  We need to clear our PHI translation cache here as the
+         ANTIC sets shrink and we restrict valid translations to
+	 those having operands with leaders in ANTIC.  Same below
+	 for PA ANTIC computation.  */
       num_iterations++;
       changed = false;
       for (i = n_basic_blocks - NUM_FIXED_BLOCKS - 1; i >= 0; i--)
@@ -3965,7 +3969,7 @@
 		copy_reference_ops_from_call (stmt, &ops);
 		vn_reference_lookup_pieces (gimple_vuse (stmt), 0,
 					    gimple_expr_type (stmt),
-					    ops, &ref, false);
+					    ops, &ref, VN_NOWALK);
 		VEC_free (vn_reference_op_s, heap, ops);
 		if (!ref)
 		  continue;
@@ -4035,7 +4039,7 @@
 
 		      vn_reference_lookup (gimple_assign_rhs1 (stmt),
 					   gimple_vuse (stmt),
-					   true, &ref);
+					   VN_WALK, &ref);
 		      if (!ref)
 			continue;
 
@@ -4265,7 +4269,7 @@
 	      tree rhs = gimple_assign_rhs1 (stmt);
 	      tree val;
 	      val = vn_reference_lookup (gimple_assign_lhs (stmt),
-					 gimple_vuse (stmt), true, NULL);
+					 gimple_vuse (stmt), VN_WALK, NULL);
 	      if (TREE_CODE (rhs) == SSA_NAME)
 		rhs = VN_INFO (rhs)->valnum;
 	      if (val
Index: gcc/cfgcleanup.c
===================================================================
--- gcc/cfgcleanup.c	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/cfgcleanup.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -482,15 +482,20 @@
 		  /* When not optimizing, ensure that edges or forwarder
 		     blocks with different locus are not optimized out.  */
 		  int locus = single_succ_edge (target)->goto_locus;
+		  rtx last ;
 
 		  if (locus && goto_locus && !locator_eq (locus, goto_locus))
 		    counter = n_basic_blocks;
 		  else if (locus)
 		    goto_locus = locus;
 
-		  if (INSN_P (BB_END (target)))
+		  last = BB_END (target);
+		  if (DEBUG_INSN_P (last))
+		    last = prev_nondebug_insn (last);
+
+		  if (last && INSN_P (last))
 		    {
-		      locus = INSN_LOCATOR (BB_END (target));
+		      locus = INSN_LOCATOR (last);
 
 		      if (locus && goto_locus
 			  && !locator_eq (locus, goto_locus))
Index: gcc/tree-sra.c
===================================================================
--- gcc/tree-sra.c	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/tree-sra.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -3413,7 +3413,10 @@
 	  else if (ac2->size != access->size)
 	    return NULL;
 
-	  if (access_precludes_ipa_sra_p (ac2))
+	  if (access_precludes_ipa_sra_p (ac2)
+	      || (ac2->type != access->type
+		  && (TREE_ADDRESSABLE (ac2->type)
+		      || TREE_ADDRESSABLE (access->type))))
 	    return NULL;
 
 	  modification |= ac2->write;
Index: gcc/c-convert.c
===================================================================
--- gcc/c-convert.c	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/c-convert.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -131,6 +131,32 @@
       goto maybe_fold;
 
     case COMPLEX_TYPE:
+      /* If converting from COMPLEX_TYPE to a different COMPLEX_TYPE
+	 and e is not COMPLEX_EXPR, convert_to_complex uses save_expr,
+	 but for the C FE c_save_expr needs to be called instead.  */
+      if (TREE_CODE (TREE_TYPE (e)) == COMPLEX_TYPE)
+	{
+	  tree subtype = TREE_TYPE (type);
+	  tree elt_type = TREE_TYPE (TREE_TYPE (e));
+
+	  if (TYPE_MAIN_VARIANT (elt_type) != TYPE_MAIN_VARIANT (subtype)
+	      && TREE_CODE (e) != COMPLEX_EXPR)
+	    {
+	      if (in_late_binary_op)
+		e = save_expr (e);
+	      else
+		e = c_save_expr (e);
+	      ret
+		= fold_build2 (COMPLEX_EXPR, type,
+			       convert (subtype,
+					fold_build1 (REALPART_EXPR,
+						     elt_type, e)),
+			       convert (subtype,
+					fold_build1 (IMAGPART_EXPR,
+						     elt_type, e)));
+	      goto maybe_fold;
+	    }
+	}
       ret = convert_to_complex (type, e);
       goto maybe_fold;
 
Index: gcc/tree-ssa-ter.c
===================================================================
--- gcc/tree-ssa-ter.c	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/tree-ssa-ter.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -416,7 +416,9 @@
     return false;
 
   /* Without alias info we can't move around loads.  */
-  if (gimple_references_memory_p (stmt) && !optimize)
+  if (!optimize
+      && gimple_assign_single_p (stmt)
+      && !is_gimple_val (gimple_assign_rhs1 (stmt)))
     return false;
 
   /* Float expressions must go through memory if float-store is on.  */
Index: gcc/rtl.c
===================================================================
--- gcc/rtl.c	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/rtl.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -429,7 +429,15 @@
 	case 'n':
 	case 'i':
 	  if (XINT (x, i) != XINT (y, i))
-	    return 0;
+	    {
+#ifndef GENERATOR_FILE
+	      if (((code == ASM_OPERANDS && i == 6)
+		   || (code == ASM_INPUT && i == 1))
+		  && locator_eq (XINT (x, i), XINT (y, i)))
+		break;
+#endif
+	      return 0;
+	    }
 	  break;
 
 	case 'V':
@@ -549,7 +557,15 @@
 	case 'n':
 	case 'i':
 	  if (XINT (x, i) != XINT (y, i))
-	    return 0;
+	    {
+#ifndef GENERATOR_FILE
+	      if (((code == ASM_OPERANDS && i == 6)
+		   || (code == ASM_INPUT && i == 1))
+		  && locator_eq (XINT (x, i), XINT (y, i)))
+		break;
+#endif
+	      return 0;
+	    }
 	  break;
 
 	case 'V':
Index: gcc/graphite-sese-to-poly.c
===================================================================
--- gcc/graphite-sese-to-poly.c	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/graphite-sese-to-poly.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -715,7 +715,7 @@
       gcc_assert (TREE_CODE (e) == INTEGER_CST);
 
       value_init (val);
-      value_set_si (val, int_cst_value (e));
+      tree_int_to_gmp (e, val);
       add_value_to_dim (l, expr, val);
       value_clear (val);
     }
@@ -729,16 +729,13 @@
 {
   Value val;
   ppl_Coefficient_t coef;
-  int v = int_cst_value (cst);
+  tree type = TREE_TYPE (cst);
 
   value_init (val);
-  value_set_si (val, 0);
 
   /* Necessary to not get "-1 = 2^n - 1". */
-  if (v < 0)
-    value_sub_int (val, val, -v);
-  else
-    value_add_int (val, val, v);
+  mpz_set_double_int (val, double_int_sext (tree_to_double_int (cst),
+					    TYPE_PRECISION (type)), false);
 
   value_multiply (val, val, k);
   ppl_new_Coefficient (&coef);
@@ -816,7 +813,7 @@
 	      Value val;
 	      gcc_assert (host_integerp (TREE_OPERAND (e, 1), 0));
 	      value_init (val);
-	      value_set_si (val, int_cst_value (TREE_OPERAND (e, 1)));
+	      tree_int_to_gmp (TREE_OPERAND (e, 1), val);
 	      value_multiply (val, val, k);
 	      scan_tree_for_params (s, TREE_OPERAND (e, 0), c, val);
 	      value_clear (val);
@@ -831,7 +828,7 @@
 	      Value val;
 	      gcc_assert (host_integerp (TREE_OPERAND (e, 0), 0));
 	      value_init (val);
-	      value_set_si (val, int_cst_value (TREE_OPERAND (e, 0)));
+	      tree_int_to_gmp (TREE_OPERAND (e, 0), val);
 	      value_multiply (val, val, k);
 	      scan_tree_for_params (s, TREE_OPERAND (e, 1), c, val);
 	      value_clear (val);
@@ -1717,10 +1714,13 @@
       /* subscript - low >= 0 */
       if (host_integerp (low, 0))
 	{
+	  tree minus_low;
+
 	  ppl_new_Linear_Expression_with_dimension (&expr, accessp_nb_dims);
 	  ppl_set_coef (expr, subscript, 1);
 
-	  ppl_set_inhomogeneous (expr, -int_cst_value (low));
+	  minus_low = fold_build1 (NEGATE_EXPR, TREE_TYPE (low), low);
+	  ppl_set_inhomogeneous_tree (expr, minus_low);
 
 	  ppl_new_Constraint (&cstr, expr, PPL_CONSTRAINT_TYPE_GREATER_OR_EQUAL);
 	  ppl_Polyhedron_add_constraint (accesses, cstr);
@@ -1740,7 +1740,7 @@
 	  ppl_new_Linear_Expression_with_dimension (&expr, accessp_nb_dims);
 	  ppl_set_coef (expr, subscript, -1);
 
-	  ppl_set_inhomogeneous (expr, int_cst_value (high));
+	  ppl_set_inhomogeneous_tree (expr, high);
 
 	  ppl_new_Constraint (&cstr, expr, PPL_CONSTRAINT_TYPE_GREATER_OR_EQUAL);
 	  ppl_Polyhedron_add_constraint (accesses, cstr);
Index: gcc/tree-ssa-structalias.c
===================================================================
--- gcc/tree-ssa-structalias.c	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/tree-ssa-structalias.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -369,7 +369,11 @@
   ret->may_have_pointers = true;
   ret->is_global_var = (t == NULL_TREE);
   if (t && DECL_P (t))
-    ret->is_global_var = is_global_var (t);
+    ret->is_global_var = (is_global_var (t)
+			  /* We have to treat even local register variables
+			     as escape points.  */
+			  || (TREE_CODE (t) == VAR_DECL
+			      && DECL_HARD_REGISTER (t)));
   ret->solution = BITMAP_ALLOC (&pta_obstack);
   ret->oldsolution = BITMAP_ALLOC (&oldpta_obstack);
   ret->next = NULL;
Index: gcc/config/sparc/sparc.md
===================================================================
--- gcc/config/sparc/sparc.md	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/config/sparc/sparc.md	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -1106,14 +1106,15 @@
 
 ;; Load in operand 0 the (absolute) address of operand 1, which is a symbolic
 ;; value subject to a PC-relative relocation.  Operand 2 is a helper function
-;; that adds the PC value at the call point to operand 0.
+;; that adds the PC value at the call point to register #(operand 3).
 
 (define_insn "load_pcrel_sym<P:mode>"
   [(set (match_operand:P 0 "register_operand" "=r")
 	(unspec:P [(match_operand:P 1 "symbolic_operand" "")
-		   (match_operand:P 2 "call_address_operand" "")] UNSPEC_LOAD_PCREL_SYM))
+		   (match_operand:P 2 "call_address_operand" "")
+		   (match_operand:P 3 "const_int_operand" "")] UNSPEC_LOAD_PCREL_SYM))
    (clobber (reg:P 15))]
-  ""
+  "REGNO (operands[0]) == INTVAL (operands[3])"
 {
   if (flag_delayed_branch)
     return "sethi\t%%hi(%a1-4), %0\n\tcall\t%a2\n\t add\t%0, %%lo(%a1+4), %0";
Index: gcc/config/sparc/sparc.c
===================================================================
--- gcc/config/sparc/sparc.c	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/config/sparc/sparc.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -363,7 +363,7 @@
 static int epilogue_renumber (rtx *, int);
 static bool sparc_assemble_integer (rtx, unsigned int, int);
 static int set_extends (rtx);
-static void load_pic_register (void);
+static void load_got_register (void);
 static int save_or_restore_regs (int, int, rtx, int, int);
 static void emit_save_or_restore_regs (int);
 static void sparc_asm_function_prologue (FILE *, HOST_WIDE_INT);
@@ -966,6 +966,36 @@
   return 0;
 }
 
+/* Return true if the address of LABEL can be loaded by means of the
+   mov{si,di}_pic_label_ref patterns in PIC mode.  */
+
+static bool
+can_use_mov_pic_label_ref (rtx label)
+{
+  /* VxWorks does not impose a fixed gap between segments; the run-time
+     gap can be different from the object-file gap.  We therefore can't
+     assume X - _GLOBAL_OFFSET_TABLE_ is a link-time constant unless we
+     are absolutely sure that X is in the same segment as the GOT.
+     Unfortunately, the flexibility of linker scripts means that we
+     can't be sure of that in general, so assume that GOT-relative
+     accesses are never valid on VxWorks.  */
+  if (TARGET_VXWORKS_RTP)
+    return false;
+
+  /* Similarly, if the label is non-local, it might end up being placed
+     in a different section than the current one; now mov_pic_label_ref
+     requires the label and the code to be in the same section.  */
+  if (LABEL_REF_NONLOCAL_P (label))
+    return false;
+
+  /* Finally, if we are reordering basic blocks and partition into hot
+     and cold sections, this might happen for any label.  */
+  if (flag_reorder_blocks_and_partition)
+    return false;
+
+  return true;
+}
+
 /* Expand a move instruction.  Return true if all work is done.  */
 
 bool
@@ -1000,14 +1030,9 @@
       if (pic_address_needs_scratch (operands[1]))
 	operands[1] = legitimize_pic_address (operands[1], NULL_RTX);
 
-      /* VxWorks does not impose a fixed gap between segments; the run-time
-	 gap can be different from the object-file gap.  We therefore can't
-	 assume X - _GLOBAL_OFFSET_TABLE_ is a link-time constant unless we
-	 are absolutely sure that X is in the same segment as the GOT.
-	 Unfortunately, the flexibility of linker scripts means that we
-	 can't be sure of that in general, so assume that _G_O_T_-relative
-	 accesses are never valid on VxWorks.  */
-      if (GET_CODE (operands[1]) == LABEL_REF && !TARGET_VXWORKS_RTP)
+      /* We cannot use the mov{si,di}_pic_label_ref patterns in all cases.  */
+      if (GET_CODE (operands[1]) == LABEL_REF
+	  && can_use_mov_pic_label_ref (operands[1]))
 	{
 	  if (mode == SImode)
 	    {
@@ -2907,26 +2932,39 @@
     }
 }
 
-/* PIC support.  */
-static GTY(()) bool pic_helper_needed = false;
-static GTY(()) rtx pic_helper_symbol;
-static GTY(()) rtx global_offset_table;
+/* Global Offset Table support.  */
+static GTY(()) rtx got_helper_rtx = NULL_RTX;
+static GTY(()) rtx global_offset_table_rtx = NULL_RTX;
 
+/* Return the SYMBOL_REF for the Global Offset Table.  */
+
+static GTY(()) rtx sparc_got_symbol = NULL_RTX;
+
+static rtx
+sparc_got (void)
+{
+  if (!sparc_got_symbol)
+    sparc_got_symbol = gen_rtx_SYMBOL_REF (Pmode, "_GLOBAL_OFFSET_TABLE_");
+
+  return sparc_got_symbol;
+}
+
 /* Ensure that we are not using patterns that are not OK with PIC.  */
 
 int
 check_pic (int i)
 {
+  rtx op;
+
   switch (flag_pic)
     {
     case 1:
-      gcc_assert (GET_CODE (recog_data.operand[i]) != SYMBOL_REF
-	  	  && (GET_CODE (recog_data.operand[i]) != CONST
-	          || (GET_CODE (XEXP (recog_data.operand[i], 0)) == MINUS
-		      && (XEXP (XEXP (recog_data.operand[i], 0), 0)
-			  == global_offset_table)
-		      && (GET_CODE (XEXP (XEXP (recog_data.operand[i], 0), 1))
-			  == CONST))));
+      op = recog_data.operand[i];
+      gcc_assert (GET_CODE (op) != SYMBOL_REF
+	  	  && (GET_CODE (op) != CONST
+		      || (GET_CODE (XEXP (op, 0)) == MINUS
+			  && XEXP (XEXP (op, 0), 0) == sparc_got ()
+			  && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST)));
     case 2:
     default:
       return 1;
@@ -3161,9 +3199,9 @@
   return 1;
 }
 
-/* Construct the SYMBOL_REF for the tls_get_offset function.  */
+/* Return the SYMBOL_REF for the tls_get_addr function.  */
 
-static GTY(()) rtx sparc_tls_symbol;
+static GTY(()) rtx sparc_tls_symbol = NULL_RTX;
 
 static rtx
 sparc_tls_get_addr (void)
@@ -3174,21 +3212,28 @@
   return sparc_tls_symbol;
 }
 
+/* Return the Global Offset Table to be used in TLS mode.  */
+
 static rtx
 sparc_tls_got (void)
 {
-  rtx temp;
+  /* In PIC mode, this is just the PIC offset table.  */
   if (flag_pic)
     {
       crtl->uses_pic_offset_table = 1;
       return pic_offset_table_rtx;
     }
 
-  if (!global_offset_table)
-    global_offset_table = gen_rtx_SYMBOL_REF (Pmode, "_GLOBAL_OFFSET_TABLE_");
-  temp = gen_reg_rtx (Pmode);
-  emit_move_insn (temp, global_offset_table);
-  return temp;
+  /* In non-PIC mode, Sun as (unlike GNU as) emits PC-relative relocations for
+     the GOT symbol with the 32-bit ABI, so we reload the GOT register.  */
+  if (TARGET_SUN_TLS && TARGET_ARCH32)
+    {
+      load_got_register ();
+      return global_offset_table_rtx;
+    }
+
+  /* In all other cases, we load a new pseudo with the GOT symbol.  */
+  return copy_to_reg (sparc_got ());
 }
 
 /* Return true if X contains a thread-local symbol.  */
@@ -3369,7 +3414,7 @@
 
   if (GET_CODE (orig) == SYMBOL_REF
       /* See the comment in sparc_expand_move.  */
-      || (TARGET_VXWORKS_RTP && GET_CODE (orig) == LABEL_REF))
+      || (GET_CODE (orig) == LABEL_REF && !can_use_mov_pic_label_ref (orig)))
     {
       rtx pic_ref, address;
       rtx insn;
@@ -3420,11 +3465,13 @@
 	}
       else
 	{
-	  pic_ref = gen_const_mem (Pmode,
-				   gen_rtx_PLUS (Pmode,
-						 pic_offset_table_rtx, address));
+	  pic_ref
+	    = gen_const_mem (Pmode,
+			     gen_rtx_PLUS (Pmode,
+					   pic_offset_table_rtx, address));
 	  insn = emit_move_insn (reg, pic_ref);
 	}
+
       /* Put a REG_EQUAL note on this insn, so that it can be optimized
 	 by loop.  */
       set_unique_reg_note (insn, REG_EQUAL, orig);
@@ -3462,9 +3509,8 @@
       return gen_rtx_PLUS (Pmode, base, offset);
     }
   else if (GET_CODE (orig) == LABEL_REF)
-    /* ??? Why do we do this?  */
-    /* Now movsi_pic_label_ref uses it, but we ought to be checking that
-       the register is live instead, in case it is eliminated.  */
+    /* ??? We ought to be checking that the register is live instead, in case
+       it is eliminated.  */
     crtl->uses_pic_offset_table = 1;
 
   return orig;
@@ -3529,59 +3575,69 @@
 static void
 get_pc_thunk_name (char name[32], unsigned int regno)
 {
-  const char *pic_name = reg_names[regno];
+  const char *reg_name = reg_names[regno];
 
   /* Skip the leading '%' as that cannot be used in a
      symbol name.  */
-  pic_name += 1;
+  reg_name += 1;
 
   if (USE_HIDDEN_LINKONCE)
-    sprintf (name, "__sparc_get_pc_thunk.%s", pic_name);
+    sprintf (name, "__sparc_get_pc_thunk.%s", reg_name);
   else
     ASM_GENERATE_INTERNAL_LABEL (name, "LADDPC", regno);
 }
 
-/* Emit code to load the PIC register.  */
+/* Wrapper around the load_pcrel_sym{si,di} patterns.  */
 
-static void
-load_pic_register (void)
+static rtx
+gen_load_pcrel_sym (rtx op0, rtx op1, rtx op2, rtx op3)
 {
   int orig_flag_pic = flag_pic;
+  rtx insn;
 
-  if (TARGET_VXWORKS_RTP)
-    {
-      emit_insn (gen_vxworks_load_got ());
-      emit_use (pic_offset_table_rtx);
-      return;
-    }
+  /* The load_pcrel_sym{si,di} patterns require absolute addressing.  */
+  flag_pic = 0;
+  if (TARGET_ARCH64)
+    insn = gen_load_pcrel_symdi (op0, op1, op2, op3);
+  else
+    insn = gen_load_pcrel_symsi (op0, op1, op2, op3);
+  flag_pic = orig_flag_pic;
 
-  /* If we haven't initialized the special PIC symbols, do so now.  */
-  if (!pic_helper_needed)
-    {
-      char name[32];
+  return insn;
+}
 
-      pic_helper_needed = true;
+/* Emit code to load the GOT register.  */
 
-      get_pc_thunk_name (name, REGNO (pic_offset_table_rtx));
-      pic_helper_symbol = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (name));
+static void
+load_got_register (void)
+{
+  /* In PIC mode, this will retrieve pic_offset_table_rtx.  */
+  if (!global_offset_table_rtx)
+    global_offset_table_rtx = gen_rtx_REG (Pmode, GLOBAL_OFFSET_TABLE_REGNUM);
 
-      global_offset_table = gen_rtx_SYMBOL_REF (Pmode, "_GLOBAL_OFFSET_TABLE_");
+  if (TARGET_VXWORKS_RTP)
+    emit_insn (gen_vxworks_load_got ());
+  else
+    {
+      /* The GOT symbol is subject to a PC-relative relocation so we need a
+	 helper function to add the PC value and thus get the final value.  */
+      if (!got_helper_rtx)
+	{
+	  char name[32];
+	  get_pc_thunk_name (name, GLOBAL_OFFSET_TABLE_REGNUM);
+	  got_helper_rtx = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (name));
+	}
+
+      emit_insn (gen_load_pcrel_sym (global_offset_table_rtx, sparc_got (),
+				     got_helper_rtx,
+				     GEN_INT (GLOBAL_OFFSET_TABLE_REGNUM)));
     }
 
-  flag_pic = 0;
-  if (TARGET_ARCH64)
-    emit_insn (gen_load_pcrel_symdi (pic_offset_table_rtx, global_offset_table,
-				     pic_helper_symbol));
-  else
-    emit_insn (gen_load_pcrel_symsi (pic_offset_table_rtx, global_offset_table,
-				     pic_helper_symbol));
-  flag_pic = orig_flag_pic;
-
   /* Need to emit this whether or not we obey regdecls,
      since setjmp/longjmp can cause life info to screw up.
      ??? In the case where we don't obey regdecls, this is not sufficient
      since we may not fall out the bottom.  */
-  emit_use (pic_offset_table_rtx);
+  emit_use (global_offset_table_rtx);
 }
 
 /* Emit a call instruction with the pattern given by PAT.  ADDR is the
@@ -4113,7 +4169,7 @@
 
 /* Expand the function prologue.  The prologue is responsible for reserving
    storage for the frame, saving the call-saved registers and loading the
-   PIC register if needed.  */
+   GOT register if needed.  */
 
 void
 sparc_expand_prologue (void)
@@ -4215,9 +4271,9 @@
   if (num_gfregs)
     emit_save_or_restore_regs (SORR_SAVE);
 
-  /* Load the PIC register if needed.  */
-  if (flag_pic && crtl->uses_pic_offset_table)
-    load_pic_register ();
+  /* Load the GOT register if needed.  */
+  if (crtl->uses_pic_offset_table)
+    load_got_register ();
 }
 
 /* This function generates the assembly code for function entry, which boils
@@ -8705,7 +8761,7 @@
 /* Emit the sequence of insns SEQ while preserving the registers REG and REG2.
    This is achieved by means of a manual dynamic stack space allocation in
    the current frame.  We make the assumption that SEQ doesn't contain any
-   function calls, with the possible exception of calls to the PIC helper.  */
+   function calls, with the possible exception of calls to the GOT helper.  */
 
 static void
 emit_and_preserve (rtx seq, rtx reg, rtx reg2)
@@ -8868,20 +8924,19 @@
     {
       /* The hoops we have to jump through in order to generate a sibcall
 	 without using delay slots...  */
-      rtx spill_reg, spill_reg2, seq, scratch = gen_rtx_REG (Pmode, 1);
+      rtx spill_reg, seq, scratch = gen_rtx_REG (Pmode, 1);
 
       if (flag_pic)
         {
 	  spill_reg = gen_rtx_REG (word_mode, 15);  /* %o7 */
-	  spill_reg2 = gen_rtx_REG (word_mode, PIC_OFFSET_TABLE_REGNUM);
 	  start_sequence ();
-	  /* Delay emitting the PIC helper function because it needs to
+	  /* Delay emitting the GOT helper function because it needs to
 	     change the section and we are emitting assembly code.  */
-	  load_pic_register ();  /* clobbers %o7 */
+	  load_got_register ();  /* clobbers %o7 */
 	  scratch = legitimize_pic_address (funexp, scratch);
 	  seq = get_insns ();
 	  end_sequence ();
-	  emit_and_preserve (seq, spill_reg, spill_reg2);
+	  emit_and_preserve (seq, spill_reg, pic_offset_table_rtx);
 	}
       else if (TARGET_ARCH32)
 	{
@@ -9032,17 +9087,15 @@
 static void
 sparc_file_end (void)
 {
-  /* If need to emit the special PIC helper function, do so now.  */
-  if (pic_helper_needed)
+  /* If we need to emit the special GOT helper function, do so now.  */
+  if (got_helper_rtx)
     {
-      unsigned int regno = REGNO (pic_offset_table_rtx);
-      const char *pic_name = reg_names[regno];
-      char name[32];
+      const char *name = XSTR (got_helper_rtx, 0);
+      const char *reg_name = reg_names[GLOBAL_OFFSET_TABLE_REGNUM];
 #ifdef DWARF2_UNWIND_INFO
       bool do_cfi;
 #endif
 
-      get_pc_thunk_name (name, regno);
       if (USE_HIDDEN_LINKONCE)
 	{
 	  tree decl = build_decl (BUILTINS_LOCATION, FUNCTION_DECL,
@@ -9055,7 +9108,9 @@
 	  make_decl_one_only (decl, DECL_ASSEMBLER_NAME (decl));
 	  DECL_VISIBILITY (decl) = VISIBILITY_HIDDEN;
 	  DECL_VISIBILITY_SPECIFIED (decl) = 1;
+	  resolve_unique_section (decl, 0, flag_function_sections);
 	  allocate_struct_function (decl, true);
+	  cfun->is_thunk = 1;
 	  current_function_decl = decl;
 	  init_varasm_status ();
 	  assemble_start_function (decl, name);
@@ -9076,10 +9131,10 @@
 #endif
       if (flag_delayed_branch)
 	fprintf (asm_out_file, "\tjmp\t%%o7+8\n\t add\t%%o7, %s, %s\n",
-		 pic_name, pic_name);
+		 reg_name, reg_name);
       else
 	fprintf (asm_out_file, "\tadd\t%%o7, %s, %s\n\tjmp\t%%o7+8\n\t nop\n",
-		 pic_name, pic_name);
+		 reg_name, reg_name);
 #ifdef DWARF2_UNWIND_INFO
       if (do_cfi)
 	fprintf (asm_out_file, "\t.cfi_endproc\n");
Index: gcc/config/sparc/sparc.h
===================================================================
--- gcc/config/sparc/sparc.h	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/config/sparc/sparc.h	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -964,10 +964,15 @@
    not be a register used by the prologue.  */
 #define STATIC_CHAIN_REGNUM (TARGET_ARCH64 ? 5 : 2)
 
+/* Register which holds the global offset table, if any.  */
+
+#define GLOBAL_OFFSET_TABLE_REGNUM 23
+
 /* Register which holds offset table for position-independent
    data references.  */
 
-#define PIC_OFFSET_TABLE_REGNUM (flag_pic ? 23 : INVALID_REGNUM)
+#define PIC_OFFSET_TABLE_REGNUM \
+  (flag_pic ? GLOBAL_OFFSET_TABLE_REGNUM : INVALID_REGNUM)
 
 /* Pick a default value we can notice from override_options:
    !v9: Default is on.
Index: gcc/config/rx/rx.c
===================================================================
--- gcc/config/rx/rx.c	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/config/rx/rx.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -821,9 +821,34 @@
 		   const_tree fn_decl_or_type ATTRIBUTE_UNUSED,
 		   bool       outgoing ATTRIBUTE_UNUSED)
 {
-  return gen_rtx_REG (TYPE_MODE (ret_type), FUNC_RETURN_REGNUM);
+  enum machine_mode mode = TYPE_MODE (ret_type);
+
+  /* RX ABI specifies that small integer types are
+     promoted to int when returned by a function.  */
+  if (GET_MODE_SIZE (mode) > 0 && GET_MODE_SIZE (mode) < 4)
+    return gen_rtx_REG (SImode, FUNC_RETURN_REGNUM);
+    
+  return gen_rtx_REG (mode, FUNC_RETURN_REGNUM);
 }
 
+/* TARGET_PROMOTE_FUNCTION_MODE must behave in the same way with
+   regard to function returns as does TARGET_FUNCTION_VALUE.  */
+
+static enum machine_mode
+rx_promote_function_mode (const_tree type ATTRIBUTE_UNUSED,
+			  enum machine_mode mode,
+			  int * punsignedp ATTRIBUTE_UNUSED,
+			  const_tree funtype ATTRIBUTE_UNUSED,
+			  int for_return)
+{
+  if (for_return != 1
+      || GET_MODE_SIZE (mode) >= 4
+      || GET_MODE_SIZE (mode) < 1)
+    return mode;
+
+  return SImode;
+}
+
 static bool
 rx_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)
 {
@@ -2759,6 +2784,9 @@
 #undef  TARGET_CC_MODES_COMPATIBLE
 #define TARGET_CC_MODES_COMPATIBLE		rx_cc_modes_compatible
 
+#undef  TARGET_PROMOTE_FUNCTION_MODE
+#define TARGET_PROMOTE_FUNCTION_MODE		rx_promote_function_mode
+
 struct gcc_target targetm = TARGET_INITIALIZER;
 
 /* #include "gt-rx.h" */
Index: gcc/config/i386/i386.md
===================================================================
--- gcc/config/i386/i386.md	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/config/i386/i386.md	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -92,6 +92,7 @@
    (UNSPEC_TLS_GD		21)
    (UNSPEC_TLS_LD_BASE		22)
    (UNSPEC_TLSDESC		23)
+   (UNSPEC_TLS_IE_SUN		24)
 
    ; Other random patterns
    (UNSPEC_SCAS			30)
@@ -14702,6 +14703,18 @@
    (set_attr "memory" "load")
    (set_attr "imm_disp" "false")])
 
+;; The Sun linker took the AMD64 TLS spec literally and can only handle
+;; %rax as destination of the initial executable code sequence.
+(define_insn "tls_initial_exec_64_sun"
+  [(set (match_operand:DI 0 "register_operand" "=a")
+	(unspec:DI
+	 [(match_operand:DI 1 "tls_symbolic_operand" "")]
+	 UNSPEC_TLS_IE_SUN))
+   (clobber (reg:CC FLAGS_REG))]
+  "TARGET_64BIT && TARGET_SUN_TLS"
+  "mov{q}\t{%%fs:0, %0|%0, QWORD PTR fs:0}\n\tadd{q}\t{%a1@gottpoff(%%rip), %0|%0, %a1@gottpoff[rip]}"
+  [(set_attr "type" "multi")])
+
 ;; GNU2 TLS patterns can be split.
 
 (define_expand "tls_dynamic_gnu2_32"
Index: gcc/config/i386/sse.md
===================================================================
--- gcc/config/i386/sse.md	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/config/i386/sse.md	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -5011,7 +5011,7 @@
    movsd\t{%2, %0|%0, %2}
    movlpd\t{%2, %0|%0, %2}
    movsd\t{%2, %0|%0, %2}
-   shufpd\t{$2, %2, %0|%0, %2, 2}
+   shufpd\t{$2, %1, %0|%0, %1, 2}
    movhpd\t{%H1, %0|%0, %H1}
    #
    #
@@ -5090,7 +5090,7 @@
    movsd\t{%2, %0|%0, %2}
    movlpd\t{%2, %0|%0, %2}
    movlpd\t{%2, %0|%0, %2}
-   shufpd\t{$2, %2, %0|%0, %2, 2}
+   shufpd\t{$2, %1, %0|%0, %1, 2}
    movhps\t{%H1, %0|%0, %H1}
    movhps\t{%1, %H0|%H0, %1}"
   [(set_attr "type" "ssemov,ssemov,ssemov,sselog,ssemov,ssemov")
@@ -12097,7 +12097,7 @@
   [(set (match_operand:AVXMODEF2P 0 "register_operand" "=x")
 	(unspec:AVXMODEF2P
 	  [(match_operand:AVXMODEF2P 1 "memory_operand" "m")
-	   (match_operand:AVXMODEF2P 2 "register_operand" "x")
+	   (match_operand:<avxpermvecmode> 2 "register_operand" "x")
 	   (match_dup 0)]
 	  UNSPEC_MASKLOAD))]
   "TARGET_AVX"
@@ -12110,7 +12110,7 @@
 (define_insn "avx_maskstorep<avxmodesuffixf2c><avxmodesuffix>"
   [(set (match_operand:AVXMODEF2P 0 "memory_operand" "=m")
 	(unspec:AVXMODEF2P
-	  [(match_operand:AVXMODEF2P 1 "register_operand" "x")
+	  [(match_operand:<avxpermvecmode> 1 "register_operand" "x")
 	   (match_operand:AVXMODEF2P 2 "register_operand" "x")
 	   (match_dup 0)]
 	  UNSPEC_MASKSTORE))]
Index: gcc/config/i386/i386-builtin-types.def
===================================================================
--- gcc/config/i386/i386-builtin-types.def	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/config/i386/i386-builtin-types.def	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -229,7 +229,7 @@
 DEF_FUNCTION_TYPE (V1DI, V1DI, V1DI)
 DEF_FUNCTION_TYPE (V1DI, V2SI, V2SI)
 DEF_FUNCTION_TYPE (V1DI, V8QI, V8QI)
-DEF_FUNCTION_TYPE (V2DF, PCV2DF, V2DF)
+DEF_FUNCTION_TYPE (V2DF, PCV2DF, V2DI)
 DEF_FUNCTION_TYPE (V2DF, V2DF, DI)
 DEF_FUNCTION_TYPE (V2DF, V2DF, INT)
 DEF_FUNCTION_TYPE (V2DF, V2DF, PCDOUBLE)
@@ -251,7 +251,7 @@
 DEF_FUNCTION_TYPE (V2SI, V2SI, SI)
 DEF_FUNCTION_TYPE (V2SI, V2SI, V2SI)
 DEF_FUNCTION_TYPE (V2SI, V4HI, V4HI)
-DEF_FUNCTION_TYPE (V4DF, PCV4DF, V4DF)
+DEF_FUNCTION_TYPE (V4DF, PCV4DF, V4DI)
 DEF_FUNCTION_TYPE (V4DF, V4DF, INT)
 DEF_FUNCTION_TYPE (V4DF, V4DF, V4DF)
 DEF_FUNCTION_TYPE (V4DF, V4DF, V4DI)
@@ -260,7 +260,7 @@
 DEF_FUNCTION_TYPE (V4HI, V4HI, SI)
 DEF_FUNCTION_TYPE (V4HI, V4HI, V4HI)
 DEF_FUNCTION_TYPE (V4HI, V8QI, V8QI)
-DEF_FUNCTION_TYPE (V4SF, PCV4SF, V4SF)
+DEF_FUNCTION_TYPE (V4SF, PCV4SF, V4SI)
 DEF_FUNCTION_TYPE (V4SF, V4SF, DI)
 DEF_FUNCTION_TYPE (V4SF, V4SF, INT)
 DEF_FUNCTION_TYPE (V4SF, V4SF, PCV2SF)
@@ -284,7 +284,7 @@
 DEF_FUNCTION_TYPE (V8HI, V8HI, V8HI)
 DEF_FUNCTION_TYPE (V8QI, V4HI, V4HI)
 DEF_FUNCTION_TYPE (V8QI, V8QI, V8QI)
-DEF_FUNCTION_TYPE (V8SF, PCV8SF, V8SF)
+DEF_FUNCTION_TYPE (V8SF, PCV8SF, V8SI)
 DEF_FUNCTION_TYPE (V8SF, V8SF, INT)
 DEF_FUNCTION_TYPE (V8SF, V8SF, V8SF)
 DEF_FUNCTION_TYPE (V8SF, V8SF, V8SI)
@@ -343,10 +343,10 @@
 DEF_FUNCTION_TYPE (V8SI, V8SI, V8SI, INT)
 DEF_FUNCTION_TYPE (V8SI, V8SI, V8SI, V8SI)
 DEF_FUNCTION_TYPE (VOID, PCVOID, UNSIGNED, UNSIGNED)
-DEF_FUNCTION_TYPE (VOID, PV2DF, V2DF, V2DF)
-DEF_FUNCTION_TYPE (VOID, PV4DF, V4DF, V4DF)
-DEF_FUNCTION_TYPE (VOID, PV4SF, V4SF, V4SF)
-DEF_FUNCTION_TYPE (VOID, PV8SF, V8SF, V8SF)
+DEF_FUNCTION_TYPE (VOID, PV2DF, V2DI, V2DF)
+DEF_FUNCTION_TYPE (VOID, PV4DF, V4DI, V4DF)
+DEF_FUNCTION_TYPE (VOID, PV4SF, V4SI, V4SF)
+DEF_FUNCTION_TYPE (VOID, PV8SF, V8SI, V8SF)
 DEF_FUNCTION_TYPE (VOID, UINT, UINT, UINT)
 DEF_FUNCTION_TYPE (VOID, UINT64, UINT, UINT)
 DEF_FUNCTION_TYPE (VOID, V16QI, V16QI, PCHAR)
Index: gcc/config/i386/avxintrin.h
===================================================================
--- gcc/config/i386/avxintrin.h	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/config/i386/avxintrin.h	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -890,55 +890,55 @@
 }
 
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
-_mm_maskload_pd (double const *__P, __m128d __M)
+_mm_maskload_pd (double const *__P, __m128i __M)
 {
   return (__m128d) __builtin_ia32_maskloadpd ((const __v2df *)__P,
-					      (__v2df)__M);
+					      (__v2di)__M);
 }
 
 extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
-_mm_maskstore_pd (double *__P, __m128d __M, __m128d __A)
+_mm_maskstore_pd (double *__P, __m128i __M, __m128d __A)
 {
-  __builtin_ia32_maskstorepd ((__v2df *)__P, (__v2df)__M, (__v2df)__A);
+  __builtin_ia32_maskstorepd ((__v2df *)__P, (__v2di)__M, (__v2df)__A);
 }
 
 extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
-_mm256_maskload_pd (double const *__P, __m256d __M)
+_mm256_maskload_pd (double const *__P, __m256i __M)
 {
   return (__m256d) __builtin_ia32_maskloadpd256 ((const __v4df *)__P,
-						 (__v4df)__M);
+						 (__v4di)__M);
 }
 
 extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
-_mm256_maskstore_pd (double *__P, __m256d __M, __m256d __A)
+_mm256_maskstore_pd (double *__P, __m256i __M, __m256d __A)
 {
-  __builtin_ia32_maskstorepd256 ((__v4df *)__P, (__v4df)__M, (__v4df)__A);
+  __builtin_ia32_maskstorepd256 ((__v4df *)__P, (__v4di)__M, (__v4df)__A);
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
-_mm_maskload_ps (float const *__P, __m128 __M)
+_mm_maskload_ps (float const *__P, __m128i __M)
 {
   return (__m128) __builtin_ia32_maskloadps ((const __v4sf *)__P,
-					     (__v4sf)__M);
+					     (__v4si)__M);
 }
 
 extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
-_mm_maskstore_ps (float *__P, __m128 __M, __m128 __A)
+_mm_maskstore_ps (float *__P, __m128i __M, __m128 __A)
 {
-  __builtin_ia32_maskstoreps ((__v4sf *)__P, (__v4sf)__M, (__v4sf)__A);
+  __builtin_ia32_maskstoreps ((__v4sf *)__P, (__v4si)__M, (__v4sf)__A);
 }
 
 extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
-_mm256_maskload_ps (float const *__P, __m256 __M)
+_mm256_maskload_ps (float const *__P, __m256i __M)
 {
   return (__m256) __builtin_ia32_maskloadps256 ((const __v8sf *)__P,
-						(__v8sf)__M);
+						(__v8si)__M);
 }
 
 extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
-_mm256_maskstore_ps (float *__P, __m256 __M, __m256 __A)
+_mm256_maskstore_ps (float *__P, __m256i __M, __m256 __A)
 {
-  __builtin_ia32_maskstoreps256 ((__v8sf *)__P, (__v8sf)__M, (__v8sf)__A);
+  __builtin_ia32_maskstoreps256 ((__v8sf *)__P, (__v8si)__M, (__v8sf)__A);
 }
 
 extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
Index: gcc/config/i386/i386.c
===================================================================
--- gcc/config/i386/i386.c	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/config/i386/i386.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -10438,6 +10438,17 @@
     case TLS_MODEL_INITIAL_EXEC:
       if (TARGET_64BIT)
 	{
+	  if (TARGET_SUN_TLS)
+	    {
+	      /* The Sun linker took the AMD64 TLS spec literally
+		 and can only handle %rax as destination of the
+		 initial executable code sequence.  */
+
+	      dest = gen_reg_rtx (Pmode);
+	      emit_insn (gen_tls_initial_exec_64_sun (dest, x));
+	      return dest;
+	    }
+
 	  pic = NULL;
 	  type = UNSPEC_GOTNTPOFF;
 	}
@@ -11027,7 +11038,11 @@
 	return orig_x;
       x = XVECEXP (XEXP (x, 0), 0, 0);
       if (GET_MODE (orig_x) != Pmode)
-	return simplify_gen_subreg (GET_MODE (orig_x), x, Pmode, 0);
+	{
+	  x = simplify_gen_subreg (GET_MODE (orig_x), x, Pmode, 0);
+	  if (x == NULL_RTX)
+	    return orig_x;
+	}
       return x;
     }
 
@@ -11096,7 +11111,11 @@
 	return orig_x;
     }
   if (GET_MODE (orig_x) != Pmode && MEM_P (orig_x))
-    return simplify_gen_subreg (GET_MODE (orig_x), result, Pmode, 0);
+    {
+      result = simplify_gen_subreg (GET_MODE (orig_x), result, Pmode, 0);
+      if (result == NULL_RTX)
+	return orig_x;
+    }
   return result;
 }
 
@@ -21638,14 +21657,14 @@
   { OPTION_MASK_ISA_AVX, CODE_FOR_avx_movntv4df, "__builtin_ia32_movntpd256", IX86_BUILTIN_MOVNTPD256, UNKNOWN, (int) VOID_FTYPE_PDOUBLE_V4DF },
   { OPTION_MASK_ISA_AVX, CODE_FOR_avx_movntv8sf, "__builtin_ia32_movntps256", IX86_BUILTIN_MOVNTPS256, UNKNOWN, (int) VOID_FTYPE_PFLOAT_V8SF },
 
-  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_maskloadpd, "__builtin_ia32_maskloadpd", IX86_BUILTIN_MASKLOADPD, UNKNOWN, (int) V2DF_FTYPE_PCV2DF_V2DF },
-  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_maskloadps, "__builtin_ia32_maskloadps", IX86_BUILTIN_MASKLOADPS, UNKNOWN, (int) V4SF_FTYPE_PCV4SF_V4SF },
-  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_maskloadpd256, "__builtin_ia32_maskloadpd256", IX86_BUILTIN_MASKLOADPD256, UNKNOWN, (int) V4DF_FTYPE_PCV4DF_V4DF },
-  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_maskloadps256, "__builtin_ia32_maskloadps256", IX86_BUILTIN_MASKLOADPS256, UNKNOWN, (int) V8SF_FTYPE_PCV8SF_V8SF },
-  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_maskstorepd, "__builtin_ia32_maskstorepd", IX86_BUILTIN_MASKSTOREPD, UNKNOWN, (int) VOID_FTYPE_PV2DF_V2DF_V2DF },
-  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_maskstoreps, "__builtin_ia32_maskstoreps", IX86_BUILTIN_MASKSTOREPS, UNKNOWN, (int) VOID_FTYPE_PV4SF_V4SF_V4SF },
-  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_maskstorepd256, "__builtin_ia32_maskstorepd256", IX86_BUILTIN_MASKSTOREPD256, UNKNOWN, (int) VOID_FTYPE_PV4DF_V4DF_V4DF },
-  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_maskstoreps256, "__builtin_ia32_maskstoreps256", IX86_BUILTIN_MASKSTOREPS256, UNKNOWN, (int) VOID_FTYPE_PV8SF_V8SF_V8SF },
+  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_maskloadpd, "__builtin_ia32_maskloadpd", IX86_BUILTIN_MASKLOADPD, UNKNOWN, (int) V2DF_FTYPE_PCV2DF_V2DI },
+  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_maskloadps, "__builtin_ia32_maskloadps", IX86_BUILTIN_MASKLOADPS, UNKNOWN, (int) V4SF_FTYPE_PCV4SF_V4SI },
+  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_maskloadpd256, "__builtin_ia32_maskloadpd256", IX86_BUILTIN_MASKLOADPD256, UNKNOWN, (int) V4DF_FTYPE_PCV4DF_V4DI },
+  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_maskloadps256, "__builtin_ia32_maskloadps256", IX86_BUILTIN_MASKLOADPS256, UNKNOWN, (int) V8SF_FTYPE_PCV8SF_V8SI },
+  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_maskstorepd, "__builtin_ia32_maskstorepd", IX86_BUILTIN_MASKSTOREPD, UNKNOWN, (int) VOID_FTYPE_PV2DF_V2DI_V2DF },
+  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_maskstoreps, "__builtin_ia32_maskstoreps", IX86_BUILTIN_MASKSTOREPS, UNKNOWN, (int) VOID_FTYPE_PV4SF_V4SI_V4SF },
+  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_maskstorepd256, "__builtin_ia32_maskstorepd256", IX86_BUILTIN_MASKSTOREPD256, UNKNOWN, (int) VOID_FTYPE_PV4DF_V4DI_V4DF },
+  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_maskstoreps256, "__builtin_ia32_maskstoreps256", IX86_BUILTIN_MASKSTOREPS256, UNKNOWN, (int) VOID_FTYPE_PV8SF_V8SI_V8SF },
 
   { OPTION_MASK_ISA_LWP, CODE_FOR_lwp_llwpcb, "__builtin_ia32_llwpcb", IX86_BUILTIN_LLWPCB, UNKNOWN, (int) VOID_FTYPE_PVOID },
   { OPTION_MASK_ISA_LWP, CODE_FOR_lwp_slwpcb, "__builtin_ia32_slwpcb", IX86_BUILTIN_SLWPCB, UNKNOWN, (int) PVOID_FTYPE_VOID },
@@ -23927,18 +23946,18 @@
       klass = load;
       memory = 1;
       break;
-    case V8SF_FTYPE_PCV8SF_V8SF:
-    case V4DF_FTYPE_PCV4DF_V4DF:
-    case V4SF_FTYPE_PCV4SF_V4SF:
-    case V2DF_FTYPE_PCV2DF_V2DF:
+    case V8SF_FTYPE_PCV8SF_V8SI:
+    case V4DF_FTYPE_PCV4DF_V4DI:
+    case V4SF_FTYPE_PCV4SF_V4SI:
+    case V2DF_FTYPE_PCV2DF_V2DI:
       nargs = 2;
       klass = load;
       memory = 0;
       break;
-    case VOID_FTYPE_PV8SF_V8SF_V8SF:
-    case VOID_FTYPE_PV4DF_V4DF_V4DF:
-    case VOID_FTYPE_PV4SF_V4SF_V4SF:
-    case VOID_FTYPE_PV2DF_V2DF_V2DF:
+    case VOID_FTYPE_PV8SF_V8SI_V8SF:
+    case VOID_FTYPE_PV4DF_V4DI_V4DF:
+    case VOID_FTYPE_PV4SF_V4SI_V4SF:
+    case VOID_FTYPE_PV2DF_V2DI_V2DF:
       nargs = 2;
       klass = store;
       /* Reserve memory operand for target.  */
Index: gcc/config/rs6000/rs6000.c
===================================================================
--- gcc/config/rs6000/rs6000.c	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/config/rs6000/rs6000.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -4472,7 +4472,7 @@
 {
   enum machine_mode mode = GET_MODE (vec);
   enum machine_mode inner_mode = GET_MODE_INNER (mode);
-  rtx mem, x;
+  rtx mem;
 
   if (VECTOR_MEM_VSX_P (mode) && (mode == V2DFmode || mode == V2DImode))
     {
@@ -4485,17 +4485,11 @@
   /* Allocate mode-sized buffer.  */
   mem = assign_stack_temp (mode, GET_MODE_SIZE (mode), 0);
 
+  emit_move_insn (mem, vec);
+
   /* Add offset to field within buffer matching vector element.  */
-  mem = adjust_address_nv (mem, mode, elt * GET_MODE_SIZE (inner_mode));
+  mem = adjust_address_nv (mem, inner_mode, elt * GET_MODE_SIZE (inner_mode));
 
-  /* Store single field into mode-sized buffer.  */
-  x = gen_rtx_UNSPEC (VOIDmode,
-		      gen_rtvec (1, const0_rtx), UNSPEC_STVE);
-  emit_insn (gen_rtx_PARALLEL (VOIDmode,
-			       gen_rtvec (2,
-					  gen_rtx_SET (VOIDmode,
-						       mem, vec),
-					  x)));
   emit_move_insn (target, adjust_address_nv (mem, inner_mode, 0));
 }
 
@@ -9897,6 +9891,7 @@
   rtx op2 = expand_normal (arg2);
   rtx pat, addr;
   enum machine_mode tmode = insn_data[icode].operand[0].mode;
+  enum machine_mode smode = insn_data[icode].operand[1].mode;
   enum machine_mode mode1 = Pmode;
   enum machine_mode mode2 = Pmode;
 
@@ -9906,8 +9901,8 @@
       || arg2 == error_mark_node)
     return const0_rtx;
 
-  if (! (*insn_data[icode].operand[1].predicate) (op0, tmode))
-    op0 = copy_to_mode_reg (tmode, op0);
+  if (! (*insn_data[icode].operand[1].predicate) (op0, smode))
+    op0 = copy_to_mode_reg (smode, op0);
 
   op2 = copy_to_mode_reg (mode2, op2);
 
Index: gcc/config/rs6000/altivec.md
===================================================================
--- gcc/config/rs6000/altivec.md	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/config/rs6000/altivec.md	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -171,6 +171,7 @@
 (define_mode_iterator VM2 [V4SI V8HI V16QI V4SF V2DF V2DI])
 
 (define_mode_attr VI_char [(V4SI "w") (V8HI "h") (V16QI "b")])
+(define_mode_attr VI_scalar [(V4SI "SI") (V8HI "HI") (V16QI "QI")])
 
 ;; Vector move instructions.
 (define_insn "*altivec_mov<mode>"
@@ -1777,19 +1778,15 @@
   [(set_attr "type" "vecstore")])
 
 (define_insn "altivec_stve<VI_char>x"
-  [(parallel
-    [(set (match_operand:VI 0 "memory_operand" "=Z")
-	  (match_operand:VI 1 "register_operand" "v"))
-     (unspec [(const_int 0)] UNSPEC_STVE)])]
+  [(set (match_operand:<VI_scalar> 0 "memory_operand" "=Z")
+	(unspec:<VI_scalar> [(match_operand:VI 1 "register_operand" "v")] UNSPEC_STVE))]
   "TARGET_ALTIVEC"
   "stve<VI_char>x %1,%y0"
   [(set_attr "type" "vecstore")])
 
 (define_insn "*altivec_stvesfx"
-  [(parallel
-    [(set (match_operand:V4SF 0 "memory_operand" "=Z")
-	  (match_operand:V4SF 1 "register_operand" "v"))
-     (unspec [(const_int 0)] UNSPEC_STVE)])]
+  [(set (match_operand:SF 0 "memory_operand" "=Z")
+	(unspec:SF [(match_operand:V4SF 1 "register_operand" "v")] UNSPEC_STVE))]
   "TARGET_ALTIVEC"
   "stvewx %1,%y0"
   [(set_attr "type" "vecstore")])
Index: gcc/config/arm/arm.c
===================================================================
--- gcc/config/arm/arm.c	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/config/arm/arm.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -1114,6 +1114,7 @@
 			     va_list_type);
   DECL_ARTIFICIAL (va_list_name) = 1;
   TYPE_NAME (va_list_type) = va_list_name;
+  TYPE_STUB_DECL (va_list_type) = va_list_name;
   /* Create the __ap field.  */
   ap_field = build_decl (BUILTINS_LOCATION,
 			 FIELD_DECL, 
Index: gcc/config/pa/pa.md
===================================================================
--- gcc/config/pa/pa.md	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/config/pa/pa.md	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -811,7 +811,7 @@
 			 (match_operand:DI 3 "arith11_operand" "rI"))
 		 (match_operand:DI 1 "register_operand" "r")))]
   "TARGET_64BIT"
-  "sub%I3 %3,%2,%%r0\;add,dc %%r0,%1,%0"
+  "sub%I3,* %3,%2,%%r0\;add,dc %%r0,%1,%0"
   [(set_attr "type" "binary")
    (set_attr "length" "8")])
 
@@ -833,7 +833,7 @@
 			 (match_operand:DI 3 "register_operand" "r"))
 		 (match_operand:DI 1 "register_operand" "r")))]
   "TARGET_64BIT"
-  "sub %2,%3,%%r0\;add,dc %%r0,%1,%0"
+  "sub,* %2,%3,%%r0\;add,dc %%r0,%1,%0"
   [(set_attr "type" "binary")
    (set_attr "length" "8")])
 
@@ -856,7 +856,7 @@
 			 (match_operand:DI 3 "int11_operand" "I"))
 		 (match_operand:DI 1 "register_operand" "r")))]
   "TARGET_64BIT"
-  "addi %k3,%2,%%r0\;add,dc %%r0,%1,%0"
+  "addi,* %k3,%2,%%r0\;add,dc %%r0,%1,%0"
   [(set_attr "type" "binary")
    (set_attr "length" "8")])
 
@@ -902,7 +902,7 @@
 		  (gtu:DI (match_operand:DI 2 "register_operand" "r")
 			  (match_operand:DI 3 "arith11_operand" "rI"))))]
   "TARGET_64BIT"
-  "sub%I3 %3,%2,%%r0\;sub,db %1,%%r0,%0"
+  "sub%I3,* %3,%2,%%r0\;sub,db %1,%%r0,%0"
   [(set_attr "type" "binary")
    (set_attr "length" "8")])
 
@@ -924,7 +924,7 @@
 				    (match_operand:DI 3 "arith11_operand" "rI")))
 		  (match_operand:DI 4 "register_operand" "r")))]
   "TARGET_64BIT"
-  "sub%I3 %3,%2,%%r0\;sub,db %1,%4,%0"
+  "sub%I3,* %3,%2,%%r0\;sub,db %1,%4,%0"
   [(set_attr "type" "binary")
    (set_attr "length" "8")])
 
@@ -946,7 +946,7 @@
 		  (ltu:DI (match_operand:DI 2 "register_operand" "r")
 			  (match_operand:DI 3 "register_operand" "r"))))]
   "TARGET_64BIT"
-  "sub %2,%3,%%r0\;sub,db %1,%%r0,%0"
+  "sub,* %2,%3,%%r0\;sub,db %1,%%r0,%0"
   [(set_attr "type" "binary")
    (set_attr "length" "8")])
 
@@ -968,7 +968,7 @@
 				    (match_operand:DI 3 "register_operand" "r")))
 		  (match_operand:DI 4 "register_operand" "r")))]
   "TARGET_64BIT"
-  "sub %2,%3,%%r0\;sub,db %1,%4,%0"
+  "sub,* %2,%3,%%r0\;sub,db %1,%4,%0"
   [(set_attr "type" "binary")
    (set_attr "length" "8")])
 
@@ -991,7 +991,7 @@
 		  (leu:DI (match_operand:DI 2 "register_operand" "r")
 			  (match_operand:DI 3 "int11_operand" "I"))))]
   "TARGET_64BIT"
-  "addi %k3,%2,%%r0\;sub,db %1,%%r0,%0"
+  "addi,* %k3,%2,%%r0\;sub,db %1,%%r0,%0"
   [(set_attr "type" "binary")
    (set_attr "length" "8")])
 
@@ -1013,7 +1013,7 @@
 				    (match_operand:DI 3 "int11_operand" "I")))
 		  (match_operand:DI 4 "register_operand" "r")))]
   "TARGET_64BIT"
-  "addi %k3,%2,%%r0\;sub,db %1,%4,%0"
+  "addi,* %k3,%2,%%r0\;sub,db %1,%4,%0"
   [(set_attr "type" "binary")
    (set_attr "length" "8")])
 
Index: gcc/config/pa/pa.c
===================================================================
--- gcc/config/pa/pa.c	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ gcc/config/pa/pa.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -6097,37 +6097,94 @@
 }
 
 /* Return TRUE if INSN, a jump insn, has an unfilled delay slot and
-   it branches to the next real instruction.  Otherwise, return FALSE.  */
+   it branches into the delay slot.  Otherwise, return FALSE.  */
 
 static bool
 branch_to_delay_slot_p (rtx insn)
 {
+  rtx jump_insn;
+
   if (dbr_sequence_length ())
     return FALSE;
 
-  return next_real_insn (JUMP_LABEL (insn)) == next_real_insn (insn);
+  jump_insn = next_active_insn (JUMP_LABEL (insn));
+  while (insn)
+    {
+      insn = next_active_insn (insn);
+      if (jump_insn == insn)
+	return TRUE;
+
+      /* We can't rely on the length of asms.  So, we return FALSE when
+	 the branch is followed by an asm.  */
+      if (!insn
+	  || GET_CODE (PATTERN (insn)) == ASM_INPUT
+	  || extract_asm_operands (PATTERN (insn)) != NULL_RTX
+	  || get_attr_length (insn) > 0)
+	break;
+    }
+
+  return FALSE;
 }
 
-/* Return TRUE if INSN, a jump insn, needs a nop in its delay slot.
+/* Return TRUE if INSN, a forward jump insn, needs a nop in its delay slot.
 
    This occurs when INSN has an unfilled delay slot and is followed
-   by an ASM_INPUT.  Disaster can occur if the ASM_INPUT is empty and
-   the jump branches into the delay slot.  So, we add a nop in the delay
-   slot just to be safe.  This messes up our instruction count, but we
-   don't know how big the ASM_INPUT insn is anyway.  */
+   by an asm.  Disaster can occur if the asm is empty and the jump
+   branches into the delay slot.  So, we add a nop in the delay slot
+   when this occurs.  */
 
 static bool
 branch_needs_nop_p (rtx insn)
 {
-  rtx next_insn;
+  rtx jump_insn;
 
   if (dbr_sequence_length ())
     return FALSE;
 
-  next_insn = next_real_insn (insn);
-  return GET_CODE (PATTERN (next_insn)) == ASM_INPUT;
+  jump_insn = next_active_insn (JUMP_LABEL (insn));
+  while (insn)
+    {
+      insn = next_active_insn (insn);
+      if (!insn || jump_insn == insn)
+	return TRUE;
+
+      if (!(GET_CODE (PATTERN (insn)) == ASM_INPUT
+	   || extract_asm_operands (PATTERN (insn)) != NULL_RTX)
+	  && get_attr_length (insn) > 0)
+	break;
+    }
+
+  return FALSE;
 }
 
+/* Return TRUE if INSN, a forward jump insn, can use nullification
+   to skip the following instruction.  This avoids an extra cycle due
+   to a mis-predicted branch when we fall through.  */
+
+static bool
+use_skip_p (rtx insn)
+{
+  rtx jump_insn = next_active_insn (JUMP_LABEL (insn));
+
+  while (insn)
+    {
+      insn = next_active_insn (insn);
+
+      /* We can't rely on the length of asms, so we can't skip asms.  */
+      if (!insn
+	  || GET_CODE (PATTERN (insn)) == ASM_INPUT
+	  || extract_asm_operands (PATTERN (insn)) != NULL_RTX)
+	break;
+      if (get_attr_length (insn) == 4
+	  && jump_insn == next_active_insn (insn))
+	return TRUE;
+      if (get_attr_length (insn) > 0)
+	break;
+    }
+
+  return FALSE;
+}
+
 /* This routine handles all the normal conditional branch sequences we
    might need to generate.  It handles compare immediate vs compare
    register, nullification of delay slots, varying length branches,
@@ -6139,7 +6196,7 @@
 output_cbranch (rtx *operands, int negated, rtx insn)
 {
   static char buf[100];
-  int useskip = 0;
+  bool useskip;
   int nullify = INSN_ANNULLED_BRANCH_P (insn);
   int length = get_attr_length (insn);
   int xdelay;
@@ -6177,12 +6234,7 @@
   /* A forward branch over a single nullified insn can be done with a
      comclr instruction.  This avoids a single cycle penalty due to
      mis-predicted branch if we fall through (branch not taken).  */
-  if (length == 4
-      && next_real_insn (insn) != 0
-      && get_attr_length (next_real_insn (insn)) == 4
-      && JUMP_LABEL (insn) == next_nonnote_insn (next_real_insn (insn))
-      && nullify)
-    useskip = 1;
+  useskip = (length == 4 && nullify) ? use_skip_p (insn) : FALSE;
 
   switch (length)
     {
@@ -6470,7 +6522,7 @@
 output_bb (rtx *operands ATTRIBUTE_UNUSED, int negated, rtx insn, int which)
 {
   static char buf[100];
-  int useskip = 0;
+  bool useskip;
   int nullify = INSN_ANNULLED_BRANCH_P (insn);
   int length = get_attr_length (insn);
   int xdelay;
@@ -6496,14 +6548,8 @@
   /* A forward branch over a single nullified insn can be done with a
      extrs instruction.  This avoids a single cycle penalty due to
      mis-predicted branch if we fall through (branch not taken).  */
+  useskip = (length == 4 && nullify) ? use_skip_p (insn) : FALSE;
 
-  if (length == 4
-      && next_real_insn (insn) != 0
-      && get_attr_length (next_real_insn (insn)) == 4
-      && JUMP_LABEL (insn) == next_nonnote_insn (next_real_insn (insn))
-      && nullify)
-    useskip = 1;
-
   switch (length)
     {
 
@@ -6661,7 +6707,7 @@
 output_bvb (rtx *operands ATTRIBUTE_UNUSED, int negated, rtx insn, int which)
 {
   static char buf[100];
-  int useskip = 0;
+  bool useskip;
   int nullify = INSN_ANNULLED_BRANCH_P (insn);
   int length = get_attr_length (insn);
   int xdelay;
@@ -6687,14 +6733,8 @@
   /* A forward branch over a single nullified insn can be done with a
      extrs instruction.  This avoids a single cycle penalty due to
      mis-predicted branch if we fall through (branch not taken).  */
+  useskip = (length == 4 && nullify) ? use_skip_p (insn) : FALSE;
 
-  if (length == 4
-      && next_real_insn (insn) != 0
-      && get_attr_length (next_real_insn (insn)) == 4
-      && JUMP_LABEL (insn) == next_nonnote_insn (next_real_insn (insn))
-      && nullify)
-    useskip = 1;
-
   switch (length)
     {
 
Index: libstdc++-v3/src/bitmap_allocator.cc
===================================================================
--- libstdc++-v3/src/bitmap_allocator.cc	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ libstdc++-v3/src/bitmap_allocator.cc	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -49,6 +49,7 @@
   {
 #if defined __GTHREADS
     __mutex_type& __bfl_mutex = _M_get_mutex();
+    __bfl_mutex.lock();
 #endif
     const vector_type& __free_list = _M_get_free_list();
     using __gnu_cxx::__detail::__lower_bound;
Index: libstdc++-v3/ChangeLog
===================================================================
--- libstdc++-v3/ChangeLog	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ libstdc++-v3/ChangeLog	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -1,3 +1,16 @@
+2011-01-19  Graham Reed  <greed@pobox.com>
+
+	PR libstdc++/47354
+	* src/bitmap_allocator.cc (free_list::_M_get): Lock mutex.
+
+2010-12-17  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	Backport from mainline:
+	2010-12-10  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* testsuite/lib/libstdc++.exp (v3-build_support): Delete
+	libtestc++.a before creation.
+
 2010-12-16  Release Manager
 
 	* GCC 4.5.2 released.
Index: libstdc++-v3/testsuite/lib/libstdc++.exp
===================================================================
--- libstdc++-v3/testsuite/lib/libstdc++.exp	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ libstdc++-v3/testsuite/lib/libstdc++.exp	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -586,6 +586,15 @@
     }
 
     # Collect into libtestc++.a
+    # Delete libtestc++.a first.  Mixed 32 and 64-bit archives cannot be
+    # linked on IRIX 6.
+    # Use same procedure as gcc-dg.exp (remove-build-file).
+    if [is_remote host] {
+	# Ensure the host knows the file is gone by deleting there
+	# first.
+	remote_file host delete "./libtestc++.a"
+	}
+    remote_file build delete "./libtestc++.a"
     if  [info exists env(AR)] {
 	set ar $env(AR)
     } else {
Index: libffi/ChangeLog
===================================================================
--- libffi/ChangeLog	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ libffi/ChangeLog	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -1,3 +1,11 @@
+2010-12-17  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	Backport from mainline:
+	2010-12-01  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* testsuite/libffi.call/ffitest.h [__sgi] (PRId64, PRIu64): Define.
+	(PRIuPTR): Define.
+
 2010-12-16  Release Manager
 
 	* GCC 4.5.2 released.
Index: libffi/testsuite/libffi.call/ffitest.h
===================================================================
--- libffi/testsuite/libffi.call/ffitest.h	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ libffi/testsuite/libffi.call/ffitest.h	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -77,6 +77,26 @@
 #define PRIuPTR "lu"
 #endif
 
+/* IRIX kludge.  */
+#if defined(__sgi)
+/* IRIX 6.5 <inttypes.h> provides all definitions, but only for C99
+   compilations.  */
+#if (_MIPS_SZLONG == 32)
+#define PRId64 "lld"
+#define PRIu64 "llu"
+#endif
+/* This doesn't match <inttypes.h>, which always has "lld" here, but the
+   arguments are uint64_t, int64_t, which are unsigned long, long for
+   64-bit in <sgidefs.h>.  */
+#if (_MIPS_SZLONG == 64)
+#define PRId64 "ld"
+#define PRIu64 "lu"
+#endif
+/* This doesn't match <inttypes.h>, which has "u" here, but the arguments
+   are uintptr_t, which is always unsigned long.  */
+#define PRIuPTR "lu"
+#endif
+
 /* Solaris < 10 kludge.  */
 #if defined(__sun__) && defined(__svr4__) && !defined(PRIuPTR)
 #if defined(__arch64__) || defined (__x86_64__)
Index: libjava/classpath/lib/java/security/VMAccessController.class
===================================================================
Nie mona wywietli: plik binarny.
svn:mime-type = application/octet-stream
Index: libjava/ChangeLog
===================================================================
--- libjava/ChangeLog	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ libjava/ChangeLog	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -1,3 +1,24 @@
+2011-01-07  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	Backport from mainline:
+	2011-01-06  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* testsuite/libjava.jni/jni.exp (gcj_jni_get_cxxflags_invocation):
+	Add -shared-libgcc to cxxflags for *-*-solaris*.
+	Remove -lsocket.
+
+2010-12-13  Andrew John Hughes  <ahughes@redhat.com>
+
+	PR libgcj/46774
+	* libjava/java/security/VMAccessController.java:
+	(DEFAULT_CONTEXT): Create ProtectionDomain with
+	four argument constructor (arguments are the same
+	as those implied by the two argument constructor).
+	(getContext()): Create ProtectionDomain instances
+	with four argument constructor using a null Principal
+	array (as before) but including the classloader, which
+	was always null before.
+
 2010-12-16  Release Manager
 
 	* GCC 4.5.2 released.
Index: libjava/testsuite/libjava.jni/jni.exp
===================================================================
--- libjava/testsuite/libjava.jni/jni.exp	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ libjava/testsuite/libjava.jni/jni.exp	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -274,8 +274,10 @@
     eval lappend cxxflags "-shared-libgcc -lgcj $libiconv"
   }
 
+  # Make sure libgcc unwinder is used on 64-bit Solaris 10+/x86 rather than
+  # the libc one.
   if { [istarget "*-*-solaris*"] } {
-    lappend cxxflags "-lsocket"
+    lappend cxxflags "-shared-libgcc"
   }
 
   return $cxxflags
Index: libjava/java/security/VMAccessController.java
===================================================================
--- libjava/java/security/VMAccessController.java	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ libjava/java/security/VMAccessController.java	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -56,7 +56,7 @@
     Permissions permissions = new Permissions();
     permissions.add(new AllPermission());
     ProtectionDomain[] domain = new ProtectionDomain[] {
-      new ProtectionDomain(source, permissions)
+      new ProtectionDomain(source, permissions, null, null)
     };
     DEFAULT_CONTEXT = new AccessControlContext(domain);
   }
@@ -178,12 +178,13 @@
     for (int i = 3; i < classes.length; i++)
       {
         Class clazz = classes[i];
+        ClassLoader loader = clazz.getClassLoader();
 
         if (DEBUG)
           {
             debug("checking " + clazz);
             // subject to getClassLoader RuntimePermission
-            debug("loader = " + clazz.getClassLoader());
+            debug("loader = " + loader);
           }
 
         if (privileged && i == classes.length - 2)
@@ -208,7 +209,8 @@
         // Create a static snapshot of this domain, which may change over time
         // if the current policy changes.
         domains.add(new ProtectionDomain(domain.getCodeSource(),
-                                         domain.getPermissions()));
+                                         domain.getPermissions(),
+                                         loader, null));
       }
 
     if (DEBUG)
Index: libcpp/directives.c
===================================================================
--- libcpp/directives.c	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ libcpp/directives.c	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -280,16 +280,17 @@
 static void
 end_directive (cpp_reader *pfile, int skip_line)
 {
-  if (pfile->state.in_deferred_pragma)
-    ;
-  else if (CPP_OPTION (pfile, traditional))
+  if (CPP_OPTION (pfile, traditional))
     {
       /* Revert change of prepare_directive_trad.  */
-      pfile->state.prevent_expansion--;
+      if (!pfile->state.in_deferred_pragma)
+	pfile->state.prevent_expansion--;
 
       if (pfile->directive != &dtable[T_DEFINE])
 	_cpp_remove_overlay (pfile);
     }
+  else if (pfile->state.in_deferred_pragma)
+    ;
   /* We don't skip for an assembler #.  */
   else if (skip_line)
     {
Index: libcpp/ChangeLog
===================================================================
--- libcpp/ChangeLog	(.../tags/gcc_4_5_2_release)	(wersja 169176)
+++ libcpp/ChangeLog	(.../branches/gcc-4_5-branch)	(wersja 169176)
@@ -1,3 +1,10 @@
+2011-11-04  Eric Botcazou  <ebotcazou@adacore.com>
+            Jakub Jelinek  <jakub@redhat.com>
+
+	PR preprocessor/39213
+	* directives.c (end_directive): Call _cpp_remove_overlay for deferred
+	pragmas as well in traditional mode.
+
 2010-12-16  Release Manager
 
 	* GCC 4.5.2 released.
