Index: Makefile.in
===================================================================
--- Makefile.in	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ Makefile.in	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -51167,6 +51167,8 @@
 # Provide a GCC build when we're building target libraries.  This does
 # not work as a dependency, just as the minimum necessary to avoid errors.
 stage_last:
+	@r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
 	$(MAKE) $(RECURSE_FLAGS_TO_PASS) stage1-bubble
 
 # Same as unstage, but not phony and defaulting to stage1-start.  We place
Index: gcc/regrename.c
===================================================================
--- gcc/regrename.c	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/regrename.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -820,7 +820,7 @@
 		    OP_IN, 0);
 
 	  for (i = 0; i < recog_data.n_dups; i++)
-	    *recog_data.dup_loc[i] = copy_rtx (old_dups[i]);
+	    *recog_data.dup_loc[i] = old_dups[i];
 	  for (i = 0; i < n_ops; i++)
 	    *recog_data.operand_loc[i] = old_operands[i];
 	  if (recog_data.n_dups)
Index: gcc/doc/invoke.texi
===================================================================
--- gcc/doc/invoke.texi	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/doc/invoke.texi	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -5406,8 +5406,9 @@
 This option implies @option{-fmerge-constants}.  In addition to
 @option{-fmerge-constants} this considers e.g.@: even constant initialized
 arrays or initialized constant variables with integral or floating point
-types.  Languages like C or C++ require each non-automatic variable to
-have distinct location, so using this option will result in non-conforming
+types.  Languages like C or C++ require each variable, including multiple
+instances of the same variable in recursive calls, to have distinct locations,
+so using this option will result in non-conforming
 behavior.
 
 @item -fmodulo-sched
Index: gcc/DATESTAMP
===================================================================
--- gcc/DATESTAMP	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/DATESTAMP	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -1 +1 @@
-20090124
+20090307
Index: gcc/tree.h
===================================================================
--- gcc/tree.h	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/tree.h	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -4753,6 +4753,7 @@
 
 extern tree fold (tree);
 extern tree fold_unary (enum tree_code, tree, tree);
+extern tree fold_unary_ignore_overflow (enum tree_code, tree, tree);
 extern tree fold_binary (enum tree_code, tree, tree, tree);
 extern tree fold_ternary (enum tree_code, tree, tree, tree, tree);
 extern tree fold_build1_stat (enum tree_code, tree, tree MEM_STAT_DECL);
Index: gcc/fold-const.c
===================================================================
--- gcc/fold-const.c	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/fold-const.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -8519,6 +8519,24 @@
     } /* switch (code) */
 }
 
+
+/* If the operation was a conversion do _not_ mark a resulting constant
+   with TREE_OVERFLOW if the original constant was not.  These conversions
+   have implementation defined behavior and retaining the TREE_OVERFLOW
+   flag here would confuse later passes such as VRP.  */
+tree
+fold_unary_ignore_overflow (enum tree_code code, tree type, tree op0)
+{
+  tree res = fold_unary (code, type, op0);
+  if (res
+      && TREE_CODE (res) == INTEGER_CST
+      && TREE_CODE (op0) == INTEGER_CST
+      && (code == NOP_EXPR || code == CONVERT_EXPR))
+    TREE_OVERFLOW (res) = TREE_OVERFLOW (op0);
+
+  return res;
+}
+
 /* Fold a binary expression of code CODE and type TYPE with operands
    OP0 and OP1, containing either a MIN-MAX or a MAX-MIN combination.
    Return the folded expression if folding is successful.  Otherwise,
@@ -11673,7 +11691,8 @@
 
     case RSHIFT_EXPR:
       /* Optimize -1 >> x for arithmetic right shifts.  */
-      if (integer_all_onesp (arg0) && !TYPE_UNSIGNED (type))
+      if (integer_all_onesp (arg0) && !TYPE_UNSIGNED (type)
+	  && tree_expr_nonnegative_p (arg1))
 	return omit_one_operand (type, arg0, arg1);
       /* ... fall through ...  */
 
Index: gcc/real.c
===================================================================
--- gcc/real.c	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/real.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -905,15 +905,23 @@
       /* Sign of zero doesn't matter for compares.  */
       return 0;
 
+    case CLASS2 (rvc_normal, rvc_zero):
+      /* Decimal float zero is special and uses rvc_normal, not rvc_zero.  */
+      if (a->decimal)
+	return decimal_do_compare (a, b, nan_result);
+      /* Fall through.  */
     case CLASS2 (rvc_inf, rvc_zero):
     case CLASS2 (rvc_inf, rvc_normal):
-    case CLASS2 (rvc_normal, rvc_zero):
       return (a->sign ? -1 : 1);
 
     case CLASS2 (rvc_inf, rvc_inf):
       return -a->sign - -b->sign;
 
     case CLASS2 (rvc_zero, rvc_normal):
+      /* Decimal float zero is special and uses rvc_normal, not rvc_zero.  */
+      if (b->decimal)
+	return decimal_do_compare (a, b, nan_result);
+      /* Fall through.  */
     case CLASS2 (rvc_zero, rvc_inf):
     case CLASS2 (rvc_normal, rvc_inf):
       return (b->sign ? 1 : -1);
@@ -1266,6 +1274,31 @@
   *r = u;
   return true;
 }
+
+/* Return true if arithmetic on values in IMODE that were promoted
+   from values in TMODE is equivalent to direct arithmetic on values
+   in TMODE.  */
+
+bool
+real_can_shorten_arithmetic (enum machine_mode imode, enum machine_mode tmode)
+{
+  const struct real_format *tfmt, *ifmt;
+  tfmt = REAL_MODE_FORMAT (tmode);
+  ifmt = REAL_MODE_FORMAT (imode);
+  /* These conditions are conservative rather than trying to catch the
+     exact boundary conditions; the main case to allow is IEEE float
+     and double.  */
+  return (ifmt->b == tfmt->b
+	  && ifmt->p > 2 * tfmt->p
+	  && ifmt->emin < 2 * tfmt->emin - tfmt->p - 2
+	  && ifmt->emin < tfmt->emin - tfmt->emax - tfmt->p - 2
+	  && ifmt->emax > 2 * tfmt->emax + 2
+	  && ifmt->emax > tfmt->emax - tfmt->emin + tfmt->p + 2
+	  && ifmt->round_towards_zero == tfmt->round_towards_zero
+	  && ifmt->has_nans >= tfmt->has_nans
+	  && ifmt->has_inf >= tfmt->has_inf
+	  && ifmt->has_signed_zero >= tfmt->has_signed_zero);
+}
 
 /* Render R as an integer.  */
 
Index: gcc/real.h
===================================================================
--- gcc/real.h	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/real.h	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -413,6 +413,11 @@
 /* Replace R by 1/R in the given machine mode, if the result is exact.  */
 extern bool exact_real_inverse (enum machine_mode, REAL_VALUE_TYPE *);
 
+/* Return true if arithmetic on values in IMODE that were promoted
+   from values in TMODE is equivalent to direct arithmetic on values
+   in TMODE.  */
+bool real_can_shorten_arithmetic (enum machine_mode, enum machine_mode);
+
 /* In tree.c: wrap up a REAL_VALUE_TYPE in a tree node.  */
 extern tree build_real (tree, REAL_VALUE_TYPE);
 
Index: gcc/DEV-PHASE
===================================================================
--- gcc/DEV-PHASE	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/DEV-PHASE	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1 @@
+prerelease
Index: gcc/tree-ssa-sccvn.c
===================================================================
--- gcc/tree-ssa-sccvn.c	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/tree-ssa-sccvn.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -1507,7 +1507,7 @@
   if (op0 == TREE_OPERAND (rhs, 0))
     return rhs;
 
-  result = fold_unary (TREE_CODE (rhs), TREE_TYPE (rhs), op0);
+  result = fold_unary_ignore_overflow (TREE_CODE (rhs), TREE_TYPE (rhs), op0);
   if (result)
     {
       STRIP_USELESS_TYPE_CONVERSION (result);
Index: gcc/ChangeLog
===================================================================
--- gcc/ChangeLog	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/ChangeLog	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -1,3 +1,319 @@
+2009-03-02  Richard Sandiford  <rdsandiford@googlemail.com>
+
+	* config/mips/mips.c (mips_mdebug_abi_name): Fix the handling
+	of ABI_64.
+
+2009-03-02  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	* config/spu/spu.c (TARGET_SECTION_TYPE_FLAGS): Define.
+	(spu_section_type_flags): New function.
+
+2009-02-28  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline:
+	2008-12-02  Martin Jambor  <mjambor@suse.cz>
+	
+	PR middle-end/37861
+	* tree-ssa-forwprop.c 
+	(forward_propagate_addr_into_variable_array_index): Check that the
+	offset is not computed from a MULT_EXPR if element size is one.
+
+2009-02-28  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline:
+	2009-02-26  Uros Bizjak  <ubizjak@gmail.com>
+
+	* config/alpha/alpha.h (alpha_expand_mov): Return false if
+	force_const_mem returns NULL_RTX.
+
+2009-02-26  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline:
+	2009-02-02  Jakub Jelinek  <jakub@redhat.com>
+
+	PR inline-asm/39058
+	* recog.h (asm_operand_ok): Add constraints argument.
+	* recog.c (asm_operand_ok): Likewise.  If it is set, for digits
+	recurse on matching constraint.
+	(check_asm_operands): Pass constraints as 3rd argument to
+	asm_operand_ok.  Don't look up matching constraint here.
+	* stmt.c (expand_asm_operands): Pass NULL as 3rd argument
+	to asm_operand_ok.
+
+2009-02-25  Janis Johnson  <janis187@us.ibm.com>
+
+	Backport from mainline:
+	2008-10-29  Joseph Myers  <joseph@codesourcery.com>
+
+	PR middle-end/36578
+	* convert.c (convert_to_real): Do not optimize conversions of
+	binary arithmetic operations between binary and decimal
+	floating-point types.  Consider mode of target type in determining
+	decimal type for arithmetic.  Unless
+	flag_unsafe_math_optimizations, do not optimize binary conversions
+	where this may change rounding behavior.
+	* real.c (real_can_shorten_arithmetic): New.
+	* real.h (real_can_shorten_arithmetic): Declare.
+
+2009-02-21  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline:
+	2009-02-20  Jaka Mocnik  <jaka@xlab.si>
+
+	* calls.c (emit_library_call_value_1): Use slot_offset instead of
+	offset when calculating bounds for indexing stack_usage_map.  Fixes
+	a buffer overflow with certain target setups.
+
+2009-02-20  Steve Ellcey  <sje@cup.hp.com>
+
+	PR target/38056
+	* config/ia64/ia64.c (ia64_function_ok_for_sibcall): Check
+	TARGET_CONST_GP.
+
+2009-02-19  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/39228
+	* config/i386/i386.md (isinfxf2): Split from isinf<mode>2.
+	(UNSPEC_FXAM_MEM): New unspec.
+	(fxam<mode>2_i387_with_temp): New insn and split pattern.
+	(isinf<mode>2): Use MODEF mode iterator.  Force operand[1] through
+	memory using fxam<mode>2_i387_with_temp to remove excess precision.
+
+2009-02-17  Uros Bizjak  <ubizjak@gmail.com>
+
+	* config/soft-fp/double.h: Update from glibc CVS.
+
+2009-02-17  Joseph Myers  <joseph@codesourcery.com>
+
+	PR c/35446
+	* c-parser.c (c_parser_braced_init): Call pop_init_level when
+	skipping until next close brace.
+
+2009-02-13  Joseph Myers  <joseph@codesourcery.com>
+
+	PR c/35444
+	* c-parser.c (c_parser_parms_list_declarator): Discard pending
+	sizes on syntax error after some arguments have been parsed.
+
+2009-02-11  Uros Bizjak  <ubizjak@gmail.com>
+	    Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/39118
+	* config/i386/i386.md (UNSPEC_MEMORY_BLOCKAGE): New constant.
+	(memory_blockage): New expander.
+	(*memory_blockage): New insn pattern.
+	* config/i386/i386.c (ix86_expand_prologue): Use memory_blockage
+	instead of general blockage at the end of function prologue when
+	frame pointer is used to access red zone area.  Do not emit blockage
+	when profiling, it is emitted in generic code.
+	(ix86_expand_epilogue): Emit memory_blockage at the beginning of
+	function epilogue when frame pointer is used to access red zone area.
+
+2009-02-10  Steve Ellcey  <sje@cup.hp.com>
+
+	PR c/39084
+	* c-decl.c (start_struct): Return NULL on error.
+
+2009-02-10  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/39118
+	* config/i386/i386.c (expand_prologue): Emit blockage at the end
+	of function prologue when frame pointer is used to access
+	red zone area.
+
+2009-02-09  Janis Johnson  <janis187@us.ibm.com>
+
+	PR c/39035
+	* real.c (do_compare): Special-case compare of zero against
+	decimal float value.
+
+2009-02-08  Joseph Myers  <joseph@codesourcery.com>
+
+	PR c/35434
+	* c-common.c (handle_alias_attribute): Disallow attribute for
+	anything not a FUNCTION_DECL or VAR_DECL.
+
+2009-02-08  Joseph Myers  <joseph@codesourcery.com>
+
+	PR c/36432
+	* c-decl.c (grokdeclarator): Don't treat [] declarators in fields
+	as indicating flexible array members unless the field itself is
+	being declarared as the incomplete array.
+
+2009-02-07  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	Backport from mainline:
+	2009-02-05  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	PR target/38991
+	* config/sh/predicates.md (general_movsrc_operand): Don't check
+	the subreg of system registers here.
+
+2009-02-05  Joseph Myers  <joseph@codesourcery.com>
+
+	PR c/35435
+	* c-common.c (handle_tls_model_attribute): Ignore attribute for
+	non-VAR_DECLs without checking DECL_THREAD_LOCAL_P.
+
+2009-02-05  Richard Guenther  <rguenther@suse.de>
+
+	Backport from mainline
+	2009-02-05  Daniel Berlin  <dberlin@dberlin.org>
+		    Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/39100
+	* tree-ssa-structalias.c (do_ds_constraint): Actually do what the
+	comment says and add edges.
+
+2009-02-04  Ramana Radhakrishnan  <ramana.r@gmail.com>
+
+	PR rtl-optimization/39076
+	Backport from mainline:
+	2008-06-28  Andrew Jenner  <andrew@codesourcery.com>
+	
+	* regrename.c (build_def_use): Don't copy RTX.
+
+2009-02-04  Joseph Myers  <joseph@codesourcery.com>
+
+	PR c/35433
+	* c-typeck.c (composite_type): Set TYPE_SIZE and TYPE_SIZE_UNIT
+	for composite type involving a zero-length array type.
+
+2009-02-02  Catherine Moore  <clm@codesourcery.com>
+
+	* sde.h (SUBTARGET_ARM_SPEC): Don't assemble -fpic code as
+	-mabicalls.
+
+2009-01-31  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	* config/pa/fptr.c: Revert license to GPL 2.
+	* config/pa/milli64.S: Likewise.
+
+2009-01-30  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/39041
+	* tree-ssa-forwprop.c (forward_propagate_addr_expr_1):
+	Propagate variable indices only if the types match for this stmt.
+
+2009-01-29  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline:
+	2009-01-28  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/38988
+	* config/i386/i386.md (set_rip_rex64): Wrap operand 1 in label_ref.
+	(set_got_offset_rex64): Ditto.
+
+	2009-01-27  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR middle-end/38969
+	* calls.c (initialize_argument_information): Do not wrap complex
+	arguments in SAVE_EXPR.
+
+2009-01-27  Steve Ellcey  <sje@cup.hp.com>
+
+	PR middle-end/38615
+	* gimplify.c (gimplify_init_constructor): Fix promotion of const
+	variables to static.
+	* doc/invoke.texi (-fmerge-all-constants): Update description.
+
+2009-01-27  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline:
+	2009-01-13  Uros Bizjak  <ubizjak@gmail.com>
+
+	* config/alpha/alpha.c (alpha_legitimate_address_p): Explicit
+	relocations of local symbols wider than UNITS_PER_WORD are not valid.
+	(alpha_legitimize_address): Do not split local symbols wider than
+	UNITS_PER_WORD into HIGH/LO_SUM parts.
+
+	2009-01-07  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/38706
+	* config/alpha/alpha.c (alpha_end_function): For TARGET_ABI_OSF, call
+	free_after_compilation when outputting a thunk.
+	(alpha_output_mi_thunk_osf): Assert that we are processing a thunk.
+	Do not call free_after_compilation here.
+
+	2008-12-22  Uros Bizjak  <ubizjak@gmail.com>
+
+	* config/alpha/elf.h (ASM_OUTPUT_EXTERNAL): New macro.
+
+	2008-12-21  Uros Bizjak  <ubizjak@gmail.com>
+
+	* config/alpha/alpha.c (alpha_pad_noreturn): New static function.
+	(alpha_reorg): Call alpha_pad_noreturn.
+
+	2008-12-08  Uros Bizjak  <ubizjak@gmail.com>
+
+	* config/alpha/alpha.c (alpha_set_memflags): Process memory
+	references in full insn sequence.
+
+	2008-12-05  Uros Bizjak  <ubizjak@gmail.com>
+
+	* config/alpha/alpha.c (alpha_fold_vector_minmax): Create
+	VIEW_CONVERT_EXPR to convert output to long_integer_type_node.
+
+	(alpha_emit_conditional_branch): Do not generate direct branch
+	for UNORDERED comparisons.
+
+2008-01-26  Paolo Bonzini  <bonzini@gnu.org>
+
+	PR tree-optimization/38932
+	* fold-const.c (fold_unary_ignore_overflow): New.
+	* tree.h (fold_unary_ignore_overflow): Declare.
+	* tree-ssa-ccp.c (ccp_fold): Use fold_unary_ignore_overflow.
+	* tree-ssa-sccvn.c (simplify_unary_expression): Likewise.
+
+2009-01-25  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline:
+	2009-01-22  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/38931
+	* config/i386/i386.md (*movsi_1): Use type "mmx" for alternative 2.
+	(*movdi_1_rex64): Use type "mmx" for alternative 5.
+
+	2009-01-21  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR rtl-optimization/38879
+	* alias.c (base_alias_check): Unaligned access via AND address can
+	alias all surrounding object types except those with sizes equal
+	or wider than the size of unaligned access.
+
+2009-01-25  Richard Guenther  <rguenther@suse.de>
+
+	Backport from mainline:
+	2008-12-02  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/38359
+	* fold-const.c (fold_binary): Fold -1 >> x to -1 only for
+	non-negative x.
+
+2009-01-24  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* config/sparc/linux.h (DBX_REGISTER_NUMBER): Delete.
+	* config/sparc/linux64.h (DBX_REGISTER_NUMBER): Likewise.
+	* config/sparc/sysv4.h (DBX_REGISTER_NUMBER): Likewise.
+
+2009-01-24  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/38902
+	Backport from mainline:
+	2008-12-23  Jakub Jelinek  <jakub@redhat.com>
+
+	* config/i386/i386.c (expand_movmem_via_rep_mov): Set MEM_SIZE
+	correctly.
+	(expand_setmem_via_rep_stos): Add ORIG_VALUE argument.  If
+	ORIG_VALUE is const0_rtx and COUNT is constant, set MEM_SIZE
+	on DESTMEM.
+	(ix86_expand_setmem): Adjust callers.
+
+2008-01-24  Richard Guenther  <rguenther@suse.de>
+
+	* BASE-VER: Set to 4.3.4.
+	* DEV-PHASE: Set to prerelease.
+
 2009-01-24  Release Manager
 
 	* GCC 4.3.3 released.
@@ -5,8 +321,7 @@
 2009-01-20  Joseph Myers  <joseph@codesourcery.com>
 
 	PR other/38758
-	* longlong.h: Update copyright years.  Use soft-fp license
-	notice.
+	* longlong.h: Update copyright years.  Use soft-fp license notice.
 
 2009-01-19  Richard Guenther  <rguenther@suse.de>
 
@@ -41,7 +356,8 @@
 	
 2009-01-11  Matthias Klose  <doko@ubuntu.com>
 
-	PR middle-end/38616, backport from mainline:
+	PR middle-end/38616
+	Backport from mainline:
 	2008-05-04  Uros Bizjak  <ubizjak@gmail.com>
 
 	* config/i386/i386.md (*strmovsi_1): Simplify asm alternatives.
@@ -509,8 +825,8 @@
 	PR tree-optimization/37102
 	* tree-outof-ssa.c (remove_gimple_phi_args): Remove all the PHI args  
 	from a node. Check to see if another PHI is dead.
-	(eliminate_useless_phis): Rename from eliminate_virtual_phis and remove
-	real PHIs which have no uses.
+	(eliminate_useless_phis): Rename from eliminate_virtual_phis and
+	remove real PHIs which have no uses.
 	(rewrite_out_of_ssa): Call eliminate_useless_phis.
 
 2008-10-08  Simon Martin  <simartin@users.sourceforge.net>
@@ -986,8 +1302,10 @@
 
 	(MFC_MIN_DMA_LIST_ELEMENTS): New define.
 	(MFC_MAX_DMA_LIST_ELEMENTS): Likewise.
-	(MFC_MIN_DMA_LIST_SIZE): Redefine in terms of MFC_MIN_DMA_LIST_ELEMENTS.
-	(MFC_MAX_DMA_LIST_SIZE): Redefine in terms of MFC_MAX_DMA_LIST_ELEMENTS.
+	(MFC_MIN_DMA_LIST_SIZE): Redefine in terms of
+	MFC_MIN_DMA_LIST_ELEMENTS.
+	(MFC_MAX_DMA_LIST_SIZE): Redefine in terms of
+	MFC_MAX_DMA_LIST_ELEMENTS.
 
 	(MFC_START_ENABLE): Remove PPU-only define.
 	(MFC_PUTS_CMD, MFC_PUTFS_CMD, MFC_PUTBS_CMD): Likewise.
Index: gcc/testsuite/gcc.c-torture/execute/pr39100.c
===================================================================
--- gcc/testsuite/gcc.c-torture/execute/pr39100.c	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/execute/pr39100.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,65 @@
+/* Bad PTA results (incorrect store handling) was causing us to delete
+   *na = 0 store.  */
+
+typedef struct E
+{
+  int p;
+  struct E *n;
+} *EP;   
+
+typedef struct C
+{
+  EP x;
+  short cn, cp; 
+} *CP;
+
+__attribute__((noinline)) CP
+foo (CP h, EP x)
+{
+  EP pl = 0, *pa = &pl;
+  EP nl = 0, *na = &nl;
+  EP n;
+
+  while (x)
+    {
+      n = x->n;   
+      if ((x->p & 1) == 1) 
+        {
+          h->cp++;
+          *pa = x;
+          pa = &((*pa)->n);
+        }
+      else
+        {
+          h->cn++;
+          *na = x;
+          na = &((*na)->n);
+        }    
+      x = n;
+    }
+  *pa = nl;
+  *na = 0;
+  h->x = pl;
+  return h;
+}
+
+int
+main (void)
+{  
+  struct C c = { 0, 0, 0 };
+  struct E e[2] = { { 0, &e[1] }, { 1, 0 } };
+  EP p;
+
+  foo (&c, &e[0]);
+  if (c.cn != 1 || c.cp != 1)
+    __builtin_abort ();
+  if (c.x != &e[1])
+    __builtin_abort ();
+  if (e[1].n != &e[0])
+    __builtin_abort ();
+  if (e[0].n)
+    __builtin_abort ();
+  return 0;  
+}
+
+
Index: gcc/testsuite/gcc.c-torture/execute/pr39228.c
===================================================================
--- gcc/testsuite/gcc.c-torture/execute/pr39228.c	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/execute/pr39228.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,36 @@
+extern void abort (void);
+
+static int __attribute__((always_inline)) testf (float b)
+{
+  float c = 1.01f * b;
+
+  return __builtin_isinff (c);
+}
+
+static int __attribute__((always_inline)) test (double b)
+{
+  double c = 1.01 * b;
+
+  return __builtin_isinf (c);
+}
+
+static int __attribute__((always_inline)) testl (long double b)
+{
+  long double c = 1.01L * b;
+
+  return __builtin_isinfl (c);
+}
+
+int main()
+{
+  if (testf (__FLT_MAX__) < 1)
+    abort ();
+
+  if (test (__DBL_MAX__) < 1)
+    abort ();
+
+  if (testl (__LDBL_MAX__) < 1)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr39228.x
===================================================================
--- gcc/testsuite/gcc.c-torture/execute/pr39228.x	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/execute/pr39228.x	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,10 @@
+if { [istarget "alpha*-*-*"] || [istarget "sh*-*-*"] } {
+	# alpha and SH require -mieee for this test.
+	set additional_flags "-mieee"
+}
+if [istarget "spu-*-*"] {
+	# No Inf/NaN support on SPU.
+	return 1
+}
+
+return 0
Index: gcc/testsuite/gcc.c-torture/execute/shiftopt-1.c
===================================================================
--- gcc/testsuite/gcc.c-torture/execute/shiftopt-1.c	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/testsuite/gcc.c-torture/execute/shiftopt-1.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -43,12 +43,6 @@
 
   if (0 >> x != 0)
     link_error ();
-
-  if (-1 >> x != -1)
-    link_error ();
-
-  if (~0 >> x != ~0)
-    link_error ();
 }
 
 int
Index: gcc/testsuite/gcc.c-torture/execute/pr38969.c
===================================================================
--- gcc/testsuite/gcc.c-torture/execute/pr38969.c	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/execute/pr38969.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,25 @@
+__complex__ float
+__attribute__ ((noinline)) foo (__complex__ float x)
+{
+  return x;
+}
+
+__complex__ float
+__attribute__ ((noinline)) bar (__complex__ float x)
+{
+  return foo (x);
+}
+
+int main()
+{
+  __complex__ float a, b;
+  __real__ a = 9;
+  __imag__ a = 42;
+
+  b = bar (a);
+
+  if (a != b)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/struct-aliasing-1.c
===================================================================
--- gcc/testsuite/gcc.c-torture/execute/struct-aliasing-1.c	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/execute/struct-aliasing-1.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,17 @@
+struct S { float f; };
+int __attribute__((noinline))
+foo (int *r, struct S *p)
+{
+  int *q = (int *)&p->f;
+  int i = *q;
+  *r = 0;
+  return i + *q;
+}
+extern void abort (void);
+int main()
+{
+  int i = 1;
+  if (foo (&i, (struct S *)&i) != 1)
+    abort ();
+  return (0);
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr38789.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr38789.c	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr38789.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,18 @@
+/* PR tree-optimization/38789 */
+
+void
+baz (int v)
+{
+  unsigned a = (v == 1) ? 1 : 2;
+
+  if (__builtin_constant_p (a))
+    asm volatile ("# constant %0" :: "i" (a));
+  else
+    asm volatile ("# register %0" :: "r" (a));
+
+  a = 6;
+  if (__builtin_constant_p (a))
+    asm volatile ("# constant %0" :: "i" (a));
+  else
+    asm volatile ("# register %0" :: "r" (a));
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr38359.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr38359.c	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr38359.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,17 @@
+unsigned _ov_64_seek_lap (_Bool x1, _Bool x2, _Bool x3)
+{
+  unsigned ltmp_3978_7__PHI_TEMPORARY;
+  signed ltmp_4011_7;
+
+  if (!x1 || !x2)
+    while (1) ;
+
+  if (x3)
+    ltmp_3978_7__PHI_TEMPORARY = 0xffffff7e;
+  else
+    ltmp_3978_7__PHI_TEMPORARY = 1;
+
+  ltmp_4011_7 = -1;
+  return ltmp_4011_7 >> ltmp_3978_7__PHI_TEMPORARY;
+}
+
Index: gcc/testsuite/gcc.c-torture/compile/pr39041.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr39041.c	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr39041.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,28 @@
+int test_bit(int nr, void *addr)
+{
+  int *a = (int *)addr;
+  int mask;
+  a += nr;
+  mask = 1 << nr;
+  return mask & *a;
+}
+struct {
+    struct {
+	int disabled;
+    } *data[1];
+} trace;
+struct {
+    unsigned bits[1];
+} cpumask;
+void inc(int *);
+void dec(int *);
+int foo(void)
+{
+  int cpu;
+  for (cpu = 0; cpu < 1; cpu++) {
+      if (test_bit(cpu, cpumask.bits))
+	inc(&trace.data[cpu]->disabled);
+      if (!test_bit(cpu, cpumask.bits))
+	dec(&trace.data[cpu]->disabled);
+  }
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr38926.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr38926.c	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr38926.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,41 @@
+static inline int foo (unsigned _si1)
+{
+  if (_si1 != 0)
+    if (_si1 > 2147483647)
+      return 1;
+  return 0;
+}
+
+static inline unsigned bar (unsigned _left, int _right)
+{
+  return (unsigned) _right >= 8 ? 1 : _left >> _right;
+}
+
+unsigned g_2;
+unsigned g_67;
+volatile unsigned g_162;
+
+static inline int func_62 (unsigned p_63)
+{
+  p_63 = g_2 & g_67;
+  if (g_2)
+    ;
+  else if (p_63)
+    return 1;
+  g_67 = bar (p_63, g_2);
+  return 0;
+}
+
+unsigned baz (void)
+{
+  if (g_2)
+    for (; g_2 <= -16; g_2 = foo (g_2))
+      {
+        for (; g_162; g_162)
+          func_62 (func_62 (0));
+        if (g_67)
+          break;
+      }
+  return g_2;
+}
+
Index: gcc/testsuite/gcc.c-torture/compile/pr38857.c
===================================================================
--- gcc/testsuite/gcc.c-torture/compile/pr38857.c	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.c-torture/compile/pr38857.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,22 @@
+static const int vs_total_ac_bits = 2680;
+typedef struct EncBlockInfo {
+      short mb[64];
+      unsigned char next[64];
+} EncBlockInfo;
+inline void dv_guess_qnos(EncBlockInfo* blks, int* qnos) {
+      int size[5];
+      int j, k, a, prev;
+      EncBlockInfo* b;
+      for(a=2; a==2 || vs_total_ac_bits < size[0]; a+=a){
+	 for (j=0; j<6*5; j++, b++) {
+	     for (k= b->next[prev]; k<64; k= b->next[k]) {
+		 if(b->mb[k] < a && b->mb[k] > -a){
+		     b->next[prev] = b->next[k];
+		 }
+		 else{
+		     prev = k;
+		 }
+	     }
+	 }
+     }
+}
Index: gcc/testsuite/gcc.target/i386/pr36578-1.c
===================================================================
--- gcc/testsuite/gcc.target/i386/pr36578-1.c	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/i386/pr36578-1.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,22 @@
+/* Test for unsafe floating-point conversions.  PR 36578.  */
+/* { dg-do run } */
+/* { dg-options "-msse2 -mfpmath=sse" } */
+
+#include "sse2-check.h"
+
+extern void abort (void);
+extern void exit (int);
+extern int printf(const char *, ...);
+
+volatile double d1 = 1.0;
+volatile double d2 = 0x1.00001p-53;
+volatile double d3;
+
+static void
+sse2_test (void)
+{
+  d3 = (double)((long double)d1 + (long double)d2);
+  if (d3 != d1)
+    abort ();
+  exit (0);
+}
Index: gcc/testsuite/gcc.target/i386/pr36578-2.c
===================================================================
--- gcc/testsuite/gcc.target/i386/pr36578-2.c	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/i386/pr36578-2.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,23 @@
+/* Test for unsafe floating-point conversions.  */
+/* { dg-do run } */
+/* { dg-options "-msse2 -mfpmath=sse" } */
+
+#include "sse2-check.h"
+
+extern void abort (void);
+extern void exit (int);
+extern int printf(const char *, ...);
+
+volatile double d1 = 0x1.000001p0;
+volatile double d2 = 0x1p-54;
+volatile float f = 0x1.000002p0f;
+volatile float f2;
+
+static void
+sse2_test (void)
+{
+  f2 = (float)((long double)d1 + (long double)d2);
+  if (f != f2)
+    abort ();
+  exit (0);
+}
Index: gcc/testsuite/gcc.target/i386/pr38988.c
===================================================================
--- gcc/testsuite/gcc.target/i386/pr38988.c	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/i386/pr38988.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,24 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target lp64 } */
+/* { dg-require-effective-target fpic } */
+/* { dg-options "-O2 -fpic -mcmodel=large" } */
+
+typedef long unsigned int size_t;
+typedef void (*func_ptr) (void);
+
+static func_ptr __DTOR_LIST__[1] = { (func_ptr) (-1) };
+
+void
+__do_global_dtors_aux (void)
+{
+  extern func_ptr __DTOR_END__[];
+  size_t dtor_idx = 0;
+  const size_t max_idx = __DTOR_END__ - __DTOR_LIST__ - 1;
+  func_ptr f;
+
+  while (dtor_idx < max_idx)
+    {
+      f = __DTOR_LIST__[++dtor_idx];
+      f ();
+    }
+}
Index: gcc/testsuite/gcc.target/i386/pr38931.c
===================================================================
--- gcc/testsuite/gcc.target/i386/pr38931.c	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/i386/pr38931.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,23 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -msse" } */
+
+typedef int __m64 __attribute__ ((__vector_size__ (8)));
+
+extern __m64 foo () ;
+
+void bar (const int input_bpl, const unsigned char *input,
+	  unsigned char *output, unsigned long x1)
+{
+  unsigned char *pix_end_ptr = output + x1 * 4;
+  __m64 m_original = { 0, 0 };
+  __m64 m_base_addr = __builtin_ia32_vec_init_v2si (0, input_bpl);
+  __m64 m_addr = __builtin_ia32_paddd (m_original, m_base_addr);
+  __m64 *a0 = (__m64 *) input;
+
+  for (; output < pix_end_ptr; output += 4)
+    {
+      a0 = (__m64 *) (input + __builtin_ia32_vec_ext_v2si (m_addr, 0));
+      m_addr = foo ();
+      __builtin_prefetch (a0, 0);
+    }
+}
Index: gcc/testsuite/gcc.target/i386/pr39058.c
===================================================================
--- gcc/testsuite/gcc.target/i386/pr39058.c	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/i386/pr39058.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,34 @@
+/* PR inline-asm/39058 */
+/* { dg-options "-O2" } */
+
+double
+f1 ()
+{
+  double x;
+  asm ("" : "=r,r" (x) : "0,0" (x));
+  return x;
+}
+
+double
+f2 ()
+{
+  double x;
+  asm ("" : "=r" (x) : "0" (x));
+  return x;
+}
+
+double
+f3 ()
+{
+  double x, y;
+  asm ("" : "=r,r" (x), "=r,r" (y) : "%0,0" (x), "r,r" (0));
+  return x;
+}
+
+double
+f4 ()
+{
+  double x, y;
+  asm ("" : "=r" (x), "=r" (y) : "0" (x), "r" (0));
+  return x;
+}
Index: gcc/testsuite/gcc.target/ia64/sibcall-opt-1.c
===================================================================
--- gcc/testsuite/gcc.target/ia64/sibcall-opt-1.c	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/ia64/sibcall-opt-1.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,12 @@
+/* PR target/38056.  Do not do sibcall optimization across object file
+   boundery when -mconstant-gp is not used.  */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+/* { dg-final { scan-assembler "br.call.*bar" } } */
+
+int bar(int x);
+
+int foo(int x)
+{
+  return (bar(x + 1));
+}
Index: gcc/testsuite/gcc.target/ia64/sibcall-opt-2.c
===================================================================
--- gcc/testsuite/gcc.target/ia64/sibcall-opt-2.c	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.target/ia64/sibcall-opt-2.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,12 @@
+/* PR target/38056.  Do sibcall optimization across object file
+   boundery when -mconstant-gp is used.  */
+/* { dg-do compile } */
+/* { dg-options "-O2 -mconstant-gp" } */
+/* { dg-final { scan-assembler-not "br.call.*bar" } } */
+
+int bar(int x);
+
+int foo(int x)
+{
+  return (bar(x + 1));
+}
Index: gcc/testsuite/gcc.dg/c90-flex-array-2.c
===================================================================
--- gcc/testsuite/gcc.dg/c90-flex-array-2.c	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/c90-flex-array-2.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,15 @@
+/* [] does not indicate a flexible array member unless it is the field
+   itself being declared as an incomplete array type rather than a
+   pointer or other type derived from such a type.  PR 36432.  */
+/* { dg-do compile } */
+/* { dg-options "-std=iso9899:1990 -pedantic-errors" } */
+
+void
+f (void)
+{
+  int a[3];
+  int (*p)[];
+  struct { int (*p)[]; } s;
+  p = &a;
+  s.p = &a;
+}
Index: gcc/testsuite/gcc.dg/attr-alias-4.c
===================================================================
--- gcc/testsuite/gcc.dg/attr-alias-4.c	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/attr-alias-4.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,4 @@
+/* ICE on invalid alias attribute: PR 35434.  */
+/* { dg-do compile } */
+/* { dg-options "" } */
+typedef int i __attribute__((alias("j"))); /* { dg-warning "ignored" } */
Index: gcc/testsuite/gcc.dg/pr38932.c
===================================================================
--- gcc/testsuite/gcc.dg/pr38932.c	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/pr38932.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,19 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+/* This variable needed only to exercise FRE instead of CCP.  */
+unsigned char g;
+
+extern void abort();
+
+void f (long long int p)
+{
+  g = 255;
+  if (p >= (-9223372036854775807LL - 1) - (signed char) g)
+    p = 1;
+
+  if (p)
+    abort ();
+}
+
+
Index: gcc/testsuite/gcc.dg/pr38245-4.c
===================================================================
--- gcc/testsuite/gcc.dg/pr38245-4.c	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/pr38245-4.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,107 @@
+/* PR rtl-optimization/38245 */
+/* { dg-do compile } */
+/* { dg-options "" } */
+
+#include "pr38245-3.h"
+
+int
+b1 (long long a1, long a2, long a3, long a4,
+    long a5, long a6, long a7, long a8,
+    long long a9, long a10, long a11, long a12,
+    long a13, long a14, long a15, long a16,
+    long long a17, long a18, long a19, long a20,
+    long a21, long a22, long a23, long a24,
+    long long a25, long a26, long a27, long a28,
+    long a29, long a30, long a31, long a32)
+{
+  return a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 + a9 + a10
+	 + a11 + a12 + a13 + a14 + a15 + a16 + a17 + a18 + a19 + a20
+	 + a21 + a22 + a23 + a24 + a25 + a26 + a27 + a28 + a29 + a30
+	 + a31 + a32 + globv;
+}
+
+int
+b2 (long long a1, long a2, long a3, long a4,
+    long a5, long a6, long a7, long a8,
+    long long a9, long a10, long a11, long a12,
+    long a13, long a14, long a15, long a16,
+    long long a17, long a18, long a19, long a20,
+    long a21, long a22, long a23, long a24,
+    long long a25, long a26, long a27, long a28,
+    long a29, long a30, long a31, long a32)
+{
+  return a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 + a9 + a10
+	 + a11 + a12 + a13 + a14 + a15 + a16 + a17 + a18 + a19 + a20
+	 + a21 + a22 + a23 + a24 + a25 + a26 + a27 + a28 + a29 + a30
+	 + a31 + a32;
+}
+
+int
+b3 (long long a1, long a2, long a3, long a4,
+    long a5, long a6, long a7, struct B a8,
+    long long a9, struct B a10, long a11, struct B a12,
+    long a13, long a14, long a15, long a16,
+    long long a17, struct B a18, long a19, struct B a20,
+    long a21, long a22, long a23, long a24,
+    long long a25, struct B a26, long a27, struct B a28,
+    long a29, long a30, long a31, long a32)
+{
+  return a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8.a + a9 + a10.a
+	 + a11 + a12.a + a13 + a14 + a15 + a16 + a17 + a18.a + a19 + a20.a
+	 + a21 + a22 + a23 + a24 + a25 + a26.a + a27 + a28.a + a29 + a30
+	 + a31 + a32 + globv;
+}
+
+int
+b4 (long long a1, long a2, long a3, long a4,
+    long a5, long a6, long a7, struct B a8,
+    long long a9, struct B a10, long a11, struct B a12,
+    long a13, long a14, long a15, long a16,
+    long long a17, struct B a18, long a19, struct B a20,
+    long a21, long a22, long a23, long a24,
+    long long a25, struct B a26, long a27, struct B a28,
+    long a29, long a30, long a31, long a32)
+{
+  return a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8.a + a9 + a10.a
+	 + a11 + a12.a + a13 + a14 + a15 + a16 + a17 + a18.a + a19 + a20.a
+	 + a21 + a22 + a23 + a24 + a25 + a26.a + a27 + a28.a + a29 + a30
+	 + a31 + a32;
+}
+
+int
+b5 (double a1, int a2, int a3, int a4, int a5, int a6, double a7,
+    double a8, double a9)
+{
+  return a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 + a9 + globv;
+}
+
+int
+b6 (double a1, int a2, int a3, int a4, int a5, int a6, double a7,
+    double a8, double a9)
+{
+  return a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 + a9;
+}
+
+int
+b7 (int a1, int a2)
+{
+  return a1 + a2 + globv;
+}
+
+int
+b8 (int a1, int a2)
+{
+  return a1 + a2;
+}
+
+int
+b9 (int a1, int a2, int a3, int a4, int a5, int a6, int a7)
+{
+  return a1 + a2 + a3 + a4 + a5 + a6 + a7 + globv;
+}
+
+int
+b10 (int a1, int a2, int a3, int a4, int a5, int a6, int a7)
+{
+  return a1 + a2 + a3 + a4 + a5 + a6 + a7;
+}
Index: gcc/testsuite/gcc.dg/torture/pr39241.c
===================================================================
--- gcc/testsuite/gcc.dg/torture/pr39241.c	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/torture/pr39241.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+/* { dg-options "-w" } */
+
+static inline int
+foo (float f)
+{
+  return *((int *) &f) - 1;
+}
+
+float
+bar (float x, float y, float *z)
+{
+  float c = y < 0.002f ? 0.002f : y;
+  float d = x < c ? c : x;
+  return z[foo (c)] + z[foo (d * 255.0f)];
+}
Index: gcc/testsuite/gcc.dg/tree-ssa/struct-aliasing-1.c
===================================================================
--- gcc/testsuite/gcc.dg/tree-ssa/struct-aliasing-1.c	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/tree-ssa/struct-aliasing-1.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,15 @@
+/* { dg-do "compile" } */
+/* { dg-options "-O2 -fdump-tree-fre" } */
+
+struct S { float f; };
+int __attribute__((noinline))
+foo (float *r, struct S *p)
+{
+  int *q = (int *)&p->f;
+  int i = *q;
+  *r = 0.0;
+  return i + *q;
+}
+
+/* { dg-final { scan-tree-dump-times "\\\*q" 1 "fre" } } */
+/* { dg-final { cleanup-tree-dump "fre" } } */
Index: gcc/testsuite/gcc.dg/tls/diag-6.c
===================================================================
--- gcc/testsuite/gcc.dg/tls/diag-6.c	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/tls/diag-6.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,8 @@
+/* Invalid tls_model attributes.  PR 35435.  */
+/* { dg-require-effective-target tls } */
+
+int v __attribute__((tls_model("initial-exec"))); /* { dg-warning "attribute ignored" } */
+typedef int X __attribute__((tls_model("initial-exec"))); /* { dg-warning "attribute ignored" } */
+void f(int x __attribute__((tls_model("initial-exec")))); /* { dg-warning "attribute ignored" } */
+__thread int a __attribute__((tls_model(1))); /* { dg-error "tls_model argument not a string" } */
+__thread int b __attribute__((tls_model("unknown"))); /* { dg-error "tls_model argument must be one of" } */
Index: gcc/testsuite/gcc.dg/pr38615.c
===================================================================
--- gcc/testsuite/gcc.dg/pr38615.c	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/pr38615.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,19 @@
+/* { dg-do run } */
+
+int t;
+extern void abort (void);
+
+int f(int t, const int *a)
+{
+ const int b[] = { 1, 2, 3};
+ if (!t)
+   return f(1, b);
+ return b == a;
+}
+
+int main(void)
+{
+ if (f(0, 0))
+   abort ();
+ return 0;
+}
Index: gcc/testsuite/gcc.dg/pr39084.c
===================================================================
--- gcc/testsuite/gcc.dg/pr39084.c	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/pr39084.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+struct color { int i; };
+static const struct color col;
+struct color * f(void)
+{
+    return (struct color *) &col;
+}
+
+struct color { int j; }; /* { dg-error "redefinition of" } */
Index: gcc/testsuite/gcc.dg/pr38364.c
===================================================================
--- gcc/testsuite/gcc.dg/pr38364.c	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/pr38364.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,79 @@
+/* PR middle-end/38364 */
+/* { dg-do run } */
+/* { dg-options "-O2 -ftrapv" } */
+
+extern void abort (void);
+
+static inline short
+f1 (short x, short y)
+{
+  if (x > 0)
+    {
+      if (y > 0)
+	{
+	  if (x > __SHRT_MAX__ / y)
+	    return x;
+	}
+      else if (y < (-__SHRT_MAX__ - 1) / x)
+	return x;
+    }
+  else
+    {
+      if (y > 0)
+	{
+	  if (x < (-__SHRT_MAX__ - 1) / y)
+	    return x;
+	}
+      else if (x != 0 && y < __SHRT_MAX__ / x)
+	return x;
+    }
+  return x * y;
+}
+
+static inline signed char
+f2 (signed char x, signed char y)
+{
+  if (((x ^ y) & (((x ^ ((x ^ y) & (1 << (__CHAR_BIT__ - 1)))) - y) ^ y)) < 0)
+    return x;
+  return x - y;
+}
+
+unsigned int v;
+
+int
+f3 (int x, unsigned int y)
+{
+  f1 (1, 1);
+  return 1;
+}
+
+int
+f4 (unsigned short x)
+{
+  v = x;
+  return 1;
+}
+
+int
+f5 (int x)
+{
+  if (f2 (x, 1))
+    f1 (1, f4 (1));
+  return x;
+}
+
+int
+f6 (unsigned int x)
+{
+  f4 (x < (1 != f5 (0)));
+  return x;
+}
+
+int
+main (void)
+{
+  f6 (1);
+  if (v != 0)
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/pr38902.c
===================================================================
--- gcc/testsuite/gcc.dg/pr38902.c	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/pr38902.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,131 @@
+/* PR target/38902 */
+/* { dg-do run } */
+/* { dg-options "-O2 -fstack-protector" } */
+/* { dg-require-effective-target fstack_protector } */
+
+#ifdef DEBUG
+#include <stdio.h>
+#define debug(format, args...) printf (format , ## args)
+#else
+extern int sprintf (char *, const char *, ...);
+#define debug(format, args...)
+#endif
+
+extern void abort (void);
+
+/*
+
+Copyright (C) 2009 Canonical, Ltd.
+Author: Kees Cook <kees@ubuntu.com>
+License: GPLv3
+
+http://gcc.gnu.org/bugzilla/show_bug.cgi?id=38616
+https://bugs.launchpad.net/ubuntu/+source/gcc-4.3/+bug/316019
+http://gcc.gnu.org/bugzilla/show_bug.cgi?id=38902
+
+gcc -O2 -fstack-protector truncate.c -o truncate
+
+    Broken:
+
+        Only the first operation fails, so create a new function for each test.
+        Source must be local (literal or stack)
+
+        __builtin_memmove
+        __builtin_memcpy
+        __builtin_strcpy  (optimized to __builtin_memcpy?)
+        sprintf (direct)  (optmized to __builtin_strcpy?)
+        sprintf (via %s)  (optmized to __builtin_strcpy?)
+
+    OK:
+        __builtin_strcat
+        sprintf (complex format)
+
+ */
+
+char *heap = "1234567890abcdefghijklmnopqrstuvwxyz";
+
+int failed = 0;
+
+#define CHECK(count, a...) \
+void test##count (void) \
+{ \
+  char *local = "1234567890abcdefghijklmnopqrstuvwxyz"; \
+  char buffer[1024]=""; \
+    a; \
+    if (__builtin_strcmp(buffer, heap) == 0) { \
+        debug("Okay(%d):\n\t%s\n", count, # a); \
+    } \
+    else { \
+        debug("Failed(%d):\n\t%s\n", count, # a); \
+	failed++; \
+    } \
+}
+
+
+CHECK( 0, __builtin_memcpy (buffer, "1234567890abcdefghijklmnopqrstuvwxyz", __builtin_strlen("1234567890abcdefghijklmnopqrstuvwxyz")+1);                                        );
+CHECK( 1, __builtin_memcpy (buffer, local, __builtin_strlen(local)+1);                );
+CHECK( 2, __builtin_memcpy (buffer, heap, __builtin_strlen(heap)+1);                );
+
+CHECK( 3, __builtin_memmove (buffer, "1234567890abcdefghijklmnopqrstuvwxyz", __builtin_strlen("1234567890abcdefghijklmnopqrstuvwxyz")+1);                                       );
+CHECK( 4, __builtin_memmove (buffer, local, __builtin_strlen(local)+1);               );
+CHECK( 5, __builtin_memmove (buffer, heap, __builtin_strlen(heap)+1);               );
+
+CHECK( 6, __builtin_strcpy (buffer, "1234567890abcdefghijklmnopqrstuvwxyz");          );
+CHECK( 7, __builtin_strcpy (buffer, local);                                      );
+CHECK( 8, __builtin_strcpy (buffer, heap);                                      );
+
+CHECK( 9,  sprintf (buffer, "1234567890abcdefghijklmnopqrstuvwxyz");         );
+CHECK(10,  sprintf (buffer, local);                                     );
+CHECK(11,  sprintf (buffer, heap);                                     );
+
+CHECK(12,  sprintf (buffer, "%s", "1234567890abcdefghijklmnopqrstuvwxyz");   );
+CHECK(13,  sprintf (buffer, "%s", local);                               );
+CHECK(14,  sprintf (buffer, "%s", heap);                               );
+
+CHECK(15, __builtin_strcat (buffer, "1234567890abcdefghijklmnopqrstuvwxyz");          );
+CHECK(16, __builtin_strcat (buffer, local);                                      );
+CHECK(17, __builtin_strcat (buffer, heap);                                       );
+
+void mongoose(void)
+{
+  char buffer[1024]="";
+  sprintf (buffer, "%s", "1234567890abcdefghijklmnopqrstuvwxyz");;
+    if (__builtin_strcmp(buffer, heap) == 0) {
+        debug("Okay(%d):\n\t%s\n", -1, "sprintf (buffer, \"%s\", \"1234567890abcdefghijklmnopqrstuvwxyz\");");
+    }
+    else {
+        debug("Failed(%d):\n\t%s\n", -1, "sprintf (buffer, \"%s\", \"1234567890abcdefghijklmnopqrstuvwxyz\");");
+	failed++;
+    }
+}
+
+int main (int argc, char *argv[])
+{
+  test0();
+  test1();
+  test2();
+  test3();
+  test4();
+  test5();
+  test6();
+  test7();
+  test8();
+  test9();
+  test10();
+  test11();
+
+  // wtf, why are these different?!
+  test12();
+  mongoose();
+
+  test13();
+  test14();
+  test15();
+  test16();
+  test17();
+
+  if (failed)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/struct/wo_prof_single_str_pointer.c
===================================================================
--- gcc/testsuite/gcc.dg/struct/wo_prof_single_str_pointer.c	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/testsuite/gcc.dg/struct/wo_prof_single_str_pointer.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -29,7 +29,9 @@
   if (p->a != res)
     abort ();
   
-  return p->a;
+  /* POSIX ignores all but the 8 low-order bits, but other
+     environments may not.  */
+  return (p->a & 255);
 }
 
 /*--------------------------------------------------------------------------*/
Index: gcc/testsuite/gcc.dg/struct/w_prof_single_str_global.c
===================================================================
--- gcc/testsuite/gcc.dg/struct/w_prof_single_str_global.c	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/testsuite/gcc.dg/struct/w_prof_single_str_global.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -22,7 +22,9 @@
   if (str.a != res)
     abort ();
 
-  return str.a;
+  /* POSIX ignores all but the 8 low-order bits, but other
+     environments may not.  */
+  return (str.a & 255);
 }
 
 /*--------------------------------------------------------------------------*/
Index: gcc/testsuite/gcc.dg/struct/wo_prof_single_str_local.c
===================================================================
--- gcc/testsuite/gcc.dg/struct/wo_prof_single_str_local.c	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/testsuite/gcc.dg/struct/wo_prof_single_str_local.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -25,7 +25,9 @@
   if (str.a != res)
     abort ();
 
-  return str.a;
+  /* POSIX ignores all but the 8 low-order bits, but other
+     environments may not.  */
+  return (str.a & 255);
 }
 
 /*--------------------------------------------------------------------------*/
Index: gcc/testsuite/gcc.dg/struct/wo_prof_single_str_global.c
===================================================================
--- gcc/testsuite/gcc.dg/struct/wo_prof_single_str_global.c	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/testsuite/gcc.dg/struct/wo_prof_single_str_global.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -25,7 +25,9 @@
   if (str.a != res)
     abort ();
 
-  return str.a;
+  /* POSIX ignores all but the 8 low-order bits, but other
+     environments may not.  */
+  return (str.a & 255);
 }
 
 /*--------------------------------------------------------------------------*/
Index: gcc/testsuite/gcc.dg/c99-flex-array-6.c
===================================================================
--- gcc/testsuite/gcc.dg/c99-flex-array-6.c	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/c99-flex-array-6.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,15 @@
+/* [] does not indicate a flexible array member unless it is the field
+   itself being declared as an incomplete array type rather than a
+   pointer or other type derived from such a type.  PR 36432.  */
+/* { dg-do compile } */
+/* { dg-options "-std=iso9899:1999 -pedantic-errors" } */
+
+void
+f (void)
+{
+  int a[3];
+  int (*p)[];
+  struct { int (*p)[]; } s;
+  p = &a;
+  s.p = &a;
+}
Index: gcc/testsuite/gcc.dg/pr38245-3.c
===================================================================
--- gcc/testsuite/gcc.dg/pr38245-3.c	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/pr38245-3.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,112 @@
+/* PR rtl-optimization/38245 */
+/* { dg-do run } */
+/* { dg-additional-sources "pr38245-4.c" } */
+/* { dg-options "-O2" } */
+
+#include "pr38245-3.h"
+
+extern void abort (void);
+
+struct A { int i, j; union { short s[4]; long long l; }; char pad[512]; } a;
+int globv = 6;
+
+void __attribute__((noinline))
+f1 (void)
+{
+  a.s[2] = b1 (6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
+	       6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21);
+  a.l = 6;
+}
+
+void __attribute__((noinline))
+f2 (void)
+{
+  a.s[2] = b2 (6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
+	       6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21);
+  a.l = 6;
+}
+
+void __attribute__((noinline))
+f3 (void)
+{
+  struct B b = { 30, 31, { 32, 33 } };
+  a.s[2] = b3 (6, 7, 8, 9, 10, 11, 12, b, 14, b, 16, b, 18, 19, 20, 21,
+	       6, b, 8, b, 10, 11, 12, 13, 14, b, 16, b, 18, 19, 20, 21);
+  a.l = 6;
+}
+
+void __attribute__((noinline))
+f4 (void)
+{
+  struct B b = { 30, 31, { 32, 33 } };
+  a.s[2] = b4 (6, 7, 8, 9, 10, 11, 12, b, 14, b, 16, b, 18, 19, 20, 21,
+	       6, b, 8, b, 10, 11, 12, 13, 14, b, 16, b, 18, 19, 20, 21);
+  a.l = 6;
+}
+
+void __attribute__((noinline))
+f5 (void)
+{
+  a.s[2] = b5 (6.0, 7, 8, 9, 10, 11, 21.0, 22.0, 23.0);
+  a.l = 6;
+}
+
+void __attribute__((noinline))
+f6 (void)
+{
+  a.s[2] = b6 (6.0, 7, 8, 9, 10, 11, 21.0, 22.0, 23.0);
+  a.l = 6;
+}
+
+void __attribute__((noinline))
+f7 (void)
+{
+  a.s[2] = b7 (6, 7);
+  a.l = 6;
+}
+
+void __attribute__((noinline))
+f8 (void)
+{
+  a.s[2] = b8 (6, 7);
+  a.l = 6;
+}
+
+void __attribute__((noinline))
+f9 (void)
+{
+  a.s[2] = b9 (6, 7, 8, 9, 10, 11, 12);
+  a.l = 6;
+}
+
+void __attribute__((noinline))
+f10 (void)
+{
+  a.s[2] = b10 (6, 7, 8, 9, 10, 11, 12);
+  a.l = 6;
+}
+
+int
+main (void)
+{
+  char buf[256];
+  int i;
+  for (i = 0; i < (int) sizeof buf; i++)
+    buf[i] = i;
+  asm volatile ("" : : "r" (buf) : "memory");
+  f1 ();
+  f2 ();
+  f3 ();
+  f4 ();
+  f5 ();
+  f6 ();
+  f7 ();
+  f8 ();
+  f9 ();
+  f10 ();
+  asm volatile ("" : : "r" (buf) : "memory");
+  for (i = 0; i < (int) sizeof buf; i++)
+    if (buf[i] != (char) i)
+      abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/dfp/convert-bfp-13.c
===================================================================
--- gcc/testsuite/gcc.dg/dfp/convert-bfp-13.c	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/dfp/convert-bfp-13.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,20 @@
+/* Test for bug where fold changed binary operation to decimal
+   depending on typedefs.  */
+/* { dg-options "-std=gnu99" } */
+
+extern void abort (void);
+extern void exit (int);
+
+volatile double d = 1.2345675;
+
+typedef const volatile _Decimal32 d32;
+
+int
+main (void)
+{
+  _Decimal32 a = (d * d);
+  d32 b = (d * d);
+  if (a != b)
+    abort ();
+  exit (0);
+}
Index: gcc/testsuite/gcc.dg/dfp/pr39035.c
===================================================================
--- gcc/testsuite/gcc.dg/dfp/pr39035.c	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/dfp/pr39035.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,81 @@
+/* { dg-do run } */
+/* { dg-options "-std=gnu99 -O" } */
+
+/* DFP TR 24732 == WG14 / N1176, N1312 */
+/* Based on a test from Fred Tydeman.  */
+
+extern void abort (void);
+int failures = 0;
+
+#ifdef DBG
+#include <stdio.h>
+#define FAILURE(MSG) { printf ("line %d: %s\n", __LINE__, MSG); failures++; }
+#else
+#define FAILURE(MSG) failures++;
+#endif
+
+/* Test runtime computations.  */
+
+void
+runtime32 (void)
+{
+  volatile _Decimal32 d;
+  d = 0.0DF;
+  if (d)
+    FAILURE ("0.0DF should be zero")
+}
+
+void
+runtime64 (void)
+{
+  volatile _Decimal64 d;
+  d = 0.0DD;
+  if (d)
+    FAILURE ("0.0DD should be zero")
+}
+
+void
+runtime128 (void)
+{
+  volatile _Decimal128 d;
+  d = 0.0DL;
+  if (d)
+    FAILURE ("0.0DL should be zero")
+}
+
+void
+fold32 (void)
+{
+  if (0.0DF)
+    FAILURE ("0.0DF should be zero")
+}
+
+void
+fold64 (void)
+{
+  if (0.0DD)
+    FAILURE ("0.0DD should be zero")
+}
+
+void
+fold128 (void)
+{
+  if (0.0DL)
+    FAILURE ("0.0DL should be zero")
+}
+
+int
+main(void)
+{
+  runtime32 ();
+  runtime64 ();
+  runtime128 ();
+
+  fold32 ();
+  fold64 ();
+  fold128 ();
+
+  if (failures != 0)
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/dfp/convert-dfp-fold-2.c
===================================================================
--- gcc/testsuite/gcc.dg/dfp/convert-dfp-fold-2.c	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/dfp/convert-dfp-fold-2.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,17 @@
+/* Test for bug where fold narrowed decimal floating-point
+   operations.  */
+/* { dg-options "-std=gnu99" } */
+
+extern void abort (void);
+extern void exit (int);
+
+volatile _Decimal32 f = 1.23456DF;
+volatile _Decimal64 d = 1.23456DD;
+
+int
+main (void)
+{
+  if ((_Decimal128)((_Decimal64)f * (_Decimal64)f) != (_Decimal128)(d * d))
+    abort ();
+  exit (0);
+}
Index: gcc/testsuite/gcc.dg/dfp/convert-bfp-14.c
===================================================================
--- gcc/testsuite/gcc.dg/dfp/convert-bfp-14.c	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/dfp/convert-bfp-14.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,17 @@
+/* Test for bug where fold narrowed decimal floating-point
+   operations.  */
+/* { dg-options "-std=gnu99" } */
+
+extern void abort (void);
+extern void exit (int);
+
+volatile _Decimal32 f = 1.23456DF;
+volatile _Decimal64 d = 1.23456DD;
+
+int
+main (void)
+{
+  if ((double)((_Decimal64)f * (_Decimal64)f) != (double)(d * d))
+    abort ();
+  exit (0);
+}
Index: gcc/testsuite/gcc.dg/dfp/pr39034.c
===================================================================
--- gcc/testsuite/gcc.dg/dfp/pr39034.c	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/dfp/pr39034.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,110 @@
+/* { dg-do run } */
+/* { dg-options "-std=gnu99 -O" } */
+
+/* DFP TR 24732 == WG14 / N1176, N1312 */
+
+extern void abort (void);
+int failures = 0;
+
+#ifdef DBG
+#include <stdio.h>
+#define FAILURE(MSG) { printf ("line %d: %s\n", __LINE__, MSG); failures++; }
+#else
+#define FAILURE(MSG) failures++;
+#endif
+
+
+/* Test runtime computations.  */
+
+void
+runtime32 (void)
+{
+  volatile float v1 = 28.f, v2 = 3.f, v3 = 9.f, v4 = 31.f, v5 = 3.f, v6 = 10.f;
+  float      b32 = (float)((v1/v2-v3) - (v4/v5-v6));
+  _Decimal32 d32 = (float)((v1/v2-v3) - (v4/v5-v6));
+
+  if (b32)
+    FAILURE ("runtime: b32 should be zero")
+  if (d32)
+    FAILURE ("runtime: d32 should be zero")
+}
+
+void
+runtime64 (void)
+{
+  volatile double v1 = 28., v2 = 3., v3 = 9., v4 = 31., v5 = 3., v6 = 10.;
+  double     b64 = (double)((v1/v2-v3) - (v4/v5-v6));
+  _Decimal64 d64 = (double)((v1/v2-v3) - (v4/v5-v6));
+
+  if (b64)
+    FAILURE ("runtime: b64 should be zero")
+  if (d64)
+    FAILURE ("runtime: d64 should be zero")
+}
+
+void
+runtime128 (void)
+{
+  volatile long double v1 = 28.l, v2 = 3.l, v3 = 9.l,
+                       v4 = 31.l, v5 = 3.l, v6 = 10.l;
+  long double b128 = (long double)((v1/v2-v3) - (v4/v5-v6));
+  _Decimal128 d128 = (long double)((v1/v2-v3) - (v4/v5-v6));
+
+  if (b128)
+    FAILURE ("runtime: b128 should be zero")
+  if (d128)
+    FAILURE ("runtime: d128 should be zero")
+}
+
+/* Test constant folding.  */
+
+void
+fold32 (void)
+{
+  double     d32 = (float)((28.f/3.f-9.f) - (31.f/3.f-10.f));
+  _Decimal32 b32 = (float)((28.f/3.f-9.f) - (31.f/3.f-10.f));
+
+  if (b32)
+    FAILURE ("fold: b32 should be zero")
+  if (d32)
+    FAILURE ("fold: d32 should be zero")
+}
+
+void
+fold64 (void)
+{
+  double     b64 = (double)((28./3.-9.) - (31./3.-10.));
+  _Decimal64 d64 = (double)((28./3.-9.) - (31./3.-10.));
+
+  if (b64)
+    FAILURE ("fold: b64 should be zero")
+  if (d64)
+    FAILURE ("fold: d64 should be zero")
+}
+
+void
+fold128 (void)
+{
+  long double b128 = (long double)((28./3.-9.) - (31./3.-10.));
+  _Decimal128 d128 = (long double)((28./3.-9.) - (31./3.-10.));
+
+  if (b128)
+    FAILURE ("fold: b128 should be zero")
+  if (d128)
+    FAILURE ("fold: d128 should be zero")
+}
+
+int
+main ()
+{
+  runtime32 ();
+  runtime64 ();
+  runtime128 ();
+  fold32 ();
+  fold64 ();
+  fold128 ();
+
+  if (failures != 0)
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/pr38245-3.h
===================================================================
--- gcc/testsuite/gcc.dg/pr38245-3.h	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/pr38245-3.h	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,35 @@
+/* PR rtl-optimization/38245 */
+
+struct B { long a, b; char p[32]; };
+extern int globv;
+
+extern int b1 (long long, long, long, long, long, long, long, long,
+	       long long, long, long, long, long, long, long, long,
+	       long long, long, long, long, long, long, long, long,
+	       long long, long, long, long, long, long, long, long)
+     __attribute__((pure, noinline));
+extern int b2 (long long, long, long, long, long, long, long, long,
+	       long long, long, long, long, long, long, long, long,
+	       long long, long, long, long, long, long, long, long,
+	       long long, long, long, long, long, long, long, long)
+     __attribute__((const, noinline));
+extern int b3 (long long, long, long, long, long, long, long, struct B,
+	       long long, struct B, long, struct B, long, long, long, long,
+	       long long, struct B, long, struct B, long, long, long, long,
+	       long long, struct B, long, struct B, long, long, long, long)
+     __attribute__((pure, noinline));
+extern int b4 (long long, long, long, long, long, long, long, struct B,
+	       long long, struct B, long, struct B, long, long, long, long,
+	       long long, struct B, long, struct B, long, long, long, long,
+	       long long, struct B, long, struct B, long, long, long, long)
+     __attribute__((const, noinline));
+extern int b5 () __attribute__((pure, noinline));
+extern int b6 () __attribute__((const, noinline));
+extern int b7 (int, int)
+     __attribute__((pure, noinline));
+extern int b8 (int, int)
+     __attribute__((const, noinline));
+extern int b9 (int, int, int, int, int, int, int)
+     __attribute__((pure, noinline));
+extern int b10 (int, int, int, int, int, int, int)
+     __attribute__((const, noinline));
Index: gcc/testsuite/gcc.dg/noncompile/init-5.c
===================================================================
--- gcc/testsuite/gcc.dg/noncompile/init-5.c	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/noncompile/init-5.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,4 @@
+/* Test for ICE after syntax error in initializer with range
+   designator: PR 35446.  */
+
+int a[2][2] = { [0 ... 1] = { ; } }; /* { dg-error "expected expression" } */
Index: gcc/testsuite/gcc.dg/noncompile/pr35444-1.c
===================================================================
--- gcc/testsuite/gcc.dg/noncompile/pr35444-1.c	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/noncompile/pr35444-1.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,3 @@
+/* PR 35444: ICE from pending VLA sizes in invalid parameter list.  */
+void foo(int n, int a[n], int 0); /* { dg-error "expected" } */
+void bar() {}
Index: gcc/testsuite/gcc.dg/noncompile/pr35444-2.c
===================================================================
--- gcc/testsuite/gcc.dg/noncompile/pr35444-2.c	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/noncompile/pr35444-2.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,4 @@
+/* PR 35444: ICE from pending VLA sizes in invalid parameter list.
+   Similar case to the PR, but with "..." before the syntax error.  */
+void foo(int n, int a[n], ... 0); /* { dg-error "expected" } */
+void bar() {}
Index: gcc/testsuite/gcc.dg/init-bad-4.c
===================================================================
--- gcc/testsuite/gcc.dg/init-bad-4.c	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/testsuite/gcc.dg/init-bad-4.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -2,4 +2,4 @@
 /* Origin: Richard Guenther <rguenth@gcc.gnu.org> */
 /* { dg-do compile } */
 
-struct A { } a = (struct A) {{ (X)0 }};  /* { dg-error "no members|extra brace|near|undeclared|constant|compound" } */
+struct A { } a = (struct A) {{ (X)0 }};  /* { dg-error "no members|extra brace|near|undeclared|constant|compound|excess" } */
Index: gcc/testsuite/gcc.dg/init-bad-6.c
===================================================================
--- gcc/testsuite/gcc.dg/init-bad-6.c	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/gcc.dg/init-bad-6.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,12 @@
+/* ICE arising from bug computing composite type of zero-length array
+   types: PR 35433.  */
+/* { dg-do compile } */
+/* { dg-options "" } */
+
+typedef int* X;
+typedef int* Y;
+
+X (*p)[][0];
+Y (*q)[][0];
+
+typeof(*(0 ? p : q)) x = { 0 }; /* { dg-warning "excess elements in array initializer|near initialization" } */
Index: gcc/testsuite/ChangeLog
===================================================================
--- gcc/testsuite/ChangeLog	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/testsuite/ChangeLog	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -1,3 +1,335 @@
+2009-03-04  Jason Merrill  <jason@redhat.com>
+	    Giovanni Bajo  <giovannibajo@gcc.gnu.org>
+
+	PR c++/9634
+	PR c++/29469
+	PR c++/29607
+	* g++.dg/template/dependent-name5.C: New test.
+
+2009-02-26  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline:
+	2009-02-02  Jakub Jelinek  <jakub@redhat.com>
+
+	PR inline-asm/39058
+	* gcc.target/i386/pr39058.c: New test.
+
+2009-02-25  Janis Johnson  <janis187@us.ibm.com>
+
+	Backport from mainline:
+	2008-10-29  Joseph Myers  <joseph@codesourcery.com>
+
+	PR middle-end/36578
+	* gcc.dg/dfp/convert-bfp-13.c, gcc.dg/dfp/convert-bfp-14.c,
+	gcc.dg/dfp/convert-dfp-fold-2.c, gcc.target/i386/pr36578-1.c,
+	gcc.target/i386/pr36578-2.c: New tests.
+
+2009-02-25  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline:
+	2008-02-25  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR rtl-optimization/39241
+	* gcc.dg/torture/pr39241.c: New.
+
+2009-02-21  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	* gcc.c-torture/execute/pr39228.x: New.
+
+2009-02-20  Steve Ellcey  <sje@cup.hp.com>
+
+	PR target/38056
+	* gcc.target/ia64/sibcall-opt-1.c: New test.
+	* gcc.target/ia64/sibcall-opt-2.c: New test.
+
+2009-02-20  Jason Merrill  <jason@redhat.com>
+
+	PR c++/39225
+	* g++.dg/parse/dtor15.C: New test.
+
+2009-02-19  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/39228
+	* gcc.c-torture/execute/pr39228.c: New test.
+
+2009-02-19  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/38852
+	PR fortran/39006
+	Backport from mainline:
+	* gfortran.dg/bound_6.f90: New test.
+
+2009-02-17  Jason Merrill  <jason@redhat.com>
+
+	PR c++/38950
+	* g++.dg/template/array20.C: New test.
+
+2009-02-17  Joseph Myers  <joseph@codesourcery.com>
+
+	PR c/35446
+	* gcc.dg/noncompile/init-5.c: New test.
+	* gcc.dg/init-bad-4.c: Adjust expected errors.
+
+2009-02-15  Uros Bizjak  <ubizjak@gmail.com>
+
+	* gcc.dg/struct/w_prof_single_str_global.c: Mask return value.
+
+	Backport from mainline:
+	2009-01-12  Mark Mitchell  <mark@codesourcery.com>
+
+	* gcc.dg/struct/wo_prof_single_str_global.c: Mask return value.
+	* gcc.dg/struct/wo_prof_single_str_local.c: Mask return value.
+	* gcc.dg/struct/wo_prof_single_str_pointer.c: Mask return value.
+
+2009-02-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/39070
+	* g++.dg/cpp0x/decltype16.C: New.
+
+2009-02-13  Joseph Myers  <joseph@codesourcery.com>
+
+	PR c/35444
+	* gcc.dg/noncompile/pr35444-1.c, gcc.dg/noncompile/pr35444-2.c:
+	New tests.
+
+2009-02-10  Steve Ellcey  <sje@cup.hp.com>
+
+	PR c/39084
+	* gcc.dg/pr39084.c: New test.
+
+2009-02-09  Janis Johnson  <janis187@us.ibm.com>
+
+	PR c/39035
+	* gcc.dg/dfp/pr39035.c: New test.
+
+2009-02-08  Joseph Myers  <joseph@codesourcery.com>
+
+	PR c/35434
+	* gcc.dg/attr-alias-4.c: New test.
+
+2009-02-08  Joseph Myers  <joseph@codesourcery.com>
+
+	PR c/36432
+	* gcc.dg/c90-flex-array-2.c, gcc.dg/c99-flex-array-6.c: New tests.
+
+2009-02-05  Joseph Myers  <joseph@codesourcery.com>
+
+	PR c/35435
+	* gcc.dg/tls/diag-6.c: New test.
+
+2009-02-05  Richard Guenther  <rguenther@suse.de>
+
+	Backport from mainline
+	2009-02-05  Daniel Berlin  <dberlin@dberlin.org>
+
+	* gcc.c-torture/execute/pr39100.c: New.
+
+2009-02-04  Joseph Myers  <joseph@codesourcery.com>
+
+	PR c/35433
+	* gcc.dg/init-bad-6.c: New test.
+
+2009-02-03  Paolo Bonzini  <bonzini@gnu.org>
+
+	PR c++/36897
+	* g++.dg/template/func2.C: New test.
+
+	PR c++/37314
+	* g++.dg/template/typename15.C: New.
+	* g++.dg/template/typename16.C: New.
+
+2009-02-02  Jason Merrill  <jason@redhat.com>
+
+	PR c++/39054
+	* g++.dg/parse/dtor14.C: New test.
+
+2009-01-30  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline:
+	2009-01-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/38245
+	* gcc.dg/pr38245-3.c: New test.
+	* gcc.dg/pr38245-3.h: New file.
+	* gcc.dg/pr38245-4.c: New file.
+	* gcc.dg/pr38364.c: New test.
+
+2009-01-30  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/39041
+	* gcc.c-torture/compile/pr39041.c: New testcase.
+
+2009-01-30  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline:
+	2009-01-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/38789
+	* gcc.c-torture/compile/pr38789.c: New test.
+
+2009-01-30  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline:
+	2009-01-27  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/38503
+	* g++.dg/warn/Wstrict-aliasing-bogus-placement-new.C: New testcase.
+
+	2009-01-26  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/38745
+	* g++.dg/torture/pr38745.C: New testcase.
+
+	2009-01-26  Richard Guenther  <rguenther@suse.de>
+
+	PR middle-end/38851
+	* g++.dg/warn/Wuninitialized-1.C: New testcase.
+
+	2009-01-20  Andrew Pinski  <andrew_pinski@playstation.sony.com>
+		    Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/38747
+	PR tree-optimization/38748
+	* gcc.dg/tree-ssa/struct-aliasing-1.c: New test.
+	* gcc.c-torture/execute/struct-aliasing-1.c: Likewise.
+
+2009-01-29  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline:
+	2009-01-28  Richard Guenther  <rguenther@suse.de>
+
+	PR middle-end/38908
+	* g++.dg/warn/Wuninitialized-2.C: New testcase.
+
+	2009-01-27  Daniel Kraft  <d@domob.eu>
+
+	PR fortran/38883
+	* gfortran.dg/mvbits_6.f90:  New test.
+	* gfortran.dg/mvbits_7.f90:  New test.
+	* gfortran.dg/mvbits_8.f90:  New test.
+
+	2009-01-21  Daniel Kraft  <d@domob.eu>
+
+	PR fortran/38887
+	* gfortran.dg/mvbits_5.f90:  New test.
+
+2009-01-29  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline:
+	2009-01-29  Steve Ellcey  <sje@cup.hp.com>
+
+	PR middle-end/38857
+	* gcc.c-torture/compile/pr38857.c: New test.
+
+	2009-01-28  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/38926
+	* gcc.c-torture/compile/pr38926.c: New testcase.
+
+2009-01-29  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline:
+	2009-01-28  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/38988
+	* gcc.target/i386/pr38988.c: New test.
+
+	2009-01-27  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR middle-end/38969
+	* gcc.c-torture/execute/pr38969.c: New test.
+
+2009-01-27  Steve Ellcey  <sje@cup.hp.com>
+
+	PR middle-end/38615
+	* gcc.dg/pr38615.c: New test.
+
+2009-01-27  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline:
+	2009-01-07  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/38706
+	* g++.dg/other/pr38706.C: New test.
+
+2009-01-26  Jason Merrill  <jason@redhat.com>
+
+	PR c++/23287
+	* g++.dg/template/dtor5.C: New test.
+
+2009-01-26  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline:
+	2008-07-17  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR testsuite/36443
+	* objc.dg/gnu-encoding/gnu-encoding.exp: Temporarily unset
+	GCC_EXEC_PREFIX from environment when running $HOSTCC.
+
+2008-01-26  Paolo Bonzini  <bonzini@gnu.org>
+
+	PR tree-optimization/38932
+	* gcc.dg/pr38932.c: New.
+
+2009-01-26  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/38907
+	Backport from trunk
+	* gfortran.dg/host_assoc_function_7.f90: New test.
+
+2009-01-26  Mikael Morin  <mikael.morin@tele2.fr>
+
+	PR fortran/38859
+	Backport from trunk
+	* gfortran.dg/bound_5.f90: New test.
+
+2009-01-26  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/38657
+	Backport from trunk.
+	* gfortran.dg/module_commons_3.f90: Reapply.
+
+2009-01-25  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline:
+	2009-01-22  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/38931
+	* gcc.target/i386/pr38931.c: New test.
+
+2009-01-25  Richard Guenther  <rguenther@suse.de>
+
+	Backport from mainline:
+	2008-12-02  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/38359
+	* gcc.c-torture/compile/pr38359.c: New testcase.
+	* gcc.c-torture/execute/shiftopt-1.c: Adjust.
+
+2009-01-24  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/38672
+	Backport from trunk.
+	* gfortran.dg/host_assoc_blockdata_1.f90:  New test.
+	* gfortran.dg/host_assoc_blockdata_2.f90:  New test.
+
+2009-01-24  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline:
+	2009-01-20  Kees Cook  <kees@ubuntu.com>
+		    H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/38902
+	* gcc.dg/pr38902.c: New.
+
+2009-01-24  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline:
+	2008-01-20  Paolo Bonzini  <bonzini@gnu.org>
+
+	PR target/38868
+	* gfortran.dg/pr38868.f: New testcase.
+
 2009-01-24  Release Manager
 
 	* GCC 4.3.3 released.
@@ -89,7 +421,7 @@
 
 	Backport from mainline:
 	2008-12-29  Dorit Nuzman  <dorit@il.ibm.com>
-	            Ira Rosen  <irar@il.ibm.com>
+		    Ira Rosen  <irar@il.ibm.com>
 
 	PR tree-optimization/38529
 	* gcc.dg/vect/pr38529.c: New test.
@@ -426,8 +758,8 @@
 
 2008-11-14  Paul Thomas  <pault@gcc.gnu.org>
 
-        PR fortran/37836
-        * gfortran.dg/minmaxval_1.f90: New test.
+	PR fortran/37836
+	* gfortran.dg/minmaxval_1.f90: New test.
 
 2008-11-13  Jason Merrill  <jason@redhat.com>
 
Index: gcc/testsuite/g++.dg/other/pr38706.C
===================================================================
--- gcc/testsuite/g++.dg/other/pr38706.C	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/other/pr38706.C	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,19 @@
+// PR target/38706
+// { dg-do compile }
+// { dg-options "-O2" }
+
+class ios_base
+{
+public:
+  virtual ~ios_base ();
+
+};
+
+class istrstream:virtual public ios_base
+{
+public:
+  virtual ~istrstream ();
+
+};
+
+istrstream::~istrstream () {}
Index: gcc/testsuite/g++.dg/warn/Wstrict-aliasing-bogus-placement-new.C
===================================================================
--- gcc/testsuite/g++.dg/warn/Wstrict-aliasing-bogus-placement-new.C	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/warn/Wstrict-aliasing-bogus-placement-new.C	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,29 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -Wstrict-aliasing" } */
+
+inline void *operator new (__SIZE_TYPE__, void *__p) throw() { return __p; }
+
+struct Y {
+  Y() {}
+  int i;
+};
+
+struct X {
+  X() {}
+  void construct(const Y& y)
+  {
+    new (&m_data[0]) Y(y);
+  }
+  bool initialized;
+  char m_data[sizeof (Y)];
+};
+
+void bar(const X&);
+void foo(Y& y)
+{
+  X x;
+  x.construct(y);
+  x.initialized = true;
+  bar(x);
+}
+
Index: gcc/testsuite/g++.dg/warn/Wuninitialized-2.C
===================================================================
--- gcc/testsuite/g++.dg/warn/Wuninitialized-2.C	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/warn/Wuninitialized-2.C	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,53 @@
+/* { dg-do compile } */
+/* { dg-options "-O -Wuninitialized" } */
+
+struct S8 { template<typename T> S8(T) { } };
+
+template<typename T> struct S10;
+template<typename T> struct S10<T()> { typedef T S12; typedef S8 S1(); };
+
+template<typename T> struct S3 { };
+template<typename T> struct S11 { S11(S3<T>); };
+
+struct S2
+{
+  template<typename T> operator S11<T>() { return S11<T>(S5<T>()); }
+  template<typename T> struct S5:public S3<T>
+  {
+    virtual typename S10<T>::S12 S13() {
+      return 0;
+    }
+  };
+};
+
+template<typename T> S11<T> S6(S3<T>) { return S11<T>(S3<T>()); }
+template<typename S12> struct S7 { typedef S12 S15(); };
+
+struct S4
+{
+  template<typename T> operator S11<T>()
+  {
+    struct S14:public S3<T>
+    { 
+      S14(S2 x):S11_(x) { }
+      S11<typename S7<typename S10<T>::S12>::S15> S11_;
+    };
+    return S6(S14(S11_));
+  }
+  S2 S11_;
+};
+
+struct S9
+{
+  template<typename F> operator S11<F>() { return S11<F>(S14<F>(S11_)); }
+  template<typename F> struct S14:public S3<F>
+  {
+    S14(S4 x):S11_(x) { }
+    S11<typename S10<F>::S1> S11_;
+  };
+  S4 S11_;
+};
+
+void S15(S11<void()>);
+void S16() { S9 x; S15(x); }
+
Index: gcc/testsuite/g++.dg/warn/Wuninitialized-1.C
===================================================================
--- gcc/testsuite/g++.dg/warn/Wuninitialized-1.C	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/warn/Wuninitialized-1.C	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,15 @@
+/* { dg-options "-O2 -Wuninitialized" } */
+
+struct Empty { Empty() {} }; /* { dg-bogus "uninitialized" } */
+struct Other {
+    Other(const Empty& e_) : e(e_) {}
+    Empty e;
+};
+void bar(Other&);
+void foo()
+{
+  Empty e;
+  Other o(e);
+  bar(o);
+}
+
Index: gcc/testsuite/g++.dg/parse/dtor14.C
===================================================================
--- gcc/testsuite/g++.dg/parse/dtor14.C	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/parse/dtor14.C	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,8 @@
+// PR c++/39054
+
+struct A {};
+
+template<typename> void foo()
+{ 
+  A().~int();			// { dg-error "expected" }
+}
Index: gcc/testsuite/g++.dg/parse/dtor15.C
===================================================================
--- gcc/testsuite/g++.dg/parse/dtor15.C	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/parse/dtor15.C	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,16 @@
+// PR c++/39225
+
+template <class T>
+class A
+{
+public:
+    A() {}
+    ~B() {}			// { dg-error "~B" }
+};
+
+int main()
+{
+    A<int> *a = new A<int>;
+
+    return 0;
+}
Index: gcc/testsuite/g++.dg/cpp0x/decltype16.C
===================================================================
--- gcc/testsuite/g++.dg/cpp0x/decltype16.C	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/cpp0x/decltype16.C	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,10 @@
+// PR c++/39070
+// { dg-options "-std=c++0x" }
+
+template<typename X> struct junk {
+   template<typename Z> static Z y();
+   template<typename Y> static int  test(...);
+   template<typename Y> static char test(decltype(y<Y>())*);
+   static int const value=sizeof(test<X>(0));
+};
+typedef char type[junk<int>::value==sizeof(char) ? 1 : -1];
Index: gcc/testsuite/g++.dg/torture/pr38745.C
===================================================================
--- gcc/testsuite/g++.dg/torture/pr38745.C	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/torture/pr38745.C	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,36 @@
+/* { dg-do compile } */
+
+union u_u16
+{
+  unsigned short v;
+  struct
+    {
+      unsigned char lo8, hi8;
+    } __attribute__ ((__may_alias__)) u;
+} __attribute__ ((__may_alias__));
+union u_u32
+{
+  unsigned int v;
+  struct
+    {
+      u_u16 lo16, hi16;
+    } u;
+} __attribute__ ((__may_alias__));
+union u_u64
+{
+  struct
+    {
+      u_u32 lo32, hi32;
+    } u;
+};
+struct Record
+{
+};
+long long
+UnpackFullKey (Record & rec, const char *&p)
+{
+  long long c64 = 0;
+  (*(u_u16 *) & (*(u_u32 *) & ( *(u_u64*)&c64).u.lo32.v).u.lo16.v).u.hi8 = 1;
+  return c64;
+}
+
Index: gcc/testsuite/g++.dg/template/dependent-name5.C
===================================================================
--- gcc/testsuite/g++.dg/template/dependent-name5.C	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/template/dependent-name5.C	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,45 @@
+// PR c++/9634, c++/29469, c++/29607
+// Contributed by: Giovanni Bajo <giovannibajo at gcc dot gnu dot org>
+// DR224: Make sure that a name is *truly* semantically dependent.
+
+struct D {
+  typedef int K;
+};
+
+template <typename T>
+struct A
+{
+  typedef int Bar;
+
+  template <typename>
+  struct N {};
+
+  typedef Bar          type1;
+  typedef A::Bar       type2;
+  typedef A<T>::Bar    type3;
+  typedef A<T*>::Bar    type4;  // { dg-error "" }
+  typedef typename A<T*>::Bar type5;
+
+  typedef N<int>       type6;
+  typedef A::N<int>    type7;
+  typedef A<T>::N<int> type8;
+  typedef A<T*>::template N<int> type9;  // { dg-error "" }
+  typedef typename A<T*>::template N<int> type10;
+
+  typedef D Bar2;
+  struct N2 { typedef int K; };
+
+  // Check that A::N2 is still considered dependent (because it
+  //  could be specialized), while A::Bar2 (being just ::D) is not.
+  typedef A::Bar2 type11;
+  typedef type11::K k3;
+
+  typedef A::N2 type12;
+  typedef typename type12::K k2;
+  typedef type12::K k1;  // { dg-error "" }
+
+  // Check that A::Bar2 is not considered dependent even if we use
+  // the typename keyword.
+  typedef typename A::Bar2 type13;
+  typedef type13::K k4;
+};
Index: gcc/testsuite/g++.dg/template/func2.C
===================================================================
--- gcc/testsuite/g++.dg/template/func2.C	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/template/func2.C	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,12 @@
+// { dg-do compile }
+
+typedef void (*fptr)();
+fptr zeroptr = 0;
+template<typename T, fptr F> struct foo { };
+template<typename T> struct foo<T,zeroptr> { };
+// { dg-error "not a valid template argument" "not valid" { target *-*-* } 6 } 
+// { dg-error "must be the address" "must be the address " { target *-*-* } 6 }
+
+// The rest is needed to trigger the ICE in 4.0 to 4.3:
+void f() { }
+foo<int,&f> m_foo;
Index: gcc/testsuite/g++.dg/template/array20.C
===================================================================
--- gcc/testsuite/g++.dg/template/array20.C	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/template/array20.C	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,10 @@
+// PR c++/38950
+
+template <typename T, T N> void f(T(&)[N]);
+
+int main() {
+    int x[2];
+    unsigned int y[2];
+    f(x); // works
+    f(y); // ICE
+}
Index: gcc/testsuite/g++.dg/template/typename15.C
===================================================================
--- gcc/testsuite/g++.dg/template/typename15.C	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/template/typename15.C	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,12 @@
+// PR37314 ice-on-valid-code, from w.doeringer
+template <typename T>
+class Cdeque {
+    typedef T *pointer;
+    class iterator {
+        typedef typename Cdeque<T>::pointer pointer;
+        pointer operator->();
+    };
+};
+template <typename T> T* Cdeque<T>::iterator::operator->() { }
+
+
Index: gcc/testsuite/g++.dg/template/dtor5.C
===================================================================
--- gcc/testsuite/g++.dg/template/dtor5.C	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/template/dtor5.C	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,21 @@
+// PR c++/23287
+
+template <class T> struct A
+{
+  int i;
+  ~A();
+}; 
+
+template <class T> void f(A<T> *ap) {
+  ap->~A(); 
+} 
+
+template <class T> void g(A<T> *ap) {
+  ap->~B(); 			// { dg-error "destructor name" }
+} 
+
+int main()
+{
+  f(new A<int>);
+  g(new A<int>);
+}
Index: gcc/testsuite/g++.dg/template/typename16.C
===================================================================
--- gcc/testsuite/g++.dg/template/typename16.C	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/g++.dg/template/typename16.C	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,25 @@
+// PR37314 rejects-valid, from w.doeringer
+template <typename T>
+struct A {
+  typedef __PTRDIFF_TYPE__ difference_type;
+  struct B {
+    typedef typename A<T>::difference_type difference_type;
+    difference_type operator-(B const&) const; 
+    T t;
+  };
+};
+// 
+
+template <typename T>
+typename A<T>::B::difference_type A<T>::B::operator-(B const&) const {
+  return -1;
+} 
+
+//
+int main() {
+  A<int>::B i;
+  ++i.t;
+  return 0;
+}
+
+
Index: gcc/testsuite/objc.dg/gnu-encoding/gnu-encoding.exp
===================================================================
--- gcc/testsuite/objc.dg/gnu-encoding/gnu-encoding.exp	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/testsuite/objc.dg/gnu-encoding/gnu-encoding.exp	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -37,8 +37,20 @@
 set generator_src "$generator_src $srcdir/$subdir/generate-random.c"
 set generator_src "$generator_src $srcdir/$subdir/generate-random_r.c"
 set generator_cmd "-o $generator $generator_src"
+# Temporarily unset GCC_EXEC_PREFIX from environment, as that might
+# confuse the $HOSTCC.
+set orig_gcc_exec_prefix_saved 0
+if [info exists env(GCC_EXEC_PREFIX)] {
+     set orig_gcc_exec_prefix "$env(GCC_EXEC_PREFIX)"
+     set orig_gcc_exec_prefix_saved 1
+     unsetenv GCC_EXEC_PREFIX
+}
 set status [remote_exec host "$HOSTCC $HOSTCFLAGS $generator_cmd"]
 set status [lindex $status 0]
+if { $orig_gcc_exec_prefix_saved } {
+     set orig_gcc_exec_prefix_saved 0
+     setenv GCC_EXEC_PREFIX "$orig_gcc_exec_prefix"
+}
 if { $status == 0 } then {
     file delete -force $tstobjdir
     file mkdir $tstobjdir
Index: gcc/testsuite/gfortran.dg/mvbits_5.f90
===================================================================
--- gcc/testsuite/gfortran.dg/mvbits_5.f90	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/mvbits_5.f90	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,17 @@
+! { dg-do run }
+
+! PR fortran/38887
+! This aborted at runtime for the runtime zero-sized array arguments.
+
+! Contributed by Dick Hendrickson <dick.hendrickson@gmail.com>
+
+program try_ya0013
+  integer ida(9)
+  call ya0013(ida,1,5,6)
+end program
+
+SUBROUTINE YA0013(IDA,nf1,nf5,nf6)
+  INTEGER IDA(9)
+  IDA = 1
+  CALL MVBITS(IDA(NF5:NF1), 0, 1, IDA(NF6:NF1),2)
+END SUBROUTINE
Index: gcc/testsuite/gfortran.dg/mvbits_6.f90
===================================================================
--- gcc/testsuite/gfortran.dg/mvbits_6.f90	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/mvbits_6.f90	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,33 @@
+! { dg-do compile }
+
+! PR fortran/38883
+! This ICE'd because the temporary-creation in the MVBITS call was wrong.
+! This is the original test from the PR, the complicated version.
+
+! Contributed by Dick Hendrickson <dick.hendrickson@gmail.com>
+
+     module yg0009_stuff
+
+      type unseq
+         integer I
+      end type
+
+      contains
+
+      SUBROUTINE YG0009(TDA2L,NF4,NF3,NF1,MF1,MF4,MF3)
+        TYPE(UNSEQ) TDA2L(NF4,NF3)
+
+        CALL MVBITS (TDA2L(NF4:NF1:MF1,NF1:NF3)%I,2, &
+          4, TDA2L(-MF4:-MF1:-NF1,-MF1:-MF3)%I, 3)
+
+      END SUBROUTINE
+
+      end module yg0009_stuff
+
+      program try_yg0009
+      use yg0009_stuff
+      type(unseq)  tda2l(4,3)
+
+      call yg0009(tda2l,4,3,1,-1,-4,-3)
+
+      end
Index: gcc/testsuite/gfortran.dg/mvbits_7.f90
===================================================================
--- gcc/testsuite/gfortran.dg/mvbits_7.f90	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/mvbits_7.f90	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,30 @@
+! { dg-do run }
+
+! PR fortran/38883
+! This ICE'd because the temporary-creation in the MVBITS call was wrong.
+
+! Contributed by Paul Richard Thomas <paul.richard.thomas@gmail.com>
+
+  type t
+    integer  ::  I
+    character(9)  :: chr
+  end type
+  type(t) :: x(4,3)
+  type(t) :: y(4,3)
+  x = reshape ([((t (i*j, "a"),i = 1,4), j=1,3)], [4,3])
+  call foo (x)
+  y = reshape ([((t (i*j*2, "a"),i = 1,4), j=1,3)], [4,3])
+  call bar(y, 4, 3, 1, -1, -4, -3)
+  if (any (x%i .ne. y%i)) call abort
+contains
+  SUBROUTINE foo (x)
+    TYPE(t) x(4, 3)      ! No dependency at all
+    CALL MVBITS (x%i, 0, 6, x%i, 8)
+    x%i = x%i * 2
+  END SUBROUTINE
+  SUBROUTINE bar (x, NF4, NF3, NF1, MF1, MF4, MF3)
+    TYPE(t) x(NF4, NF3)  ! Dependency through variable indices
+    CALL MVBITS (x(NF4:NF1:MF1, NF1:NF3)%i, 1, &
+                 6, x(-MF4:-MF1:-NF1, -MF1:-MF3)%i, 9)
+  END SUBROUTINE
+end
Index: gcc/testsuite/gfortran.dg/mvbits_8.f90
===================================================================
--- gcc/testsuite/gfortran.dg/mvbits_8.f90	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/mvbits_8.f90	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,36 @@
+! { dg-do run }
+
+! PR fortran/38883
+! This ICE'd because the temporary-creation in the MVBITS call was wrong.
+
+PROGRAM main
+  IMPLICIT NONE
+
+  TYPE inner
+    INTEGER :: i
+    INTEGER :: j
+  END TYPE inner
+
+  TYPE outer
+    TYPE(inner) :: comp(2)
+  END TYPE outer
+
+  TYPE(outer) :: var
+
+  var%comp%i = (/ 1, 2 /)
+  var%comp%j = (/ 3, 4 /)
+
+  CALL foobar (var, 1, 2)
+
+  IF (ANY (var%comp%i /= (/ 1, 2 /))) CALL abort ()
+  IF (ANY (var%comp%j /= (/ 3, 4 /))) CALL abort ()
+
+CONTAINS
+
+  SUBROUTINE foobar (x, lower, upper)
+    TYPE(outer), INTENT(INOUT) :: x
+    INTEGER, INTENT(IN) :: lower, upper
+    CALL MVBITS (x%comp%i, 1, 2, x%comp(lower:upper)%i, 1)
+  END SUBROUTINE foobar
+
+END PROGRAM main
Index: gcc/testsuite/gfortran.dg/host_assoc_blockdata_1.f90
===================================================================
--- gcc/testsuite/gfortran.dg/host_assoc_blockdata_1.f90	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/host_assoc_blockdata_1.f90	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,11 @@
+! { dg-do compile }
+! PR 38672 - this used to ICE.
+MODULE globals
+  TYPE :: type1
+     integer :: x
+  END TYPE type1
+  TYPE (type1) :: pdm_bps
+END module globals
+BLOCK DATA
+   use globals
+END BLOCK DATA
Index: gcc/testsuite/gfortran.dg/host_assoc_blockdata_2.f90
===================================================================
--- gcc/testsuite/gfortran.dg/host_assoc_blockdata_2.f90	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/host_assoc_blockdata_2.f90	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,17 @@
+! { dg-do compile }
+MODULE globals
+  TYPE :: type1
+     sequence
+     integer :: x
+  END TYPE type1
+  TYPE (type1) :: pdm_bps
+  common /co/ pdm_bps
+END module globals
+BLOCK DATA
+   use globals
+END BLOCK DATA
+
+program main
+  use globals
+  common /co/ pdm_bps ! { dg-error "already in a COMMON block" }
+end program main
Index: gcc/testsuite/gfortran.dg/bound_6.f90
===================================================================
--- gcc/testsuite/gfortran.dg/bound_6.f90	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/bound_6.f90	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,48 @@
+! { dg-do run }
+! Test the fix for PR38852 and PR39006 in which LBOUND did not work
+! for some arrays with negative strides.
+!
+! Contributed by Dick Hendrickson  <dick.hendrickson@gmail.com>
+! and Clive Page <clivegpage@googlemail.com>
+!
+program try_je0031
+  integer ida(4)
+  real dda(5,5,5,5,5)
+  integer, parameter :: nx = 4, ny = 3
+  integer :: array1(nx,ny), array2(nx,ny) 
+  data array2 / 1,2,3,4, 10,20,30,40, 100,200,300,400 /
+  array1 = array2
+  call PR38852(IDA,DDA,2,5,-2)
+  call PR39006(array1, array2(:,ny:1:-1))
+contains
+  subroutine PR39006(array1, array2)
+    integer, intent(in) :: array1(:,:), array2(:,:)
+    integer :: j
+    do j = 1, ubound(array2,2)
+      if (any (array1(:,j) .ne. array2(:,4-j))) call abort
+    end do
+  end subroutine
+end 
+
+SUBROUTINE PR38852(IDA,DDA,nf2,nf5,mf2)
+  INTEGER IDA(4)
+  REAL DLA(:,:,:,:)
+  REAL DDA(5,5,5,5,5)
+  POINTER DLA
+  TARGET DDA
+  DLA => DDA(2:3, 1:3:2, 5:4:-1, NF2, NF5:NF2:MF2)
+  IDA = UBOUND(DLA)
+  if (any(ida /= 2)) call abort
+  DLA => DDA(2:3, 1:3:2, 5:4:-1, 2, 5:2:-2)
+  IDA = UBOUND(DLA)
+  if (any(ida /= 2)) call abort
+!
+! These worked.
+!
+  DLA => DDA(2:3, 1:3:2, 5:4:-1, 2, 5:2:-2)
+  IDA = shape(DLA)
+  if (any(ida /= 2)) call abort
+  DLA => DDA(2:3, 1:3:2, 5:4:-1, 2, 5:2:-2)
+  IDA = LBOUND(DLA)
+  if (any(ida /= 1)) call abort
+END SUBROUTINE
Index: gcc/testsuite/gfortran.dg/module_commons_3.f90
===================================================================
--- gcc/testsuite/gfortran.dg/module_commons_3.f90	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/module_commons_3.f90	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,57 @@
+! { dg-do run }
+!
+! PR fortran/38657, in which the mixture of PRIVATE and
+! COMMON in TEST4, would mess up the association with
+! TESTCHAR in TEST2.
+!
+! Contributed by Paul Thomas <pault@gcc.gnu.org>
+! From a report in clf by Chris Bradley.
+!
+MODULE TEST4
+  PRIVATE
+  CHARACTER(LEN=80) :: T1 = &
+    "Mary had a little lamb, Its fleece was white as snow;"
+  CHARACTER(LEN=80) :: T2 = &
+    "And everywhere that Mary went, The lamb was sure to go."
+  CHARACTER(LEN=80) :: TESTCHAR
+  COMMON /TESTCOMMON1/ TESTCHAR
+  PUBLIC T1, T2, FOOBAR
+CONTAINS
+  subroutine FOOBAR (CHECK)
+    CHARACTER(LEN=80) :: CHECK
+    IF (TESTCHAR .NE. CHECK) CALL ABORT
+  end subroutine
+END MODULE TEST4
+
+MODULE TEST3
+  CHARACTER(LEN=80) :: TESTCHAR
+  COMMON /TESTCOMMON1/ TESTCHAR
+END MODULE TEST3
+
+MODULE TEST2
+  use TEST4
+  USE TEST3, chr => testchar
+  PRIVATE
+  CHARACTER(LEN=80) :: TESTCHAR
+  COMMON /TESTCOMMON1/ TESTCHAR
+  PUBLIC TESTCHAR, FOO, BAR, CHR, T1, T2, FOOBAR
+contains
+  subroutine FOO
+    TESTCHAR = T1
+  end subroutine
+  subroutine BAR (CHECK)
+    CHARACTER(LEN=80) :: CHECK
+    IF (TESTCHAR .NE. CHECK) CALL ABORT
+    IF (CHR .NE. CHECK) CALL ABORT
+  end subroutine
+END MODULE TEST2
+
+PROGRAM TEST1
+  USE TEST2
+  call FOO
+  call BAR (T1)
+  TESTCHAR = T2
+  call BAR (T2)
+  CALL FOOBAR (T2)
+END PROGRAM TEST1
+! { dg-final { cleanup-modules "TEST2 TEST3 TEST4" } }
Index: gcc/testsuite/gfortran.dg/bounds_5.f90
===================================================================
--- gcc/testsuite/gfortran.dg/bounds_5.f90	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/bounds_5.f90	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,26 @@
+! { dg-do run }
+!
+! PR fortran/38859
+! Wrong bounds simplification
+!
+! Contributed by Dick Hendrickson <dick.hendrickson@gmail.com>
+
+       type x
+         integer I
+       end type x
+       type (x) A(0:5, 2:8)
+       integer ida(2)
+
+       ida = lbound(a)
+       if (any(ida /= (/0,2/))) call abort
+
+       ida = lbound(a%i)
+       if (any(ida /= (/1,1/))) call abort
+
+       ida = ubound(a)
+       if (any(ida /= (/5,8/))) call abort
+       
+       ida = ubound(a%i)
+       if (any(ida /= (/6,7/))) call abort
+
+       end
Index: gcc/testsuite/gfortran.dg/host_assoc_function_7.f90
===================================================================
--- gcc/testsuite/gfortran.dg/host_assoc_function_7.f90	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/host_assoc_function_7.f90	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,41 @@
+! { dg-do run }
+! Tests the fix for PR38907, in which any expressions, including unary plus,
+! in front of the call to S_REAL_SUM_I (marked) would throw the mechanism
+! for correcting invalid host association.
+!
+! Contributed by Dick Hendrickson <dick.hendrickson@gmail.com>
+!
+module sa0054_stuff
+  REAL :: S_REAL_SUM_2(10) = [(REAL (I), I = 1, 10)]
+contains
+  ELEMENTAL FUNCTION S_REAL_SUM_I (A)
+    REAL  ::  S_REAL_SUM_I
+    REAL, INTENT(IN)  ::  A
+    X = 1.0
+    S_REAL_SUM_I = X
+  END FUNCTION S_REAL_SUM_I
+  SUBROUTINE SA0054 (RDA)
+    REAL RDA(:)
+    RDA =  + S_REAL_SUM_I (RDA)          ! Reported problem => ICE
+    RDA = RDA + S_REAL_SUM_2 (INT (RDA)) ! Also failed
+  CONTAINS
+    ELEMENTAL FUNCTION S_REAL_SUM_I (A)
+      REAL  ::  S_REAL_SUM_I
+      REAL, INTENT(IN)  ::  A
+      S_REAL_SUM_I = 2.0 * A
+    END FUNCTION S_REAL_SUM_I
+    ELEMENTAL FUNCTION S_REAL_SUM_2 (A)
+      REAL  ::  S_REAL_SUM_2
+      INTEGER, INTENT(IN)  ::  A
+      S_REAL_SUM_2 = 2.0 * A
+    END FUNCTION S_REAL_SUM_2
+  END SUBROUTINE
+end module sa0054_stuff
+
+  use sa0054_stuff
+  REAL :: RDA(10) = [(REAL(I), I = 1, 10)]
+  call SA0054 (RDA)
+  IF (ANY (INT (RDA) .ne. [(6 * I, I = 1, 10)])) print *, rda
+END
+
+! { dg-final { cleanup-modules "sa0054_stuff" } }
Index: gcc/testsuite/gfortran.dg/pr38868.f
===================================================================
--- gcc/testsuite/gfortran.dg/pr38868.f	(.../tags/gcc_4_3_3_release)	(wersja 0)
+++ gcc/testsuite/gfortran.dg/pr38868.f	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -0,0 +1,17 @@
+! { dg-do compile }
+! { dg-options "-O2 -fdump-rtl-expand" }
+      PROGRAM testcase
+      IMPLICIT NONE
+
+      CHARACTER*4 ANER(18)
+      CHARACTER*80 LINE
+      aner = ''
+      ANER(1)='A   '
+      ANER(2)='    '
+      LINE=' '
+      LINE(78:80)='xyz'
+      WRITE(*,'(A82)') "'"//LINE//"'"
+      END
+
+! { dg-final { scan-rtl-dump-times "line\\\+80" 0 "expand" } }
+! { dg-final { cleanup-rtl-dump "expand" } } */
Index: gcc/cp/typeck.c
===================================================================
--- gcc/cp/typeck.c	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/cp/typeck.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -608,6 +608,20 @@
 
   code1 = TREE_CODE (t1);
   code2 = TREE_CODE (t2);
+  if (code1 != code2)
+    {
+      gcc_assert (code1 == TYPENAME_TYPE || code2 == TYPENAME_TYPE);
+      if (code1 == TYPENAME_TYPE)
+	{
+          t1 = resolve_typename_type (t1, /*only_current_p=*/true);
+	  code1 = TREE_CODE (t1);
+	}
+      else
+	{
+          t2 = resolve_typename_type (t2, /*only_current_p=*/true);
+	  code2 = TREE_CODE (t2);
+	}
+    }
 
   switch (code1)
     {
@@ -2034,8 +2048,8 @@
   return result;
 }
 
-/* Return the destructor denoted by OBJECT.SCOPE::~DTOR_NAME, or, if
-   SCOPE is NULL, by OBJECT.~DTOR_NAME.  */
+/* Return the destructor denoted by OBJECT.SCOPE::DTOR_NAME, or, if
+   SCOPE is NULL, by OBJECT.DTOR_NAME, where DTOR_NAME is ~type.  */
 
 static tree
 lookup_destructor (tree object, tree scope, tree dtor_name)
@@ -2050,8 +2064,22 @@
 	     scope, dtor_type);
       return error_mark_node;
     }
-  if (!DERIVED_FROM_P (dtor_type, TYPE_MAIN_VARIANT (object_type)))
+  if (TREE_CODE (dtor_type) == IDENTIFIER_NODE)
     {
+      /* In a template, names we can't find a match for are still accepted
+	 destructor names, and we check them here.  */
+      if (check_dtor_name (object_type, dtor_type))
+	dtor_type = object_type;
+      else
+	{
+	  error ("object type %qT does not match destructor name ~%qT",
+		 object_type, dtor_type);
+	  return error_mark_node;
+	}
+      
+    }
+  else if (!DERIVED_FROM_P (dtor_type, TYPE_MAIN_VARIANT (object_type)))
+    {
       error ("the type being destroyed is %qT, but the destructor refers to %qT",
 	     TYPE_MAIN_VARIANT (object_type), dtor_type);
       return error_mark_node;
Index: gcc/cp/class.c
===================================================================
--- gcc/cp/class.c	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/cp/class.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -5688,6 +5688,9 @@
 {
   int i;
 
+  if (!CLASS_TYPE_P (t))
+    return false;
+
   /* We start looking from 1 because entry 0 is from global scope,
      and has no type.  */
   for (i = current_class_depth; i > 0; --i)
Index: gcc/cp/decl.c
===================================================================
--- gcc/cp/decl.c	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/cp/decl.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -2978,12 +2978,6 @@
   gcc_assert (TREE_CODE (name) == IDENTIFIER_NODE);
   gcc_assert (TYPE_P (context));
 
-  /* When the CONTEXT is a dependent type,  NAME could refer to a
-     dependent base class of CONTEXT.  So we cannot peek inside it,
-     even if CONTEXT is a currently open scope.  */
-  if (dependent_type_p (context))
-    return build_typename_type (context, name, fullname, tag_type);
-
   if (!IS_AGGR_TYPE (context))
     {
       if (complain & tf_error)
@@ -2991,11 +2985,23 @@
       return error_mark_node;
     }
   
+  /* When the CONTEXT is a dependent type,  NAME could refer to a
+     dependent base class of CONTEXT.  But look inside it anyway
+     if CONTEXT is a currently open scope, in case it refers to a
+     member of the current instantiation or a non-dependent base;
+     lookup will stop when we hit a dependent base.  */
+  if (!dependent_scope_p (context))
+    /* We should only set WANT_TYPE when we're a nested typename type.
+       Then we can give better diagnostics if we find a non-type.  */
+    t = lookup_field (context, name, 0, /*want_type=*/true);
+  else
+    t = NULL_TREE;
+
+  if (!t && dependent_type_p (context)) 
+    return build_typename_type (context, name, fullname, tag_type);
+
   want_template = TREE_CODE (fullname) == TEMPLATE_ID_EXPR;
   
-  /* We should only set WANT_TYPE when we're a nested typename type.
-     Then we can give better diagnostics if we find a non-type.  */
-  t = lookup_field (context, name, 0, /*want_type=*/true);
   if (!t)
     {
       if (complain & tf_error)
@@ -7512,7 +7518,9 @@
 		    }
 
 		  type = TREE_OPERAND (decl, 0);
-		  name = IDENTIFIER_POINTER (constructor_name (type));
+		  if (TYPE_P (type))
+		    type = constructor_name (type);
+		  name = IDENTIFIER_POINTER (type);
 		  dname = decl;
 		}
 		break;
@@ -8009,8 +8017,9 @@
       switch (TREE_CODE (unqualified_id))
 	{
 	case BIT_NOT_EXPR:
-	  unqualified_id
-	    = constructor_name (TREE_OPERAND (unqualified_id, 0));
+	  unqualified_id = TREE_OPERAND (unqualified_id, 0);
+	  if (TYPE_P (unqualified_id))
+	    unqualified_id = constructor_name (unqualified_id);
 	  break;
 
 	case IDENTIFIER_NODE:
@@ -8856,21 +8865,20 @@
 	    /* Check that the name used for a destructor makes sense.  */
 	    if (sfk == sfk_destructor)
 	      {
+		tree uqname = id_declarator->u.id.unqualified_name;
+
 		if (!ctype)
 		  {
 		    gcc_assert (friendp);
 		    error ("expected qualified name in friend declaration "
-			   "for destructor %qD",
-			   id_declarator->u.id.unqualified_name);
+			   "for destructor %qD", uqname);
 		    return error_mark_node;
 		  }
 
-		if (!same_type_p (TREE_OPERAND
-				  (id_declarator->u.id.unqualified_name, 0),
-				  ctype))
+		if (!check_dtor_name (ctype, TREE_OPERAND (uqname, 0)))
 		  {
 		    error ("declaration of %qD as member of %qT",
-			   id_declarator->u.id.unqualified_name, ctype);
+			   uqname, ctype);
 		    return error_mark_node;
 		  }
 	      }
Index: gcc/cp/cp-tree.h
===================================================================
--- gcc/cp/cp-tree.h	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/cp/cp-tree.h	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -4460,6 +4460,7 @@
 extern tree maybe_get_template_decl_from_type_decl (tree);
 extern int processing_template_parmlist;
 extern bool dependent_type_p			(tree);
+extern bool dependent_scope_p			(tree);
 extern bool any_dependent_template_arguments_p  (const_tree);
 extern bool dependent_template_p		(tree);
 extern bool dependent_template_id_p		(tree, tree);
@@ -4623,7 +4624,7 @@
 extern tree finish_stmt_expr			(tree, bool);
 extern tree stmt_expr_value_expr		(tree);
 extern tree perform_koenig_lookup		(tree, tree);
-extern tree finish_call_expr			(tree, tree, bool, bool);
+extern tree finish_call_expr			(tree, tree, bool, int);
 extern tree finish_increment_expr		(tree, enum tree_code);
 extern tree finish_this_expr			(void);
 extern tree finish_pseudo_destructor_expr       (tree, tree, tree);
Index: gcc/cp/ChangeLog
===================================================================
--- gcc/cp/ChangeLog	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/cp/ChangeLog	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -1,3 +1,56 @@
+2009-03-04  Jason Merrill  <jason@redhat.com>
+
+	PR c++/9634
+	PR c++/29469
+	PR c++/29607
+	* decl.c (make_typename_type): Do look inside currently open classes.
+	* parser.c (cp_parser_lookup_name): Likewise.
+	(cp_parser_template_name): Likewise.
+	* pt.c (dependent_scope_p): New function.
+	* cp-tree.h: Declare it.
+	* class.c (currently_open_class): Return fast if T isn't a class.
+
+2009-02-20  Jason Merrill  <jason@redhat.com>
+
+	PR c++/39225
+	* decl.c (grokdeclarator): Handle ~identifier.
+
+2009-02-17  Jason Merrill  <jason@redhat.com>
+
+	PR c++/38950
+	* pt.c (unify)[TEMPLATE_PARM_INDEX]: Convert to the tsubsted type.
+
+2009-02-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/39070
+	* semantics.c (finish_call_expr): Change koenig_p parm to int.
+	If -1, don't set KOENIG_LOOKUP_P but do keep hidden candidates.
+	* cp-tree.h: Adjust prototype.
+	* pt.c (tsubst_copy_and_build) [CALL_EXPR]: Pass -1.
+
+2009-02-03  Paolo Bonzini  <bonzini@gnu.org>
+
+	PR c++/36897
+	* pt.c (convert_nontype_argument_function): Expect expr to be an
+	ADDR_EXPR.
+
+	PR c++/37314
+	* typeck.c (merge_types): Call resolve_typename_type if only
+	one type is a typename.
+
+2009-02-02  Jason Merrill  <jason@redhat.com>
+
+	PR c++/39054
+	* parser.c (cp_parser_unqualified_id): Don't wrap error_mark_node 
+	in BIT_NOT_EXPR.
+
+2009-01-26  Jason Merrill  <jason@redhat.com>
+
+	PR c++/23287
+	* parser.c (cp_parser_unqualified_id): In a template,
+	accept ~identifier.
+	* typeck.c (lookup_destructor): Handle IDENTIFIER_NODE.
+
 2009-01-24  Release Manager
 
 	* GCC 4.3.3 released.
Index: gcc/cp/pt.c
===================================================================
--- gcc/cp/pt.c	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/cp/pt.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -4555,6 +4555,13 @@
       expr = convert_nontype_argument_function (type, expr);
       if (!expr || expr == error_mark_node)
 	return expr;
+
+      if (TREE_CODE (expr) != ADDR_EXPR)
+	{
+	  error ("%qE is not a valid template argument for type %qT", expr, type);
+	  error ("it must be the address of a function with external linkage");
+	  return NULL_TREE;
+	}
     }
   /* [temp.arg.nontype]/5, bullet 5
 
@@ -11054,12 +11061,12 @@
 		       qualified_p ? LOOKUP_NONVIRTUAL : LOOKUP_NORMAL,
 		       /*fn_p=*/NULL));
 	  }
-	/* Pass true for koenig_p so that build_new_function_call will
+	/* Pass -1 for koenig_p so that build_new_function_call will
 	   allow hidden friends found by arg-dependent lookup at template
 	   parsing time.  */
 	return finish_call_expr (function, call_args,
 				 /*disallow_virtual=*/qualified_p,
-				 /*koenig_p*/true);
+				 /*koenig_p*/-1);
       }
 
     case COND_EXPR:
@@ -13051,7 +13058,7 @@
 	/* Convert the ARG to the type of PARM; the deduced non-type
 	   template argument must exactly match the types of the
 	   corresponding parameter.  */
-	arg = fold (build_nop (TREE_TYPE (parm), arg));
+	arg = fold (build_nop (tparm, arg));
       else if (uses_template_parms (tparm))
 	/* We haven't deduced the type of this parameter yet.  Try again
 	   later.  */
@@ -15637,6 +15644,16 @@
   return TYPE_DEPENDENT_P (type);
 }
 
+/* Returns TRUE if SCOPE is a dependent scope, in which we can't do any
+   lookup.  In other words, a dependent type that is not the current
+   instantiation.  */
+
+bool
+dependent_scope_p (tree scope)
+{
+  return dependent_type_p (scope) && !currently_open_class (scope);
+}
+
 /* Returns TRUE if EXPRESSION is dependent, according to CRITERION.  */
 
 static bool
@@ -15658,7 +15675,7 @@
      An id-expression is type-dependent if it contains a
      nested-name-specifier that contains a class-name that names a
      dependent type.  */
-  /* The suggested resolution to Core Issue 2 implies that if the
+  /* The suggested resolution to Core Issue 224 implies that if the
      qualifying type is the current class, then we must peek
      inside it.  */
   if (DECL_P (name)
Index: gcc/cp/semantics.c
===================================================================
--- gcc/cp/semantics.c	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/cp/semantics.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -1832,10 +1832,14 @@
    qualified.  For example a call to `X::f' never generates a virtual
    call.)
 
+   KOENIG_P is 1 if we want to perform argument-dependent lookup,
+   -1 if we don't, but we want to accept functions found by previous
+   argument-dependent lookup, and 0 if we want nothing to do with it.
+
    Returns code for the call.  */
 
 tree
-finish_call_expr (tree fn, tree args, bool disallow_virtual, bool koenig_p)
+finish_call_expr (tree fn, tree args, bool disallow_virtual, int koenig_p)
 {
   tree result;
   tree orig_fn;
@@ -1857,7 +1861,7 @@
 	  || any_type_dependent_arguments_p (args))
 	{
 	  result = build_nt_call_list (fn, args);
-	  KOENIG_LOOKUP_P (result) = koenig_p;
+	  KOENIG_LOOKUP_P (result) = koenig_p > 0;
 	  if (cfun)
 	    {
 	      do
@@ -1946,7 +1950,7 @@
 
       if (!result)
 	/* A call to a namespace-scope function.  */
-	result = build_new_function_call (fn, args, koenig_p);
+	result = build_new_function_call (fn, args, koenig_p != 0);
     }
   else if (TREE_CODE (fn) == PSEUDO_DTOR_EXPR)
     {
Index: gcc/cp/parser.c
===================================================================
--- gcc/cp/parser.c	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/cp/parser.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -3791,6 +3791,8 @@
 	    parser->scope = NULL_TREE;
 	    parser->object_scope = NULL_TREE;
 	    parser->qualifying_scope = NULL_TREE;
+	    if (processing_template_decl)
+	      cp_parser_parse_tentatively (parser);
 	    type_decl
 	      = cp_parser_class_name (parser,
 				      /*typename_keyword_p=*/false,
@@ -3799,6 +3801,16 @@
 				      /*check_dependency=*/false,
 				      /*class_head_p=*/false,
 				      declarator_p);
+	    if (processing_template_decl
+		&& ! cp_parser_parse_definitely (parser))
+	      {
+		/* We couldn't find a type with this name, so just accept
+		   it and check for a match at instantiation time.  */
+		type_decl = cp_parser_identifier (parser);
+		if (type_decl != error_mark_node)
+		  type_decl = build_nt (BIT_NOT_EXPR, type_decl);
+		return type_decl;
+	      }
 	  }
 	/* If an error occurred, assume that the name of the
 	   destructor is the same as the name of the qualifying
@@ -9941,7 +9953,7 @@
 	  && !template_keyword_p
 	  && parser->scope && TYPE_P (parser->scope)
 	  && check_dependency_p
-	  && dependent_type_p (parser->scope)
+	  && dependent_scope_p (parser->scope)
 	  /* Do not do this for dtors (or ctors), since they never
 	     need the template keyword before their name.  */
 	  && !constructor_name_p (identifier, parser->scope))
@@ -16214,35 +16226,11 @@
 	 cannot look up the name if the scope is not a class type; it
 	 might, for example, be a template type parameter.  */
       dependent_p = (TYPE_P (parser->scope)
-		     && !(parser->in_declarator_p
-			  && currently_open_class (parser->scope))
-		     && dependent_type_p (parser->scope));
+		     && dependent_scope_p (parser->scope));
       if ((check_dependency || !CLASS_TYPE_P (parser->scope))
-	   && dependent_p)
-	{
-	  if (tag_type)
-	    {
-	      tree type;
-
-	      /* The resolution to Core Issue 180 says that `struct
-		 A::B' should be considered a type-name, even if `A'
-		 is dependent.  */
-	      type = make_typename_type (parser->scope, name, tag_type,
-					 /*complain=*/tf_error);
-	      decl = TYPE_NAME (type);
-	    }
-	  else if (is_template
-		   && (cp_parser_next_token_ends_template_argument_p (parser)
-		       || cp_lexer_next_token_is (parser->lexer,
-						  CPP_CLOSE_PAREN)))
-	    decl = make_unbound_class_template (parser->scope,
-						name, NULL_TREE,
-						/*complain=*/tf_error);
-	  else
-	    decl = build_qualified_name (/*type=*/NULL_TREE,
-					 parser->scope, name,
-					 is_template);
-	}
+	  && dependent_p)
+	/* Defer lookup.  */
+	decl = error_mark_node;
       else
 	{
 	  tree pushed_scope = NULL_TREE;
@@ -16263,14 +16251,42 @@
 					/*complain=*/true);
 
 	  /* If we have a single function from a using decl, pull it out.  */
-	  if (decl
-	      && TREE_CODE (decl) == OVERLOAD
+	  if (TREE_CODE (decl) == OVERLOAD
 	      && !really_overloaded_fn (decl))
 	    decl = OVL_FUNCTION (decl);
 
 	  if (pushed_scope)
 	    pop_scope (pushed_scope);
 	}
+
+      /* If the scope is a dependent type and either we deferred lookup or
+	 we did lookup but didn't find the name, rememeber the name.  */
+      if (decl == error_mark_node && TYPE_P (parser->scope)
+	  && dependent_type_p (parser->scope))
+	{
+	  if (tag_type)
+	    {
+	      tree type;
+
+	      /* The resolution to Core Issue 180 says that `struct
+		 A::B' should be considered a type-name, even if `A'
+		 is dependent.  */
+	      type = make_typename_type (parser->scope, name, tag_type,
+					 /*complain=*/tf_error);
+	      decl = TYPE_NAME (type);
+	    }
+	  else if (is_template
+		   && (cp_parser_next_token_ends_template_argument_p (parser)
+		       || cp_lexer_next_token_is (parser->lexer,
+						  CPP_CLOSE_PAREN)))
+	    decl = make_unbound_class_template (parser->scope,
+						name, NULL_TREE,
+						/*complain=*/tf_error);
+	  else
+	    decl = build_qualified_name (/*type=*/NULL_TREE,
+					 parser->scope, name,
+					 is_template);
+	}
       parser->qualifying_scope = parser->scope;
       parser->object_scope = NULL_TREE;
     }
Index: gcc/tree-ssa-ccp.c
===================================================================
--- gcc/tree-ssa-ccp.c	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/tree-ssa-ccp.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -938,7 +938,7 @@
       if ((code == NOP_EXPR || code == CONVERT_EXPR)
 	  && useless_type_conversion_p (TREE_TYPE (rhs), TREE_TYPE (op0)))
 	return op0;
-      return fold_unary (code, TREE_TYPE (rhs), op0);
+      return fold_unary_ignore_overflow (code, TREE_TYPE (rhs), op0);
     }
 
   /* Binary and comparison operators.  We know one or both of the
Index: gcc/recog.c
===================================================================
--- gcc/recog.c	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/recog.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -1,6 +1,6 @@
 /* Subroutines used by or related to instruction recognition.
    Copyright (C) 1987, 1988, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998
-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009
    Free Software Foundation, Inc.
 
 This file is part of GCC.
@@ -147,10 +147,7 @@
       const char *c = constraints[i];
       if (c[0] == '%')
 	c++;
-      if (ISDIGIT ((unsigned char) c[0]) && c[1] == '\0')
-	c = constraints[c[0] - '0'];
-
-      if (! asm_operand_ok (operands[i], c))
+      if (! asm_operand_ok (operands[i], c, constraints))
 	return 0;
     }
 
@@ -1506,7 +1503,7 @@
    Return > 0 if ok, = 0 if bad, < 0 if inconclusive.  */
 
 int
-asm_operand_ok (rtx op, const char *constraint)
+asm_operand_ok (rtx op, const char *constraint, const char **constraints)
 {
   int result = 0;
 
@@ -1534,15 +1531,29 @@
 
 	case '0': case '1': case '2': case '3': case '4':
 	case '5': case '6': case '7': case '8': case '9':
-	  /* For best results, our caller should have given us the
-	     proper matching constraint, but we can't actually fail
-	     the check if they didn't.  Indicate that results are
-	     inconclusive.  */
-	  do
-	    constraint++;
-	  while (ISDIGIT (*constraint));
-	  if (! result)
-	    result = -1;
+	  /* If caller provided constraints pointer, look up
+	     the maching constraint.  Otherwise, our caller should have
+	     given us the proper matching constraint, but we can't
+	     actually fail the check if they didn't.  Indicate that
+	     results are inconclusive.  */
+	  if (constraints)
+	    {
+	      char *end;
+	      unsigned long match;
+
+	      match = strtoul (constraint, &end, 10);
+	      if (!result)
+		result = asm_operand_ok (op, constraints[match], NULL);
+	      constraint = (const char *) end;
+	    }
+	  else
+	    {
+	      do
+		constraint++;
+	      while (ISDIGIT (*constraint));
+	      if (! result)
+		result = -1;
+	    }
 	  continue;
 
 	case 'p':
Index: gcc/ada/ChangeLog
===================================================================
--- gcc/ada/ChangeLog	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/ada/ChangeLog	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -1,3 +1,8 @@
+2009-02-28  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* Makefile.in (cygwin/mingw): Revert accidental EH_MECHANISM change
+	made on 2007-12-06.
+
 2009-01-24  Release Manager
 
 	* GCC 4.3.3 released.
Index: gcc/ada/Makefile.in
===================================================================
--- gcc/ada/Makefile.in	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/ada/Makefile.in	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -1353,7 +1353,6 @@
   mlib-tgt-specific.adb<mlib-tgt-mingw.adb \
   indepsw.adb<indepsw-mingw.adb
 
-  EH_MECHANISM=-gcc
   GMEM_LIB = gmemlib
   PREFIX_OBJS = $(PREFIX_REAL_OBJS)
   EXTRA_GNATTOOLS = ../../gnatdll$(exeext)
Index: gcc/recog.h
===================================================================
--- gcc/recog.h	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/recog.h	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -1,6 +1,6 @@
 /* Declarations for interface to insn recognizer and insn-output.c.
    Copyright (C) 1987, 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004,
-   2005, 2006, 2007 Free Software Foundation, Inc.
+   2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
 
 This file is part of GCC.
 
@@ -71,7 +71,7 @@
 extern void init_recog (void);
 extern void init_recog_no_volatile (void);
 extern int check_asm_operands (rtx);
-extern int asm_operand_ok (rtx, const char *);
+extern int asm_operand_ok (rtx, const char *, const char **);
 extern bool validate_change (rtx, rtx *, rtx, bool);
 extern bool validate_unshare_change (rtx, rtx *, rtx, bool);
 extern bool canonicalize_change_group (rtx insn, rtx x);
Index: gcc/c-decl.c
===================================================================
--- gcc/c-decl.c	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/c-decl.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -4386,12 +4386,20 @@
 	      }
 	    else if (decl_context == FIELD)
 	      {
-		if (pedantic && !flag_isoc99 && !in_system_header)
+		bool flexible_array_member = false;
+		const struct c_declarator *t = declarator;
+		while (t->kind == cdk_attrs)
+		  t = t->declarator;
+		flexible_array_member = (t->kind == cdk_id);
+		if (flexible_array_member
+		    && pedantic && !flag_isoc99 && !in_system_header)
 		  pedwarn ("ISO C90 does not support flexible array members");
 
 		/* ISO C99 Flexible array members are effectively
 		   identical to GCC's zero-length array extension.  */
-		itype = build_range_type (sizetype, size_zero_node, NULL_TREE);
+		if (flexible_array_member || array_parm_vla_unspec_p)
+		  itype = build_range_type (sizetype, size_zero_node,
+					    NULL_TREE);
 	      }
 	    else if (decl_context == PARM)
 	      {
@@ -5362,6 +5370,8 @@
 	    error ("redefinition of %<union %E%>", name);
 	  else
 	    error ("redefinition of %<struct %E%>", name);
+	  /* Don't create structures using a name already in use.  */
+	  ref = NULL_TREE;
 	}
       else if (C_TYPE_BEING_DEFINED (ref))
 	{
Index: gcc/fortran/ChangeLog
===================================================================
--- gcc/fortran/ChangeLog	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/fortran/ChangeLog	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -1,3 +1,43 @@
+2009-02-19  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/38852
+	PR fortran/39006
+	Backport from trunk
+	* trans-intrinsic.c (gfc_conv_intrinsic_bound): Use the array
+	descriptor ubound for UBOUND, when the array lbound == 1.
+
+2009-01-26  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/38907
+	Backport from trunk
+	* resolve.c (check_host_association): Remove the matching to
+	correct an incorrect host association and use manipulation of
+	the expression instead.
+
+2009-01-26  Mikael Morin  <mikael.morin@tele2.fr>
+
+        PR fortran/38859
+	Backport from trunk
+        * simplify.c (simplify_bound): Don't use array specification
+        if variable or component has subsequent references.
+
+2009-01-26  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/38657
+	Backport from trunk.
+	* module.c (write_common_0): Add argument 'this_module' and
+	check that non-use associated common blocks are written first.
+	(write_common): Call write_common_0 twice, once with true and
+	then with false.
+
+2009-01-24  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/38672
+	Backport from trunk.
+	* resolve.c (resolve_symbol):  Check for the
+	presence of derived->ns->proc_name before
+	accessing derived->ns->proc_name->attr.flavor .
+
 2009-01-24  Release Manager
 
 	* GCC 4.3.3 released.
Index: gcc/fortran/module.c
===================================================================
--- gcc/fortran/module.c	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/fortran/module.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -3992,7 +3992,7 @@
 /* Write a common block to the module -- recursive helper function.  */
 
 static void
-write_common_0 (gfc_symtree *st)
+write_common_0 (gfc_symtree *st, bool this_module)
 {
   gfc_common_head *p;
   const char * name;
@@ -4004,7 +4004,7 @@
   if (st == NULL)
     return;
 
-  write_common_0 (st->left);
+  write_common_0 (st->left, this_module);
 
   /* We will write out the binding label, or the name if no label given.  */
   name = st->n.common->name;
@@ -4023,6 +4023,10 @@
       w = (c < 0) ? w->left : w->right;
     }
 
+  /* Give priority to commons that are not use associated.  */
+  if (this_module && p->use_assoc)
+    write_me = false;
+
   if (write_me)
     {
       /* Write the common to the module.  */
@@ -4043,12 +4047,12 @@
 
       /* Record that we have written this common.  */
       w = gfc_getmem (sizeof (struct written_common));
+      w->label = label;
       w->name = name;
-      w->label = label;
       gfc_insert_bbt (&written_commons, w, compare_written_commons);
     }
 
-  write_common_0 (st->right);
+  write_common_0 (st->right, this_module);
 }
 
 
@@ -4059,7 +4063,8 @@
 write_common (gfc_symtree *st)
 {
   written_commons = NULL;
-  write_common_0 (st);
+  write_common_0 (st, true);
+  write_common_0 (st, false);
   free_written_common (written_commons);
   written_commons = NULL;
 }
Index: gcc/fortran/resolve.c
===================================================================
--- gcc/fortran/resolve.c	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/fortran/resolve.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -4189,15 +4189,17 @@
 /* Checks to see that the correct symbol has been host associated.
    The only situation where this arises is that in which a twice
    contained function is parsed after the host association is made.
-   Therefore, on detecting this, the line is rematched, having got
-   rid of the existing references and actual_arg_list.  */
+   Therefore, on detecting this, change the symbol in the expression
+   and convert the array reference into an actual arglist if the old
+   symbol is a variable.  */
 static bool
 check_host_association (gfc_expr *e)
 {
   gfc_symbol *sym, *old_sym;
-  locus temp_locus;
-  gfc_expr *expr;
+  gfc_symtree *st;
   int n;
+  gfc_ref *ref;
+  gfc_actual_arglist *arg, *tail;
   bool retval = e->expr_type == EXPR_FUNCTION;
 
   /*  If the expression is the result of substitution in
@@ -4213,26 +4215,16 @@
   if (gfc_current_ns->parent
 	&& old_sym->ns != gfc_current_ns)
     {
+      /* Use the 'USE' name so that renamed module symbols are
+	 correctly handled.  */
       gfc_find_symbol (e->symtree->name, gfc_current_ns, 1, &sym);
+
       if (sym && old_sym != sym
 	      && sym->ts.type == old_sym->ts.type
 	      && sym->attr.flavor == FL_PROCEDURE
 	      && sym->attr.contained)
 	{
-	  temp_locus = gfc_current_locus;
-	  gfc_current_locus = e->where;
-
-	  gfc_buffer_error (1);
-
-	  gfc_free_ref_list (e->ref);
-	  e->ref = NULL;
-
-	  if (retval)
-	    {
-	      gfc_free_actual_arglist (e->value.function.actual);
-	      e->value.function.actual = NULL;
-	    }
-
+	  /* Clear the shape, since it might not be valid.  */
 	  if (e->shape != NULL)
 	    {
 	      for (n = 0; n < e->rank; n++)
@@ -4241,22 +4233,58 @@
 	      gfc_free (e->shape);
 	    }
 
-/* TODO - Replace this gfc_match_rvalue with a straight replacement of
-   actual arglists for function to function substitutions and with a
-   conversion of the reference list to an actual arglist in the case of
-   a variable to function replacement.  This should be quite easy since
-   only integers and vectors can be involved.  */	    
-	  gfc_match_rvalue (&expr);
-	  gfc_clear_error ();
-	  gfc_buffer_error (0);
+	  /* Give the symbol a symtree in the right place!  */
+	  gfc_get_sym_tree (sym->name, gfc_current_ns, &st);
+	  st->n.sym = sym;
 
-	  gcc_assert (expr && sym == expr->symtree->n.sym);
+	  if (old_sym->attr.flavor == FL_PROCEDURE)
+	    {
+	      /* Original was function so point to the new symbol, since
+		 the actual argument list is already attached to the
+		 expression. */
+	      e->value.function.esym = NULL;
+	      e->symtree = st;
+	    }
+	  else
+	    {
+	      /* Original was variable so convert array references into
+		 an actual arglist. This does not need any checking now
+		 since gfc_resolve_function will take care of it.  */
+	      e->value.function.actual = NULL;
+	      e->expr_type = EXPR_FUNCTION;
+	      e->symtree = st;
 
-	  *e = *expr;
-	  gfc_free (expr);
+	      /* Ambiguity will not arise if the array reference is not
+		 the last reference.  */
+	      for (ref = e->ref; ref; ref = ref->next)
+		if (ref->type == REF_ARRAY && ref->next == NULL)
+		  break;
+
+	      gcc_assert (ref->type == REF_ARRAY);
+
+	      /* Grab the start expressions from the array ref and
+		 copy them into actual arguments.  */
+	      for (n = 0; n < ref->u.ar.dimen; n++)
+		{
+		  arg = gfc_get_actual_arglist ();
+		  arg->expr = gfc_copy_expr (ref->u.ar.start[n]);
+		  if (e->value.function.actual == NULL)
+		    tail = e->value.function.actual = arg;
+	          else
+		    {
+		      tail->next = arg;
+		      tail = arg;
+		    }
+		}
+
+	      /* Dump the reference list and set the rank.  */
+	      gfc_free_ref_list (e->ref);
+	      e->ref = NULL;
+	      e->rank = sym->as ? sym->as->rank : 0;
+	    }
+
+	  gfc_resolve_expr (e);
 	  sym->refs++;
-
-	  gfc_current_locus = temp_locus;
 	}
     }
   /* This might have changed!  */
@@ -8116,6 +8144,7 @@
      module function and is not PRIVATE.  */
   if (sym->ts.type == BT_DERIVED
 	&& sym->ts.derived->attr.use_assoc
+	&& sym->ns->proc_name
 	&& sym->ns->proc_name->attr.flavor == FL_MODULE)
     {
       gfc_symbol *ds;
Index: gcc/fortran/trans-intrinsic.c
===================================================================
--- gcc/fortran/trans-intrinsic.c	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/fortran/trans-intrinsic.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -917,12 +917,17 @@
 
       cond4 = fold_build2 (LT_EXPR, boolean_type_node, stride,
 			   gfc_index_zero_node);
-      cond4 = fold_build2 (TRUTH_AND_EXPR, boolean_type_node, cond4, cond2);
 
       if (upper)
 	{
+	  tree cond5;
 	  cond = fold_build2 (TRUTH_OR_EXPR, boolean_type_node, cond3, cond4);
 
+	  cond5 = fold_build2 (EQ_EXPR, boolean_type_node, gfc_index_one_node, lbound);
+	  cond5 = fold_build2 (TRUTH_AND_EXPR, boolean_type_node, cond4, cond5);
+
+	  cond = fold_build2 (TRUTH_OR_EXPR, boolean_type_node, cond, cond5);
+
 	  se->expr = fold_build3 (COND_EXPR, gfc_array_index_type, cond,
 				  ubound, gfc_index_zero_node);
 	}
Index: gcc/fortran/simplify.c
===================================================================
--- gcc/fortran/simplify.c	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/fortran/simplify.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -2104,8 +2104,11 @@
 	    case AR_FULL:
 	      /* We're done because 'as' has already been set in the
 		 previous iteration.  */
-	      goto done;
+	      if (!ref->next)
+	        goto done;
 
+	    /* Fall through.  */
+
 	    case AR_SECTION:
 	    case AR_UNKNOWN:
 	      return NULL;
Index: gcc/BASE-VER
===================================================================
--- gcc/BASE-VER	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/BASE-VER	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -1 +1 @@
-4.3.3
+4.3.4
Index: gcc/alias.c
===================================================================
--- gcc/alias.c	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/alias.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -1508,26 +1508,27 @@
   if (rtx_equal_p (x_base, y_base))
     return 1;
 
-  /* The base addresses of the read and write are different expressions.
-     If they are both symbols and they are not accessed via AND, there is
-     no conflict.  We can bring knowledge of object alignment into play
-     here.  For example, on alpha, "char a, b;" can alias one another,
-     though "char a; long b;" cannot.  */
+  /* The base addresses are different expressions.  If they are not accessed
+     via AND, there is no conflict.  We can bring knowledge of object
+     alignment into play here.  For example, on alpha, "char a, b;" can
+     alias one another, though "char a; long b;" cannot.  AND addesses may
+     implicitly alias surrounding objects; i.e. unaligned access in DImode
+     via AND address can alias all surrounding object types except those
+     with aligment 8 or higher.  */
+  if (GET_CODE (x) == AND && GET_CODE (y) == AND)
+    return 1;
+  if (GET_CODE (x) == AND
+      && (GET_CODE (XEXP (x, 1)) != CONST_INT
+	  || (int) GET_MODE_UNIT_SIZE (y_mode) < -INTVAL (XEXP (x, 1))))
+    return 1;
+  if (GET_CODE (y) == AND
+      && (GET_CODE (XEXP (y, 1)) != CONST_INT
+	  || (int) GET_MODE_UNIT_SIZE (x_mode) < -INTVAL (XEXP (y, 1))))
+    return 1;
+
+  /* Differing symbols not accessed via AND never alias.  */
   if (GET_CODE (x_base) != ADDRESS && GET_CODE (y_base) != ADDRESS)
-    {
-      if (GET_CODE (x) == AND && GET_CODE (y) == AND)
-	return 1;
-      if (GET_CODE (x) == AND
-	  && (GET_CODE (XEXP (x, 1)) != CONST_INT
-	      || (int) GET_MODE_UNIT_SIZE (y_mode) < -INTVAL (XEXP (x, 1))))
-	return 1;
-      if (GET_CODE (y) == AND
-	  && (GET_CODE (XEXP (y, 1)) != CONST_INT
-	      || (int) GET_MODE_UNIT_SIZE (x_mode) < -INTVAL (XEXP (y, 1))))
-	return 1;
-      /* Differing symbols never alias.  */
-      return 0;
-    }
+    return 0;
 
   /* If one address is a stack reference there can be no alias:
      stack references using different base registers do not alias,
Index: gcc/c-typeck.c
===================================================================
--- gcc/c-typeck.c	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/c-typeck.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -327,10 +327,14 @@
 	tree d2 = TYPE_DOMAIN (t2);
 	bool d1_variable, d2_variable;
 	bool d1_zero, d2_zero;
+	bool t1_complete, t2_complete;
 
 	/* We should not have any type quals on arrays at all.  */
 	gcc_assert (!TYPE_QUALS (t1) && !TYPE_QUALS (t2));
 
+	t1_complete = COMPLETE_TYPE_P (t1);
+	t2_complete = COMPLETE_TYPE_P (t2);
+
 	d1_zero = d1 == 0 || !TYPE_MAX_VALUE (d1);
 	d2_zero = d2 == 0 || !TYPE_MAX_VALUE (d2);
 
@@ -370,6 +374,15 @@
 						 || !d1_variable))
 					    ? t1
 					    : t2));
+	/* Ensure a composite type involving a zero-length array type
+	   is a zero-length type not an incomplete type.  */
+	if (d1_zero && d2_zero
+	    && (t1_complete || t2_complete)
+	    && !COMPLETE_TYPE_P (t1))
+	  {
+	    TYPE_SIZE (t1) = bitsize_zero_node;
+	    TYPE_SIZE_UNIT (t1) = size_zero_node;
+	  }
 	t1 = c_build_qualified_type (t1, quals);
 	return build_type_attribute_variant (t1, attributes);
       }
Index: gcc/gimplify.c
===================================================================
--- gcc/gimplify.c	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/gimplify.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -3206,7 +3206,8 @@
 	if (valid_const_initializer
 	    && num_nonzero_elements > 1
 	    && TREE_READONLY (object)
-	    && TREE_CODE (object) == VAR_DECL)
+	    && TREE_CODE (object) == VAR_DECL
+	    && (flag_merge_constants >= 2 || !TREE_ADDRESSABLE (object)))
 	  {
 	    if (notify_temp_creation)
 	      return GS_ERROR;
Index: gcc/calls.c
===================================================================
--- gcc/calls.c	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/calls.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -978,7 +978,6 @@
 	    && targetm.calls.split_complex_arg (argtype))
 	  {
 	    tree subtype = TREE_TYPE (argtype);
-	    arg = save_expr (arg);
 	    args[j].tree_value = build1 (REALPART_EXPR, subtype, arg);
 	    j += inc;
 	    args[j].tree_value = build1 (IMAGPART_EXPR, subtype, arg);
@@ -3678,10 +3677,10 @@
 #ifdef ARGS_GROW_DOWNWARD
 	      /* stack_slot is negative, but we want to index stack_usage_map
 		 with positive values.  */
-	      upper_bound = -argvec[argnum].locate.offset.constant + 1;
+	      upper_bound = -argvec[argnum].locate.slot_offset.constant + 1;
 	      lower_bound = upper_bound - argvec[argnum].locate.size.constant;
 #else
-	      lower_bound = argvec[argnum].locate.offset.constant;
+	      lower_bound = argvec[argnum].locate.slot_offset.constant;
 	      upper_bound = lower_bound + argvec[argnum].locate.size.constant;
 #endif
 
Index: gcc/tree-ssa-forwprop.c
===================================================================
--- gcc/tree-ssa-forwprop.c	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/tree-ssa-forwprop.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -487,28 +487,36 @@
 forward_propagate_addr_into_variable_array_index (tree offset,
 						  tree def_rhs, tree use_stmt)
 {
-  tree index;
+  tree index, offset_def;
 
-  /* Try to find an expression for a proper index.  This is either
-     a multiplication expression by the element size or just the
-     ssa name we came along in case the element size is one.  */
+  /* Get the offset's defining statement.  */
+  offset_def = SSA_NAME_DEF_STMT (offset);
+
+  /* Try to find an expression for a proper index.  This is either a
+     multiplication expression by the element size or just the ssa name we came
+     along in case the element size is one. In that case, however, we do not
+     allow multiplications because they can be computing index to a higher
+     level dimension (PR 37861). */
   if (integer_onep (TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (def_rhs)))))
-    index = offset;
+    {
+      if (TREE_CODE (offset_def) == GIMPLE_MODIFY_STMT
+	  && TREE_CODE (GIMPLE_STMT_OPERAND (offset_def, 1)) == MULT_EXPR)
+	return false;
+
+      index = offset;
+    }
   else
     {
-      /* Get the offset's defining statement.  */
-      offset = SSA_NAME_DEF_STMT (offset);
-
       /* The statement which defines OFFSET before type conversion
          must be a simple GIMPLE_MODIFY_STMT.  */
-      if (TREE_CODE (offset) != GIMPLE_MODIFY_STMT)
+      if (TREE_CODE (offset_def) != GIMPLE_MODIFY_STMT)
 	return false;
 
       /* The RHS of the statement which defines OFFSET must be a
 	 multiplication of an object by the size of the array elements. 
 	 This implicitly verifies that the size of the array elements
 	 is constant.  */
-     offset = GIMPLE_STMT_OPERAND (offset, 1);
+     offset = GIMPLE_STMT_OPERAND (offset_def, 1);
       if (TREE_CODE (offset) != MULT_EXPR
 	  || TREE_CODE (TREE_OPERAND (offset, 1)) != INTEGER_CST
 	  || !simple_cst_equal (TREE_OPERAND (offset, 1),
@@ -677,6 +685,7 @@
      array elements, then the result is converted into the proper
      type for the arithmetic.  */
   if (TREE_CODE (TREE_OPERAND (rhs, 1)) == SSA_NAME
+      && useless_type_conversion_p (TREE_TYPE (name), TREE_TYPE (def_rhs))
       /* Avoid problems with IVopts creating PLUS_EXPRs with a
 	 different type than their operands.  */
       && useless_type_conversion_p (TREE_TYPE (rhs), TREE_TYPE (name)))
Index: gcc/c-common.c
===================================================================
--- gcc/c-common.c	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/c-common.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -5534,7 +5534,12 @@
 {
   tree decl = *node;
 
-  if ((TREE_CODE (decl) == FUNCTION_DECL && DECL_INITIAL (decl))
+  if (TREE_CODE (decl) != FUNCTION_DECL && TREE_CODE (decl) != VAR_DECL)
+    {
+      warning (OPT_Wattributes, "%qE attribute ignored", name);
+      *no_add_attrs = true;
+    }
+  else if ((TREE_CODE (decl) == FUNCTION_DECL && DECL_INITIAL (decl))
       || (TREE_CODE (decl) != FUNCTION_DECL 
 	  && TREE_PUBLIC (decl) && !DECL_EXTERNAL (decl))
       /* A static variable declaration is always a tentative definition,
@@ -5782,7 +5787,7 @@
 
   *no_add_attrs = true;
 
-  if (!DECL_THREAD_LOCAL_P (decl))
+  if (TREE_CODE (decl) != VAR_DECL || !DECL_THREAD_LOCAL_P (decl))
     {
       warning (OPT_Wattributes, "%qE attribute ignored", name);
       return NULL_TREE;
Index: gcc/tree-ssa-structalias.c
===================================================================
--- gcc/tree-ssa-structalias.c	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/tree-ssa-structalias.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -1509,24 +1509,23 @@
 	  varinfo_t v;
 	  unsigned int t;
 	  unsigned HOST_WIDE_INT fieldoffset = get_varinfo (j)->offset + loff;
-	  bitmap tmp;
 
 	  v = first_vi_for_offset (get_varinfo (j), fieldoffset);
 	  /* If the access is outside of the variable we can ignore it.  */
 	  if (!v)
 	    continue;
 	  t = find (v->id);
-	  tmp = get_varinfo (t)->solution;
-
-	  if (set_union_with_increment (tmp, sol, 0))
+	  if (add_graph_edge (graph, t, rhs))
 	    {
-	      get_varinfo (t)->solution = tmp;
-	      if (t == rhs)
-		sol = get_varinfo (rhs)->solution;
-	      if (!TEST_BIT (changed, t))
+	      if (bitmap_ior_into (get_varinfo (t)->solution, sol))
 		{
-		  SET_BIT (changed, t);
-		  changed_count++;
+		  if (t == rhs)
+		    sol = get_varinfo (rhs)->solution;
+		  if (!TEST_BIT (changed, t))
+		    {
+		      SET_BIT (changed, t);
+		      changed_count++;
+		    }
 		}
 	    }
 	}
Index: gcc/c-parser.c
===================================================================
--- gcc/c-parser.c	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/c-parser.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -2680,6 +2680,7 @@
 			     "expected %<;%>, %<,%> or %<)%>"))
 	{
 	  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);
+	  get_pending_sizes ();
 	  return NULL;
 	}
       if (c_parser_next_token_is (parser, CPP_ELLIPSIS))
@@ -2707,6 +2708,7 @@
 	    {
 	      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,
 					 "expected %<)%>");
+	      get_pending_sizes ();
 	      return NULL;
 	    }
 	}
@@ -3132,6 +3134,7 @@
       ret.value = error_mark_node;
       ret.original_code = ERROR_MARK;
       c_parser_skip_until_found (parser, CPP_CLOSE_BRACE, "expected %<}%>");
+      pop_init_level (0);
       return ret;
     }
   c_parser_consume_token (parser);
Index: gcc/config/alpha/elf.h
===================================================================
--- gcc/config/alpha/elf.h	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/config/alpha/elf.h	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -423,3 +423,13 @@
 #if defined(HAVE_LD_EH_FRAME_HDR)
 #define LINK_EH_SPEC "%{!static:--eh-frame-hdr} "
 #endif
+
+/* A C statement (sans semicolon) to output to the stdio stream STREAM
+   any text necessary for declaring the name of an external symbol
+   named NAME which is referenced in this compilation but not defined.
+   It is needed to properly support non-default visibility.  */
+
+#ifndef ASM_OUTPUT_EXTERNAL
+#define ASM_OUTPUT_EXTERNAL(FILE, DECL, NAME) \
+  default_elf_asm_output_external (FILE, DECL, NAME)
+#endif
Index: gcc/config/alpha/alpha.c
===================================================================
--- gcc/config/alpha/alpha.c	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/config/alpha/alpha.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -1,6 +1,7 @@
 /* Subroutines used for code generation on the DEC Alpha.
    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
-   2002, 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.
+   2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
+   Free Software Foundation, Inc.
    Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)
 
 This file is part of GCC.
@@ -863,9 +864,11 @@
 	}
     }
 
-  /* If we're managing explicit relocations, LO_SUM is valid, as
-     are small data symbols.  */
-  else if (TARGET_EXPLICIT_RELOCS)
+  /* If we're managing explicit relocations, LO_SUM is valid, as are small
+     data symbols.  Avoid explicit relocations in modes larger than word
+     mode since i.e. $LC0+8($1) can fold around +/- 32k offset.  */
+  else if (TARGET_EXPLICIT_RELOCS
+	   && GET_MODE_SIZE (mode) <= UNITS_PER_WORD)
     {
       if (small_symbolic_operand (x, Pmode))
 	return true;
@@ -915,8 +918,7 @@
    to be legitimate.  If we find one, return the new, valid address.  */
 
 rtx
-alpha_legitimize_address (rtx x, rtx scratch,
-			  enum machine_mode mode ATTRIBUTE_UNUSED)
+alpha_legitimize_address (rtx x, rtx scratch, enum machine_mode mode)
 {
   HOST_WIDE_INT addend;
 
@@ -964,8 +966,12 @@
       goto split_addend;
     }
 
-  /* If this is a local symbol, split the address into HIGH/LO_SUM parts.  */
-  if (TARGET_EXPLICIT_RELOCS && symbolic_operand (x, Pmode))
+  /* If this is a local symbol, split the address into HIGH/LO_SUM parts.
+     Avoid modes larger than word mode since i.e. $LC0+8($1) can fold
+     around +/- 32k offset.  */
+  if (TARGET_EXPLICIT_RELOCS
+      && GET_MODE_SIZE (mode) <= UNITS_PER_WORD
+      && symbolic_operand (x, Pmode))
     {
       rtx r0, r16, eqv, tga, tp, insn, dest, seq;
 
@@ -1602,18 +1608,17 @@
   return -1;
 }
 
-/* Given INSN, which is an INSN list or the PATTERN of a single insn
-   generated to perform a memory operation, look for any MEMs in either
+/* Given SEQ, which is an INSN list, look for any MEMs in either
    a SET_DEST or a SET_SRC and copy the in-struct, unchanging, and
    volatile flags from REF into each of the MEMs found.  If REF is not
    a MEM, don't do anything.  */
 
 void
-alpha_set_memflags (rtx insn, rtx ref)
+alpha_set_memflags (rtx seq, rtx ref)
 {
-  rtx *base_ptr;
+  rtx insn;
 
-  if (GET_CODE (ref) != MEM)
+  if (!MEM_P (ref))
     return;
 
   /* This is only called from alpha.md, after having had something
@@ -1626,11 +1631,11 @@
       && !MEM_READONLY_P (ref))
     return;
 
-  if (INSN_P (insn))
-    base_ptr = &PATTERN (insn);
-  else
-    base_ptr = &insn;
-  for_each_rtx (base_ptr, alpha_set_memflags_1, (void *) ref);
+  for (insn = seq; insn; insn = NEXT_INSN (insn))
+    if (INSN_P (insn))
+      for_each_rtx (&PATTERN (insn), alpha_set_memflags_1, (void *) ref);
+    else
+      gcc_unreachable ();
 }
 
 static rtx alpha_emit_set_const (rtx, enum machine_mode, HOST_WIDE_INT,
@@ -2118,6 +2123,8 @@
 bool
 alpha_expand_mov (enum machine_mode mode, rtx *operands)
 {
+  rtx tmp;
+
   /* If the output is not a register, the input must be.  */
   if (GET_CODE (operands[0]) == MEM
       && ! reg_or_0_operand (operands[1], mode))
@@ -2126,8 +2133,6 @@
   /* Allow legitimize_address to perform some simplifications.  */
   if (mode == Pmode && symbolic_operand (operands[1], mode))
     {
-      rtx tmp;
-
       tmp = alpha_legitimize_address (operands[1], operands[0], mode);
       if (tmp)
 	{
@@ -2152,14 +2157,18 @@
     }
 
   /* Otherwise we've nothing left but to drop the thing to memory.  */
-  operands[1] = force_const_mem (mode, operands[1]);
+  tmp = force_const_mem (mode, operands[1]);
+
+  if (tmp == NULL_RTX)
+    return false;
+
   if (reload_in_progress)
     {
-      emit_move_insn (operands[0], XEXP (operands[1], 0));
-      operands[1] = replace_equiv_address (operands[1], operands[0]);
+      emit_move_insn (operands[0], XEXP (tmp, 0));
+      operands[1] = replace_equiv_address (tmp, operands[0]);
     }
   else
-    operands[1] = validize_mem (operands[1]);
+    operands[1] = validize_mem (tmp);
   return false;
 }
 
@@ -2452,7 +2461,7 @@
   if (alpha_compare.fp_p)
     {
       cmp_mode = DFmode;
-      if (flag_unsafe_math_optimizations)
+      if (flag_unsafe_math_optimizations && cmp_code != UNORDERED)
 	{
 	  /* When we are not as concerned about non-finite values, and we
 	     are comparing against zero, we can branch directly.  */
@@ -6794,7 +6803,7 @@
   tree op0 = fold_convert (vtype, op[0]);
   tree op1 = fold_convert (vtype, op[1]);
   tree val = fold_build2 (code, vtype, op0, op1);
-  return fold_convert (long_integer_type_node, val);
+  return fold_build1 (VIEW_CONVERT_EXPR, long_integer_type_node, val);
 }
 
 static tree
@@ -8242,6 +8251,11 @@
   if (GET_CODE (insn) == CALL_INSN)
     output_asm_insn (get_insn_template (CODE_FOR_nop, NULL), NULL);
 
+#if TARGET_ABI_OSF
+  if (current_function_is_thunk)
+    free_after_compilation (cfun);
+#endif
+
 #if TARGET_ABI_OPEN_VMS
   alpha_write_linkage (file, fnname, decl);
 #endif
@@ -8281,6 +8295,8 @@
   HOST_WIDE_INT hi, lo;
   rtx this, insn, funexp;
 
+  gcc_assert (current_function_is_thunk);
+
   /* We always require a valid GP.  */
   emit_insn (gen_prologue_ldgp ());
   emit_note (NOTE_INSN_PROLOGUE_END);
@@ -9268,12 +9284,68 @@
       i = next;
     }
 }
+
+/* Insert an unop between a noreturn function call and GP load.  */
+
+static void
+alpha_pad_noreturn (void)
+{
+  rtx insn, next;
+
+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))
+    {
+      rtx pat;
+
+      if (!CALL_P (insn)
+	  || !find_reg_note (insn, REG_NORETURN, NULL_RTX))
+        continue;
+
+      next = next_active_insn (insn);
+
+      if (next)
+	{
+	  pat = PATTERN (next);
+
+	  if (GET_CODE (pat) == SET
+	      && GET_CODE (SET_SRC (pat)) == UNSPEC_VOLATILE
+	      && XINT (SET_SRC (pat), 1) == UNSPECV_LDGP1)
+	    emit_insn_after (gen_unop (), insn);
+	}
+    }
+}
 
 /* Machine dependent reorg pass.  */
 
 static void
 alpha_reorg (void)
 {
+  /* Workaround for a linker error that triggers when an
+     exception handler immediatelly follows a noreturn function.
+
+     The instruction stream from an object file:
+
+  54:   00 40 5b 6b     jsr     ra,(t12),58 <__func+0x58>
+  58:   00 00 ba 27     ldah    gp,0(ra)
+  5c:   00 00 bd 23     lda     gp,0(gp)
+  60:   00 00 7d a7     ldq     t12,0(gp)
+  64:   00 40 5b 6b     jsr     ra,(t12),68 <__func+0x68>
+
+     was converted in the final link pass to:
+
+   fdb24:       a0 03 40 d3     bsr     ra,fe9a8 <_called_func+0x8>
+   fdb28:       00 00 fe 2f     unop
+   fdb2c:       00 00 fe 2f     unop
+   fdb30:       30 82 7d a7     ldq     t12,-32208(gp)
+   fdb34:       00 40 5b 6b     jsr     ra,(t12),fdb38 <__func+0x68>
+
+     GP load instructions were wrongly cleared by the linker relaxation
+     pass.  This workaround prevents removal of GP loads by inserting
+     an unop instruction between a noreturn function call and
+     exception handler prologue.  */
+
+  if (current_function_has_exception_handlers ())
+    alpha_pad_noreturn ();
+
   if (alpha_tp != ALPHA_TP_PROG || flag_exceptions)
     alpha_handle_trap_shadows ();
 
Index: gcc/config/spu/spu.c
===================================================================
--- gcc/config/spu/spu.c	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/config/spu/spu.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -142,6 +142,7 @@
 static bool spu_vector_alignment_reachable (const_tree, bool);
 static int spu_sms_res_mii (struct ddg *g);
 static void asm_file_start (void);
+static unsigned int spu_section_type_flags (tree, const char *, int);
 
 extern const char *reg_names[];
 rtx spu_compare_op0, spu_compare_op1;
@@ -325,6 +326,9 @@
 #undef TARGET_ASM_FILE_START
 #define TARGET_ASM_FILE_START asm_file_start
 
+#undef TARGET_SECTION_TYPE_FLAGS
+#define TARGET_SECTION_TYPE_FLAGS spu_section_type_flags
+
 struct gcc_target targetm = TARGET_INITIALIZER;
 
 void
@@ -6220,3 +6224,13 @@
   default_file_start ();
 }
 
+/* Implement targetm.section_type_flags.  */
+static unsigned int
+spu_section_type_flags (tree decl, const char *name, int reloc)
+{
+  /* .toe needs to have type @nobits.  */
+  if (strcmp (name, ".toe") == 0)
+    return SECTION_BSS;
+  return default_section_type_flags (decl, name, reloc);
+}
+
Index: gcc/config/sparc/linux.h
===================================================================
--- gcc/config/sparc/linux.h	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/config/sparc/linux.h	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -148,10 +148,6 @@
   "%{V} %{v:%{!V:-V}} %{!Qn:-Qy} %{n} %{T} %{Ym,*} %{Wa,*:%*} -s \
    %{fpic|fPIC|fpie|fPIE:-K PIC} %(asm_cpu) %(asm_relax)"
 
-/* Same as sparc.h */
-#undef DBX_REGISTER_NUMBER
-#define DBX_REGISTER_NUMBER(REGNO) (REGNO)
-
 #undef ASM_OUTPUT_ALIGNED_LOCAL
 #define ASM_OUTPUT_ALIGNED_LOCAL(FILE, NAME, SIZE, ALIGN)		\
 do {									\
Index: gcc/config/sparc/linux64.h
===================================================================
--- gcc/config/sparc/linux64.h	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/config/sparc/linux64.h	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -285,10 +285,6 @@
 %{mlittle-endian:-EL} \
 %(asm_cpu) %(asm_arch) %(asm_relax)"
 
-/* Same as sparc.h */
-#undef DBX_REGISTER_NUMBER
-#define DBX_REGISTER_NUMBER(REGNO) (REGNO)
-
 #undef ASM_OUTPUT_ALIGNED_LOCAL
 #define ASM_OUTPUT_ALIGNED_LOCAL(FILE, NAME, SIZE, ALIGN)		\
 do {									\
Index: gcc/config/sparc/sysv4.h
===================================================================
--- gcc/config/sparc/sysv4.h	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/config/sparc/sysv4.h	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -93,22 +93,6 @@
 	fprintf (FILE, "\n");						\
   } while (0)
 
-/* Define how the SPARC registers should be numbered for Dwarf output.
-   The numbering provided here should be compatible with the native
-   svr4 SDB debugger in the SPARC/svr4 reference port.  The numbering
-   is as follows:
-
-   Assembly name	gcc internal regno	Dwarf regno
-   ----------------------------------------------------------
-   g0-g7		0-7			0-7
-   o0-o7		8-15			8-15
-   l0-l7		16-23			16-23
-   i0-i7		24-31			24-31
-   f0-f31		32-63			40-71
-*/
-
-#define DBX_REGISTER_NUMBER(REGNO) ((REGNO) < 32 ? (REGNO) : (REGNO) + 8)
-
 /* A set of symbol definitions for assembly pseudo-ops which will
    get us switched to various sections of interest.  These are used
    in all places where we simply want to switch to a section, and
Index: gcc/config/i386/i386.md
===================================================================
--- gcc/config/i386/i386.md	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/config/i386/i386.md	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -67,12 +67,13 @@
    (UNSPEC_DEF_CFA		15)
    (UNSPEC_SET_RIP		16)
    (UNSPEC_SET_GOT_OFFSET	17)
+   (UNSPEC_MEMORY_BLOCKAGE	18)
 
    ; TLS support
-   (UNSPEC_TP			18)
-   (UNSPEC_TLS_GD		19)
-   (UNSPEC_TLS_LD_BASE		20)
-   (UNSPEC_TLSDESC		21)
+   (UNSPEC_TP			20)
+   (UNSPEC_TLS_GD		21)
+   (UNSPEC_TLS_LD_BASE		22)
+   (UNSPEC_TLSDESC		23)
 
    ; Other random patterns
    (UNSPEC_SCAS			30)
@@ -144,6 +145,7 @@
    (UNSPEC_FPREM1_U		91)
 
    (UNSPEC_C2_FLAG		95)
+   (UNSPEC_FXAM_MEM		96)
 
    ; SSP patterns
    (UNSPEC_SP_SET		100)
@@ -1397,7 +1399,7 @@
 	  gcc_unreachable ();
 	}
 
-    case TYPE_MMXADD:
+    case TYPE_MMX:
       return "pxor\t%0, %0";
 
     case TYPE_MMXMOV:
@@ -1415,7 +1417,7 @@
 }
   [(set (attr "type")
      (cond [(eq_attr "alternative" "2")
-	      (const_string "mmxadd")
+	      (const_string "mmx")
 	    (eq_attr "alternative" "3,4,5")
 	      (const_string "mmxmov")
 	    (eq_attr "alternative" "6")
@@ -2231,7 +2233,7 @@
       return "movq\t{%1, %0|%0, %1}";
 
     case TYPE_SSELOG1:
-    case TYPE_MMXADD:
+    case TYPE_MMX:
       return "pxor\t%0, %0";
 
     case TYPE_MULTI:
@@ -2252,7 +2254,7 @@
 }
   [(set (attr "type")
      (cond [(eq_attr "alternative" "5")
-	      (const_string "mmxadd")
+	      (const_string "mmx")
 	    (eq_attr "alternative" "6,7,8,9,10")
 	      (const_string "mmxmov")
 	    (eq_attr "alternative" "11")
@@ -14877,6 +14879,24 @@
   ""
   [(set_attr "length" "0")])
 
+;; Do not schedule instructions accessing memory across this point.
+
+(define_expand "memory_blockage"
+  [(set (match_dup 0)
+	(unspec:BLK [(match_dup 0)] UNSPEC_MEMORY_BLOCKAGE))]
+  ""
+{
+  operands[0] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));
+  MEM_VOLATILE_P (operands[0]) = 1;
+})
+
+(define_insn "*memory_blockage"
+  [(set (match_operand:BLK 0 "" "")
+	(unspec:BLK [(match_dup 0)] UNSPEC_MEMORY_BLOCKAGE))]
+  ""
+  ""
+  [(set_attr "length" "0")])
+
 ;; As USE insns aren't meaningful after reload, this is used instead
 ;; to prevent deleting instructions setting registers for PIC code
 (define_insn "prologue_use"
@@ -15001,7 +15021,7 @@
 
 (define_insn "set_rip_rex64"
   [(set (match_operand:DI 0 "register_operand" "=r")
-	(unspec:DI [(match_operand:DI 1 "" "")] UNSPEC_SET_RIP))]
+	(unspec:DI [(label_ref (match_operand 1 "" ""))] UNSPEC_SET_RIP))]
   "TARGET_64BIT"
   "lea{q}\t{%l1(%%rip), %0|%0, %l1[rip]}"
   [(set_attr "type" "lea")
@@ -15009,7 +15029,9 @@
 
 (define_insn "set_got_offset_rex64"
   [(set (match_operand:DI 0 "register_operand" "=r")
-	(unspec:DI [(match_operand:DI 1 "" "")] UNSPEC_SET_GOT_OFFSET))]
+	(unspec:DI
+	  [(label_ref (match_operand 1 "" ""))]
+	  UNSPEC_SET_GOT_OFFSET))]
   "TARGET_64BIT"
   "movabs{q}\t{$_GLOBAL_OFFSET_TABLE_-%l1, %0|%0, OFFSET FLAT:_GLOBAL_OFFSET_TABLE_-%l1}"
   [(set_attr "type" "imov")
@@ -18472,9 +18494,56 @@
    (set_attr "unit" "i387")
    (set_attr "mode" "<MODE>")])
 
+(define_insn_and_split "fxam<mode>2_i387_with_temp"
+  [(set (match_operand:HI 0 "register_operand" "")
+	(unspec:HI
+	  [(match_operand:MODEF 1 "memory_operand" "")]
+	  UNSPEC_FXAM_MEM))]
+  "TARGET_USE_FANCY_MATH_387
+   && !(reload_completed || reload_in_progress)"
+  "#"
+  "&& 1"
+  [(set (match_dup 2)(match_dup 1))
+   (set (match_dup 0)
+	(unspec:HI [(match_dup 2)] UNSPEC_FXAM))]
+{
+  operands[2] = gen_reg_rtx (<MODE>mode);
+
+  MEM_VOLATILE_P (operands[1]) = 1;
+}
+  [(set_attr "type" "multi")
+   (set_attr "unit" "i387")
+   (set_attr "mode" "<MODE>")])
+
+(define_expand "isinfxf2"
+  [(use (match_operand:SI 0 "register_operand" ""))
+   (use (match_operand:XF 1 "register_operand" ""))]
+  "TARGET_USE_FANCY_MATH_387
+   && TARGET_C99_FUNCTIONS"
+{
+  rtx mask = GEN_INT (0x45);
+  rtx val = GEN_INT (0x05);
+
+  rtx cond;
+
+  rtx scratch = gen_reg_rtx (HImode);
+  rtx res = gen_reg_rtx (QImode);
+
+  emit_insn (gen_fxamxf2_i387 (scratch, operands[1]));
+
+  emit_insn (gen_andqi_ext_0 (scratch, scratch, mask));
+  emit_insn (gen_cmpqi_ext_3 (scratch, val));
+  cond = gen_rtx_fmt_ee (EQ, QImode,
+			 gen_rtx_REG (CCmode, FLAGS_REG),
+			 const0_rtx);
+  emit_insn (gen_rtx_SET (VOIDmode, res, cond));
+  emit_insn (gen_zero_extendqisi2 (operands[0], res));
+  DONE;
+})
+
 (define_expand "isinf<mode>2"
   [(use (match_operand:SI 0 "register_operand" ""))
-   (use (match_operand:X87MODEF 1 "register_operand" ""))]
+   (use (match_operand:MODEF 1 "nonimmediate_operand" ""))]
   "TARGET_USE_FANCY_MATH_387
    && TARGET_C99_FUNCTIONS
    && !(SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)"
@@ -18487,7 +18556,18 @@
   rtx scratch = gen_reg_rtx (HImode);
   rtx res = gen_reg_rtx (QImode);
 
-  emit_insn (gen_fxam<mode>2_i387 (scratch, operands[1]));
+  /* Remove excess precision by forcing value through memory. */
+  if (memory_operand (operands[1], VOIDmode))
+    emit_insn (gen_fxam<mode>2_i387_with_temp (scratch, operands[1]));
+  else
+    {
+      int slot = virtuals_instantiated ? SLOT_TEMP : SLOT_VIRTUAL;
+      rtx temp = assign_386_stack_local (<MODE>mode, slot);
+
+      emit_move_insn (temp, operands[1]);
+      emit_insn (gen_fxam<mode>2_i387_with_temp (scratch, temp));
+    }
+
   emit_insn (gen_andqi_ext_0 (scratch, scratch, mask));
   emit_insn (gen_cmpqi_ext_3 (scratch, val));
   cond = gen_rtx_fmt_ee (EQ, QImode,
Index: gcc/config/i386/i386.c
===================================================================
--- gcc/config/i386/i386.c	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/config/i386/i386.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -6483,15 +6483,22 @@
         insn = emit_insn (gen_set_got (pic_offset_table_rtx));
     }
 
-  /* Prevent function calls from being scheduled before the call to mcount.
-     In the pic_reg_used case, make sure that the got load isn't deleted.  */
-  if (current_function_profile)
-    {
-      if (pic_reg_used)
-	emit_insn (gen_prologue_use (pic_offset_table_rtx));
-      emit_insn (gen_blockage ());
-    }
+  /* In the pic_reg_used case, make sure that the got load isn't deleted
+     when mcount needs it.  Blockage to avoid call movement across mcount
+     call is emitted in generic code after the NOTE_INSN_PROLOGUE_END
+     note.  */
+  if (current_function_profile && pic_reg_used)
+    emit_insn (gen_prologue_use (pic_offset_table_rtx));
 
+  /* Prevent instructions from being scheduled into register save push
+     sequence when access to the redzone area is done through frame pointer.
+     The offset betweeh the frame pointer and the stack pointer is calculated
+     relative to the value of the stack pointer at the end of the function
+     prologue, and moving instructions that access redzone area via frame
+     pointer inside push sequence violates this assumption.  */
+  if (frame_pointer_needed && frame.red_zone_size)
+    emit_insn (gen_memory_blockage ());
+
   /* Emit cld instruction if stringops are used in the function.  */
   if (TARGET_CLD && ix86_current_function_needs_cld)
     emit_insn (gen_cld ());
@@ -6539,6 +6546,11 @@
 
   ix86_compute_frame_layout (&frame);
 
+  /* See the comment about red zone and frame
+     pointer usage in ix86_expand_prologue.  */
+  if (frame_pointer_needed && frame.red_zone_size)
+    emit_insn (gen_memory_blockage ()); 
+
   /* Calculate start of saved registers relative to ebp.  Special care
      must be taken for the normal return case of a function using
      eh_return: the eax and edx registers are marked as saved, but not
@@ -14773,6 +14785,22 @@
       destexp = gen_rtx_PLUS (Pmode, destptr, countreg);
       srcexp = gen_rtx_PLUS (Pmode, srcptr, countreg);
     }
+  if (CONST_INT_P (count))
+    {
+      count = GEN_INT (INTVAL (count)
+		       & ~((HOST_WIDE_INT) GET_MODE_SIZE (mode) - 1));
+      destmem = shallow_copy_rtx (destmem);
+      srcmem = shallow_copy_rtx (srcmem);
+      set_mem_size (destmem, count);
+      set_mem_size (srcmem, count);
+    }
+  else
+    {
+      if (MEM_SIZE (destmem))
+	set_mem_size (destmem, NULL_RTX);
+      if (MEM_SIZE (srcmem))
+	set_mem_size (srcmem, NULL_RTX);
+    }
   emit_insn (gen_rep_mov (destptr, destmem, srcptr, srcmem, countreg,
 			  destexp, srcexp));
 }
@@ -14781,8 +14809,8 @@
    Arguments have same meaning as for previous function */
 static void
 expand_setmem_via_rep_stos (rtx destmem, rtx destptr, rtx value,
-			    rtx count,
-			    enum machine_mode mode)
+			    rtx count, enum machine_mode mode,
+			    rtx orig_value)
 {
   rtx destexp;
   rtx countreg;
@@ -14799,6 +14827,15 @@
     }
   else
     destexp = gen_rtx_PLUS (Pmode, destptr, countreg);
+  if (orig_value == const0_rtx && CONST_INT_P (count))
+    {
+      count = GEN_INT (INTVAL (count)
+		       & ~((HOST_WIDE_INT) GET_MODE_SIZE (mode) - 1));
+      destmem = shallow_copy_rtx (destmem);
+      set_mem_size (destmem, count);
+    }
+  else if (MEM_SIZE (destmem))
+    set_mem_size (destmem, NULL_RTX);
   emit_insn (gen_rep_stos (destptr, countreg, destmem, value, destexp));
 }
 
@@ -15871,15 +15908,15 @@
       break;
     case rep_prefix_8_byte:
       expand_setmem_via_rep_stos (dst, destreg, promoted_val, count_exp,
-				  DImode);
+				  DImode, val_exp);
       break;
     case rep_prefix_4_byte:
       expand_setmem_via_rep_stos (dst, destreg, promoted_val, count_exp,
-				  SImode);
+				  SImode, val_exp);
       break;
     case rep_prefix_1_byte:
       expand_setmem_via_rep_stos (dst, destreg, promoted_val, count_exp,
-				  QImode);
+				  QImode, val_exp);
       break;
     }
   /* Adjust properly the offset of src and dest memory for aliasing.  */
Index: gcc/config/sh/predicates.md
===================================================================
--- gcc/config/sh/predicates.md	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/config/sh/predicates.md	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -1,5 +1,5 @@
 ;; Predicate definitions for Renesas / SuperH SH.
-;; Copyright (C) 2005, 2006, 2007 Free Software Foundation, Inc.
+;; Copyright (C) 2005, 2006, 2007, 2009 Free Software Foundation, Inc.
 ;;
 ;; This file is part of GCC.
 ;;
@@ -392,12 +392,6 @@
 	return 0;
     }
 
-  if ((mode == QImode || mode == HImode)
-      && (GET_CODE (op) == SUBREG
-	  && GET_CODE (XEXP (op, 0)) == REG
-	  && system_reg_operand (XEXP (op, 0), mode)))
-    return 0;
-
   if (TARGET_SHMEDIA
       && (GET_CODE (op) == PARALLEL || GET_CODE (op) == CONST_VECTOR)
       && sh_rep_vec (op, mode))
Index: gcc/config/ia64/ia64.c
===================================================================
--- gcc/config/ia64/ia64.c	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/config/ia64/ia64.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -4328,8 +4328,9 @@
     return false;
 
   /* We must always return with our current GP.  This means we can
-     only sibcall to functions defined in the current module.  */
-  return decl && (*targetm.binds_local_p) (decl);
+     only sibcall to functions defined in the current module unless
+     TARGET_CONST_GP is set to true.  */
+  return (decl && (*targetm.binds_local_p) (decl)) || TARGET_CONST_GP;
 }
 
 
Index: gcc/config/pa/fptr.c
===================================================================
--- gcc/config/pa/fptr.c	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/config/pa/fptr.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -6,7 +6,7 @@
 
 GCC is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free
-Software Foundation; either version 3, or (at your option) any later
+Software Foundation; either version 2, or (at your option) any later
 version.
 
 In addition to the permissions in the GNU General Public License, the
@@ -24,8 +24,9 @@
 for more details.
 
 You should have received a copy of the GNU General Public License
-along with GCC; see the file COPYING3.  If not see
-<http://www.gnu.org/licenses/>.  */
+along with GCC; see the file COPYING.  If not, write to the Free
+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301, USA.  */
 
 /* WARNING: The code is this function depends on internal and undocumented
    details of the GNU linker and dynamic loader as implemented for parisc
Index: gcc/config/pa/milli64.S
===================================================================
--- gcc/config/pa/milli64.S	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/config/pa/milli64.S	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -8,7 +8,7 @@
 
 GCC is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free
-Software Foundation; either version 3, or (at your option) any later
+Software Foundation; either version 2, or (at your option) any later
 version.
 
 In addition to the permissions in the GNU General Public License, the
@@ -26,8 +26,9 @@
 for more details.
 
 You should have received a copy of the GNU General Public License
-	along with GCC; see the file COPYING3.  If not see
-<http://www.gnu.org/licenses/>.  */
+along with GCC; see the file COPYING.  If not, write to the Free
+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301, USA.  */
 
 #ifdef pa64
         .level  2.0w
Index: gcc/config/mips/sde.h
===================================================================
--- gcc/config/mips/sde.h	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/config/mips/sde.h	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -56,7 +56,6 @@
 #undef SUBTARGET_ASM_SPEC
 #define SUBTARGET_ASM_SPEC "\
 %{!mips1:--trap} \
-%{fPIC|fpic|fPIE|fpie:%{!mips16*:-KPIC}} \
 %{mips16:-no-mips16}"
 
 #undef LINK_SPEC
Index: gcc/config/mips/mips.c
===================================================================
--- gcc/config/mips/mips.c	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/config/mips/mips.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -7080,7 +7080,7 @@
     case ABI_N32:
       return "abiN32";
     case ABI_64:
-      return "abiN64";
+      return "abi64";
     case ABI_EABI:
       return TARGET_64BIT ? "eabi64" : "eabi32";
     default:
Index: gcc/config/soft-fp/double.h
===================================================================
--- gcc/config/soft-fp/double.h	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/config/soft-fp/double.h	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -1,6 +1,7 @@
 /* Software floating-point emulation.
    Definitions for IEEE Double Precision
-   Copyright (C) 1997,1998,1999,2006,2007 Free Software Foundation, Inc.
+   Copyright (C) 1997, 1998, 1999, 2006, 2007, 2008, 2009
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Richard Henderson (rth@cygnus.com),
 		  Jakub Jelinek (jj@ultra.linux.cz),
@@ -203,13 +204,13 @@
 
 #define FP_UNPACK_SEMIRAW_D(X,val)	\
   do {					\
-    _FP_UNPACK_RAW_2(1,X,val);		\
+    _FP_UNPACK_RAW_1(D,X,val);		\
     _FP_UNPACK_SEMIRAW(D,1,X);		\
   } while (0)
 
 #define FP_UNPACK_SEMIRAW_DP(X,val)	\
   do {					\
-    _FP_UNPACK_RAW_2_P(1,X,val);	\
+    _FP_UNPACK_RAW_1_P(D,X,val);	\
     _FP_UNPACK_SEMIRAW(D,1,X);		\
   } while (0)
 
Index: gcc/stmt.c
===================================================================
--- gcc/stmt.c	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/stmt.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -1,6 +1,6 @@
 /* Expands front end tree to back end RTL for GCC
    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997,
-   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
+   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009
    Free Software Foundation, Inc.
 
 This file is part of GCC.
@@ -895,7 +895,7 @@
       else if (MEM_P (op))
 	op = validize_mem (op);
 
-      if (asm_operand_ok (op, constraint) <= 0)
+      if (asm_operand_ok (op, constraint, NULL) <= 0)
 	{
 	  if (allows_reg && TYPE_MODE (type) != BLKmode)
 	    op = force_reg (TYPE_MODE (type), op);
Index: gcc/convert.c
===================================================================
--- gcc/convert.c	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ gcc/convert.c	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -261,18 +261,22 @@
 	     tree arg1 = strip_float_extensions (TREE_OPERAND (expr, 1));
 
 	     if (FLOAT_TYPE_P (TREE_TYPE (arg0))
-		 && FLOAT_TYPE_P (TREE_TYPE (arg1)))
+		 && FLOAT_TYPE_P (TREE_TYPE (arg1))
+		 && DECIMAL_FLOAT_TYPE_P (itype) == DECIMAL_FLOAT_TYPE_P (type))
 	       {
 		  tree newtype = type;
 
 		  if (TYPE_MODE (TREE_TYPE (arg0)) == SDmode
-		      || TYPE_MODE (TREE_TYPE (arg1)) == SDmode)
+		      || TYPE_MODE (TREE_TYPE (arg1)) == SDmode
+		      || TYPE_MODE (type) == SDmode)
 		    newtype = dfloat32_type_node;
 		  if (TYPE_MODE (TREE_TYPE (arg0)) == DDmode
-		      || TYPE_MODE (TREE_TYPE (arg1)) == DDmode)
+		      || TYPE_MODE (TREE_TYPE (arg1)) == DDmode
+		      || TYPE_MODE (type) == DDmode)
 		    newtype = dfloat64_type_node;
 		  if (TYPE_MODE (TREE_TYPE (arg0)) == TDmode
-		      || TYPE_MODE (TREE_TYPE (arg1)) == TDmode)
+		      || TYPE_MODE (TREE_TYPE (arg1)) == TDmode
+		      || TYPE_MODE (type) == TDmode)
                     newtype = dfloat128_type_node;
 		  if (newtype == dfloat32_type_node
 		      || newtype == dfloat64_type_node
@@ -290,7 +294,32 @@
 		    newtype = TREE_TYPE (arg0);
 		  if (TYPE_PRECISION (TREE_TYPE (arg1)) > TYPE_PRECISION (newtype))
 		    newtype = TREE_TYPE (arg1);
-		  if (TYPE_PRECISION (newtype) < TYPE_PRECISION (itype))
+		  /* Sometimes this transformation is safe (cannot
+		     change results through affecting double rounding
+		     cases) and sometimes it is not.  If NEWTYPE is
+		     wider than TYPE, e.g. (float)((long double)double
+		     + (long double)double) converted to
+		     (float)(double + double), the transformation is
+		     unsafe regardless of the details of the types
+		     involved; double rounding can arise if the result
+		     of NEWTYPE arithmetic is a NEWTYPE value half way
+		     between two representable TYPE values but the
+		     exact value is sufficiently different (in the
+		     right direction) for this difference to be
+		     visible in ITYPE arithmetic.  If NEWTYPE is the
+		     same as TYPE, however, the transformation may be
+		     safe depending on the types involved: it is safe
+		     if the ITYPE has strictly more than twice as many
+		     mantissa bits as TYPE, can represent infinities
+		     and NaNs if the TYPE can, and has sufficient
+		     exponent range for the product or ratio of two
+		     values representable in the TYPE to be within the
+		     range of normal values of ITYPE.  */
+		  if (TYPE_PRECISION (newtype) < TYPE_PRECISION (itype)
+		      && (flag_unsafe_math_optimizations
+			  || (TYPE_PRECISION (newtype) == TYPE_PRECISION (type)
+			      && real_can_shorten_arithmetic (TYPE_MODE (itype),
+							      TYPE_MODE (type)))))
 		    {
 		      expr = build2 (TREE_CODE (expr), newtype,
 				     fold (convert_to_real (newtype, arg0)),
Index: libstdc++-v3/scripts/extract_symvers
===================================================================
--- libstdc++-v3/scripts/extract_symvers	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ libstdc++-v3/scripts/extract_symvers	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -1,6 +1,6 @@
 #!/bin/sh
 
-# Copyright (C) 2002, 2003 Free Software Foundation, Inc.
+# Copyright (C) 2002, 2003, 2009 Free Software Foundation, Inc.
 #
 # This file is part of the GNU ISO C++ Library.  This library is free
 # software; you can redistribute it and/or modify it under the
@@ -52,7 +52,9 @@
 
 tmp=extract.$$
 
-${readelf} ${lib} | sed '/\.dynsym/,/^$/p;d' | egrep -v ' (LOCAL|UND) ' |\
+${readelf} ${lib} |\
+sed -e 's/ \[<other>: [A-Fa-f0-9]*\] //' -e '/\.dynsym/,/^$/p;d' |\
+egrep -v ' (LOCAL|UND) ' |\
 awk '{ if ($4 == "FUNC" || $4 == "NOTYPE")
          printf "%s:%s\n", $4, $8;
        else if ($4 == "OBJECT")
Index: libstdc++-v3/include/parallel/iterator.h
===================================================================
--- libstdc++-v3/include/parallel/iterator.h	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ libstdc++-v3/include/parallel/iterator.h	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -131,7 +131,8 @@
     public:
       typedef IteratorCategory iterator_category;
       typedef void value_type;
-      typedef typename Iterator1::difference_type difference_type;
+      typedef typename std::iterator_traits<Iterator1>::difference_type
+                                                            difference_type;
       typedef type* pointer;
       typedef type& reference;
 
Index: libstdc++-v3/include/parallel/par_loop.h
===================================================================
--- libstdc++-v3/include/parallel/par_loop.h	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ libstdc++-v3/include/parallel/par_loop.h	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -42,6 +42,7 @@
 #include <omp.h>
 #include <parallel/settings.h>
 #include <parallel/base.h>
+#include <parallel/equally_split.h>
 
 namespace __gnu_parallel
 {
@@ -80,9 +81,9 @@
   {
     typedef std::iterator_traits<RandomAccessIterator> traits_type;
     typedef typename traits_type::difference_type difference_type;
-
     const difference_type length = end - begin;
     Result *thread_results;
+    bool* constructed;
 
     thread_index_t num_threads =
       __gnu_parallel::min<difference_type>(get_max_threads(), length);
@@ -92,13 +93,15 @@
 #       pragma omp single
           {
             num_threads = omp_get_num_threads();
-            thread_results = new Result[num_threads];
+            thread_results = static_cast<Result*>(
+                                ::operator new(num_threads * sizeof(Result)));
+            constructed = new bool[num_threads];
           }
 
         thread_index_t iam = omp_get_thread_num();
 
         // Neutral element.
-        Result reduct = Result();
+        Result* reduct = static_cast<Result*>(::operator new(sizeof(Result)));
 
         difference_type
             start = equally_split_point(length, num_threads, iam),
@@ -106,23 +109,30 @@
 
         if (start < stop)
           {
-            reduct = f(o, begin + start);
+            new(reduct) Result(f(o, begin + start));
             ++start;
+            constructed[iam] = true;
           }
+        else
+          constructed[iam] = false;
 
         for (; start < stop; ++start)
-          reduct = r(reduct, f(o, begin + start));
+          *reduct = r(*reduct, f(o, begin + start));
 
-        thread_results[iam] = reduct;
+        thread_results[iam] = *reduct;
       } //parallel
 
     for (thread_index_t i = 0; i < num_threads; ++i)
-      output = r(output, thread_results[i]);
+        if (constructed[i])
+            output = r(output, thread_results[i]);
 
     // Points to last element processed (needed as return value for
     // some algorithms like transform).
     f.finish_iterator = begin + length;
 
+    delete[] thread_results;
+    delete[] constructed;
+
     return o;
   }
 
Index: libstdc++-v3/include/parallel/numeric
===================================================================
--- libstdc++-v3/include/parallel/numeric	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ libstdc++-v3/include/parallel/numeric	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -103,13 +103,13 @@
 	  __gnu_parallel::accumulate_selector<_RandomAccessIterator>
 	    my_selector;
 	  __gnu_parallel::
-	    for_each_template_random_access(begin, end,
+	    for_each_template_random_access_ed(begin, end,
 					    __gnu_parallel::nothing(),
 					    my_selector,
 					    __gnu_parallel::
 					    accumulate_binop_reduct
 					    <BinaryOperation>(binary_op),
-					    res, res, -1, parallelism_tag);
+					    res, res, -1);
 	  return res;
 	}
       else
@@ -211,9 +211,9 @@
 	    inner_product_selector<RandomAccessIterator1,
 	    RandomAccessIterator2, T> my_selector(first1, first2);
 	  __gnu_parallel::
-	    for_each_template_random_access(first1, last1, binary_op2,
+	    for_each_template_random_access_ed(first1, last1, binary_op2,
 					    my_selector, binary_op1,
-					    res, res, -1, parallelism_tag);
+					    res, res, -1);
 	  return res;
 	}
       else
@@ -432,10 +432,10 @@
 	    end_pair(end, result + (end - begin));
 	  __gnu_parallel::adjacent_difference_selector<ip> functionality;
 	  __gnu_parallel::
-	    for_each_template_random_access(begin_pair, end_pair, bin_op,
+	    for_each_template_random_access_ed(begin_pair, end_pair, bin_op,
 					    functionality,
 					    __gnu_parallel::dummy_reduct(),
-					    dummy, dummy, -1, parallelism_tag);
+					    dummy, dummy, -1);
 	  return functionality.finish_iterator;
 	}
       else
Index: libstdc++-v3/include/parallel/algorithmfwd.h
===================================================================
--- libstdc++-v3/include/parallel/algorithmfwd.h	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ libstdc++-v3/include/parallel/algorithmfwd.h	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -99,7 +99,8 @@
   template<typename _RAIter, typename _Tp>
     typename iterator_traits<_RAIter>::difference_type
     count_switch(_RAIter, _RAIter, const _Tp&, random_access_iterator_tag,
-		 __gnu_parallel::_Parallelism);
+		 __gnu_parallel::_Parallelism parallelism
+		 = __gnu_parallel::parallel_unbalanced);
 
 
   template<typename _IIter, typename _Predicate>
@@ -121,7 +122,8 @@
   template<typename _RAIter, typename _Predicate>
     typename iterator_traits<_RAIter>::difference_type
     count_if_switch(_RAIter, _RAIter, _Predicate, random_access_iterator_tag,
-		    __gnu_parallel::_Parallelism);
+		    __gnu_parallel::_Parallelism parallelism
+		    = __gnu_parallel::parallel_unbalanced);
 
   // algobase.h
   template<typename _IIter1, typename _IIter2>
@@ -228,7 +230,8 @@
   template<typename _RAIter, typename _Function>
     _Function
     for_each_switch(_RAIter, _RAIter, _Function, random_access_iterator_tag, 
-		    __gnu_parallel::_Parallelism);
+		    __gnu_parallel::_Parallelism  parallelism
+		    = __gnu_parallel::parallel_balanced);
 
 
   template<typename _FIter, typename _Generator>
@@ -250,7 +253,8 @@
   template<typename _RAIter, typename _Generator>
     void
     generate_switch(_RAIter, _RAIter, _Generator, random_access_iterator_tag, 
-		    __gnu_parallel::_Parallelism);
+		    __gnu_parallel::_Parallelism parallelism
+		    = __gnu_parallel::parallel_balanced);
 
   template<typename _OIter, typename _Size, typename _Generator>
     _OIter
@@ -272,7 +276,8 @@
   template<typename _RAIter, typename _Size, typename _Generator>
     _RAIter
     generate_n_switch(_RAIter, _Size, _Generator, random_access_iterator_tag, 
-		      __gnu_parallel::_Parallelism);
+		      __gnu_parallel::_Parallelism parallelism
+		      = __gnu_parallel::parallel_balanced);
 
   template<typename _IIter1, typename _IIter2>
     bool
@@ -429,7 +434,8 @@
     _RAOIter
     transform1_switch(_RAIIter, _RAIIter, _RAOIter, UnaryOperation, 
 		      random_access_iterator_tag, random_access_iterator_tag, 
-		      __gnu_parallel::_Parallelism);
+		      __gnu_parallel::_Parallelism parallelism
+		      = __gnu_parallel::parallel_balanced);
 
 
   template<typename _IIter1, typename _IIter2, typename _OIter,
@@ -455,7 +461,8 @@
     transform2_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter3, _BiOperation, 
 		      random_access_iterator_tag, random_access_iterator_tag, 
 		      random_access_iterator_tag,
-		      __gnu_parallel::_Parallelism);
+		      __gnu_parallel::_Parallelism parallelism
+		      = __gnu_parallel::parallel_balanced);
 
   template<typename _IIter1, typename _IIter2, typename _OIter,
 	   typename _BiOperation, typename _Tag1,
@@ -546,7 +553,8 @@
   template<typename _RAIter, typename _Compare>
     _RAIter
     max_element_switch(_RAIter, _RAIter, _Compare, random_access_iterator_tag, 
-		       __gnu_parallel::_Parallelism);
+		       __gnu_parallel::_Parallelism parallelism
+		       = __gnu_parallel::parallel_balanced);
 
 
   template<typename _IIter1, typename _IIter2, typename _OIter>
@@ -615,7 +623,8 @@
   template<typename _RAIter, typename _Compare>
     _RAIter
     min_element_switch(_RAIter, _RAIter, _Compare, random_access_iterator_tag, 
-		       __gnu_parallel::_Parallelism);
+		       __gnu_parallel::_Parallelism parallelism
+		       = __gnu_parallel::parallel_balanced);
 
   template<typename _RAIter>
     void
Index: libstdc++-v3/include/parallel/numericfwd.h
===================================================================
--- libstdc++-v3/include/parallel/numericfwd.h	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ libstdc++-v3/include/parallel/numericfwd.h	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -83,7 +83,8 @@
     _Tp
     accumulate_switch(_RAIter, _RAIter, _Tp, _BinaryOper,
 		      random_access_iterator_tag,
-		      __gnu_parallel::_Parallelism);
+		      __gnu_parallel::_Parallelism parallelism
+		      = __gnu_parallel::parallel_unbalanced);
 
   template<typename _IIter, typename _OIter>
     _OIter
@@ -124,7 +125,8 @@
     adjacent_difference_switch(_IIter, _IIter, _OIter, _BinaryOper, 
 			       random_access_iterator_tag, 
 			       random_access_iterator_tag, 
-			       __gnu_parallel::_Parallelism);
+			       __gnu_parallel::_Parallelism parallelism
+			       = __gnu_parallel::parallel_unbalanced);
 
   template<typename _IIter1, typename _IIter2, typename _Tp>
     _Tp
@@ -164,7 +166,8 @@
     inner_product_switch(_RAIter1, _RAIter1, _RAIter2, _Tp, BinaryFunction1, 
 			 BinaryFunction2, random_access_iterator_tag, 
 			 random_access_iterator_tag, 
-			 __gnu_parallel::_Parallelism);
+			 __gnu_parallel::_Parallelism
+			 = __gnu_parallel::parallel_unbalanced);
 
   template<typename _IIter1, typename _IIter2, typename _Tp,
 	   typename _BinaryFunction1, typename _BinaryFunction2,
Index: libstdc++-v3/ChangeLog
===================================================================
--- libstdc++-v3/ChangeLog	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ libstdc++-v3/ChangeLog	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -1,3 +1,28 @@
+2009-02-09  Johannes Singler  <singler@ira.uka.de>
+
+        Backport from mainline:
+        2009-02-03  Johannes Singler  <singler@ira.uka.de>
+
+        * include/parallel/algorithmfwd.h:
+        Add parallelism default for many declarations.
+        * include/parallel/numericfwd.h: Likewise.
+        * include/parallel/iterator.h: Use iterator_traits as usual.
+        * include/parallel/par_loop.h:
+        Include equally_split.h.
+        (for_each_template_random_access_ed):
+        Avoid calling the Result default constructor.
+        * include/parallel/numeric: Replace
+        for_each_template_random_access by
+        for_each_template_random_access_ed in numeric functions.
+
+2009-01-27  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline:
+	2009-01-13  Uros Bizjak  <ubizjak@gmail.com>
+
+	* scripts/extract_symvers: Add sed script to remove ' [<other>: xx] '
+	field from readelf output.
+
 2009-01-24  Release Manager
 
 	* GCC 4.3.3 released.
Index: Makefile.tpl
===================================================================
--- Makefile.tpl	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ Makefile.tpl	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -1432,6 +1432,8 @@
 # Provide a GCC build when we're building target libraries.  This does
 # not work as a dependency, just as the minimum necessary to avoid errors.
 stage_last:
+	@r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
 	$(MAKE) $(RECURSE_FLAGS_TO_PASS) stage1-bubble
 
 # Same as unstage, but not phony and defaulting to stage1-start.  We place
Index: ChangeLog
===================================================================
--- ChangeLog	(.../tags/gcc_4_3_3_release)	(wersja 144693)
+++ ChangeLog	(.../branches/gcc-4_3-branch)	(wersja 144693)
@@ -1,3 +1,9 @@
+2009-02-05  Andreas Schwab  <schwab@suse.de>
+
+	* Makefile.tpl (stage_last): Define $r and $s before using
+	$(RECURSE_FLAGS_TO_PASS).
+	* Makefile.in: Regenerate
+
 2009-01-24  Release Manager
 
 	* GCC 4.3.3 released.
@@ -241,7 +247,7 @@
 	* Makefile.def: Add libgomp config as a maybe dependency for libstdc++.
 	* configure: Regenerate.
 	* Makefile.in: Regenerate.
-	
+
 2007-09-17  Andreas Schwab  <schwab@suse.de>
 
 	* configure.ac: Raise minimum makeinfo version to 4.6.
@@ -433,13 +439,13 @@
 	* configure.ac: Likewise.
 	* Makefile.in: Regenerate.
 	* configure: Regenerate.
-						
+
 2007-06-28  DJ Delorie  <dj@redhat.com>
 
 	* configure.ac (arm*-*-linux-gnueabi): Don't build libgloss if we're
 	not building newlib.
 	* configure: Regenerated.
-	
+
 2007-06-28  Jan Sjodin  <jan.sjodin@amd.com>
 
 	* MAINTAINERS (Write After Approval): Add myself.
@@ -618,7 +624,7 @@
 2007-04-04  Christian Bruel  <christian.bruel@st.com>
 
 	* MAINTAINERS (Write After Approval): Add myself.
-	
+
 2007-04-02  Dave Korn  <dave.korn@artimi.com>
 
 	* MAINTAINERS (Write After Approval): Add myself.
@@ -630,7 +636,7 @@
 2007-03-28  Dwarakanath Rajagopal  <dwarak.rajagopal@amd.com>
 
 	* MAINTAINERS (Write After Approval): Add myself.
-	
+
 2007-03-24  Ayal Zaks  <zaks@il.ibm.com>
 
 	* MAINTAINERS (Modulo Scheduler): Add myself.
