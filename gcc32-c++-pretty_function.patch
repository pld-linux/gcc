2002-05-24  Jakub Jelinek  <jakub@redhat.com>

	PR c++/6794
	* decl.c (cp_make_fname_decl): If outside of function, emit
	the variable immediately.
	* call.c (build_call): Avoid crashing when noreturn function
	is called outside of function context.

	* g++.dg/ext/pretty1.C: New test.
	* g++.dg/ext/pretty2.C: New test.

--- gcc/cp/decl.c.jj	Tue May 21 20:27:10 2002
+++ gcc/cp/decl.c	Fri May 24 17:28:16 2002
@@ -6772,7 +6772,10 @@ cp_make_fname_decl (id, type_dep)
   TREE_USED (decl) = 1;
 
   cp_finish_decl (decl, init, NULL_TREE, LOOKUP_ONLYCONVERTING);
-      
+
+  if (!current_function_decl)
+    rest_of_decl_compilation (decl, 0, 1, 0);
+
   return decl;
 }
 
--- gcc/cp/call.c.jj	Mon Apr 15 14:48:51 2002
+++ gcc/cp/call.c	Fri May 24 12:49:22 2002
@@ -408,7 +408,7 @@ build_call (function, parms)
   nothrow = ((decl && TREE_NOTHROW (decl))
 	     || TYPE_NOTHROW_P (TREE_TYPE (TREE_TYPE (function))));
 
-  if (decl && TREE_THIS_VOLATILE (decl))
+  if (decl && TREE_THIS_VOLATILE (decl) && current_function_decl)
     current_function_returns_abnormally = 1;
 
   if (decl && TREE_DEPRECATED (decl))
--- gcc/testsuite/g++.dg/ext/pretty1.C.jj	Fri May 24 18:09:27 2002
+++ gcc/testsuite/g++.dg/ext/pretty1.C	Fri May 24 18:13:10 2002
@@ -0,0 +1,67 @@
+// PR c++/6794
+// Test whether __PRETTY_FUNCTION__ works in templates, functions and
+// in initializers at global scope
+// { dg-do compile }
+// { dg-options "" }
+
+extern "C" void __assert_fail (const char *, const char *,
+			       unsigned int, const char *)
+  throw() __attribute__((noreturn));
+extern "C" void abort (void);
+extern "C" void exit (int);
+
+#define str(expr) #expr
+#define assert(expr)						\
+  ((expr) ? 0 : (__assert_fail (str(expr), __FILE__, __LINE__,	\
+				__PRETTY_FUNCTION__), 0))
+
+int __attribute__((noinline))
+foo (void)
+{
+  return 1;
+}
+
+template<class T> int
+bar (T)
+{
+  return (assert (foo ()), 1);
+}
+
+template<> int
+bar<int> (int)
+{
+  return (assert (foo ()), 2);
+}
+
+int a = (assert (foo ()), 1);
+int b = (assert (foo ()), 2);
+
+int
+main ()
+{
+  double c = 1.0;
+  unsigned char *d = 0;
+  int e = (assert (foo ()), 3);
+
+  bar (c);
+  bar (d);
+  bar (e);
+}
+
+namespace N
+{
+  int f = (assert (foo ()), 4);
+}
+
+void __attribute__((noinline))
+__assert_fail (const char *cond, const char *file, unsigned int line,
+	       const char *pretty) throw ()
+{
+  abort ();
+}
+
+// { dg-final { scan-assembler "int bar\\(T\\).*with T = int" } }
+// { dg-final { scan-assembler "top level" } }
+// { dg-final { scan-assembler "int main\\(\\)" } }
+// { dg-final { scan-assembler "int bar\\(T\\).*with T = double" } }
+// { dg-final { scan-assembler "int bar\\(T\\).*with T = unsigned char\*" } }
--- gcc/testsuite/g++.dg/ext/pretty2.C.jj	Fri May 24 18:09:27 2002
+++ gcc/testsuite/g++.dg/ext/pretty2.C	Fri May 24 18:13:42 2002
@@ -0,0 +1,61 @@
+// PR c++/6794
+// Test whether __PRETTY_FUNCTION__ works in templates, functions and
+// in initializers at global scope
+// { dg-do run }
+// { dg-options "" }
+
+extern "C" void __assert_fail (const char *, const char *,
+			       unsigned int, const char *)
+  throw() __attribute__((noreturn));
+extern "C" void abort (void);
+extern "C" void exit (int);
+
+#define str(expr) #expr
+#define assert(expr)						\
+  ((expr) ? 0 : (__assert_fail (str(expr), __FILE__, __LINE__,	\
+				__PRETTY_FUNCTION__), 0))
+
+int __attribute__((noinline))
+foo (void)
+{
+  return 1;
+}
+
+template<class T> int
+bar (T)
+{
+  return (assert (foo ()), 1);
+}
+
+template<> int
+bar<int> (int)
+{
+  return (assert (foo ()), 2);
+}
+
+int a = (assert (foo ()), 1);
+int b = (assert (foo ()), 2);
+
+int
+main ()
+{
+  double c = 1.0;
+  unsigned char *d = 0;
+  int e = (assert (foo ()), 3);
+
+  bar (c);
+  bar (d);
+  bar (e);
+}
+
+namespace N
+{
+  int f = (assert (foo ()), 4);
+}
+
+void __attribute__((noinline))
+__assert_fail (const char *cond, const char *file, unsigned int line,
+	       const char *pretty) throw ()
+{
+  abort ();
+}
