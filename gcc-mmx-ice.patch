        * config/i386/i386.c (ix86_register_move_cost): Increase cost
        for secondary_memory_needed pairs.

Index: i386.c
===================================================================
RCS file: /cvs/gcc/gcc/gcc/config/i386/i386.c,v
retrieving revision 1.463
diff -c -p -d -r1.463 i386.c
*** gcc/gcc/config/i386/i386.c	2 Oct 2002 15:02:50 -0000	1.463
--- gcc/gcc/config/i386/i386.c	2 Oct 2002 18:22:47 -0000
*************** ix86_register_move_cost (mode, class1, c
*** 13580,13596 ****
       enum reg_class class1, class2;
  {
    /* In case we require secondary memory, compute cost of the store followed
!      by load.  In case of copying from general_purpose_register we may emit
!      multiple stores followed by single load causing memory size mismatch
!      stall.  Count this as arbitarily high cost of 20.  */
    if (ix86_secondary_memory_needed (class1, class2, mode, 0))
      {
!       int add_cost = 0;
        if (CLASS_MAX_NREGS (class1, mode) > CLASS_MAX_NREGS (class2, mode))
! 	  add_cost = 20;
!       return (MEMORY_MOVE_COST (mode, class1, 0)
! 	      + MEMORY_MOVE_COST (mode, class2, 1) + add_cost);
      }
    /* Moves between SSE/MMX and integer unit are expensive.  */
    if (MMX_CLASS_P (class1) != MMX_CLASS_P (class2)
        || SSE_CLASS_P (class1) != SSE_CLASS_P (class2))
--- 13580,13612 ----
       enum reg_class class1, class2;
  {
    /* In case we require secondary memory, compute cost of the store followed
!      by load.  In order to avoid bad register allocation choices, we need 
!      for this to be *at least* as high as the symmetric MEMORY_MOVE_COST.  */
! 
    if (ix86_secondary_memory_needed (class1, class2, mode, 0))
      {
!       int cost = 1;
! 
!       cost += MAX (MEMORY_MOVE_COST (mode, class1, 0),
! 		   MEMORY_MOVE_COST (mode, class1, 1));
!       cost += MAX (MEMORY_MOVE_COST (mode, class2, 0),
! 		   MEMORY_MOVE_COST (mode, class2, 1));
!       
!       /* In case of copying from general_purpose_register we may emit multiple
!          stores followed by single load causing memory size mismatch stall.
!          Count this as arbitarily high cost of 20.  */
        if (CLASS_MAX_NREGS (class1, mode) > CLASS_MAX_NREGS (class2, mode))
! 	cost += 20;
! 
!       /* In the case of FP/MMX moves, the registers actually overlap, and we
! 	 have to switch modes in order to treat them differently.  */
!       if ((MMX_CLASS_P (class1) && MAYBE_FLOAT_CLASS_P (class2))
!           || (MMX_CLASS_P (class2) && MAYBE_FLOAT_CLASS_P (class1)))
! 	cost += 20;
! 
!       return cost;
      }
+ 
    /* Moves between SSE/MMX and integer unit are expensive.  */
    if (MMX_CLASS_P (class1) != MMX_CLASS_P (class2)
        || SSE_CLASS_P (class1) != SSE_CLASS_P (class2))


