2005-07-30  James A. Morrison  <phython@gcc.gnu.org>

	PR tree-optimization/23128
	PR tree-optimization/23129
	* tree-vrp.c (vrp_int_const_binop): Treat unsigned types like
	flag_wrapv.
	(extract_range_from_binary_expr): Set value range to varying for
	divisions with anti-ranges.  Set value range to varying for unsigned
	addition and subtraction if it could wrap.
	(compare_ranges): Return false for EQ_EXPR if VR0 is less than VR1 or
	vice-versa.

--- gcc/gcc/tree-vrp.c	29 Jul 2005 15:21:54 -0000	2.47
+++ gcc/gcc/tree-vrp.c	30 Jul 2005 18:10:26 -0000
@@ -908,7 +908,7 @@ vrp_int_const_binop (enum tree_code code
 {
   tree res;
 
-  if (flag_wrapv)
+  if (flag_wrapv || TYPE_UNSIGNED (TREE_TYPE (val1)))
     return int_const_binop (code, val1, val2, 0);
 
   /* If we are not using wrapping arithmetic, operate symbolically
@@ -1095,6 +1095,22 @@ extract_range_from_binary_expr (value_ra
 	 the same end of each range.  */
       min = vrp_int_const_binop (code, vr0.min, vr1.min);
       max = vrp_int_const_binop (code, vr0.max, vr1.max);
+
+      /* Check for possible unsigned wrapping.  */
+      if (code == PLUS_EXPR && TYPE_UNSIGNED (TREE_TYPE (expr)))
+	{
+	  tree res0 = fold_binary_to_constant (GT_EXPR, TREE_TYPE (expr),
+					       vr0.max, max);
+	  tree res1 = fold_binary_to_constant (GT_EXPR, TREE_TYPE (expr),
+					       vr1.max, max);
+
+	  if ((res0 && integer_onep (res0))
+	      || (res1 && integer_onep (res1)))
+	    {
+	      set_value_range_to_varying (vr);
+	      return;
+	    }
+	}
     }
   else if (code == MULT_EXPR
 	   || code == TRUNC_DIV_EXPR
@@ -1136,7 +1152,8 @@ extract_range_from_binary_expr (value_ra
 	 the new range.  */
 
       /* Divisions by zero result in a VARYING value.  */
-      if (code != MULT_EXPR && range_includes_zero_p (&vr1))
+      if (code != MULT_EXPR
+	  && (vr0.type == VR_ANTI_RANGE || range_includes_zero_p (&vr1)))
 	{
 	  set_value_range_to_varying (vr);
 	  return;
@@ -1204,6 +1221,22 @@ extract_range_from_binary_expr (value_ra
 	 each range.  */
       min = vrp_int_const_binop (code, vr0.min, vr1.max);
       max = vrp_int_const_binop (code, vr0.max, vr1.min);
+
+      /* Check for possible unsigned wrapping.  */
+      if (TYPE_UNSIGNED (TREE_TYPE (expr)))
+	{
+	  tree res0 = fold_binary_to_constant (LT_EXPR, TREE_TYPE (expr),
+					       vr0.min, min);
+	  tree res1 = fold_binary_to_constant (GT_EXPR, TREE_TYPE (expr),
+					       vr1.max, max);
+
+	  if ((res0 && integer_onep (res0))
+	      || (res1 && integer_onep (res1)))
+	    {
+	      set_value_range_to_varying (vr);
+	      return;
+	    }
+	}
     }
   else
     gcc_unreachable ();
@@ -1677,6 +1710,10 @@ compare_ranges (enum tree_code comp, val
 	  else if (cmp_min != -2 && cmp_max != -2)
 	    return boolean_false_node;
 	}
+      /* If [V0_MIN, V1_MAX] < [V1_MIN, V1_MAX] then V0 != V1.  */
+      else if (compare_values (vr0->min, vr1->max) == 1
+	       || compare_values (vr1->min, vr0->max) == 1)
+	return boolean_false_node;
 
       return NULL_TREE;
     }
