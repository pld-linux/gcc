--- gcc-3.4.0/obj-amd64-pld-linux/gcc/ada/sinfo.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.4.0/obj-amd64-pld-linux/gcc/ada/sinfo.h	2004-06-02 00:54:16.000000000 +0200
@@ -0,0 +1,847 @@
+/*--------------------------------------------------------------------------*/
+/*                                                                          */
+/*                         GNAT COMPILER COMPONENTS                         */
+/*                                                                          */
+/*                                S I N F O                                 */
+/*                                                                          */
+/*                              C Header File                               */
+/*                                                                          */
+/*          Copyright (C) 1992-2004, Free Software Foundation, Inc.         */
+/*                                                                          */
+/* GNAT is free software;  you can  redistribute it  and/or modify it under */
+/* terms of the  GNU General Public License as published  by the Free Soft- */
+/* ware  Foundation;  either version 2,  or (at your option) any later ver- */
+/* sion.  GNAT is distributed in the hope that it will be useful, but WITH- */
+/* OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY */
+/* or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License */
+/* for  more details.  You should have  received  a copy of the GNU General */
+/* Public License  distributed with GNAT;  see file COPYING.  If not, write */
+/* to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, */
+/* MA 02111-1307, USA.                                                      */
+/*                                                                          */
+/* As a special exception,  if other files  instantiate  generics from this */
+/* unit, or you link  this unit with other files  to produce an executable, */
+/* this  unit  does not  by itself cause  the resulting  executable  to  be */
+/* covered  by the  GNU  General  Public  License.  This exception does not */
+/* however invalidate  any other reasons why  the executable file  might be */
+/* covered by the  GNU Public License.                                      */
+/*                                                                          */
+/* GNAT was originally developed  by the GNAT team at  New York University. */
+/* Extensive contributions were provided by Ada Core Technologies Inc.      */
+/*                                                                          */
+/*--------------------------------------------------------------------------*/
+
+      #define N_Unused_At_Start 0
+      #define N_At_Clause 1
+      #define N_Component_Clause 2
+      #define N_Enumeration_Representation_Clause 3
+      #define N_Mod_Clause 4
+      #define N_Record_Representation_Clause 5
+      #define N_Attribute_Definition_Clause 6
+      #define N_Empty 7
+      #define N_Pragma 8
+      #define N_Pragma_Argument_Association 9
+      #define N_Error 10
+      #define N_Defining_Character_Literal 11
+      #define N_Defining_Identifier 12
+      #define N_Defining_Operator_Symbol 13
+      #define N_Expanded_Name 14
+      #define N_Identifier 15
+      #define N_Operator_Symbol 16
+      #define N_Character_Literal 17
+      #define N_Op_Add 18
+      #define N_Op_Concat 19
+      #define N_Op_Expon 20
+      #define N_Op_Subtract 21
+      #define N_Op_Divide 22
+      #define N_Op_Mod 23
+      #define N_Op_Multiply 24
+      #define N_Op_Rem 25
+      #define N_Op_And 26
+      #define N_Op_Eq 27
+      #define N_Op_Ge 28
+      #define N_Op_Gt 29
+      #define N_Op_Le 30
+      #define N_Op_Lt 31
+      #define N_Op_Ne 32
+      #define N_Op_Or 33
+      #define N_Op_Xor 34
+      #define N_Op_Rotate_Left 35
+      #define N_Op_Rotate_Right 36
+      #define N_Op_Shift_Left 37
+      #define N_Op_Shift_Right 38
+      #define N_Op_Shift_Right_Arithmetic 39
+      #define N_Op_Abs 40
+      #define N_Op_Minus 41
+      #define N_Op_Not 42
+      #define N_Op_Plus 43
+      #define N_Attribute_Reference 44
+      #define N_And_Then 45
+      #define N_Conditional_Expression 46
+      #define N_Explicit_Dereference 47
+      #define N_Function_Call 48
+      #define N_In 49
+      #define N_Indexed_Component 50
+      #define N_Integer_Literal 51
+      #define N_Not_In 52
+      #define N_Null 53
+      #define N_Or_Else 54
+      #define N_Procedure_Call_Statement 55
+      #define N_Qualified_Expression 56
+      #define N_Raise_Constraint_Error 57
+      #define N_Raise_Program_Error 58
+      #define N_Raise_Storage_Error 59
+      #define N_Aggregate 60
+      #define N_Allocator 61
+      #define N_Extension_Aggregate 62
+      #define N_Range 63
+      #define N_Real_Literal 64
+      #define N_Reference 65
+      #define N_Selected_Component 66
+      #define N_Slice 67
+      #define N_String_Literal 68
+      #define N_Subprogram_Info 69
+      #define N_Type_Conversion 70
+      #define N_Unchecked_Expression 71
+      #define N_Unchecked_Type_Conversion 72
+      #define N_Subtype_Indication 73
+      #define N_Component_Declaration 74
+      #define N_Entry_Declaration 75
+      #define N_Formal_Object_Declaration 76
+      #define N_Formal_Type_Declaration 77
+      #define N_Full_Type_Declaration 78
+      #define N_Incomplete_Type_Declaration 79
+      #define N_Loop_Parameter_Specification 80
+      #define N_Object_Declaration 81
+      #define N_Protected_Type_Declaration 82
+      #define N_Private_Extension_Declaration 83
+      #define N_Private_Type_Declaration 84
+      #define N_Subtype_Declaration 85
+      #define N_Function_Specification 86
+      #define N_Procedure_Specification 87
+      #define N_Entry_Index_Specification 88
+      #define N_Freeze_Entity 89
+      #define N_Access_Function_Definition 90
+      #define N_Access_Procedure_Definition 91
+      #define N_Task_Type_Declaration 92
+      #define N_Package_Body_Stub 93
+      #define N_Protected_Body_Stub 94
+      #define N_Subprogram_Body_Stub 95
+      #define N_Task_Body_Stub 96
+      #define N_Function_Instantiation 97
+      #define N_Package_Instantiation 98
+      #define N_Procedure_Instantiation 99
+      #define N_Package_Body 100
+      #define N_Subprogram_Body 101
+      #define N_Protected_Body 102
+      #define N_Task_Body 103
+      #define N_Implicit_Label_Declaration 104
+      #define N_Package_Declaration 105
+      #define N_Single_Task_Declaration 106
+      #define N_Subprogram_Declaration 107
+      #define N_Use_Package_Clause 108
+      #define N_Generic_Package_Declaration 109
+      #define N_Generic_Subprogram_Declaration 110
+      #define N_Constrained_Array_Definition 111
+      #define N_Unconstrained_Array_Definition 112
+      #define N_Exception_Renaming_Declaration 113
+      #define N_Object_Renaming_Declaration 114
+      #define N_Package_Renaming_Declaration 115
+      #define N_Subprogram_Renaming_Declaration 116
+      #define N_Generic_Function_Renaming_Declaration 117
+      #define N_Generic_Package_Renaming_Declaration 118
+      #define N_Generic_Procedure_Renaming_Declaration 119
+      #define N_Abort_Statement 120
+      #define N_Accept_Statement 121
+      #define N_Assignment_Statement 122
+      #define N_Asynchronous_Select 123
+      #define N_Block_Statement 124
+      #define N_Case_Statement 125
+      #define N_Code_Statement 126
+      #define N_Conditional_Entry_Call 127
+      #define N_Delay_Relative_Statement 128
+      #define N_Delay_Until_Statement 129
+      #define N_Entry_Call_Statement 130
+      #define N_Free_Statement 131
+      #define N_Goto_Statement 132
+      #define N_Loop_Statement 133
+      #define N_Null_Statement 134
+      #define N_Raise_Statement 135
+      #define N_Requeue_Statement 136
+      #define N_Return_Statement 137
+      #define N_Selective_Accept 138
+      #define N_Timed_Entry_Call 139
+      #define N_Exit_Statement 140
+      #define N_If_Statement 141
+      #define N_Accept_Alternative 142
+      #define N_Delay_Alternative 143
+      #define N_Elsif_Part 144
+      #define N_Entry_Body_Formal_Part 145
+      #define N_Iteration_Scheme 146
+      #define N_Terminate_Alternative 147
+      #define N_Abortable_Part 148
+      #define N_Abstract_Subprogram_Declaration 149
+      #define N_Access_Definition 150
+      #define N_Access_To_Object_Definition 151
+      #define N_Case_Statement_Alternative 152
+      #define N_Compilation_Unit 153
+      #define N_Compilation_Unit_Aux 154
+      #define N_Component_Association 155
+      #define N_Component_Definition 156
+      #define N_Component_List 157
+      #define N_Derived_Type_Definition 158
+      #define N_Decimal_Fixed_Point_Definition 159
+      #define N_Defining_Program_Unit_Name 160
+      #define N_Delta_Constraint 161
+      #define N_Designator 162
+      #define N_Digits_Constraint 163
+      #define N_Discriminant_Association 164
+      #define N_Discriminant_Specification 165
+      #define N_Enumeration_Type_Definition 166
+      #define N_Entry_Body 167
+      #define N_Entry_Call_Alternative 168
+      #define N_Exception_Declaration 169
+      #define N_Exception_Handler 170
+      #define N_Floating_Point_Definition 171
+      #define N_Formal_Decimal_Fixed_Point_Definition 172
+      #define N_Formal_Derived_Type_Definition 173
+      #define N_Formal_Discrete_Type_Definition 174
+      #define N_Formal_Floating_Point_Definition 175
+      #define N_Formal_Modular_Type_Definition 176
+      #define N_Formal_Ordinary_Fixed_Point_Definition 177
+      #define N_Formal_Package_Declaration 178
+      #define N_Formal_Private_Type_Definition 179
+      #define N_Formal_Signed_Integer_Type_Definition 180
+      #define N_Formal_Subprogram_Declaration 181
+      #define N_Generic_Association 182
+      #define N_Handled_Sequence_Of_Statements 183
+      #define N_Index_Or_Discriminant_Constraint 184
+      #define N_Itype_Reference 185
+      #define N_Label 186
+      #define N_Modular_Type_Definition 187
+      #define N_Number_Declaration 188
+      #define N_Ordinary_Fixed_Point_Definition 189
+      #define N_Others_Choice 190
+      #define N_Package_Specification 191
+      #define N_Parameter_Association 192
+      #define N_Parameter_Specification 193
+      #define N_Protected_Definition 194
+      #define N_Range_Constraint 195
+      #define N_Real_Range_Specification 196
+      #define N_Record_Definition 197
+      #define N_Signed_Integer_Type_Definition 198
+      #define N_Single_Protected_Declaration 199
+      #define N_Subunit 200
+      #define N_Task_Definition 201
+      #define N_Triggering_Alternative 202
+      #define N_Use_Type_Clause 203
+      #define N_Validate_Unchecked_Conversion 204
+      #define N_Variant 205
+      #define N_Variant_Part 206
+      #define N_With_Clause 207
+      #define N_With_Type_Clause 208
+      #define N_Unused_At_End 209
+
+      #define Number_Node_Kinds 210
+   SUBTYPE (N_Access_To_Subprogram_Definition, Node_Kind, 
+      N_Access_Function_Definition,
+      N_Access_Procedure_Definition)
+   SUBTYPE (N_Array_Type_Definition, Node_Kind, 
+      N_Constrained_Array_Definition,
+      N_Unconstrained_Array_Definition)
+   SUBTYPE (N_Binary_Op, Node_Kind, 
+      N_Op_Add,
+      N_Op_Shift_Right_Arithmetic)
+   SUBTYPE (N_Body_Stub, Node_Kind, 
+      N_Package_Body_Stub,
+      N_Task_Body_Stub)
+   SUBTYPE (N_Declaration, Node_Kind, 
+      N_Component_Declaration,
+      N_Procedure_Specification)
+   SUBTYPE (N_Direct_Name, Node_Kind, 
+      N_Identifier,
+      N_Character_Literal)
+   SUBTYPE (N_Entity, Node_Kind, 
+      N_Defining_Character_Literal,
+      N_Defining_Operator_Symbol)
+   SUBTYPE (N_Generic_Declaration, Node_Kind, 
+      N_Generic_Package_Declaration,
+      N_Generic_Subprogram_Declaration)
+   SUBTYPE (N_Generic_Instantiation, Node_Kind, 
+      N_Function_Instantiation,
+      N_Procedure_Instantiation)
+   SUBTYPE (N_Generic_Renaming_Declaration, Node_Kind, 
+      N_Generic_Function_Renaming_Declaration,
+      N_Generic_Procedure_Renaming_Declaration)
+   SUBTYPE (N_Has_Chars, Node_Kind, 
+      N_Attribute_Definition_Clause,
+      N_Op_Plus)
+   SUBTYPE (N_Has_Entity, Node_Kind, 
+      N_Expanded_Name,
+      N_Attribute_Reference)
+   SUBTYPE (N_Has_Etype, Node_Kind, 
+      N_Error,
+      N_Subtype_Indication)
+   SUBTYPE (N_Has_Treat_Fixed_As_Integer, Node_Kind, 
+      N_Op_Divide,
+      N_Op_Rem)
+   SUBTYPE (N_Later_Decl_Item, Node_Kind, 
+      N_Task_Type_Declaration,
+      N_Generic_Subprogram_Declaration)
+   SUBTYPE (N_Op, Node_Kind, 
+      N_Op_Add,
+      N_Op_Plus)
+   SUBTYPE (N_Op_Boolean, Node_Kind, 
+      N_Op_And,
+      N_Op_Xor)
+   SUBTYPE (N_Op_Compare, Node_Kind, 
+      N_Op_Eq,
+      N_Op_Ne)
+   SUBTYPE (N_Op_Shift, Node_Kind, 
+      N_Op_Rotate_Left,
+      N_Op_Shift_Right_Arithmetic)
+   SUBTYPE (N_Proper_Body, Node_Kind, 
+      N_Package_Body,
+      N_Task_Body)
+   SUBTYPE (N_Raise_xxx_Error, Node_Kind, 
+      N_Raise_Constraint_Error,
+      N_Raise_Storage_Error)
+   SUBTYPE (N_Renaming_Declaration, Node_Kind, 
+      N_Exception_Renaming_Declaration,
+      N_Generic_Procedure_Renaming_Declaration)
+   SUBTYPE (N_Representation_Clause, Node_Kind, 
+      N_At_Clause,
+      N_Attribute_Definition_Clause)
+   SUBTYPE (N_Statement_Other_Than_Procedure_Call, Node_Kind, 
+      N_Abort_Statement,
+      N_If_Statement)
+   SUBTYPE (N_Has_Condition, Node_Kind, 
+      N_Exit_Statement,
+      N_Terminate_Alternative)
+   SUBTYPE (N_Subexpr, Node_Kind, 
+      N_Expanded_Name,
+      N_Unchecked_Type_Conversion)
+   SUBTYPE (N_Subprogram_Specification, Node_Kind, 
+      N_Function_Specification,
+      N_Procedure_Specification)
+   SUBTYPE (N_Unary_Op, Node_Kind, 
+      N_Op_Abs,
+      N_Op_Plus)
+   SUBTYPE (N_Unit_Body, Node_Kind, 
+      N_Package_Body,
+      N_Subprogram_Body)
+   INLINE Boolean   ABE_Is_Certain                 (Node_Id N)
+      { return Flag18 (N); }
+   INLINE Boolean   Abort_Present                  (Node_Id N)
+      { return Flag15 (N); }
+   INLINE Node_Id   Abortable_Part                 (Node_Id N)
+      { return Node2 (N); }
+   INLINE Boolean   Abstract_Present               (Node_Id N)
+      { return Flag4 (N); }
+   INLINE List_Id   Accept_Handler_Records         (Node_Id N)
+      { return List5 (N); }
+   INLINE Node_Id   Accept_Statement               (Node_Id N)
+      { return Node2 (N); }
+   INLINE Elist_Id  Access_Types_To_Process        (Node_Id N)
+      { return Elist2 (N); }
+   INLINE List_Id   Actions                        (Node_Id N)
+      { return List1 (N); }
+   INLINE Node_Id   Activation_Chain_Entity        (Node_Id N)
+      { return Node3 (N); }
+   INLINE Boolean   Acts_As_Spec                   (Node_Id N)
+      { return Flag4 (N); }
+   INLINE Node_Id   Aggregate_Bounds               (Node_Id N)
+      { return Node3 (N); }
+   INLINE Boolean   Aliased_Present                (Node_Id N)
+      { return Flag4 (N); }
+   INLINE Boolean   All_Others                     (Node_Id N)
+      { return Flag11 (N); }
+   INLINE Boolean   All_Present                    (Node_Id N)
+      { return Flag15 (N); }
+   INLINE List_Id   Alternatives                   (Node_Id N)
+      { return List4 (N); }
+   INLINE Node_Id   Ancestor_Part                  (Node_Id N)
+      { return Node3 (N); }
+   INLINE Node_Id   Array_Aggregate                (Node_Id N)
+      { return Node3 (N); }
+   INLINE Boolean   Assignment_OK                  (Node_Id N)
+      { return Flag15 (N); }
+   INLINE Node_Id   Associated_Node                (Node_Id N)
+      { return Node4 (N); }
+   INLINE Node_Id   At_End_Proc                    (Node_Id N)
+      { return Node1 (N); }
+   INLINE Name_Id   Attribute_Name                 (Node_Id N)
+      { return Name2 (N); }
+   INLINE Node_Id   Aux_Decls_Node                 (Node_Id N)
+      { return Node5 (N); }
+   INLINE Boolean   Backwards_OK                   (Node_Id N)
+      { return Flag6 (N); }
+   INLINE Boolean   Bad_Is_Detected                (Node_Id N)
+      { return Flag15 (N); }
+   INLINE Boolean   By_Ref                         (Node_Id N)
+      { return Flag5 (N); }
+   INLINE Boolean   Body_Required                  (Node_Id N)
+      { return Flag13 (N); }
+   INLINE Node_Id   Body_To_Inline                 (Node_Id N)
+      { return Node3 (N); }
+   INLINE Boolean   Box_Present                    (Node_Id N)
+      { return Flag15 (N); }
+   INLINE Char_Code Char_Literal_Value             (Node_Id N)
+      { return Char_Code2 (N); }
+   INLINE Name_Id   Chars                          (Node_Id N)
+      { return Name1 (N); }
+   INLINE Boolean   Check_Address_Alignment        (Node_Id N)
+      { return Flag11 (N); }
+   INLINE Node_Id   Choice_Parameter               (Node_Id N)
+      { return Node2 (N); }
+   INLINE List_Id   Choices                        (Node_Id N)
+      { return List1 (N); }
+   INLINE Boolean   Compile_Time_Known_Aggregate   (Node_Id N)
+      { return Flag18 (N); }
+   INLINE List_Id   Component_Associations         (Node_Id N)
+      { return List2 (N); }
+   INLINE List_Id   Component_Clauses              (Node_Id N)
+      { return List3 (N); }
+   INLINE Node_Id   Component_Definition           (Node_Id N)
+      { return Node4 (N); }
+   INLINE List_Id   Component_Items                (Node_Id N)
+      { return List3 (N); }
+   INLINE Node_Id   Component_List                 (Node_Id N)
+      { return Node1 (N); }
+   INLINE Node_Id   Component_Name                 (Node_Id N)
+      { return Node1 (N); }
+   INLINE Node_Id   Condition                      (Node_Id N)
+      { return Node1 (N); }
+   INLINE List_Id   Condition_Actions              (Node_Id N)
+      { return List3 (N); }
+   INLINE List_Id   Config_Pragmas                 (Node_Id N)
+      { return List4 (N); }
+   INLINE Boolean   Constant_Present               (Node_Id N)
+      { return Flag17 (N); }
+   INLINE Node_Id   Constraint                     (Node_Id N)
+      { return Node3 (N); }
+   INLINE List_Id   Constraints                    (Node_Id N)
+      { return List1 (N); }
+   INLINE Boolean   Context_Installed              (Node_Id N)
+      { return Flag13 (N); }
+   INLINE List_Id   Context_Items                  (Node_Id N)
+      { return List1 (N); }
+   INLINE Node_Id   Controlling_Argument           (Node_Id N)
+      { return Node1 (N); }
+   INLINE Boolean   Conversion_OK                  (Node_Id N)
+      { return Flag14 (N); }
+   INLINE Node_Id   Corresponding_Body             (Node_Id N)
+      { return Node5 (N); }
+   INLINE Node_Id   Corresponding_Generic_Association (Node_Id N)
+      { return Node5 (N); }
+   INLINE Uint      Corresponding_Integer_Value    (Node_Id N)
+      { return Uint4 (N); }
+   INLINE Node_Id   Corresponding_Spec             (Node_Id N)
+      { return Node5 (N); }
+   INLINE Node_Id   Corresponding_Stub             (Node_Id N)
+      { return Node3 (N); }
+   INLINE Entity_Id Dcheck_Function                (Node_Id N)
+      { return Node5 (N); }
+   INLINE Node_Id   Debug_Statement                (Node_Id N)
+      { return Node3 (N); }
+   INLINE List_Id   Declarations                   (Node_Id N)
+      { return List2 (N); }
+   INLINE Node_Id   Default_Expression             (Node_Id N)
+      { return Node5 (N); }
+   INLINE Node_Id   Default_Name                   (Node_Id N)
+      { return Node2 (N); }
+   INLINE Entity_Id Defining_Identifier            (Node_Id N)
+      { return Node1 (N); }
+   INLINE Node_Id   Defining_Unit_Name             (Node_Id N)
+      { return Node1 (N); }
+   INLINE Node_Id   Delay_Alternative              (Node_Id N)
+      { return Node4 (N); }
+   INLINE Boolean   Delay_Finalize_Attach          (Node_Id N)
+      { return Flag14 (N); }
+   INLINE Node_Id   Delay_Statement                (Node_Id N)
+      { return Node2 (N); }
+   INLINE Node_Id   Delta_Expression               (Node_Id N)
+      { return Node3 (N); }
+   INLINE Node_Id   Digits_Expression              (Node_Id N)
+      { return Node2 (N); }
+   INLINE Boolean   Discr_Check_Funcs_Built        (Node_Id N)
+      { return Flag11 (N); }
+   INLINE List_Id   Discrete_Choices               (Node_Id N)
+      { return List4 (N); }
+   INLINE Node_Id   Discrete_Range                 (Node_Id N)
+      { return Node4 (N); }
+   INLINE Node_Id   Discrete_Subtype_Definition    (Node_Id N)
+      { return Node4 (N); }
+   INLINE List_Id   Discrete_Subtype_Definitions   (Node_Id N)
+      { return List2 (N); }
+   INLINE List_Id   Discriminant_Specifications    (Node_Id N)
+      { return List4 (N); }
+   INLINE Node_Id   Discriminant_Type              (Node_Id N)
+      { return Node5 (N); }
+   INLINE Boolean   Do_Accessibility_Check         (Node_Id N)
+      { return Flag13 (N); }
+   INLINE Boolean   Do_Discriminant_Check          (Node_Id N)
+      { return Flag13 (N); }
+   INLINE Boolean   Do_Division_Check              (Node_Id N)
+      { return Flag13 (N); }
+   INLINE Boolean   Do_Length_Check                (Node_Id N)
+      { return Flag4 (N); }
+   INLINE Boolean   Do_Overflow_Check              (Node_Id N)
+      { return Flag17 (N); }
+   INLINE Boolean   Do_Range_Check                 (Node_Id N)
+      { return Flag9 (N); }
+   INLINE Boolean   Do_Storage_Check               (Node_Id N)
+      { return Flag17 (N); }
+   INLINE Boolean   Do_Tag_Check                   (Node_Id N)
+      { return Flag13 (N); }
+   INLINE Boolean   Elaborate_All_Present          (Node_Id N)
+      { return Flag15 (N); }
+   INLINE Boolean   Elaborate_Present              (Node_Id N)
+      { return Flag4 (N); }
+   INLINE Node_Id   Elaboration_Boolean            (Node_Id N)
+      { return Node2 (N); }
+   INLINE List_Id   Else_Actions                   (Node_Id N)
+      { return List3 (N); }
+   INLINE List_Id   Else_Statements                (Node_Id N)
+      { return List4 (N); }
+   INLINE List_Id   Elsif_Parts                    (Node_Id N)
+      { return List3 (N); }
+   INLINE Node_Id   Enclosing_Variant              (Node_Id N)
+      { return Node2 (N); }
+   INLINE Node_Id   End_Label                      (Node_Id N)
+      { return Node4 (N); }
+   INLINE Uint      End_Span                       (Node_Id N)
+      { return Uint5 (N); }
+   INLINE Node_Id   Entity                         (Node_Id N)
+      { return Node4 (N); }
+   INLINE Node_Id   Entity_Or_Associated_Node      (Node_Id N)
+      { return Node4 (N); }
+   INLINE Node_Id   Entry_Body_Formal_Part         (Node_Id N)
+      { return Node5 (N); }
+   INLINE Node_Id   Entry_Call_Alternative         (Node_Id N)
+      { return Node1 (N); }
+   INLINE Node_Id   Entry_Call_Statement           (Node_Id N)
+      { return Node1 (N); }
+   INLINE Node_Id   Entry_Direct_Name              (Node_Id N)
+      { return Node1 (N); }
+   INLINE Node_Id   Entry_Index                    (Node_Id N)
+      { return Node5 (N); }
+   INLINE Node_Id   Entry_Index_Specification      (Node_Id N)
+      { return Node4 (N); }
+   INLINE Node_Id   Etype                          (Node_Id N)
+      { return Node5 (N); }
+   INLINE List_Id   Exception_Choices              (Node_Id N)
+      { return List4 (N); }
+   INLINE List_Id   Exception_Handlers             (Node_Id N)
+      { return List5 (N); }
+   INLINE Boolean   Exception_Junk                 (Node_Id N)
+      { return Flag11 (N); }
+   INLINE Node_Id   Explicit_Actual_Parameter      (Node_Id N)
+      { return Node3 (N); }
+   INLINE Boolean   Expansion_Delayed              (Node_Id N)
+      { return Flag11 (N); }
+   INLINE Node_Id   Explicit_Generic_Actual_Parameter (Node_Id N)
+      { return Node1 (N); }
+   INLINE Node_Id   Expression                     (Node_Id N)
+      { return Node3 (N); }
+   INLINE List_Id   Expressions                    (Node_Id N)
+      { return List1 (N); }
+   INLINE Node_Id   First_Bit                      (Node_Id N)
+      { return Node3 (N); }
+   INLINE Entity_Id First_Inlined_Subprogram       (Node_Id N)
+      { return Node3 (N); }
+   INLINE Boolean   First_Name                     (Node_Id N)
+      { return Flag5 (N); }
+   INLINE Node_Id   First_Named_Actual             (Node_Id N)
+      { return Node4 (N); }
+   INLINE Node_Id   First_Real_Statement           (Node_Id N)
+      { return Node2 (N); }
+   INLINE Entity_Id First_Subtype_Link             (Node_Id N)
+      { return Node5 (N); }
+   INLINE Boolean   Float_Truncate                 (Node_Id N)
+      { return Flag11 (N); }
+   INLINE Node_Id   Formal_Type_Definition         (Node_Id N)
+      { return Node3 (N); }
+   INLINE Boolean   Forwards_OK                    (Node_Id N)
+      { return Flag5 (N); }
+   INLINE Boolean   From_At_Mod                    (Node_Id N)
+      { return Flag4 (N); }
+   INLINE List_Id   Generic_Associations           (Node_Id N)
+      { return List3 (N); }
+   INLINE List_Id   Generic_Formal_Declarations    (Node_Id N)
+      { return List2 (N); }
+   INLINE Node_Id   Generic_Parent                 (Node_Id N)
+      { return Node5 (N); }
+   INLINE Node_Id   Generic_Parent_Type            (Node_Id N)
+      { return Node4 (N); }
+   INLINE Node_Id   Handled_Statement_Sequence     (Node_Id N)
+      { return Node4 (N); }
+   INLINE Node_Id   Handler_List_Entry             (Node_Id N)
+      { return Node2 (N); }
+   INLINE Boolean   Has_Created_Identifier         (Node_Id N)
+      { return Flag15 (N); }
+   INLINE Boolean   Has_Dynamic_Length_Check       (Node_Id N)
+      { return Flag10 (N); }
+   INLINE Boolean   Has_Dynamic_Range_Check        (Node_Id N)
+      { return Flag12 (N); }
+   INLINE Boolean   Has_No_Elaboration_Code        (Node_Id N)
+      { return Flag17 (N); }
+   INLINE Boolean   Has_Priority_Pragma            (Node_Id N)
+      { return Flag6 (N); }
+   INLINE Boolean   Has_Private_View               (Node_Id N)
+      { return Flag11 (N); }
+   INLINE Boolean   Has_Storage_Size_Pragma        (Node_Id N)
+      { return Flag5 (N); }
+   INLINE Boolean   Has_Task_Info_Pragma           (Node_Id N)
+      { return Flag7 (N); }
+   INLINE Boolean   Has_Task_Name_Pragma           (Node_Id N)
+      { return Flag8 (N); }
+   INLINE Boolean   Has_Wide_Character             (Node_Id N)
+      { return Flag11 (N); }
+   INLINE Elist_Id  Hidden_By_Use_Clause           (Node_Id N)
+      { return Elist4 (N); }
+   INLINE Node_Id   High_Bound                     (Node_Id N)
+      { return Node2 (N); }
+   INLINE Node_Id   Identifier                     (Node_Id N)
+      { return Node1 (N); }
+   INLINE Boolean   Implicit_With                  (Node_Id N)
+      { return Flag16 (N); }
+   INLINE Boolean   In_Present                     (Node_Id N)
+      { return Flag15 (N); }
+   INLINE Boolean   Includes_Infinities            (Node_Id N)
+      { return Flag11 (N); }
+   INLINE Node_Id   Instance_Spec                  (Node_Id N)
+      { return Node5 (N); }
+   INLINE Uint      Intval                         (Node_Id N)
+      { return Uint3 (N); }
+   INLINE Boolean   Is_Asynchronous_Call_Block     (Node_Id N)
+      { return Flag7 (N); }
+   INLINE Boolean   Is_Component_Left_Opnd         (Node_Id N)
+      { return Flag13 (N); }
+   INLINE Boolean   Is_Component_Right_Opnd        (Node_Id N)
+      { return Flag14 (N); }
+   INLINE Boolean   Is_Controlling_Actual          (Node_Id N)
+      { return Flag16 (N); }
+   INLINE Boolean   Is_In_Discriminant_Check       (Node_Id N)
+      { return Flag11 (N); }
+   INLINE Boolean   Is_Machine_Number              (Node_Id N)
+      { return Flag11 (N); }
+   INLINE Boolean   Is_Null_Loop                   (Node_Id N)
+      { return Flag16 (N); }
+   INLINE Boolean   Is_Overloaded                  (Node_Id N)
+      { return Flag5 (N); }
+   INLINE Boolean   Is_Power_Of_2_For_Shift        (Node_Id N)
+      { return Flag13 (N); }
+   INLINE Boolean   Is_Protected_Subprogram_Body   (Node_Id N)
+      { return Flag7 (N); }
+   INLINE Boolean   Is_Static_Expression           (Node_Id N)
+      { return Flag6 (N); }
+   INLINE Boolean   Is_Subprogram_Descriptor       (Node_Id N)
+      { return Flag16 (N); }
+   INLINE Boolean   Is_Task_Allocation_Block       (Node_Id N)
+      { return Flag6 (N); }
+   INLINE Boolean   Is_Task_Master                 (Node_Id N)
+      { return Flag5 (N); }
+   INLINE Node_Id   Iteration_Scheme               (Node_Id N)
+      { return Node2 (N); }
+   INLINE Entity_Id Itype                          (Node_Id N)
+      { return Node1 (N); }
+   INLINE Boolean   Kill_Range_Check               (Node_Id N)
+      { return Flag11 (N); }
+   INLINE Node_Id   Label_Construct                (Node_Id N)
+      { return Node2 (N); }
+   INLINE Node_Id   Left_Opnd                      (Node_Id N)
+      { return Node2 (N); }
+   INLINE Node_Id   Last_Bit                       (Node_Id N)
+      { return Node4 (N); }
+   INLINE Boolean   Last_Name                      (Node_Id N)
+      { return Flag6 (N); }
+   INLINE Node_Id   Library_Unit                   (Node_Id N)
+      { return Node4 (N); }
+   INLINE Boolean   Limited_View_Installed         (Node_Id N)
+      { return Flag18 (N); }
+   INLINE Boolean   Limited_Present                (Node_Id N)
+      { return Flag17 (N); }
+   INLINE List_Id   Literals                       (Node_Id N)
+      { return List1 (N); }
+   INLINE List_Id   Loop_Actions                   (Node_Id N)
+      { return List2 (N); }
+   INLINE Node_Id   Loop_Parameter_Specification   (Node_Id N)
+      { return Node4 (N); }
+   INLINE Node_Id   Low_Bound                      (Node_Id N)
+      { return Node1 (N); }
+   INLINE Node_Id   Mod_Clause                     (Node_Id N)
+      { return Node2 (N); }
+   INLINE Boolean   More_Ids                       (Node_Id N)
+      { return Flag5 (N); }
+   INLINE Boolean   Must_Be_Byte_Aligned           (Node_Id N)
+      { return Flag14 (N); }
+   INLINE Boolean   Must_Not_Freeze                (Node_Id N)
+      { return Flag8 (N); }
+   INLINE Node_Id   Name                           (Node_Id N)
+      { return Node2 (N); }
+   INLINE List_Id   Names                          (Node_Id N)
+      { return List2 (N); }
+   INLINE Node_Id   Next_Entity                    (Node_Id N)
+      { return Node2 (N); }
+   INLINE Node_Id   Next_Named_Actual              (Node_Id N)
+      { return Node4 (N); }
+   INLINE Node_Id   Next_Rep_Item                  (Node_Id N)
+      { return Node4 (N); }
+   INLINE Node_Id   Next_Use_Clause                (Node_Id N)
+      { return Node3 (N); }
+   INLINE Boolean   No_Ctrl_Actions                (Node_Id N)
+      { return Flag7 (N); }
+   INLINE Boolean   No_Elaboration_Check           (Node_Id N)
+      { return Flag14 (N); }
+   INLINE Boolean   No_Entities_Ref_In_Spec        (Node_Id N)
+      { return Flag8 (N); }
+   INLINE Boolean   No_Initialization              (Node_Id N)
+      { return Flag13 (N); }
+   INLINE Boolean   No_Truncation                  (Node_Id N)
+      { return Flag17 (N); }
+   INLINE Boolean   Null_Present                   (Node_Id N)
+      { return Flag13 (N); }
+   INLINE Boolean   Null_Record_Present            (Node_Id N)
+      { return Flag17 (N); }
+   INLINE Node_Id   Object_Definition              (Node_Id N)
+      { return Node4 (N); }
+   INLINE Boolean   OK_For_Stream                  (Node_Id N)
+      { return Flag4 (N); }
+   INLINE Node_Id   Original_Discriminant          (Node_Id N)
+      { return Node2 (N); }
+   INLINE Entity_Id Original_Entity                (Node_Id N)
+      { return Node2 (N); }
+   INLINE List_Id   Others_Discrete_Choices        (Node_Id N)
+      { return List1 (N); }
+   INLINE Boolean   Out_Present                    (Node_Id N)
+      { return Flag17 (N); }
+   INLINE List_Id   Parameter_Associations         (Node_Id N)
+      { return List3 (N); }
+   INLINE Boolean   Parameter_List_Truncated       (Node_Id N)
+      { return Flag17 (N); }
+   INLINE List_Id   Parameter_Specifications       (Node_Id N)
+      { return List3 (N); }
+   INLINE Node_Id   Parameter_Type                 (Node_Id N)
+      { return Node2 (N); }
+   INLINE Node_Id   Parent_Spec                    (Node_Id N)
+      { return Node4 (N); }
+   INLINE Node_Id   Position                       (Node_Id N)
+      { return Node2 (N); }
+   INLINE List_Id   Pragma_Argument_Associations   (Node_Id N)
+      { return List2 (N); }
+   INLINE List_Id   Pragmas_After                  (Node_Id N)
+      { return List5 (N); }
+   INLINE List_Id   Pragmas_Before                 (Node_Id N)
+      { return List4 (N); }
+   INLINE Node_Id   Prefix                         (Node_Id N)
+      { return Node3 (N); }
+   INLINE Uint      Present_Expr                   (Node_Id N)
+      { return Uint3 (N); }
+   INLINE Boolean   Prev_Ids                       (Node_Id N)
+      { return Flag6 (N); }
+   INLINE Boolean   Print_In_Hex                   (Node_Id N)
+      { return Flag13 (N); }
+   INLINE List_Id   Private_Declarations           (Node_Id N)
+      { return List3 (N); }
+   INLINE Boolean   Private_Present                (Node_Id N)
+      { return Flag15 (N); }
+   INLINE Node_Id   Procedure_To_Call              (Node_Id N)
+      { return Node4 (N); }
+   INLINE Node_Id   Proper_Body                    (Node_Id N)
+      { return Node1 (N); }
+   INLINE Node_Id   Protected_Definition           (Node_Id N)
+      { return Node3 (N); }
+   INLINE Boolean   Protected_Present              (Node_Id N)
+      { return Flag15 (N); }
+   INLINE Boolean   Raises_Constraint_Error        (Node_Id N)
+      { return Flag7 (N); }
+   INLINE Node_Id   Range_Constraint               (Node_Id N)
+      { return Node4 (N); }
+   INLINE Node_Id   Range_Expression               (Node_Id N)
+      { return Node4 (N); }
+   INLINE Node_Id   Real_Range_Specification       (Node_Id N)
+      { return Node4 (N); }
+   INLINE Ureal     Realval                        (Node_Id N)
+      { return Ureal3 (N); }
+   INLINE Uint      Reason                         (Node_Id N)
+      { return Uint3 (N); }
+   INLINE Node_Id   Record_Extension_Part          (Node_Id N)
+      { return Node3 (N); }
+   INLINE Boolean   Redundant_Use                  (Node_Id N)
+      { return Flag13 (N); }
+   INLINE Node_Id   Return_Type                    (Node_Id N)
+      { return Node2 (N); }
+   INLINE Boolean   Reverse_Present                (Node_Id N)
+      { return Flag15 (N); }
+   INLINE Node_Id   Right_Opnd                     (Node_Id N)
+      { return Node3 (N); }
+   INLINE Boolean   Rounded_Result                 (Node_Id N)
+      { return Flag18 (N); }
+   INLINE Node_Id   Scope                          (Node_Id N)
+      { return Node3 (N); }
+   INLINE List_Id   Select_Alternatives            (Node_Id N)
+      { return List1 (N); }
+   INLINE Node_Id   Selector_Name                  (Node_Id N)
+      { return Node2 (N); }
+   INLINE List_Id   Selector_Names                 (Node_Id N)
+      { return List1 (N); }
+   INLINE Boolean   Shift_Count_OK                 (Node_Id N)
+      { return Flag4 (N); }
+   INLINE Entity_Id Source_Type                    (Node_Id N)
+      { return Node1 (N); }
+   INLINE Node_Id   Specification                  (Node_Id N)
+      { return Node1 (N); }
+   INLINE List_Id   Statements                     (Node_Id N)
+      { return List3 (N); }
+   INLINE Boolean   Static_Processing_OK           (Node_Id N)
+      { return Flag4 (N); }
+   INLINE Node_Id   Storage_Pool                   (Node_Id N)
+      { return Node1 (N); }
+   INLINE String_Id Strval                         (Node_Id N)
+      { return Str3 (N); }
+   INLINE Node_Id   Subtype_Indication             (Node_Id N)
+      { return Node5 (N); }
+   INLINE Node_Id   Subtype_Mark                   (Node_Id N)
+      { return Node4 (N); }
+   INLINE List_Id   Subtype_Marks                  (Node_Id N)
+      { return List2 (N); }
+   INLINE Boolean   Tagged_Present                 (Node_Id N)
+      { return Flag15 (N); }
+   INLINE Entity_Id Target_Type                    (Node_Id N)
+      { return Node2 (N); }
+   INLINE Entity_Id Task_Body_Procedure            (Node_Id N)
+      { return Node2 (N); }
+   INLINE Node_Id   Task_Definition                (Node_Id N)
+      { return Node3 (N); }
+   INLINE List_Id   Then_Actions                   (Node_Id N)
+      { return List2 (N); }
+   INLINE List_Id   Then_Statements                (Node_Id N)
+      { return List2 (N); }
+   INLINE Boolean   Treat_Fixed_As_Integer         (Node_Id N)
+      { return Flag14 (N); }
+   INLINE Node_Id   Triggering_Alternative         (Node_Id N)
+      { return Node1 (N); }
+   INLINE Node_Id   Triggering_Statement           (Node_Id N)
+      { return Node1 (N); }
+   INLINE Elist_Id  TSS_Elist                      (Node_Id N)
+      { return Elist3 (N); }
+   INLINE Node_Id   Type_Definition                (Node_Id N)
+      { return Node3 (N); }
+   INLINE Node_Id   Unit                           (Node_Id N)
+      { return Node2 (N); }
+   INLINE Boolean   Unknown_Discriminants_Present  (Node_Id N)
+      { return Flag13 (N); }
+   INLINE Boolean   Unreferenced_In_Spec           (Node_Id N)
+      { return Flag7 (N); }
+   INLINE Node_Id   Variant_Part                   (Node_Id N)
+      { return Node4 (N); }
+   INLINE List_Id   Variants                       (Node_Id N)
+      { return List1 (N); }
+   INLINE List_Id   Visible_Declarations           (Node_Id N)
+      { return List2 (N); }
+   INLINE Boolean   Was_Originally_Stub            (Node_Id N)
+      { return Flag13 (N); }
+   INLINE Boolean   Zero_Cost_Handling             (Node_Id N)
+      { return Flag5 (N); }
+
--- gcc-3.4.0/obj-amd64-pld-linux/gcc/ada/einfo.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.4.0/obj-amd64-pld-linux/gcc/ada/einfo.h	2004-06-02 00:54:19.000000000 +0200
@@ -0,0 +1,1814 @@
+/*--------------------------------------------------------------------------*/
+/*                                                                          */
+/*                         GNAT COMPILER COMPONENTS                         */
+/*                                                                          */
+/*                                E I N F O                                 */
+/*                                                                          */
+/*                              C Header File                               */
+/*                                                                          */
+/*          Copyright (C) 1992-2003 Free Software Foundation, Inc.          */
+/*                                                                          */
+/* GNAT is free software;  you can  redistribute it  and/or modify it under */
+/* terms of the  GNU General Public License as published  by the Free Soft- */
+/* ware  Foundation;  either version 2,  or (at your option) any later ver- */
+/* sion.  GNAT is distributed in the hope that it will be useful, but WITH- */
+/* OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY */
+/* or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License */
+/* for  more details.  You should have  received  a copy of the GNU General */
+/* Public License  distributed with GNAT;  see file COPYING.  If not, write */
+/* to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, */
+/* MA 02111-1307, USA.                                                      */
+/*                                                                          */
+/* As a special exception,  if other files  instantiate  generics from this */
+/* unit, or you link  this unit with other files  to produce an executable, */
+/* this  unit  does not  by itself cause  the resulting  executable  to  be */
+/* covered  by the  GNU  General  Public  License.  This exception does not */
+/* however invalidate  any other reasons why  the executable file  might be */
+/* covered by the  GNU Public License.                                      */
+/*                                                                          */
+/* GNAT was originally developed  by the GNAT team at  New York University. */
+/* Extensive contributions were provided by Ada Core Technologies Inc.      */
+/*                                                                          */
+/*--------------------------------------------------------------------------*/
+
+   #define E_Void                           0
+   #define E_Variable                       1
+   #define E_Component                      2
+   #define E_Constant                       3
+   #define E_Discriminant                   4
+   #define E_Loop_Parameter                 5
+   #define E_In_Parameter                   6
+   #define E_Out_Parameter                  7
+   #define E_In_Out_Parameter               8
+   #define E_Generic_In_Out_Parameter       9
+   #define E_Generic_In_Parameter           10
+   #define E_Named_Integer                  11
+   #define E_Named_Real                     12
+   #define E_Enumeration_Type               13
+   #define E_Enumeration_Subtype            14
+   #define E_Signed_Integer_Type            15
+   #define E_Signed_Integer_Subtype         16
+   #define E_Modular_Integer_Type           17
+   #define E_Modular_Integer_Subtype        18
+   #define E_Ordinary_Fixed_Point_Type      19
+   #define E_Ordinary_Fixed_Point_Subtype   20
+   #define E_Decimal_Fixed_Point_Type       21
+   #define E_Decimal_Fixed_Point_Subtype    22
+   #define E_Floating_Point_Type            23
+   #define E_Floating_Point_Subtype         24
+   #define E_Access_Type                    25
+   #define E_Access_Subtype                 26
+   #define E_Access_Attribute_Type          27
+   #define E_Allocator_Type                 28
+   #define E_General_Access_Type            29
+   #define E_Access_Subprogram_Type         30
+   #define E_Access_Protected_Subprogram_Type 31
+   #define E_Anonymous_Access_Type          32
+   #define E_Array_Type                     33
+   #define E_Array_Subtype                  34
+   #define E_String_Type                    35
+   #define E_String_Subtype                 36
+   #define E_String_Literal_Subtype         37
+   #define E_Class_Wide_Type                38
+   #define E_Class_Wide_Subtype             39
+   #define E_Record_Type                    40
+   #define E_Record_Subtype                 41
+   #define E_Record_Type_With_Private       42
+   #define E_Record_Subtype_With_Private    43
+   #define E_Private_Type                   44
+   #define E_Private_Subtype                45
+   #define E_Limited_Private_Type           46
+   #define E_Limited_Private_Subtype        47
+   #define E_Incomplete_Type                48
+   #define E_Task_Type                      49
+   #define E_Task_Subtype                   50
+   #define E_Protected_Type                 51
+   #define E_Protected_Subtype              52
+   #define E_Exception_Type                 53
+   #define E_Subprogram_Type                54
+   #define E_Enumeration_Literal            55
+   #define E_Function                       56
+   #define E_Operator                       57
+   #define E_Procedure                      58
+   #define E_Entry                          59
+   #define E_Entry_Family                   60
+   #define E_Block                          61
+   #define E_Entry_Index_Parameter          62
+   #define E_Exception                      63
+   #define E_Generic_Function               64
+   #define E_Generic_Procedure              65
+   #define E_Generic_Package                66
+   #define E_Label                          67
+   #define E_Loop                           68
+   #define E_Package                        69
+   #define E_Package_Body                   70
+   #define E_Protected_Object               71
+   #define E_Protected_Body                 72
+   #define E_Task_Body                      73
+   #define E_Subprogram_Body                74
+
+   SUBTYPE (Access_Kind, Entity_Kind, 
+      E_Access_Type, E_Anonymous_Access_Type)
+
+   SUBTYPE (Array_Kind, Entity_Kind, 
+      E_Array_Type, E_String_Literal_Subtype)
+
+   SUBTYPE (Class_Wide_Kind, Entity_Kind, 
+      E_Class_Wide_Type, E_Class_Wide_Subtype)
+
+   SUBTYPE (Composite_Kind, Entity_Kind, 
+      E_Array_Type, E_Protected_Subtype)
+
+   SUBTYPE (Concurrent_Kind, Entity_Kind, 
+      E_Task_Type, E_Protected_Subtype)
+
+   SUBTYPE (Concurrent_Body_Kind, Entity_Kind, 
+      E_Protected_Body, E_Task_Body)
+
+   SUBTYPE (Decimal_Fixed_Point_Kind, Entity_Kind, 
+      E_Decimal_Fixed_Point_Type, E_Decimal_Fixed_Point_Subtype)
+
+   SUBTYPE (Digits_Kind, Entity_Kind, 
+      E_Decimal_Fixed_Point_Type, E_Floating_Point_Subtype)
+
+   SUBTYPE (Discrete_Kind, Entity_Kind, 
+      E_Enumeration_Type, E_Modular_Integer_Subtype)
+
+   SUBTYPE (Discrete_Or_Fixed_Point_Kind, Entity_Kind, 
+      E_Enumeration_Type, E_Decimal_Fixed_Point_Subtype)
+
+   SUBTYPE (Elementary_Kind, Entity_Kind, 
+      E_Enumeration_Type, E_Anonymous_Access_Type)
+
+   SUBTYPE (Enumeration_Kind, Entity_Kind, 
+      E_Enumeration_Type, E_Enumeration_Subtype)
+
+   SUBTYPE (Entry_Kind, Entity_Kind, 
+      E_Entry, E_Entry_Family)
+
+   SUBTYPE (Fixed_Point_Kind, Entity_Kind, 
+      E_Ordinary_Fixed_Point_Type, E_Decimal_Fixed_Point_Subtype)
+
+   SUBTYPE (Float_Kind, Entity_Kind, 
+      E_Floating_Point_Type, E_Floating_Point_Subtype)
+
+   SUBTYPE (Formal_Kind, Entity_Kind, 
+      E_In_Parameter, E_In_Out_Parameter)
+
+   SUBTYPE (Generic_Subprogram_Kind, Entity_Kind, 
+      E_Generic_Function, E_Generic_Procedure)
+
+   SUBTYPE (Generic_Unit_Kind, Entity_Kind, 
+      E_Generic_Function, E_Generic_Package)
+
+   SUBTYPE (Incomplete_Or_Private_Kind, Entity_Kind, 
+      E_Record_Type_With_Private, E_Incomplete_Type)
+
+   SUBTYPE (Integer_Kind, Entity_Kind, 
+      E_Signed_Integer_Type, E_Modular_Integer_Subtype)
+
+   SUBTYPE (Modular_Integer_Kind, Entity_Kind, 
+      E_Modular_Integer_Type, E_Modular_Integer_Subtype)
+
+   SUBTYPE (Named_Kind, Entity_Kind, 
+      E_Named_Integer, E_Named_Real)
+
+   SUBTYPE (Numeric_Kind, Entity_Kind, 
+      E_Signed_Integer_Type, E_Floating_Point_Subtype)
+
+   SUBTYPE (Object_Kind, Entity_Kind, 
+      E_Variable, E_Generic_In_Parameter)
+
+   SUBTYPE (Ordinary_Fixed_Point_Kind, Entity_Kind, 
+      E_Ordinary_Fixed_Point_Type, E_Ordinary_Fixed_Point_Subtype)
+
+   SUBTYPE (Overloadable_Kind, Entity_Kind, 
+      E_Enumeration_Literal, E_Entry)
+
+   SUBTYPE (Private_Kind, Entity_Kind, 
+      E_Record_Type_With_Private, E_Limited_Private_Subtype)
+
+   SUBTYPE (Protected_Kind, Entity_Kind, 
+      E_Protected_Type, E_Protected_Subtype)
+
+   SUBTYPE (Real_Kind, Entity_Kind, 
+      E_Ordinary_Fixed_Point_Type, E_Floating_Point_Subtype)
+
+   SUBTYPE (Record_Kind, Entity_Kind, 
+      E_Class_Wide_Type, E_Record_Subtype_With_Private)
+
+   SUBTYPE (Scalar_Kind, Entity_Kind, 
+      E_Enumeration_Type, E_Floating_Point_Subtype)
+
+   SUBTYPE (String_Kind, Entity_Kind, 
+      E_String_Type, E_String_Literal_Subtype)
+
+   SUBTYPE (Subprogram_Kind, Entity_Kind, 
+      E_Function, E_Procedure)
+
+   SUBTYPE (Signed_Integer_Kind, Entity_Kind, 
+      E_Signed_Integer_Type, E_Signed_Integer_Subtype)
+
+   SUBTYPE (Task_Kind, Entity_Kind, 
+      E_Task_Type, E_Task_Subtype)
+
+   SUBTYPE (Type_Kind, Entity_Kind, 
+      E_Enumeration_Type, E_Subprogram_Type)
+
+   typedef char Component_Alignment_Kind;
+      #define Calign_Default           0
+      #define Calign_Component_Size    1
+      #define Calign_Component_Size_4  2
+      #define Calign_Storage_Unit      3
+
+   typedef Boolean B;
+   typedef Component_Alignment_Kind C;
+   typedef Entity_Id E;
+   typedef Mechanism_Type M;
+   typedef Node_Id N;
+   typedef Uint U;
+   typedef Ureal R;
+   typedef Elist_Id L;
+   typedef List_Id S;
+
+   INLINE L Accept_Address                     (E Id);
+   INLINE E Access_Disp_Table                  (E Id);
+   INLINE E Actual_Subtype                     (E Id);
+   INLINE B Address_Taken                      (E Id);
+   INLINE E Alias                              (E Id);
+   INLINE U Alignment                          (E Id);
+   INLINE E Associated_Final_Chain             (E Id);
+   INLINE E Associated_Formal_Package          (E Id);
+   INLINE N Associated_Node_For_Itype          (E Id);
+   INLINE E Associated_Storage_Pool            (E Id);
+   INLINE N Barrier_Function                   (E Id);
+   INLINE N Block_Node                         (E Id);
+   INLINE E Body_Entity                        (E Id);
+   INLINE B Body_Needed_For_SAL                (E Id);
+   INLINE E CR_Discriminant                    (E Id);
+   INLINE B C_Pass_By_Copy                     (E Id);
+   INLINE B Can_Never_Be_Null                  (E Id);
+   INLINE B Checks_May_Be_Suppressed           (E Id);
+   INLINE E Class_Wide_Type                    (E Id);
+   INLINE E Cloned_Subtype                     (E Id);
+
+   #define Component_Alignment einfo__component_alignment
+   C Component_Alignment                (E Id);
+
+   INLINE N Component_Clause                   (E Id);
+   INLINE U Component_Bit_Offset               (E Id);
+   INLINE U Component_Size                     (E Id);
+   INLINE E Component_Type                     (E Id);
+   INLINE E Corresponding_Concurrent_Type      (E Id);
+   INLINE E Corresponding_Discriminant         (E Id);
+   INLINE E Corresponding_Equality             (E Id);
+   INLINE E Corresponding_Record_Type          (E Id);
+   INLINE E Corresponding_Remote_Type          (E Id);
+   INLINE N Current_Value                      (E Id);
+   INLINE B Debug_Info_Off                     (E Id);
+   INLINE E Debug_Renaming_Link                (E Id);
+   INLINE E DTC_Entity                         (E Id);
+   INLINE U DT_Entry_Count                     (E Id);
+   INLINE U DT_Position                        (E Id);
+   INLINE E Default_Expr_Function              (E Id);
+   INLINE B Default_Expressions_Processed      (E Id);
+   INLINE N Default_Value                      (E Id);
+   INLINE B Delay_Cleanups                     (E Id);
+   INLINE B Delay_Subprogram_Descriptors       (E Id);
+   INLINE R Delta_Value                        (E Id);
+   INLINE L Dependent_Instances                (E Id);
+   INLINE B Depends_On_Private                 (E Id);
+   INLINE U Digits_Value                       (E Id);
+   INLINE E Directly_Designated_Type           (E Id);
+   INLINE B Discard_Names                      (E Id);
+   INLINE E Discriminal                        (E Id);
+   INLINE E Discriminal_Link                   (E Id);
+   INLINE E Discriminant_Checking_Func         (E Id);
+   INLINE L Discriminant_Constraint            (E Id);
+   INLINE N Discriminant_Default_Value         (E Id);
+   INLINE U Discriminant_Number                (E Id);
+   INLINE B Elaborate_All_Desirable            (E Id);
+   INLINE E Elaboration_Entity                 (E Id);
+   INLINE B Elaboration_Entity_Required        (E Id);
+   INLINE E Enclosing_Scope                    (E Id);
+   INLINE B Entry_Accepted                     (E Id);
+   INLINE E Entry_Bodies_Array                 (E Id);
+   INLINE E Entry_Cancel_Parameter             (E Id);
+   INLINE E Entry_Component                    (E Id);
+   INLINE E Entry_Formal                       (E Id);
+   INLINE E Entry_Index_Constant               (E Id);
+   INLINE E Entry_Index_Type                   (E Id);
+   INLINE E Entry_Parameters_Type              (E Id);
+   INLINE E Enum_Pos_To_Rep                    (E Id);
+   INLINE U Enumeration_Pos                    (E Id);
+   INLINE U Enumeration_Rep                    (E Id);
+   INLINE N Enumeration_Rep_Expr               (E Id);
+   INLINE E Equivalent_Type                    (E Id);
+   INLINE U Esize                              (E Id);
+   INLINE U Exception_Code                     (E Id);
+   INLINE E Extra_Accessibility                (E Id);
+   INLINE E Extra_Constrained                  (E Id);
+   INLINE E Extra_Formal                       (E Id);
+   INLINE E Finalization_Chain_Entity          (E Id);
+
+   #define Finalize_Storage_Only einfo__finalize_storage_only
+   B Finalize_Storage_Only              (E Id);
+
+   INLINE E First_Entity                       (E Id);
+   INLINE N First_Index                        (E Id);
+   INLINE E First_Literal                      (E Id);
+   INLINE E First_Optional_Parameter           (E Id);
+   INLINE E First_Private_Entity               (E Id);
+   INLINE N First_Rep_Item                     (E Id);
+   INLINE N Freeze_Node                        (E Id);
+   INLINE B From_With_Type                     (E Id);
+   INLINE E Full_View                          (E Id);
+   INLINE B Function_Returns_With_DSP          (E Id);
+   INLINE E Generic_Homonym                    (E Id);
+   INLINE L Generic_Renamings                  (E Id);
+   INLINE S Handler_Records                    (E Id);
+   INLINE B Has_Aliased_Components             (E Id);
+   INLINE B Has_Alignment_Clause               (E Id);
+   INLINE B Has_All_Calls_Remote               (E Id);
+   INLINE B Has_Atomic_Components              (E Id);
+   INLINE B Has_Biased_Representation          (E Id);
+   INLINE B Has_Completion                     (E Id);
+   INLINE B Has_Completion_In_Body             (E Id);
+   INLINE B Has_Complex_Representation         (E Id);
+   INLINE B Has_Component_Size_Clause          (E Id);
+   INLINE B Has_Contiguous_Rep                 (E Id);
+   INLINE B Has_Controlled_Component           (E Id);
+   INLINE B Has_Controlling_Result             (E Id);
+   INLINE B Has_Convention_Pragma              (E Id);
+   INLINE B Has_Delayed_Freeze                 (E Id);
+   INLINE B Has_Discriminants                  (E Id);
+   INLINE B Has_Enumeration_Rep_Clause         (E Id);
+   INLINE B Has_Exit                           (E Id);
+   INLINE B Has_External_Tag_Rep_Clause        (E Id);
+   INLINE B Has_Fully_Qualified_Name           (E Id);
+   INLINE B Has_Gigi_Rep_Item                  (E Id);
+   INLINE B Has_Homonym                        (E Id);
+
+   #define Has_Interrupt_Handler einfo__has_interrupt_handler
+   B Has_Interrupt_Handler              (E Id);
+
+   INLINE B Has_Machine_Radix_Clause           (E Id);
+   INLINE B Has_Master_Entity                  (E Id);
+   INLINE B Has_Missing_Return                 (E Id);
+   INLINE B Has_Nested_Block_With_Handler      (E Id);
+   INLINE B Has_Forward_Instantiation          (E Id);
+   INLINE B Has_Non_Standard_Rep               (E Id);
+   INLINE B Has_Object_Size_Clause             (E Id);
+   INLINE B Has_Per_Object_Constraint          (E Id);
+   INLINE B Has_Pragma_Controlled              (E Id);
+   INLINE B Has_Pragma_Elaborate_Body          (E Id);
+   INLINE B Has_Pragma_Inline                  (E Id);
+   INLINE B Has_Pragma_Pack                    (E Id);
+   INLINE B Has_Pragma_Pure_Function           (E Id);
+   INLINE B Has_Pragma_Unreferenced            (E Id);
+   INLINE B Has_Primitive_Operations           (E Id);
+   INLINE B Has_Qualified_Name                 (E Id);
+   INLINE B Has_Record_Rep_Clause              (E Id);
+   INLINE B Has_Recursive_Call                 (E Id);
+   INLINE B Has_Size_Clause                    (E Id);
+   INLINE B Has_Small_Clause                   (E Id);
+   INLINE B Has_Specified_Layout               (E Id);
+   INLINE B Has_Storage_Size_Clause            (E Id);
+   INLINE B Has_Subprogram_Descriptor          (E Id);
+   INLINE B Has_Task                           (E Id);
+   INLINE B Has_Unchecked_Union                (E Id);
+   INLINE B Has_Unknown_Discriminants          (E Id);
+   INLINE B Has_Volatile_Components            (E Id);
+   INLINE B Has_Xref_Entry                     (E Id);
+   INLINE E Hiding_Loop_Variable               (E Id);
+   INLINE E Homonym                            (E Id);
+   INLINE B In_Package_Body                    (E Id);
+   INLINE B In_Private_Part                    (E Id);
+   INLINE B In_Use                             (E Id);
+   INLINE L Inner_Instances                    (E Id);
+   INLINE N Interface_Name                     (E Id);
+   INLINE B Is_AST_Entry                       (E Id);
+   INLINE B Is_Abstract                        (E Id);
+   INLINE B Is_Access_Constant                 (E Id);
+   INLINE B Is_Aliased                         (E Id);
+   INLINE B Is_Asynchronous                    (E Id);
+   INLINE B Is_Atomic                          (E Id);
+   INLINE B Is_Bit_Packed_Array                (E Id);
+   INLINE B Is_CPP_Class                       (E Id);
+   INLINE B Is_Called                          (E Id);
+   INLINE B Is_Character_Type                  (E Id);
+   INLINE B Is_Child_Unit                      (E Id);
+   INLINE B Is_Class_Wide_Equivalent_Type      (E Id);
+   INLINE B Is_Compilation_Unit                (E Id);
+   INLINE B Is_Completely_Hidden               (E Id);
+   INLINE B Is_Constr_Subt_For_UN_Aliased      (E Id);
+   INLINE B Is_Constr_Subt_For_U_Nominal       (E Id);
+   INLINE B Is_Constrained                     (E Id);
+   INLINE B Is_Constructor                     (E Id);
+   INLINE B Is_Controlled                      (E Id);
+   INLINE B Is_Controlling_Formal              (E Id);
+   INLINE B Is_Discrim_SO_Function             (E Id);
+   INLINE B Is_Dispatching_Operation           (E Id);
+   INLINE B Is_Eliminated                      (E Id);
+   INLINE B Is_Entry_Formal                    (E Id);
+   INLINE B Is_Exported                        (E Id);
+   INLINE B Is_First_Subtype                   (E Id);
+   INLINE B Is_For_Access_Subtype              (E Id);
+   INLINE B Is_Frozen                          (E Id);
+   INLINE B Is_Generic_Instance                (E Id);
+   INLINE B Is_Hidden                          (E Id);
+   INLINE B Is_Hidden_Open_Scope               (E Id);
+   INLINE B Is_Immediately_Visible             (E Id);
+   INLINE B Is_Imported                        (E Id);
+   INLINE B Is_Inlined                         (E Id);
+   INLINE B Is_Instantiated                    (E Id);
+   INLINE B Is_Internal                        (E Id);
+   INLINE B Is_Interrupt_Handler               (E Id);
+   INLINE B Is_Intrinsic_Subprogram            (E Id);
+   INLINE B Is_Itype                           (E Id);
+   INLINE B Is_Known_Non_Null                  (E Id);
+   INLINE B Is_Known_Valid                     (E Id);
+   INLINE B Is_Limited_Composite               (E Id);
+   INLINE B Is_Machine_Code_Subprogram         (E Id);
+   INLINE B Is_Non_Static_Subtype              (E Id);
+   INLINE B Is_Null_Init_Proc                  (E Id);
+   INLINE B Is_Optional_Parameter              (E Id);
+   INLINE B Is_Package_Body_Entity             (E Id);
+   INLINE B Is_Packed                          (E Id);
+   INLINE B Is_Packed_Array_Type               (E Id);
+   INLINE B Is_Potentially_Use_Visible         (E Id);
+   INLINE B Is_Preelaborated                   (E Id);
+   INLINE B Is_Private_Composite               (E Id);
+   INLINE B Is_Private_Descendant              (E Id);
+   INLINE B Is_Psected                         (E Id);
+   INLINE B Is_Public                          (E Id);
+   INLINE B Is_Pure                            (E Id);
+   INLINE B Is_Remote_Call_Interface           (E Id);
+   INLINE B Is_Remote_Types                    (E Id);
+   INLINE B Is_Renaming_Of_Object              (E Id);
+   INLINE B Is_Shared_Passive                  (E Id);
+   INLINE B Is_Statically_Allocated            (E Id);
+   INLINE B Is_Tag                             (E Id);
+   INLINE B Is_Tagged_Type                     (E Id);
+   INLINE B Is_Thread_Body                     (E Id);
+   INLINE B Is_True_Constant                   (E Id);
+   INLINE B Is_Unchecked_Union                 (E Id);
+   INLINE B Is_Unsigned_Type                   (E Id);
+   INLINE B Is_VMS_Exception                   (E Id);
+   INLINE B Is_Valued_Procedure                (E Id);
+   INLINE B Is_Visible_Child_Unit              (E Id);
+
+   #define Is_Volatile einfo__is_volatile
+   B Is_Volatile                        (E Id);
+
+   #define Is_Wrapper_Package einfo__is_wrapper_package
+   B Is_Wrapper_Package                 (E Id);
+
+   INLINE B Kill_Elaboration_Checks            (E Id);
+   INLINE B Kill_Range_Checks                  (E Id);
+   INLINE B Kill_Tag_Checks                    (E Id);
+   INLINE E Last_Entity                        (E Id);
+   INLINE L Limited_Views                      (E Id);
+   INLINE E Lit_Indexes                        (E Id);
+   INLINE E Lit_Strings                        (E Id);
+   INLINE B Machine_Radix_10                   (E Id);
+   INLINE E Master_Id                          (E Id);
+   INLINE B Materialize_Entity                 (E Id);
+   INLINE M Mechanism                          (E Id);
+   INLINE U Modulus                            (E Id);
+   INLINE B Needs_Debug_Info                   (E Id);
+   INLINE B Needs_No_Actuals                   (E Id);
+   INLINE B Never_Set_In_Source                (E Id);
+   INLINE E Next_Inlined_Subprogram            (E Id);
+   INLINE B No_Pool_Assigned                   (E Id);
+   INLINE B No_Return                          (E Id);
+   INLINE B Non_Binary_Modulus                 (E Id);
+   INLINE E Non_Limited_View                   (E Id);
+   INLINE B Nonzero_Is_True                    (E Id);
+   INLINE U Normalized_First_Bit               (E Id);
+   INLINE U Normalized_Position                (E Id);
+   INLINE U Normalized_Position_Max            (E Id);
+   INLINE E Object_Ref                         (E Id);
+   INLINE E Original_Array_Type                (E Id);
+   INLINE E Original_Record_Component          (E Id);
+   INLINE E Packed_Array_Type                  (E Id);
+   INLINE E Parent_Subtype                     (E Id);
+   INLINE L Primitive_Operations               (E Id);
+   INLINE E Prival                             (E Id);
+   INLINE L Privals_Chain                      (E Id);
+   INLINE L Private_Dependents                 (E Id);
+   INLINE N Private_View                       (E Id);
+   INLINE E Protected_Body_Subprogram          (E Id);
+   INLINE E Protected_Formal                   (E Id);
+   INLINE E Protected_Operation                (E Id);
+   INLINE U RM_Size                            (E Id);
+   INLINE B Reachable                          (E Id);
+   INLINE B Referenced                         (E Id);
+   INLINE B Referenced_As_LHS                  (E Id);
+   INLINE N Referenced_Object                  (E Id);
+   INLINE N Register_Exception_Call            (E Id);
+   INLINE E Related_Array_Object               (E Id);
+   INLINE E Related_Instance                   (E Id);
+   INLINE N Renamed_Entity                     (E Id);
+   INLINE N Renamed_Object                     (E Id);
+   INLINE U Renaming_Map                       (E Id);
+   INLINE B Return_Present                     (E Id);
+   INLINE B Returns_By_Ref                     (E Id);
+   INLINE B Reverse_Bit_Order                  (E Id);
+   INLINE N Scalar_Range                       (E Id);
+   INLINE U Scale_Value                        (E Id);
+   INLINE U Scope_Depth_Value                  (E Id);
+   INLINE B Sec_Stack_Needed_For_Return        (E Id);
+   INLINE S Shadow_Entities                    (E Id);
+   INLINE E Shared_Var_Assign_Proc             (E Id);
+   INLINE E Shared_Var_Read_Proc               (E Id);
+   INLINE N Size_Check_Code                    (E Id);
+   INLINE B Size_Known_At_Compile_Time         (E Id);
+   INLINE B Size_Depends_On_Discriminant       (E Id);
+   INLINE R Small_Value                        (E Id);
+   INLINE E Spec_Entity                        (E Id);
+   INLINE E Storage_Size_Variable              (E Id);
+   INLINE L Stored_Constraint                  (E Id);
+   INLINE B Strict_Alignment                   (E Id);
+   INLINE U String_Literal_Length              (E Id);
+   INLINE N String_Literal_Low_Bound           (E Id);
+   INLINE B Suppress_Elaboration_Warnings      (E Id);
+   INLINE B Suppress_Init_Proc                 (E Id);
+   INLINE B Suppress_Style_Checks              (E Id);
+   INLINE B Treat_As_Volatile                  (E Id);
+   INLINE E Underlying_Full_View               (E Id);
+   INLINE N Unset_Reference                    (E Id);
+   INLINE B Uses_Sec_Stack                     (E Id);
+   INLINE B Vax_Float                          (E Id);
+   INLINE B Warnings_Off                       (E Id);
+   INLINE B Is_Access_Type                     (E Id);
+   INLINE B Is_Array_Type                      (E Id);
+   INLINE B Is_Class_Wide_Type                 (E Id);
+   INLINE B Is_Composite_Type                  (E Id);
+   INLINE B Is_Concurrent_Body                 (E Id);
+   INLINE B Is_Concurrent_Record_Type          (E Id);
+   INLINE B Is_Concurrent_Type                 (E Id);
+   INLINE B Is_Decimal_Fixed_Point_Type        (E Id);
+   INLINE B Is_Digits_Type                     (E Id);
+   INLINE B Is_Discrete_Or_Fixed_Point_Type    (E Id);
+   INLINE B Is_Discrete_Type                   (E Id);
+   INLINE B Is_Elementary_Type                 (E Id);
+   INLINE B Is_Entry                           (E Id);
+   INLINE B Is_Enumeration_Type                (E Id);
+   INLINE B Is_Fixed_Point_Type                (E Id);
+   INLINE B Is_Floating_Point_Type             (E Id);
+   INLINE B Is_Formal                          (E Id);
+   INLINE B Is_Formal_Subprogram               (E Id);
+   INLINE B Is_Generic_Actual_Type             (E Id);
+   INLINE B Is_Generic_Unit                    (E Id);
+   INLINE B Is_Generic_Type                    (E Id);
+   INLINE B Is_Generic_Subprogram              (E Id);
+   INLINE B Is_Incomplete_Or_Private_Type      (E Id);
+   INLINE B Is_Integer_Type                    (E Id);
+   INLINE B Is_Limited_Record                  (E Id);
+   INLINE B Is_Modular_Integer_Type            (E Id);
+   INLINE B Is_Named_Number                    (E Id);
+   INLINE B Is_Numeric_Type                    (E Id);
+   INLINE B Is_Object                          (E Id);
+   INLINE B Is_Ordinary_Fixed_Point_Type       (E Id);
+   INLINE B Is_Overloadable                    (E Id);
+   INLINE B Is_Overriding_Operation            (E Id);
+   INLINE B Is_Private_Type                    (E Id);
+   INLINE B Is_Protected_Type                  (E Id);
+   INLINE B Is_Real_Type                       (E Id);
+   INLINE B Is_Record_Type                     (E Id);
+   INLINE B Is_Scalar_Type                     (E Id);
+   INLINE B Is_Signed_Integer_Type             (E Id);
+   INLINE B Is_Subprogram                      (E Id);
+   INLINE B Is_Task_Type                       (E Id);
+   INLINE B Is_Type                            (E Id);
+
+   #define Address_Clause einfo__address_clause
+   N Address_Clause                     (E Id);
+
+   #define Alignment_Clause einfo__alignment_clause
+   N Alignment_Clause                   (E Id);
+
+   #define Ancestor_Subtype einfo__ancestor_subtype
+   E Ancestor_Subtype                   (E Id);
+
+   #define Base_Type einfo__base_type
+   E Base_Type                          (E Id);
+
+   #define Constant_Value einfo__constant_value
+   N Constant_Value                     (E Id);
+
+   #define Declaration_Node einfo__declaration_node
+   N Declaration_Node                   (E Id);
+
+   #define Designated_Type einfo__designated_type
+   E Designated_Type                    (E Id);
+
+   #define Enclosing_Dynamic_Scope einfo__enclosing_dynamic_scope
+   E Enclosing_Dynamic_Scope            (E Id);
+
+   #define First_Component einfo__first_component
+   E First_Component                    (E Id);
+
+   #define First_Discriminant einfo__first_discriminant
+   E First_Discriminant                 (E Id);
+
+   #define First_Formal einfo__first_formal
+   E First_Formal                       (E Id);
+
+   #define First_Stored_Discriminant einfo__first_stored_discriminant
+   E First_Stored_Discriminant          (E Id);
+
+   #define First_Subtype einfo__first_subtype
+   E First_Subtype                      (E Id);
+
+   #define Has_Attach_Handler einfo__has_attach_handler
+   B Has_Attach_Handler                 (E Id);
+
+   #define Has_Entries einfo__has_entries
+   B Has_Entries                        (E Id);
+
+   #define Has_Foreign_Convention einfo__has_foreign_convention
+   B Has_Foreign_Convention             (E Id);
+
+   #define Has_Private_Ancestor einfo__has_private_ancestor
+   B Has_Private_Ancestor               (E Id);
+
+   INLINE B Has_Private_Declaration            (E Id);
+
+   #define Implementation_Base_Type einfo__implementation_base_type
+   E Implementation_Base_Type           (E Id);
+
+   #define Is_Always_Inlined einfo__is_always_inlined
+   B Is_Always_Inlined                  (E Id);
+
+   #define Is_Boolean_Type einfo__is_boolean_type
+   B Is_Boolean_Type                    (E Id);
+
+   #define Is_By_Copy_Type einfo__is_by_copy_type
+   B Is_By_Copy_Type                    (E Id);
+
+   #define Is_By_Reference_Type einfo__is_by_reference_type
+   B Is_By_Reference_Type               (E Id);
+
+   #define Is_Derived_Type einfo__is_derived_type
+   B Is_Derived_Type                    (E Id);
+
+   #define Is_Dynamic_Scope einfo__is_dynamic_scope
+   B Is_Dynamic_Scope                   (E Id);
+
+   #define Is_Indefinite_Subtype einfo__is_indefinite_subtype
+   B Is_Indefinite_Subtype              (E Id);
+
+   #define Is_Limited_Type einfo__is_limited_type
+   B Is_Limited_Type                    (E Id);
+
+   #define Is_Package einfo__is_package
+   B Is_Package                         (E Id);
+
+   #define Is_Protected_Private einfo__is_protected_private
+   B Is_Protected_Private               (E Id);
+
+   #define Is_Protected_Record_Type einfo__is_protected_record_type
+   B Is_Protected_Record_Type           (E Id);
+
+   #define Is_Return_By_Reference_Type einfo__is_return_by_reference_type
+   B Is_Return_By_Reference_Type        (E Id);
+
+   #define Is_String_Type einfo__is_string_type
+   B Is_String_Type                     (E Id);
+
+   #define Is_Task_Record_Type einfo__is_task_record_type
+   B Is_Task_Record_Type                (E Id);
+
+   #define Next_Component einfo__next_component
+   E Next_Component                     (E Id);
+
+   #define Next_Discriminant einfo__next_discriminant
+   E Next_Discriminant                  (E Id);
+
+   #define Next_Formal einfo__next_formal
+   E Next_Formal                        (E Id);
+
+   #define Next_Formal_With_Extras einfo__next_formal_with_extras
+   E Next_Formal_With_Extras            (E Id);
+
+   INLINE E Next_Literal                       (E Id);
+
+   #define Next_Stored_Discriminant einfo__next_stored_discriminant
+   E Next_Stored_Discriminant           (E Id);
+
+   #define Number_Dimensions einfo__number_dimensions
+   Pos Number_Dimensions                  (E Id);
+
+   #define Number_Discriminants einfo__number_discriminants
+   Pos Number_Discriminants               (E Id);
+
+   #define Number_Entries einfo__number_entries
+   Nat Number_Entries                     (E Id);
+
+   #define Number_Formals einfo__number_formals
+   Pos Number_Formals                     (E Id);
+
+   INLINE Formal_Kind Parameter_Mode                     (E Id);
+
+   #define Root_Type einfo__root_type
+   E Root_Type                          (E Id);
+
+   #define Scope_Depth_Set einfo__scope_depth_set
+   B Scope_Depth_Set                    (E Id);
+
+   #define Size_Clause einfo__size_clause
+   N Size_Clause                        (E Id);
+
+   #define Tag_Component einfo__tag_component
+   E Tag_Component                      (E Id);
+
+   #define Type_High_Bound einfo__type_high_bound
+   N Type_High_Bound                    (E Id);
+
+   #define Type_Low_Bound einfo__type_low_bound
+   N Type_Low_Bound                     (E Id);
+
+   #define Underlying_Type einfo__underlying_type
+   E Underlying_Type                    (E Id);
+
+   #define Known_Alignment einfo__known_alignment
+   B Known_Alignment                       (Entity_Id E);
+
+   #define Known_Component_Bit_Offset einfo__known_component_bit_offset
+   B Known_Component_Bit_Offset            (Entity_Id E);
+
+   #define Known_Component_Size einfo__known_component_size
+   B Known_Component_Size                  (Entity_Id E);
+
+   #define Known_Esize einfo__known_esize
+   B Known_Esize                           (Entity_Id E);
+
+   #define Known_Normalized_First_Bit einfo__known_normalized_first_bit
+   B Known_Normalized_First_Bit            (Entity_Id E);
+
+   #define Known_Normalized_Position einfo__known_normalized_position
+   B Known_Normalized_Position             (Entity_Id E);
+
+   #define Known_Normalized_Position_Max einfo__known_normalized_position_max
+   B Known_Normalized_Position_Max         (Entity_Id E);
+
+   #define Known_RM_Size einfo__known_rm_size
+   B Known_RM_Size                         (Entity_Id E);
+
+   #define Known_Static_Component_Bit_Offset einfo__known_static_component_bit_offset
+   B Known_Static_Component_Bit_Offset     (Entity_Id E);
+
+   #define Known_Static_Component_Size einfo__known_static_component_size
+   B Known_Static_Component_Size           (Entity_Id E);
+
+   #define Known_Static_Esize einfo__known_static_esize
+   B Known_Static_Esize                    (Entity_Id E);
+
+   #define Known_Static_Normalized_First_Bit einfo__known_static_normalized_first_bit
+   B Known_Static_Normalized_First_Bit     (Entity_Id E);
+
+   #define Known_Static_Normalized_Position einfo__known_static_normalized_position
+   B Known_Static_Normalized_Position      (Entity_Id E);
+
+   #define Known_Static_Normalized_Position_Max einfo__known_static_normalized_position_max
+   B Known_Static_Normalized_Position_Max  (Entity_Id E);
+
+   #define Known_Static_RM_Size einfo__known_static_rm_size
+   B Known_Static_RM_Size                  (Entity_Id E);
+
+   #define Unknown_Alignment einfo__unknown_alignment
+   B Unknown_Alignment                     (Entity_Id E);
+
+   #define Unknown_Component_Bit_Offset einfo__unknown_component_bit_offset
+   B Unknown_Component_Bit_Offset          (Entity_Id E);
+
+   #define Unknown_Component_Size einfo__unknown_component_size
+   B Unknown_Component_Size                (Entity_Id E);
+
+   #define Unknown_Esize einfo__unknown_esize
+   B Unknown_Esize                         (Entity_Id E);
+
+   #define Unknown_Normalized_First_Bit einfo__unknown_normalized_first_bit
+   B Unknown_Normalized_First_Bit          (Entity_Id E);
+
+   #define Unknown_Normalized_Position einfo__unknown_normalized_position
+   B Unknown_Normalized_Position           (Entity_Id E);
+
+   #define Unknown_Normalized_Position_Max einfo__unknown_normalized_position_max
+   B Unknown_Normalized_Position_Max       (Entity_Id E);
+
+   #define Unknown_RM_Size einfo__unknown_rm_size
+   B Unknown_RM_Size                       (Entity_Id E);
+
+
+   INLINE L Accept_Address (E Id)
+      { return Elist21 (Id); }
+
+   INLINE E Access_Disp_Table (E Id)
+      { return Node16 (Implementation_Base_Type (Id)); }
+
+   INLINE E Actual_Subtype (E Id)
+      { return Node17 (Id); }
+
+   INLINE B Address_Taken (E Id)
+      { return Flag104 (Id); }
+
+   INLINE E Alias (E Id)
+      { return Node18 (Id); }
+
+   INLINE U Alignment (E Id)
+      { return Uint14 (Id); }
+
+   INLINE E Associated_Final_Chain (E Id)
+      { return Node23 (Id); }
+
+   INLINE E Associated_Formal_Package (E Id)
+      { return Node12 (Id); }
+
+   INLINE N Associated_Node_For_Itype (E Id)
+      { return Node8 (Id); }
+
+   INLINE E Associated_Storage_Pool (E Id)
+      { return Node22 (Root_Type (Id)); }
+
+   INLINE N Barrier_Function (E Id)
+      { return Node12 (Id); }
+
+   INLINE N Block_Node (E Id)
+      { return Node11 (Id); }
+
+   INLINE E Body_Entity (E Id)
+      { return Node19 (Id); }
+
+   INLINE B Body_Needed_For_SAL (E Id)
+      { return Flag40 (Id); }
+
+   INLINE B C_Pass_By_Copy (E Id)
+      { return Flag125 (Implementation_Base_Type (Id)); }
+
+   INLINE B Can_Never_Be_Null (E Id)
+      { return Flag38 (Id); }
+
+   INLINE B Checks_May_Be_Suppressed (E Id)
+      { return Flag31 (Id); }
+
+   INLINE E Class_Wide_Type (E Id)
+      { return Node9 (Id); }
+
+   INLINE E Cloned_Subtype (E Id)
+      { return Node16 (Id); }
+
+   INLINE U Component_Bit_Offset (E Id)
+      { return Uint11 (Id); }
+
+   INLINE N Component_Clause (E Id)
+      { return Node13 (Id); }
+
+   INLINE U Component_Size (E Id)
+      { return Uint22 (Implementation_Base_Type (Id)); }
+
+   INLINE E Component_Type (E Id)
+      { return Node20 (Implementation_Base_Type (Id)); }
+
+   INLINE E Corresponding_Concurrent_Type (E Id)
+      { return Node18 (Id); }
+
+   INLINE E Corresponding_Discriminant (E Id)
+      { return Node19 (Id); }
+
+   INLINE E Corresponding_Equality (E Id)
+      { return Node13 (Id); }
+
+   INLINE E Corresponding_Record_Type (E Id)
+      { return Node18 (Id); }
+
+   INLINE E Corresponding_Remote_Type (E Id)
+      { return Node22 (Id); }
+
+   INLINE N Current_Value (E Id)
+      { return Node9 (Id); }
+
+   INLINE E CR_Discriminant (E Id)
+      { return Node23 (Id); }
+
+   INLINE B Debug_Info_Off (E Id)
+      { return Flag166 (Id); }
+
+   INLINE E Debug_Renaming_Link (E Id)
+      { return Node13 (Id); }
+
+   INLINE E Default_Expr_Function (E Id)
+      { return Node21 (Id); }
+
+   INLINE B Default_Expressions_Processed (E Id)
+      { return Flag108 (Id); }
+
+   INLINE N Default_Value (E Id)
+      { return Node20 (Id); }
+
+   INLINE B Delay_Cleanups (E Id)
+      { return Flag114 (Id); }
+
+   INLINE B Delay_Subprogram_Descriptors (E Id)
+      { return Flag50 (Id); }
+
+   INLINE R Delta_Value (E Id)
+      { return Ureal18 (Id); }
+
+   INLINE L Dependent_Instances (E Id)
+      { return Elist8 (Id); }
+
+   INLINE B Depends_On_Private (E Id)
+      { return Flag14 (Id); }
+
+   INLINE U Digits_Value (E Id)
+      { return Uint17 (Id); }
+
+   INLINE E Directly_Designated_Type (E Id)
+      { return Node20 (Id); }
+
+   INLINE B Discard_Names (E Id)
+      { return Flag88 (Id); }
+
+   INLINE E Discriminal (E Id)
+      { return Node17 (Id); }
+
+   INLINE N Discriminal_Link (E Id)
+      { return Node10 (Id); }
+
+   INLINE E Discriminant_Checking_Func (E Id)
+      { return Node20 (Id); }
+
+   INLINE L Discriminant_Constraint (E Id)
+      { return Elist21 (Id); }
+
+   INLINE N Discriminant_Default_Value (E Id)
+      { return Node20 (Id); }
+
+   INLINE U Discriminant_Number (E Id)
+      { return Uint15 (Id); }
+
+   INLINE U DT_Entry_Count (E Id)
+      { return Uint15 (Id); }
+
+   INLINE U DT_Position (E Id)
+      { return Uint15 (Id); }
+
+   INLINE E DTC_Entity (E Id)
+      { return Node16 (Id); }
+
+   INLINE B Elaborate_All_Desirable (E Id)
+      { return Flag146 (Id); }
+
+   INLINE E Elaboration_Entity (E Id)
+      { return Node13 (Id); }
+
+   INLINE B Elaboration_Entity_Required (E Id)
+      { return Flag174 (Id); }
+
+   INLINE E Enclosing_Scope (E Id)
+      { return Node18 (Id); }
+
+   INLINE B Entry_Accepted (E Id)
+      { return Flag152 (Id); }
+
+   INLINE E Entry_Bodies_Array (E Id)
+      { return Node15 (Id); }
+
+   INLINE E Entry_Cancel_Parameter (E Id)
+      { return Node23 (Id); }
+
+   INLINE E Entry_Component (E Id)
+      { return Node11 (Id); }
+
+   INLINE E Entry_Formal (E Id)
+      { return Node16 (Id); }
+
+   INLINE N Entry_Index_Constant (E Id)
+      { return Node18 (Id); }
+
+   INLINE E Entry_Parameters_Type (E Id)
+      { return Node15 (Id); }
+
+   INLINE E Enum_Pos_To_Rep (E Id)
+      { return Node23 (Id); }
+
+   INLINE Uint Enumeration_Pos (E Id)
+      { return Uint11 (Id); }
+
+   INLINE U Enumeration_Rep (E Id)
+      { return Uint12 (Id); }
+
+   INLINE N Enumeration_Rep_Expr (E Id)
+      { return Node22 (Id); }
+
+   INLINE E Equivalent_Type (E Id)
+      { return Node18 (Id); }
+
+   INLINE Uint Esize (E Id)
+      { return Uint12 (Id); }
+
+   INLINE Uint Exception_Code (E Id)
+      { return Uint22 (Id); }
+
+   INLINE E Extra_Accessibility (E Id)
+      { return Node13 (Id); }
+
+   INLINE E Extra_Constrained (E Id)
+      { return Node23 (Id); }
+
+   INLINE E Extra_Formal (E Id)
+      { return Node15 (Id); }
+
+   INLINE E Finalization_Chain_Entity (E Id)
+      { return Node19 (Id); }
+
+   INLINE E First_Entity (E Id)
+      { return Node17 (Id); }
+
+   INLINE N First_Index (E Id)
+      { return Node17 (Id); }
+
+   INLINE E First_Literal (E Id)
+      { return Node17 (Id); }
+
+   INLINE E First_Optional_Parameter (E Id)
+      { return Node14 (Id); }
+
+   INLINE E First_Private_Entity (E Id)
+      { return Node16 (Id); }
+
+   INLINE E First_Rep_Item (E Id)
+      { return Node6 (Id); }
+
+   INLINE N Freeze_Node (E Id)
+      { return Node7 (Id); }
+
+   INLINE B From_With_Type (E Id)
+      { return Flag159 (Id); }
+
+   INLINE E Full_View (E Id)
+      { return Node11 (Id); }
+
+   INLINE B Function_Returns_With_DSP (E Id)
+      { return Flag169 (Id); }
+
+   INLINE E Generic_Homonym (E Id)
+      { return Node11 (Id); }
+
+   INLINE L Generic_Renamings (E Id)
+      { return Elist23 (Id); }
+
+   INLINE S Handler_Records (E Id)
+      { return List10 (Id); }
+
+   INLINE B Has_Aliased_Components (E Id)
+      { return Flag135 (Implementation_Base_Type (Id)); }
+
+   INLINE B Has_Alignment_Clause (E Id)
+      { return Flag46 (Id); }
+
+   INLINE B Has_All_Calls_Remote (E Id)
+      { return Flag79 (Id); }
+
+   INLINE B Has_Atomic_Components (E Id)
+      { return Flag86 (Implementation_Base_Type (Id)); }
+
+   INLINE B Has_Biased_Representation (E Id)
+      { return Flag139 (Id); }
+
+   INLINE B Has_Completion (E Id)
+      { return Flag26 (Id); }
+
+   INLINE B Has_Completion_In_Body (E Id)
+      { return Flag71 (Id); }
+
+   INLINE B Has_Complex_Representation (E Id)
+      { return Flag140 (Implementation_Base_Type (Id)); }
+
+   INLINE B Has_Component_Size_Clause (E Id)
+      { return Flag68 (Implementation_Base_Type (Id)); }
+
+   INLINE B Has_Controlled_Component (E Id)
+      { return Flag43 (Base_Type (Id)); }
+
+   INLINE B Has_Contiguous_Rep (E Id)
+      { return Flag181 (Id); }
+
+   INLINE B Has_Controlling_Result (E Id)
+      { return Flag98 (Id); }
+
+   INLINE B Has_Convention_Pragma (E Id)
+      { return Flag119 (Id); }
+
+   INLINE B Has_Delayed_Freeze (E Id)
+      { return Flag18 (Id); }
+
+   INLINE B Has_Discriminants (E Id)
+      { return Flag5 (Id); }
+
+   INLINE B Has_Enumeration_Rep_Clause (E Id)
+      { return Flag66 (Id); }
+
+   INLINE B Has_Exit (E Id)
+      { return Flag47 (Id); }
+
+   INLINE B Has_External_Tag_Rep_Clause (E Id)
+      { return Flag110 (Id); }
+
+   INLINE B Has_Forward_Instantiation (E Id)
+      { return Flag175 (Id); }
+
+   INLINE B Has_Fully_Qualified_Name (E Id)
+      { return Flag173 (Id); }
+
+   INLINE B Has_Gigi_Rep_Item (E Id)
+      { return Flag82 (Id); }
+
+   INLINE B Has_Homonym (E Id)
+      { return Flag56 (Id); }
+
+   INLINE B Has_Machine_Radix_Clause (E Id)
+      { return Flag83 (Id); }
+
+   INLINE B Has_Master_Entity (E Id)
+      { return Flag21 (Id); }
+
+   INLINE B Has_Missing_Return (E Id)
+      { return Flag142 (Id); }
+
+   INLINE B Has_Nested_Block_With_Handler (E Id)
+      { return Flag101 (Id); }
+
+   INLINE B Has_Non_Standard_Rep (E Id)
+      { return Flag75 (Implementation_Base_Type (Id)); }
+
+   INLINE B Has_Object_Size_Clause (E Id)
+      { return Flag172 (Id); }
+
+   INLINE B Has_Per_Object_Constraint (E Id)
+      { return Flag154 (Id); }
+
+   INLINE B Has_Pragma_Controlled (E Id)
+      { return Flag27 (Implementation_Base_Type (Id)); }
+
+   INLINE B Has_Pragma_Elaborate_Body (E Id)
+      { return Flag150 (Id); }
+
+   INLINE B Has_Pragma_Inline (E Id)
+      { return Flag157 (Id); }
+
+   INLINE B Has_Pragma_Pack (E Id)
+      { return Flag121 (Implementation_Base_Type (Id)); }
+
+   INLINE B Has_Pragma_Pure_Function (E Id)
+      { return Flag179 (Id); }
+
+   INLINE B Has_Pragma_Unreferenced (E Id)
+      { return Flag180 (Id); }
+
+   INLINE B Has_Primitive_Operations (E Id)
+      { return Flag120 (Base_Type (Id)); }
+
+   INLINE B Has_Private_Declaration (E Id)
+      { return Flag155 (Id); }
+
+   INLINE B Has_Qualified_Name (E Id)
+      { return Flag161 (Id); }
+
+   INLINE B Has_Record_Rep_Clause (E Id)
+      { return Flag65 (Implementation_Base_Type (Id)); }
+
+   INLINE B Has_Recursive_Call (E Id)
+      { return Flag143 (Id); }
+
+   INLINE B Has_Size_Clause (E Id)
+      { return Flag29 (Id); }
+
+   INLINE B Has_Small_Clause (E Id)
+      { return Flag67 (Id); }
+
+   INLINE B Has_Specified_Layout (E Id)
+      { return Flag100 (Implementation_Base_Type (Id)); }
+
+   INLINE B Has_Storage_Size_Clause (E Id)
+      { return Flag23 (Implementation_Base_Type (Id)); }
+
+   INLINE B Has_Subprogram_Descriptor (E Id)
+      { return Flag93 (Id); }
+
+   INLINE B Has_Task (E Id)
+      { return Flag30 (Base_Type (Id)); }
+
+   INLINE B Has_Unchecked_Union (E Id)
+      { return Flag123 (Base_Type (Id)); }
+
+   INLINE B Has_Unknown_Discriminants (E Id)
+      { return Flag72 (Id); }
+
+   INLINE B Has_Volatile_Components (E Id)
+      { return Flag87 (Implementation_Base_Type (Id)); }
+
+   INLINE B Has_Xref_Entry (E Id)
+      { return Flag182 (Implementation_Base_Type (Id)); }
+
+   INLINE E Hiding_Loop_Variable (E Id)
+      { return Node8 (Id); }
+
+   INLINE E Homonym (E Id)
+      { return Node4 (Id); }
+
+   INLINE B In_Package_Body (E Id)
+      { return Flag48 (Id); }
+
+   INLINE B In_Private_Part (E Id)
+      { return Flag45 (Id); }
+
+   INLINE B In_Use (E Id)
+      { return Flag8 (Id); }
+
+   INLINE L Inner_Instances (E Id)
+      { return Elist23 (Id); }
+
+   INLINE N Interface_Name (E Id)
+      { return Node21 (Id); }
+
+   INLINE B Is_Abstract (E Id)
+      { return Flag19 (Id); }
+
+   INLINE B Is_Access_Constant (E Id)
+      { return Flag69 (Id); }
+
+   INLINE B Is_Aliased (E Id)
+      { return Flag15 (Id); }
+
+   INLINE B Is_AST_Entry (E Id)
+      { return Flag132 (Id); }
+
+   INLINE B Is_Asynchronous (E Id)
+      { return Flag81 (Id); }
+
+   INLINE B Is_Atomic (E Id)
+      { return Flag85 (Id); }
+
+   INLINE B Is_Bit_Packed_Array (E Id)
+      { return Flag122 (Implementation_Base_Type (Id)); }
+
+   INLINE B Is_Called (E Id)
+      { return Flag102 (Id); }
+
+   INLINE B Is_Character_Type (E Id)
+      { return Flag63 (Id); }
+
+   INLINE B Is_Child_Unit (E Id)
+      { return Flag73 (Id); }
+
+   INLINE B Is_Class_Wide_Equivalent_Type (E Id)
+      { return Flag35 (Id); }
+
+   INLINE B Is_Compilation_Unit (E Id)
+      { return Flag149 (Id); }
+
+   INLINE B Is_Completely_Hidden (E Id)
+      { return Flag103 (Id); }
+
+   INLINE B Is_Constr_Subt_For_U_Nominal (E Id)
+      { return Flag80 (Id); }
+
+   INLINE B Is_Constr_Subt_For_UN_Aliased (E Id)
+      { return Flag141 (Id); }
+
+   INLINE B Is_Constrained (E Id)
+      { return Flag12 (Id); }
+
+   INLINE B Is_Constructor (E Id)
+      { return Flag76 (Id); }
+
+   INLINE B Is_Controlled (E Id)
+      { return Flag42 (Base_Type (Id)); }
+
+   INLINE B Is_Controlling_Formal (E Id)
+      { return Flag97 (Id); }
+
+   INLINE B Is_CPP_Class (E Id)
+      { return Flag74 (Id); }
+
+   INLINE B Is_Discrim_SO_Function (E Id)
+      { return Flag176 (Id); }
+
+   INLINE B Is_Dispatching_Operation (E Id)
+      { return Flag6 (Id); }
+
+   INLINE B Is_Eliminated (E Id)
+      { return Flag124 (Id); }
+
+   INLINE B Is_Entry_Formal (E Id)
+      { return Flag52 (Id); }
+
+   INLINE B Is_Exported (E Id)
+      { return Flag99 (Id); }
+
+   INLINE B Is_First_Subtype (E Id)
+      { return Flag70 (Id); }
+
+   INLINE B Is_For_Access_Subtype (E Id)
+      { return Flag118 (Id); }
+
+   INLINE B Is_Formal_Subprogram (E Id)
+      { return Flag111 (Id); }
+
+   INLINE B Is_Frozen (E Id)
+      { return Flag4 (Id); }
+
+   INLINE B Is_Generic_Actual_Type (E Id)
+      { return Flag94 (Id); }
+
+   INLINE B Is_Generic_Instance (E Id)
+      { return Flag130 (Id); }
+
+   INLINE B Is_Generic_Type (E Id)
+      { return Flag13 (Id); }
+
+   INLINE B Is_Hidden (E Id)
+      { return Flag57 (Id); }
+
+   INLINE B Is_Hidden_Open_Scope (E Id)
+      { return Flag171 (Id); }
+
+   INLINE B Is_Immediately_Visible (E Id)
+      { return Flag7 (Id); }
+
+   INLINE B Is_Imported (E Id)
+      { return Flag24 (Id); }
+
+   INLINE B Is_Inlined (E Id)
+      { return Flag11 (Id); }
+
+   INLINE B Is_Instantiated (E Id)
+      { return Flag126 (Id); }
+
+   INLINE B Is_Internal (E Id)
+      { return Flag17 (Id); }
+
+   INLINE B Is_Interrupt_Handler (E Id)
+      { return Flag89 (Id); }
+
+   INLINE B Is_Intrinsic_Subprogram (E Id)
+      { return Flag64 (Id); }
+
+   INLINE B Is_Itype (E Id)
+      { return Flag91 (Id); }
+
+   INLINE B Is_Known_Non_Null (E Id)
+      { return Flag37 (Id); }
+
+   INLINE B Is_Known_Valid (E Id)
+      { return Flag170 (Id); }
+
+   INLINE B Is_Limited_Composite (E Id)
+      { return Flag106 (Id); }
+
+   INLINE B Is_Limited_Record (E Id)
+      { return Flag25 (Id); }
+
+   INLINE B Is_Machine_Code_Subprogram (E Id)
+      { return Flag137 (Id); }
+
+   INLINE B Is_Non_Static_Subtype (E Id)
+      { return Flag109 (Id); }
+
+   INLINE B Is_Null_Init_Proc (E Id)
+      { return Flag178 (Id); }
+
+   INLINE B Is_Optional_Parameter (E Id)
+      { return Flag134 (Id); }
+
+   INLINE B Is_Overriding_Operation (E Id)
+      { return Flag39 (Id); }
+
+   INLINE B Is_Package_Body_Entity (E Id)
+      { return Flag160 (Id); }
+
+   INLINE B Is_Packed (E Id)
+      { return Flag51 (Implementation_Base_Type (Id)); }
+
+   INLINE B Is_Packed_Array_Type (E Id)
+      { return Flag138 (Id); }
+
+   INLINE B Is_Potentially_Use_Visible (E Id)
+      { return Flag9 (Id); }
+
+   INLINE B Is_Preelaborated (E Id)
+      { return Flag59 (Id); }
+
+   INLINE B Is_Private_Composite (E Id)
+      { return Flag107 (Id); }
+
+   INLINE B Is_Private_Descendant (E Id)
+      { return Flag53 (Id); }
+
+   INLINE B Is_Psected (E Id)
+      { return Flag153 (Id); }
+
+   INLINE B Is_Public (E Id)
+      { return Flag10 (Id); }
+
+   INLINE B Is_Pure (E Id)
+      { return Flag44 (Id); }
+
+   INLINE B Is_Remote_Call_Interface (E Id)
+      { return Flag62 (Id); }
+
+   INLINE B Is_Remote_Types (E Id)
+      { return Flag61 (Id); }
+
+   INLINE B Is_Renaming_Of_Object (E Id)
+      { return Flag112 (Id); }
+
+   INLINE B Is_Shared_Passive (E Id)
+      { return Flag60 (Id); }
+
+   INLINE B Is_Statically_Allocated (E Id)
+      { return Flag28 (Id); }
+
+   INLINE B Is_Tag (E Id)
+      { return Flag78 (Id); }
+
+   INLINE B Is_Tagged_Type (E Id)
+      { return Flag55 (Id); }
+
+   INLINE B Is_Thread_Body (E Id)
+      { return Flag77 (Id); }
+
+   INLINE B Is_True_Constant (E Id)
+      { return Flag163 (Id); }
+
+   INLINE B Is_Unchecked_Union (E Id)
+      { return Flag117 (Id); }
+
+   INLINE B Is_Unsigned_Type (E Id)
+      { return Flag144 (Id); }
+
+   INLINE B Is_Valued_Procedure (E Id)
+      { return Flag127 (Id); }
+
+   INLINE B Is_Visible_Child_Unit (E Id)
+      { return Flag116 (Id); }
+
+   INLINE B Is_VMS_Exception (E Id)
+      { return Flag133 (Id); }
+
+   INLINE B Kill_Elaboration_Checks (E Id)
+      { return Flag32 (Id); }
+
+   INLINE B Kill_Range_Checks (E Id)
+      { return Flag33 (Id); }
+
+   INLINE B Kill_Tag_Checks (E Id)
+      { return Flag34 (Id); }
+
+   INLINE E Last_Entity (E Id)
+      { return Node20 (Id); }
+
+   INLINE L Limited_Views (E Id)
+      { return Elist23 (Id); }
+
+   INLINE E Lit_Indexes (E Id)
+      { return Node15 (Id); }
+
+   INLINE E Lit_Strings (E Id)
+      { return Node16 (Id); }
+
+   INLINE B Machine_Radix_10 (E Id)
+      { return Flag84 (Id); }
+
+   INLINE E Master_Id (E Id)
+      { return Node17 (Id); }
+
+   INLINE B Materialize_Entity (E Id)
+      { return Flag168 (Id); }
+
+   INLINE M Mechanism (E Id)
+      { return UI_To_Int (Uint8 (Id)); }
+
+   INLINE Uint Modulus (E Id)
+      { return Uint17 (Base_Type (Id)); }
+
+   INLINE B Needs_Debug_Info (E Id)
+      { return Flag147 (Id); }
+
+   INLINE B Needs_No_Actuals (E Id)
+      { return Flag22 (Id); }
+
+   INLINE B Never_Set_In_Source (E Id)
+      { return Flag115 (Id); }
+
+   INLINE E Next_Inlined_Subprogram (E Id)
+      { return Node12 (Id); }
+
+   INLINE B No_Pool_Assigned (E Id)
+      { return Flag131 (Root_Type (Id)); }
+
+   INLINE B No_Return (E Id)
+      { return Flag113 (Id); }
+
+   INLINE B Non_Binary_Modulus (E Id)
+      { return Flag58 (Base_Type (Id)); }
+
+   INLINE E Non_Limited_View (E Id)
+      { return Node17 (Id); }
+
+   INLINE B Nonzero_Is_True (E Id)
+      { return Flag162 (Base_Type (Id)); }
+
+   INLINE U Normalized_First_Bit (E Id)
+      { return Uint8 (Id); }
+
+   INLINE U Normalized_Position (E Id)
+      { return Uint14 (Id); }
+
+   INLINE U Normalized_Position_Max (E Id)
+      { return Uint10 (Id); }
+
+   INLINE E Object_Ref (E Id)
+      { return Node17 (Id); }
+
+   INLINE E Original_Array_Type (E Id)
+      { return Node21 (Id); }
+
+   INLINE E Original_Record_Component (E Id)
+      { return Node22 (Id); }
+
+   INLINE E Packed_Array_Type (E Id)
+      { return Node23 (Id); }
+
+   INLINE E Parent_Subtype (E Id)
+      { return Node19 (Id); }
+
+   INLINE L Primitive_Operations (E Id)
+      { return Elist15 (Id); }
+
+   INLINE E Prival (E Id)
+      { return Node17 (Id); }
+
+   INLINE L Privals_Chain (E Id)
+      { return Elist23 (Id); }
+
+   INLINE L Private_Dependents (E Id)
+      { return Elist18 (Id); }
+
+   INLINE N Private_View (E Id)
+      { return Node22 (Id); }
+
+   INLINE E Protected_Body_Subprogram (E Id)
+      { return Node11 (Id); }
+
+   INLINE E Protected_Formal (E Id)
+      { return Node22 (Id); }
+
+   INLINE N Protected_Operation (E Id)
+      { return Node23 (Id); }
+
+   INLINE B Reachable (E Id)
+      { return Flag49 (Id); }
+
+   INLINE B Referenced (E Id)
+      { return Flag156 (Id); }
+
+   INLINE B Referenced_As_LHS (E Id)
+      { return Flag36 (Id); }
+
+   INLINE N Referenced_Object (E Id)
+      { return Node10 (Id); }
+
+   INLINE N Register_Exception_Call (E Id)
+      { return Node20 (Id); }
+
+   INLINE E Related_Array_Object (E Id)
+      { return Node19 (Id); }
+
+   INLINE E Related_Instance (E Id)
+      { return Node15 (Id); }
+
+   INLINE N Renamed_Entity (E Id)
+      { return Node18 (Id); }
+
+   INLINE N Renamed_Object (E Id)
+      { return Node18 (Id); }
+
+   INLINE U Renaming_Map (E Id)
+      { return Uint9 (Id); }
+
+   INLINE B Return_Present (E Id)
+      { return Flag54 (Id); }
+
+   INLINE B Returns_By_Ref (E Id)
+      { return Flag90 (Id); }
+
+   INLINE B Reverse_Bit_Order (E Id)
+      { return Flag164 (Base_Type (Id)); }
+
+   INLINE U RM_Size (E Id)
+      { return Uint13 (Id); }
+
+   INLINE N Scalar_Range (E Id)
+      { return Node20 (Id); }
+
+   INLINE U Scale_Value (E Id)
+      { return Uint15 (Id); }
+
+   INLINE U Scope_Depth_Value (E Id)
+      { return Uint22 (Id); }
+
+   INLINE B Sec_Stack_Needed_For_Return (E Id)
+      { return Flag167 (Id); }
+
+   INLINE S Shadow_Entities (E Id)
+      { return List14 (Id); }
+
+   INLINE E Shared_Var_Assign_Proc (E Id)
+      { return Node22 (Id); }
+
+   INLINE E Shared_Var_Read_Proc (E Id)
+      { return Node15 (Id); }
+
+   INLINE N Size_Check_Code (E Id)
+      { return Node19 (Id); }
+
+   INLINE B Size_Depends_On_Discriminant (E Id)
+      { return Flag177 (Id); }
+
+   INLINE B Size_Known_At_Compile_Time (E Id)
+      { return Flag92 (Id); }
+
+   INLINE R Small_Value (E Id)
+      { return Ureal21 (Id); }
+
+   INLINE E Spec_Entity (E Id)
+      { return Node19 (Id); }
+
+   INLINE E Storage_Size_Variable (E Id)
+      { return Node15 (Implementation_Base_Type (Id)); }
+
+   INLINE L Stored_Constraint (E Id)
+      { return Elist23 (Id); }
+
+   INLINE B Strict_Alignment (E Id)
+      { return Flag145 (Implementation_Base_Type (Id)); }
+
+   INLINE U String_Literal_Length (E Id)
+      { return Uint16 (Id); }
+
+   INLINE N String_Literal_Low_Bound (E Id)
+      { return Node15 (Id); }
+
+   INLINE B Suppress_Elaboration_Warnings (E Id)
+      { return Flag148 (Id); }
+
+   INLINE B Suppress_Init_Proc (E Id)
+      { return Flag105 (Base_Type (Id)); }
+
+   INLINE B Suppress_Style_Checks (E Id)
+      { return Flag165 (Id); }
+
+   INLINE B Treat_As_Volatile (E Id)
+      { return Flag41 (Id); }
+
+   INLINE E Underlying_Full_View (E Id)
+      { return Node19 (Id); }
+
+   INLINE N Unset_Reference (E Id)
+      { return Node16 (Id); }
+
+   INLINE B Uses_Sec_Stack (E Id)
+      { return Flag95 (Id); }
+
+   INLINE B Vax_Float (E Id)
+      { return Flag151 (Base_Type (Id)); }
+
+   INLINE B Warnings_Off (E Id)
+      { return Flag96 (Id); }
+
+   INLINE B Is_Access_Type                      (E Id)
+      { return IN (Ekind (Id), Access_Kind); }
+
+   INLINE B Is_Array_Type                       (E Id)
+      { return IN (Ekind (Id), Array_Kind); }
+
+   INLINE B Is_Class_Wide_Type                  (E Id)
+      { return IN (Ekind (Id), Class_Wide_Kind); }
+
+   INLINE B Is_Composite_Type                   (E Id)
+      { return IN (Ekind (Id), Composite_Kind); }
+
+   INLINE B Is_Concurrent_Body                  (E Id)
+      { return IN (Ekind (Id), Concurrent_Body_Kind); }
+
+   INLINE B Is_Concurrent_Record_Type           (E Id)
+      { return Flag20 (Id); }
+
+   INLINE B Is_Concurrent_Type                  (E Id)
+      { return IN (Ekind (Id), Concurrent_Kind); }
+
+   INLINE B Is_Decimal_Fixed_Point_Type         (E Id)
+      { return IN (Ekind (Id), Decimal_Fixed_Point_Kind); }
+
+   INLINE B Is_Digits_Type                      (E Id)
+      { return IN (Ekind (Id), Digits_Kind); }
+
+   INLINE B Is_Discrete_Or_Fixed_Point_Type     (E Id)
+      { return IN (Ekind (Id), Discrete_Or_Fixed_Point_Kind); }
+
+   INLINE B Is_Discrete_Type                    (E Id)
+      { return IN (Ekind (Id), Discrete_Kind); }
+
+   INLINE B Is_Elementary_Type                  (E Id)
+      { return IN (Ekind (Id), Elementary_Kind); }
+
+   INLINE B Is_Entry                            (E Id)
+      { return IN (Ekind (Id), Entry_Kind); }
+
+   INLINE B Is_Enumeration_Type                 (E Id)
+      { return IN (Ekind (Id), Enumeration_Kind); }
+
+   INLINE B Is_Fixed_Point_Type                 (E Id)
+      { return IN (Ekind (Id), Fixed_Point_Kind); }
+
+   INLINE B Is_Floating_Point_Type              (E Id)
+      { return IN (Ekind (Id), Float_Kind); }
+
+   INLINE B Is_Formal                           (E Id)
+      { return IN (Ekind (Id), Formal_Kind); }
+
+   INLINE B Is_Generic_Subprogram               (E Id)
+      { return IN (Ekind (Id), Generic_Subprogram_Kind); }
+
+   INLINE B Is_Generic_Unit                     (E Id)
+      { return IN (Ekind (Id), Generic_Unit_Kind); }
+
+   INLINE B Is_Incomplete_Or_Private_Type       (E Id)
+      { return IN (Ekind (Id), Incomplete_Or_Private_Kind); }
+
+   INLINE B Is_Integer_Type                     (E Id)
+      { return IN (Ekind (Id), Integer_Kind); }
+
+   INLINE B Is_Modular_Integer_Type             (E Id)
+      { return IN (Ekind (Id), Modular_Integer_Kind); }
+
+   INLINE B Is_Named_Number                     (E Id)
+      { return IN (Ekind (Id), Named_Kind); }
+
+   INLINE B Is_Numeric_Type                     (E Id)
+      { return IN (Ekind (Id), Numeric_Kind); }
+
+   INLINE B Is_Object                           (E Id)
+      { return IN (Ekind (Id), Object_Kind); }
+
+   INLINE B Is_Ordinary_Fixed_Point_Type        (E Id)
+      { return IN (Ekind (Id), Ordinary_Fixed_Point_Kind); }
+
+   INLINE B Is_Overloadable                     (E Id)
+      { return IN (Ekind (Id), Overloadable_Kind); }
+
+   INLINE B Is_Private_Type                     (E Id)
+      { return IN (Ekind (Id), Private_Kind); }
+
+   INLINE B Is_Protected_Type                   (E Id)
+      { return IN (Ekind (Id), Protected_Kind); }
+
+   INLINE B Is_Real_Type                        (E Id)
+      { return IN (Ekind (Id), Real_Kind); }
+
+   INLINE B Is_Record_Type                      (E Id)
+      { return IN (Ekind (Id), Record_Kind); }
+
+   INLINE B Is_Scalar_Type                      (E Id)
+      { return IN (Ekind (Id), Scalar_Kind); }
+
+   INLINE B Is_Signed_Integer_Type              (E Id)
+      { return IN (Ekind (Id), Signed_Integer_Kind); }
+
+   INLINE B Is_Subprogram                       (E Id)
+      { return IN (Ekind (Id), Subprogram_Kind); }
+
+   INLINE B Is_Task_Type                        (E Id)
+      { return IN (Ekind (Id), Task_Kind); }
+
+   INLINE B Is_Type                             (E Id)
+      { return IN (Ekind (Id), Type_Kind); }
+
+   INLINE N Entry_Index_Type (E Id)
+      { return Etype (Discrete_Subtype_Definition (Parent (Id))); }
+
+   INLINE Node_Id Next_Index (Node_Id Id)
+      { return Next (Id); }
+
+   INLINE E Next_Literal (E Id)
+      { return Next (Id); }
+
+   INLINE Formal_Kind Parameter_Mode (E Id)
+      { return Ekind (Id); }
+
+/* End of einfo.h (C version of Einfo package specification) */
--- gcc-3.4.0/obj-amd64-pld-linux/gcc/ada/nmake.adb.orig	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.4.0/obj-amd64-pld-linux/gcc/ada/nmake.adb	2004-06-02 00:52:35.000000000 +0200
@@ -0,0 +1,2867 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                         GNAT COMPILER COMPONENTS                         --
+--                                                                          --
+--                                N M A K E                                 --
+--                                                                          --
+--                                 B o d y                                  --
+--                                                                          --
+--          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --
+--                                                                          --
+-- GNAT is free software;  you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --
+-- for  more details.  You should have  received  a copy of the GNU General --
+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --
+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --
+-- MA 02111-1307, USA.                                                      --
+--                                                                          --
+-- GNAT was originally developed  by the GNAT team at  New York University. --
+-- Extensive contributions were provided by Ada Core Technologies Inc.      --
+--                                                                          --
+------------------------------------------------------------------------------
+
+pragma Style_Checks (All_Checks);
+--  Turn off subprogram order checking, since the routines here are
+--  generated automatically in order.
+
+
+with Atree;  use Atree;
+with Sinfo;  use Sinfo;
+with Snames; use Snames;
+with Stand;  use Stand;
+
+package body Nmake is
+
+   function Make_Unused_At_Start (Sloc : Source_Ptr)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Unused_At_Start, Sloc);
+   begin
+      return N;
+   end Make_Unused_At_Start;
+
+   function Make_Unused_At_End (Sloc : Source_Ptr)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Unused_At_End, Sloc);
+   begin
+      return N;
+   end Make_Unused_At_End;
+
+   function Make_Identifier (Sloc : Source_Ptr;
+      Chars                        : Name_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Identifier, Sloc);
+   begin
+      Set_Chars (N, Chars);
+      return N;
+   end Make_Identifier;
+
+   function Make_Integer_Literal (Sloc : Source_Ptr;
+      Intval                       : Uint)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Integer_Literal, Sloc);
+   begin
+      Set_Intval (N, Intval);
+      return N;
+   end Make_Integer_Literal;
+
+   function Make_Real_Literal (Sloc : Source_Ptr;
+      Realval                      : Ureal)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Real_Literal, Sloc);
+   begin
+      Set_Realval (N, Realval);
+      return N;
+   end Make_Real_Literal;
+
+   function Make_Character_Literal (Sloc : Source_Ptr;
+      Chars                        : Name_Id;
+      Char_Literal_Value           : Char_Code)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Character_Literal, Sloc);
+   begin
+      Set_Chars (N, Chars);
+      Set_Char_Literal_Value (N, Char_Literal_Value);
+      return N;
+   end Make_Character_Literal;
+
+   function Make_String_Literal (Sloc : Source_Ptr;
+      Strval                       : String_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_String_Literal, Sloc);
+   begin
+      Set_Strval (N, Strval);
+      return N;
+   end Make_String_Literal;
+
+   function Make_Pragma (Sloc : Source_Ptr;
+      Chars                        : Name_Id;
+      Pragma_Argument_Associations : List_Id := No_List;
+      Debug_Statement              : Node_Id := Empty)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Pragma, Sloc);
+   begin
+      Set_Chars (N, Chars);
+      Set_Pragma_Argument_Associations
+        (N, Pragma_Argument_Associations);
+      Set_Debug_Statement (N, Debug_Statement);
+      return N;
+   end Make_Pragma;
+
+   function Make_Pragma_Argument_Association (Sloc : Source_Ptr;
+      Chars                        : Name_Id := No_Name;
+      Expression                   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Pragma_Argument_Association, Sloc);
+   begin
+      Set_Chars (N, Chars);
+      Set_Expression (N, Expression);
+      return N;
+   end Make_Pragma_Argument_Association;
+
+   function Make_Defining_Identifier (Sloc : Source_Ptr;
+      Chars                        : Name_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Entity (N_Defining_Identifier, Sloc);
+   begin
+      Set_Chars (N, Chars);
+      return N;
+   end Make_Defining_Identifier;
+
+   function Make_Full_Type_Declaration (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id;
+      Discriminant_Specifications  : List_Id := No_List;
+      Type_Definition              : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Full_Type_Declaration, Sloc);
+   begin
+      Set_Defining_Identifier (N, Defining_Identifier);
+      Set_Discriminant_Specifications (N, Discriminant_Specifications);
+      Set_Type_Definition (N, Type_Definition);
+      return N;
+   end Make_Full_Type_Declaration;
+
+   function Make_Subtype_Declaration (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id;
+      Subtype_Indication           : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Subtype_Declaration, Sloc);
+   begin
+      Set_Defining_Identifier (N, Defining_Identifier);
+      Set_Subtype_Indication (N, Subtype_Indication);
+      return N;
+   end Make_Subtype_Declaration;
+
+   function Make_Subtype_Indication (Sloc : Source_Ptr;
+      Subtype_Mark                 : Node_Id;
+      Constraint                   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Subtype_Indication, Sloc);
+   begin
+      Set_Subtype_Mark (N, Subtype_Mark);
+      Set_Constraint (N, Constraint);
+      return N;
+   end Make_Subtype_Indication;
+
+   function Make_Object_Declaration (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id;
+      Aliased_Present              : Boolean := False;
+      Constant_Present             : Boolean := False;
+      Object_Definition            : Node_Id;
+      Expression                   : Node_Id := Empty)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Object_Declaration, Sloc);
+   begin
+      Set_Defining_Identifier (N, Defining_Identifier);
+      Set_Aliased_Present (N, Aliased_Present);
+      Set_Constant_Present (N, Constant_Present);
+      Set_Object_Definition (N, Object_Definition);
+      Set_Expression (N, Expression);
+      return N;
+   end Make_Object_Declaration;
+
+   function Make_Number_Declaration (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id;
+      Expression                   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Number_Declaration, Sloc);
+   begin
+      Set_Defining_Identifier (N, Defining_Identifier);
+      Set_Expression (N, Expression);
+      return N;
+   end Make_Number_Declaration;
+
+   function Make_Derived_Type_Definition (Sloc : Source_Ptr;
+      Abstract_Present             : Boolean := False;
+      Subtype_Indication           : Node_Id;
+      Record_Extension_Part        : Node_Id := Empty)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Derived_Type_Definition, Sloc);
+   begin
+      Set_Abstract_Present (N, Abstract_Present);
+      Set_Subtype_Indication (N, Subtype_Indication);
+      Set_Record_Extension_Part (N, Record_Extension_Part);
+      return N;
+   end Make_Derived_Type_Definition;
+
+   function Make_Range_Constraint (Sloc : Source_Ptr;
+      Range_Expression             : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Range_Constraint, Sloc);
+   begin
+      Set_Range_Expression (N, Range_Expression);
+      return N;
+   end Make_Range_Constraint;
+
+   function Make_Range (Sloc : Source_Ptr;
+      Low_Bound                    : Node_Id;
+      High_Bound                   : Node_Id;
+      Includes_Infinities          : Boolean := False)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Range, Sloc);
+   begin
+      Set_Low_Bound (N, Low_Bound);
+      Set_High_Bound (N, High_Bound);
+      Set_Includes_Infinities (N, Includes_Infinities);
+      return N;
+   end Make_Range;
+
+   function Make_Enumeration_Type_Definition (Sloc : Source_Ptr;
+      Literals                     : List_Id;
+      End_Label                    : Node_Id := Empty)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Enumeration_Type_Definition, Sloc);
+   begin
+      Set_Literals (N, Literals);
+      Set_End_Label (N, End_Label);
+      return N;
+   end Make_Enumeration_Type_Definition;
+
+   function Make_Defining_Character_Literal (Sloc : Source_Ptr;
+      Chars                        : Name_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Entity (N_Defining_Character_Literal, Sloc);
+   begin
+      Set_Chars (N, Chars);
+      return N;
+   end Make_Defining_Character_Literal;
+
+   function Make_Signed_Integer_Type_Definition (Sloc : Source_Ptr;
+      Low_Bound                    : Node_Id;
+      High_Bound                   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Signed_Integer_Type_Definition, Sloc);
+   begin
+      Set_Low_Bound (N, Low_Bound);
+      Set_High_Bound (N, High_Bound);
+      return N;
+   end Make_Signed_Integer_Type_Definition;
+
+   function Make_Modular_Type_Definition (Sloc : Source_Ptr;
+      Expression                   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Modular_Type_Definition, Sloc);
+   begin
+      Set_Expression (N, Expression);
+      return N;
+   end Make_Modular_Type_Definition;
+
+   function Make_Floating_Point_Definition (Sloc : Source_Ptr;
+      Digits_Expression            : Node_Id;
+      Real_Range_Specification     : Node_Id := Empty)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Floating_Point_Definition, Sloc);
+   begin
+      Set_Digits_Expression (N, Digits_Expression);
+      Set_Real_Range_Specification (N, Real_Range_Specification);
+      return N;
+   end Make_Floating_Point_Definition;
+
+   function Make_Real_Range_Specification (Sloc : Source_Ptr;
+      Low_Bound                    : Node_Id;
+      High_Bound                   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Real_Range_Specification, Sloc);
+   begin
+      Set_Low_Bound (N, Low_Bound);
+      Set_High_Bound (N, High_Bound);
+      return N;
+   end Make_Real_Range_Specification;
+
+   function Make_Ordinary_Fixed_Point_Definition (Sloc : Source_Ptr;
+      Delta_Expression             : Node_Id;
+      Real_Range_Specification     : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Ordinary_Fixed_Point_Definition, Sloc);
+   begin
+      Set_Delta_Expression (N, Delta_Expression);
+      Set_Real_Range_Specification (N, Real_Range_Specification);
+      return N;
+   end Make_Ordinary_Fixed_Point_Definition;
+
+   function Make_Decimal_Fixed_Point_Definition (Sloc : Source_Ptr;
+      Delta_Expression             : Node_Id;
+      Digits_Expression            : Node_Id;
+      Real_Range_Specification     : Node_Id := Empty)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Decimal_Fixed_Point_Definition, Sloc);
+   begin
+      Set_Delta_Expression (N, Delta_Expression);
+      Set_Digits_Expression (N, Digits_Expression);
+      Set_Real_Range_Specification (N, Real_Range_Specification);
+      return N;
+   end Make_Decimal_Fixed_Point_Definition;
+
+   function Make_Digits_Constraint (Sloc : Source_Ptr;
+      Digits_Expression            : Node_Id;
+      Range_Constraint             : Node_Id := Empty)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Digits_Constraint, Sloc);
+   begin
+      Set_Digits_Expression (N, Digits_Expression);
+      Set_Range_Constraint (N, Range_Constraint);
+      return N;
+   end Make_Digits_Constraint;
+
+   function Make_Unconstrained_Array_Definition (Sloc : Source_Ptr;
+      Subtype_Marks                : List_Id;
+      Component_Definition         : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Unconstrained_Array_Definition, Sloc);
+   begin
+      Set_Subtype_Marks (N, Subtype_Marks);
+      Set_Component_Definition (N, Component_Definition);
+      return N;
+   end Make_Unconstrained_Array_Definition;
+
+   function Make_Constrained_Array_Definition (Sloc : Source_Ptr;
+      Discrete_Subtype_Definitions : List_Id;
+      Component_Definition         : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Constrained_Array_Definition, Sloc);
+   begin
+      Set_Discrete_Subtype_Definitions
+        (N, Discrete_Subtype_Definitions);
+      Set_Component_Definition (N, Component_Definition);
+      return N;
+   end Make_Constrained_Array_Definition;
+
+   function Make_Component_Definition (Sloc : Source_Ptr;
+      Aliased_Present              : Boolean := False;
+      Subtype_Indication           : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Component_Definition, Sloc);
+   begin
+      Set_Aliased_Present (N, Aliased_Present);
+      Set_Subtype_Indication (N, Subtype_Indication);
+      return N;
+   end Make_Component_Definition;
+
+   function Make_Discriminant_Specification (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id;
+      Discriminant_Type            : Node_Id;
+      Expression                   : Node_Id := Empty)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Discriminant_Specification, Sloc);
+   begin
+      Set_Defining_Identifier (N, Defining_Identifier);
+      Set_Discriminant_Type (N, Discriminant_Type);
+      Set_Expression (N, Expression);
+      return N;
+   end Make_Discriminant_Specification;
+
+   function Make_Index_Or_Discriminant_Constraint (Sloc : Source_Ptr;
+      Constraints                  : List_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Index_Or_Discriminant_Constraint, Sloc);
+   begin
+      Set_Constraints (N, Constraints);
+      return N;
+   end Make_Index_Or_Discriminant_Constraint;
+
+   function Make_Discriminant_Association (Sloc : Source_Ptr;
+      Selector_Names               : List_Id;
+      Expression                   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Discriminant_Association, Sloc);
+   begin
+      Set_Selector_Names (N, Selector_Names);
+      Set_Expression (N, Expression);
+      return N;
+   end Make_Discriminant_Association;
+
+   function Make_Record_Definition (Sloc : Source_Ptr;
+      End_Label                    : Node_Id := Empty;
+      Abstract_Present             : Boolean := False;
+      Tagged_Present               : Boolean := False;
+      Limited_Present              : Boolean := False;
+      Component_List               : Node_Id;
+      Null_Present                 : Boolean := False)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Record_Definition, Sloc);
+   begin
+      Set_End_Label (N, End_Label);
+      Set_Abstract_Present (N, Abstract_Present);
+      Set_Tagged_Present (N, Tagged_Present);
+      Set_Limited_Present (N, Limited_Present);
+      Set_Component_List (N, Component_List);
+      Set_Null_Present (N, Null_Present);
+      return N;
+   end Make_Record_Definition;
+
+   function Make_Component_List (Sloc : Source_Ptr;
+      Component_Items              : List_Id;
+      Variant_Part                 : Node_Id := Empty;
+      Null_Present                 : Boolean := False)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Component_List, Sloc);
+   begin
+      Set_Component_Items (N, Component_Items);
+      Set_Variant_Part (N, Variant_Part);
+      Set_Null_Present (N, Null_Present);
+      return N;
+   end Make_Component_List;
+
+   function Make_Component_Declaration (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id;
+      Component_Definition         : Node_Id;
+      Expression                   : Node_Id := Empty)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Component_Declaration, Sloc);
+   begin
+      Set_Defining_Identifier (N, Defining_Identifier);
+      Set_Component_Definition (N, Component_Definition);
+      Set_Expression (N, Expression);
+      return N;
+   end Make_Component_Declaration;
+
+   function Make_Variant_Part (Sloc : Source_Ptr;
+      Name                         : Node_Id;
+      Variants                     : List_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Variant_Part, Sloc);
+   begin
+      Set_Name (N, Name);
+      Set_Variants (N, Variants);
+      return N;
+   end Make_Variant_Part;
+
+   function Make_Variant (Sloc : Source_Ptr;
+      Discrete_Choices             : List_Id;
+      Component_List               : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Variant, Sloc);
+   begin
+      Set_Discrete_Choices (N, Discrete_Choices);
+      Set_Component_List (N, Component_List);
+      return N;
+   end Make_Variant;
+
+   function Make_Others_Choice (Sloc : Source_Ptr)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Others_Choice, Sloc);
+   begin
+      return N;
+   end Make_Others_Choice;
+
+   function Make_Access_To_Object_Definition (Sloc : Source_Ptr;
+      All_Present                  : Boolean := False;
+      Subtype_Indication           : Node_Id;
+      Constant_Present             : Boolean := False)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Access_To_Object_Definition, Sloc);
+   begin
+      Set_All_Present (N, All_Present);
+      Set_Subtype_Indication (N, Subtype_Indication);
+      Set_Constant_Present (N, Constant_Present);
+      return N;
+   end Make_Access_To_Object_Definition;
+
+   function Make_Access_Function_Definition (Sloc : Source_Ptr;
+      Protected_Present            : Boolean := False;
+      Parameter_Specifications     : List_Id := No_List;
+      Subtype_Mark                 : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Access_Function_Definition, Sloc);
+   begin
+      Set_Protected_Present (N, Protected_Present);
+      Set_Parameter_Specifications (N, Parameter_Specifications);
+      Set_Subtype_Mark (N, Subtype_Mark);
+      return N;
+   end Make_Access_Function_Definition;
+
+   function Make_Access_Procedure_Definition (Sloc : Source_Ptr;
+      Protected_Present            : Boolean := False;
+      Parameter_Specifications     : List_Id := No_List)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Access_Procedure_Definition, Sloc);
+   begin
+      Set_Protected_Present (N, Protected_Present);
+      Set_Parameter_Specifications (N, Parameter_Specifications);
+      return N;
+   end Make_Access_Procedure_Definition;
+
+   function Make_Access_Definition (Sloc : Source_Ptr;
+      Subtype_Mark                 : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Access_Definition, Sloc);
+   begin
+      Set_Subtype_Mark (N, Subtype_Mark);
+      return N;
+   end Make_Access_Definition;
+
+   function Make_Incomplete_Type_Declaration (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id;
+      Discriminant_Specifications  : List_Id := No_List;
+      Unknown_Discriminants_Present : Boolean := False)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Incomplete_Type_Declaration, Sloc);
+   begin
+      Set_Defining_Identifier (N, Defining_Identifier);
+      Set_Discriminant_Specifications (N, Discriminant_Specifications);
+      Set_Unknown_Discriminants_Present
+        (N, Unknown_Discriminants_Present);
+      return N;
+   end Make_Incomplete_Type_Declaration;
+
+   function Make_Explicit_Dereference (Sloc : Source_Ptr;
+      Prefix                       : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Explicit_Dereference, Sloc);
+   begin
+      Set_Prefix (N, Prefix);
+      return N;
+   end Make_Explicit_Dereference;
+
+   function Make_Indexed_Component (Sloc : Source_Ptr;
+      Prefix                       : Node_Id;
+      Expressions                  : List_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Indexed_Component, Sloc);
+   begin
+      Set_Prefix (N, Prefix);
+      Set_Expressions (N, Expressions);
+      return N;
+   end Make_Indexed_Component;
+
+   function Make_Slice (Sloc : Source_Ptr;
+      Prefix                       : Node_Id;
+      Discrete_Range               : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Slice, Sloc);
+   begin
+      Set_Prefix (N, Prefix);
+      Set_Discrete_Range (N, Discrete_Range);
+      return N;
+   end Make_Slice;
+
+   function Make_Selected_Component (Sloc : Source_Ptr;
+      Prefix                       : Node_Id;
+      Selector_Name                : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Selected_Component, Sloc);
+   begin
+      Set_Prefix (N, Prefix);
+      Set_Selector_Name (N, Selector_Name);
+      return N;
+   end Make_Selected_Component;
+
+   function Make_Attribute_Reference (Sloc : Source_Ptr;
+      Prefix                       : Node_Id;
+      Attribute_Name               : Name_Id;
+      Expressions                  : List_Id := No_List;
+      Must_Be_Byte_Aligned         : Boolean := False)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Attribute_Reference, Sloc);
+   begin
+      Set_Prefix (N, Prefix);
+      Set_Attribute_Name (N, Attribute_Name);
+      Set_Expressions (N, Expressions);
+      Set_Must_Be_Byte_Aligned (N, Must_Be_Byte_Aligned);
+      return N;
+   end Make_Attribute_Reference;
+
+   function Make_Aggregate (Sloc : Source_Ptr;
+      Expressions                  : List_Id := No_List;
+      Component_Associations       : List_Id := No_List;
+      Null_Record_Present          : Boolean := False)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Aggregate, Sloc);
+   begin
+      Set_Expressions (N, Expressions);
+      Set_Component_Associations (N, Component_Associations);
+      Set_Null_Record_Present (N, Null_Record_Present);
+      return N;
+   end Make_Aggregate;
+
+   function Make_Component_Association (Sloc : Source_Ptr;
+      Choices                      : List_Id;
+      Expression                   : Node_Id;
+      Box_Present                  : Boolean := False)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Component_Association, Sloc);
+   begin
+      Set_Choices (N, Choices);
+      Set_Expression (N, Expression);
+      Set_Box_Present (N, Box_Present);
+      return N;
+   end Make_Component_Association;
+
+   function Make_Extension_Aggregate (Sloc : Source_Ptr;
+      Ancestor_Part                : Node_Id;
+      Expressions                  : List_Id := No_List;
+      Component_Associations       : List_Id := No_List;
+      Null_Record_Present          : Boolean := False)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Extension_Aggregate, Sloc);
+   begin
+      Set_Ancestor_Part (N, Ancestor_Part);
+      Set_Expressions (N, Expressions);
+      Set_Component_Associations (N, Component_Associations);
+      Set_Null_Record_Present (N, Null_Record_Present);
+      return N;
+   end Make_Extension_Aggregate;
+
+   function Make_Null (Sloc : Source_Ptr)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Null, Sloc);
+   begin
+      return N;
+   end Make_Null;
+
+   function Make_And_Then (Sloc : Source_Ptr;
+      Left_Opnd                    : Node_Id;
+      Right_Opnd                   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_And_Then, Sloc);
+   begin
+      Set_Left_Opnd (N, Left_Opnd);
+      Set_Right_Opnd (N, Right_Opnd);
+      return N;
+   end Make_And_Then;
+
+   function Make_Or_Else (Sloc : Source_Ptr;
+      Left_Opnd                    : Node_Id;
+      Right_Opnd                   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Or_Else, Sloc);
+   begin
+      Set_Left_Opnd (N, Left_Opnd);
+      Set_Right_Opnd (N, Right_Opnd);
+      return N;
+   end Make_Or_Else;
+
+   function Make_In (Sloc : Source_Ptr;
+      Left_Opnd                    : Node_Id;
+      Right_Opnd                   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_In, Sloc);
+   begin
+      Set_Left_Opnd (N, Left_Opnd);
+      Set_Right_Opnd (N, Right_Opnd);
+      return N;
+   end Make_In;
+
+   function Make_Not_In (Sloc : Source_Ptr;
+      Left_Opnd                    : Node_Id;
+      Right_Opnd                   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Not_In, Sloc);
+   begin
+      Set_Left_Opnd (N, Left_Opnd);
+      Set_Right_Opnd (N, Right_Opnd);
+      return N;
+   end Make_Not_In;
+
+   function Make_Op_And (Sloc : Source_Ptr;
+      Left_Opnd                    : Node_Id;
+      Right_Opnd                   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Op_And, Sloc);
+   begin
+      Set_Left_Opnd (N, Left_Opnd);
+      Set_Right_Opnd (N, Right_Opnd);
+      Set_Chars (N, Name_Op_And);
+      Set_Entity (N, Standard_Op_And);
+      return N;
+   end Make_Op_And;
+
+   function Make_Op_Or (Sloc : Source_Ptr;
+      Left_Opnd                    : Node_Id;
+      Right_Opnd                   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Op_Or, Sloc);
+   begin
+      Set_Left_Opnd (N, Left_Opnd);
+      Set_Right_Opnd (N, Right_Opnd);
+      Set_Chars (N, Name_Op_Or);
+      Set_Entity (N, Standard_Op_Or);
+      return N;
+   end Make_Op_Or;
+
+   function Make_Op_Xor (Sloc : Source_Ptr;
+      Left_Opnd                    : Node_Id;
+      Right_Opnd                   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Op_Xor, Sloc);
+   begin
+      Set_Left_Opnd (N, Left_Opnd);
+      Set_Right_Opnd (N, Right_Opnd);
+      Set_Chars (N, Name_Op_Xor);
+      Set_Entity (N, Standard_Op_Xor);
+      return N;
+   end Make_Op_Xor;
+
+   function Make_Op_Eq (Sloc : Source_Ptr;
+      Left_Opnd                    : Node_Id;
+      Right_Opnd                   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Op_Eq, Sloc);
+   begin
+      Set_Left_Opnd (N, Left_Opnd);
+      Set_Right_Opnd (N, Right_Opnd);
+      Set_Chars (N, Name_Op_Eq);
+      Set_Entity (N, Standard_Op_Eq);
+      return N;
+   end Make_Op_Eq;
+
+   function Make_Op_Ne (Sloc : Source_Ptr;
+      Left_Opnd                    : Node_Id;
+      Right_Opnd                   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Op_Ne, Sloc);
+   begin
+      Set_Left_Opnd (N, Left_Opnd);
+      Set_Right_Opnd (N, Right_Opnd);
+      Set_Chars (N, Name_Op_Ne);
+      Set_Entity (N, Standard_Op_Ne);
+      return N;
+   end Make_Op_Ne;
+
+   function Make_Op_Lt (Sloc : Source_Ptr;
+      Left_Opnd                    : Node_Id;
+      Right_Opnd                   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Op_Lt, Sloc);
+   begin
+      Set_Left_Opnd (N, Left_Opnd);
+      Set_Right_Opnd (N, Right_Opnd);
+      Set_Chars (N, Name_Op_Lt);
+      Set_Entity (N, Standard_Op_Lt);
+      return N;
+   end Make_Op_Lt;
+
+   function Make_Op_Le (Sloc : Source_Ptr;
+      Left_Opnd                    : Node_Id;
+      Right_Opnd                   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Op_Le, Sloc);
+   begin
+      Set_Left_Opnd (N, Left_Opnd);
+      Set_Right_Opnd (N, Right_Opnd);
+      Set_Chars (N, Name_Op_Le);
+      Set_Entity (N, Standard_Op_Le);
+      return N;
+   end Make_Op_Le;
+
+   function Make_Op_Gt (Sloc : Source_Ptr;
+      Left_Opnd                    : Node_Id;
+      Right_Opnd                   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Op_Gt, Sloc);
+   begin
+      Set_Left_Opnd (N, Left_Opnd);
+      Set_Right_Opnd (N, Right_Opnd);
+      Set_Chars (N, Name_Op_Gt);
+      Set_Entity (N, Standard_Op_Gt);
+      return N;
+   end Make_Op_Gt;
+
+   function Make_Op_Ge (Sloc : Source_Ptr;
+      Left_Opnd                    : Node_Id;
+      Right_Opnd                   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Op_Ge, Sloc);
+   begin
+      Set_Left_Opnd (N, Left_Opnd);
+      Set_Right_Opnd (N, Right_Opnd);
+      Set_Chars (N, Name_Op_Ge);
+      Set_Entity (N, Standard_Op_Ge);
+      return N;
+   end Make_Op_Ge;
+
+   function Make_Op_Add (Sloc : Source_Ptr;
+      Left_Opnd                    : Node_Id;
+      Right_Opnd                   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Op_Add, Sloc);
+   begin
+      Set_Left_Opnd (N, Left_Opnd);
+      Set_Right_Opnd (N, Right_Opnd);
+      Set_Chars (N, Name_Op_Add);
+      Set_Entity (N, Standard_Op_Add);
+      return N;
+   end Make_Op_Add;
+
+   function Make_Op_Subtract (Sloc : Source_Ptr;
+      Left_Opnd                    : Node_Id;
+      Right_Opnd                   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Op_Subtract, Sloc);
+   begin
+      Set_Left_Opnd (N, Left_Opnd);
+      Set_Right_Opnd (N, Right_Opnd);
+      Set_Chars (N, Name_Op_Subtract);
+      Set_Entity (N, Standard_Op_Subtract);
+      return N;
+   end Make_Op_Subtract;
+
+   function Make_Op_Concat (Sloc : Source_Ptr;
+      Left_Opnd                    : Node_Id;
+      Right_Opnd                   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Op_Concat, Sloc);
+   begin
+      Set_Left_Opnd (N, Left_Opnd);
+      Set_Right_Opnd (N, Right_Opnd);
+      Set_Chars (N, Name_Op_Concat);
+      Set_Entity (N, Standard_Op_Concat);
+      return N;
+   end Make_Op_Concat;
+
+   function Make_Op_Multiply (Sloc : Source_Ptr;
+      Left_Opnd                    : Node_Id;
+      Right_Opnd                   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Op_Multiply, Sloc);
+   begin
+      Set_Left_Opnd (N, Left_Opnd);
+      Set_Right_Opnd (N, Right_Opnd);
+      Set_Chars (N, Name_Op_Multiply);
+      Set_Entity (N, Standard_Op_Multiply);
+      return N;
+   end Make_Op_Multiply;
+
+   function Make_Op_Divide (Sloc : Source_Ptr;
+      Left_Opnd                    : Node_Id;
+      Right_Opnd                   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Op_Divide, Sloc);
+   begin
+      Set_Left_Opnd (N, Left_Opnd);
+      Set_Right_Opnd (N, Right_Opnd);
+      Set_Chars (N, Name_Op_Divide);
+      Set_Entity (N, Standard_Op_Divide);
+      return N;
+   end Make_Op_Divide;
+
+   function Make_Op_Mod (Sloc : Source_Ptr;
+      Left_Opnd                    : Node_Id;
+      Right_Opnd                   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Op_Mod, Sloc);
+   begin
+      Set_Left_Opnd (N, Left_Opnd);
+      Set_Right_Opnd (N, Right_Opnd);
+      Set_Chars (N, Name_Op_Mod);
+      Set_Entity (N, Standard_Op_Mod);
+      return N;
+   end Make_Op_Mod;
+
+   function Make_Op_Rem (Sloc : Source_Ptr;
+      Left_Opnd                    : Node_Id;
+      Right_Opnd                   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Op_Rem, Sloc);
+   begin
+      Set_Left_Opnd (N, Left_Opnd);
+      Set_Right_Opnd (N, Right_Opnd);
+      Set_Chars (N, Name_Op_Rem);
+      Set_Entity (N, Standard_Op_Rem);
+      return N;
+   end Make_Op_Rem;
+
+   function Make_Op_Expon (Sloc : Source_Ptr;
+      Left_Opnd                    : Node_Id;
+      Right_Opnd                   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Op_Expon, Sloc);
+   begin
+      Set_Left_Opnd (N, Left_Opnd);
+      Set_Right_Opnd (N, Right_Opnd);
+      Set_Chars (N, Name_Op_Expon);
+      Set_Entity (N, Standard_Op_Expon);
+      return N;
+   end Make_Op_Expon;
+
+   function Make_Op_Plus (Sloc : Source_Ptr;
+      Right_Opnd                   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Op_Plus, Sloc);
+   begin
+      Set_Right_Opnd (N, Right_Opnd);
+      Set_Chars (N, Name_Op_Add);
+      Set_Entity (N, Standard_Op_Plus);
+      return N;
+   end Make_Op_Plus;
+
+   function Make_Op_Minus (Sloc : Source_Ptr;
+      Right_Opnd                   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Op_Minus, Sloc);
+   begin
+      Set_Right_Opnd (N, Right_Opnd);
+      Set_Chars (N, Name_Op_Subtract);
+      Set_Entity (N, Standard_Op_Minus);
+      return N;
+   end Make_Op_Minus;
+
+   function Make_Op_Abs (Sloc : Source_Ptr;
+      Right_Opnd                   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Op_Abs, Sloc);
+   begin
+      Set_Right_Opnd (N, Right_Opnd);
+      Set_Chars (N, Name_Op_Abs);
+      Set_Entity (N, Standard_Op_Abs);
+      return N;
+   end Make_Op_Abs;
+
+   function Make_Op_Not (Sloc : Source_Ptr;
+      Right_Opnd                   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Op_Not, Sloc);
+   begin
+      Set_Right_Opnd (N, Right_Opnd);
+      Set_Chars (N, Name_Op_Not);
+      Set_Entity (N, Standard_Op_Not);
+      return N;
+   end Make_Op_Not;
+
+   function Make_Type_Conversion (Sloc : Source_Ptr;
+      Subtype_Mark                 : Node_Id;
+      Expression                   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Type_Conversion, Sloc);
+   begin
+      Set_Subtype_Mark (N, Subtype_Mark);
+      Set_Expression (N, Expression);
+      return N;
+   end Make_Type_Conversion;
+
+   function Make_Qualified_Expression (Sloc : Source_Ptr;
+      Subtype_Mark                 : Node_Id;
+      Expression                   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Qualified_Expression, Sloc);
+   begin
+      Set_Subtype_Mark (N, Subtype_Mark);
+      Set_Expression (N, Expression);
+      return N;
+   end Make_Qualified_Expression;
+
+   function Make_Allocator (Sloc : Source_Ptr;
+      Expression                   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Allocator, Sloc);
+   begin
+      Set_Expression (N, Expression);
+      return N;
+   end Make_Allocator;
+
+   function Make_Null_Statement (Sloc : Source_Ptr)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Null_Statement, Sloc);
+   begin
+      return N;
+   end Make_Null_Statement;
+
+   function Make_Label (Sloc : Source_Ptr;
+      Identifier                   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Label, Sloc);
+   begin
+      Set_Identifier (N, Identifier);
+      return N;
+   end Make_Label;
+
+   function Make_Assignment_Statement (Sloc : Source_Ptr;
+      Name                         : Node_Id;
+      Expression                   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Assignment_Statement, Sloc);
+   begin
+      Set_Name (N, Name);
+      Set_Expression (N, Expression);
+      return N;
+   end Make_Assignment_Statement;
+
+   function Make_If_Statement (Sloc : Source_Ptr;
+      Condition                    : Node_Id;
+      Then_Statements              : List_Id;
+      Elsif_Parts                  : List_Id := No_List;
+      Else_Statements              : List_Id := No_List;
+      End_Span                     : Uint := No_Uint)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_If_Statement, Sloc);
+   begin
+      Set_Condition (N, Condition);
+      Set_Then_Statements (N, Then_Statements);
+      Set_Elsif_Parts (N, Elsif_Parts);
+      Set_Else_Statements (N, Else_Statements);
+      Set_End_Span (N, End_Span);
+      return N;
+   end Make_If_Statement;
+
+   function Make_Elsif_Part (Sloc : Source_Ptr;
+      Condition                    : Node_Id;
+      Then_Statements              : List_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Elsif_Part, Sloc);
+   begin
+      Set_Condition (N, Condition);
+      Set_Then_Statements (N, Then_Statements);
+      return N;
+   end Make_Elsif_Part;
+
+   function Make_Case_Statement (Sloc : Source_Ptr;
+      Expression                   : Node_Id;
+      Alternatives                 : List_Id;
+      End_Span                     : Uint := No_Uint)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Case_Statement, Sloc);
+   begin
+      Set_Expression (N, Expression);
+      Set_Alternatives (N, Alternatives);
+      Set_End_Span (N, End_Span);
+      return N;
+   end Make_Case_Statement;
+
+   function Make_Case_Statement_Alternative (Sloc : Source_Ptr;
+      Discrete_Choices             : List_Id;
+      Statements                   : List_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Case_Statement_Alternative, Sloc);
+   begin
+      Set_Discrete_Choices (N, Discrete_Choices);
+      Set_Statements (N, Statements);
+      return N;
+   end Make_Case_Statement_Alternative;
+
+   function Make_Loop_Statement (Sloc : Source_Ptr;
+      Identifier                   : Node_Id := Empty;
+      Iteration_Scheme             : Node_Id := Empty;
+      Statements                   : List_Id;
+      End_Label                    : Node_Id;
+      Has_Created_Identifier       : Boolean := False;
+      Is_Null_Loop                 : Boolean := False)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Loop_Statement, Sloc);
+   begin
+      Set_Identifier (N, Identifier);
+      Set_Iteration_Scheme (N, Iteration_Scheme);
+      Set_Statements (N, Statements);
+      Set_End_Label (N, End_Label);
+      Set_Has_Created_Identifier (N, Has_Created_Identifier);
+      Set_Is_Null_Loop (N, Is_Null_Loop);
+      return N;
+   end Make_Loop_Statement;
+
+   function Make_Iteration_Scheme (Sloc : Source_Ptr;
+      Condition                    : Node_Id := Empty;
+      Loop_Parameter_Specification : Node_Id := Empty)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Iteration_Scheme, Sloc);
+   begin
+      Set_Condition (N, Condition);
+      Set_Loop_Parameter_Specification
+        (N, Loop_Parameter_Specification);
+      return N;
+   end Make_Iteration_Scheme;
+
+   function Make_Loop_Parameter_Specification (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id;
+      Reverse_Present              : Boolean := False;
+      Discrete_Subtype_Definition  : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Loop_Parameter_Specification, Sloc);
+   begin
+      Set_Defining_Identifier (N, Defining_Identifier);
+      Set_Reverse_Present (N, Reverse_Present);
+      Set_Discrete_Subtype_Definition (N, Discrete_Subtype_Definition);
+      return N;
+   end Make_Loop_Parameter_Specification;
+
+   function Make_Block_Statement (Sloc : Source_Ptr;
+      Identifier                   : Node_Id := Empty;
+      Declarations                 : List_Id := No_List;
+      Handled_Statement_Sequence   : Node_Id;
+      Has_Created_Identifier       : Boolean := False;
+      Is_Task_Allocation_Block     : Boolean := False;
+      Is_Asynchronous_Call_Block   : Boolean := False)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Block_Statement, Sloc);
+   begin
+      Set_Identifier (N, Identifier);
+      Set_Declarations (N, Declarations);
+      Set_Handled_Statement_Sequence (N, Handled_Statement_Sequence);
+      Set_Has_Created_Identifier (N, Has_Created_Identifier);
+      Set_Is_Task_Allocation_Block (N, Is_Task_Allocation_Block);
+      Set_Is_Asynchronous_Call_Block (N, Is_Asynchronous_Call_Block);
+      return N;
+   end Make_Block_Statement;
+
+   function Make_Exit_Statement (Sloc : Source_Ptr;
+      Name                         : Node_Id := Empty;
+      Condition                    : Node_Id := Empty)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Exit_Statement, Sloc);
+   begin
+      Set_Name (N, Name);
+      Set_Condition (N, Condition);
+      return N;
+   end Make_Exit_Statement;
+
+   function Make_Goto_Statement (Sloc : Source_Ptr;
+      Name                         : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Goto_Statement, Sloc);
+   begin
+      Set_Name (N, Name);
+      return N;
+   end Make_Goto_Statement;
+
+   function Make_Subprogram_Declaration (Sloc : Source_Ptr;
+      Specification                : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Subprogram_Declaration, Sloc);
+   begin
+      Set_Specification (N, Specification);
+      return N;
+   end Make_Subprogram_Declaration;
+
+   function Make_Abstract_Subprogram_Declaration (Sloc : Source_Ptr;
+      Specification                : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Abstract_Subprogram_Declaration, Sloc);
+   begin
+      Set_Specification (N, Specification);
+      return N;
+   end Make_Abstract_Subprogram_Declaration;
+
+   function Make_Function_Specification (Sloc : Source_Ptr;
+      Defining_Unit_Name           : Node_Id;
+      Parameter_Specifications     : List_Id := No_List;
+      Subtype_Mark                 : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Function_Specification, Sloc);
+   begin
+      Set_Defining_Unit_Name (N, Defining_Unit_Name);
+      Set_Parameter_Specifications (N, Parameter_Specifications);
+      Set_Subtype_Mark (N, Subtype_Mark);
+      return N;
+   end Make_Function_Specification;
+
+   function Make_Procedure_Specification (Sloc : Source_Ptr;
+      Defining_Unit_Name           : Node_Id;
+      Parameter_Specifications     : List_Id := No_List)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Procedure_Specification, Sloc);
+   begin
+      Set_Defining_Unit_Name (N, Defining_Unit_Name);
+      Set_Parameter_Specifications (N, Parameter_Specifications);
+      return N;
+   end Make_Procedure_Specification;
+
+   function Make_Designator (Sloc : Source_Ptr;
+      Name                         : Node_Id;
+      Identifier                   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Designator, Sloc);
+   begin
+      Set_Name (N, Name);
+      Set_Identifier (N, Identifier);
+      return N;
+   end Make_Designator;
+
+   function Make_Defining_Program_Unit_Name (Sloc : Source_Ptr;
+      Name                         : Node_Id;
+      Defining_Identifier          : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Defining_Program_Unit_Name, Sloc);
+   begin
+      Set_Name (N, Name);
+      Set_Defining_Identifier (N, Defining_Identifier);
+      return N;
+   end Make_Defining_Program_Unit_Name;
+
+   function Make_Operator_Symbol (Sloc : Source_Ptr;
+      Chars                        : Name_Id;
+      Strval                       : String_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Operator_Symbol, Sloc);
+   begin
+      Set_Chars (N, Chars);
+      Set_Strval (N, Strval);
+      return N;
+   end Make_Operator_Symbol;
+
+   function Make_Defining_Operator_Symbol (Sloc : Source_Ptr;
+      Chars                        : Name_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Entity (N_Defining_Operator_Symbol, Sloc);
+   begin
+      Set_Chars (N, Chars);
+      return N;
+   end Make_Defining_Operator_Symbol;
+
+   function Make_Parameter_Specification (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id;
+      In_Present                   : Boolean := False;
+      Out_Present                  : Boolean := False;
+      Parameter_Type               : Node_Id;
+      Expression                   : Node_Id := Empty)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Parameter_Specification, Sloc);
+   begin
+      Set_Defining_Identifier (N, Defining_Identifier);
+      Set_In_Present (N, In_Present);
+      Set_Out_Present (N, Out_Present);
+      Set_Parameter_Type (N, Parameter_Type);
+      Set_Expression (N, Expression);
+      return N;
+   end Make_Parameter_Specification;
+
+   function Make_Subprogram_Body (Sloc : Source_Ptr;
+      Specification                : Node_Id;
+      Declarations                 : List_Id;
+      Handled_Statement_Sequence   : Node_Id;
+      Bad_Is_Detected              : Boolean := False)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Subprogram_Body, Sloc);
+   begin
+      Set_Specification (N, Specification);
+      Set_Declarations (N, Declarations);
+      Set_Handled_Statement_Sequence (N, Handled_Statement_Sequence);
+      Set_Bad_Is_Detected (N, Bad_Is_Detected);
+      return N;
+   end Make_Subprogram_Body;
+
+   function Make_Procedure_Call_Statement (Sloc : Source_Ptr;
+      Name                         : Node_Id;
+      Parameter_Associations       : List_Id := No_List)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Procedure_Call_Statement, Sloc);
+   begin
+      Set_Name (N, Name);
+      Set_Parameter_Associations (N, Parameter_Associations);
+      return N;
+   end Make_Procedure_Call_Statement;
+
+   function Make_Function_Call (Sloc : Source_Ptr;
+      Name                         : Node_Id;
+      Parameter_Associations       : List_Id := No_List)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Function_Call, Sloc);
+   begin
+      Set_Name (N, Name);
+      Set_Parameter_Associations (N, Parameter_Associations);
+      return N;
+   end Make_Function_Call;
+
+   function Make_Parameter_Association (Sloc : Source_Ptr;
+      Selector_Name                : Node_Id;
+      Explicit_Actual_Parameter    : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Parameter_Association, Sloc);
+   begin
+      Set_Selector_Name (N, Selector_Name);
+      Set_Explicit_Actual_Parameter (N, Explicit_Actual_Parameter);
+      return N;
+   end Make_Parameter_Association;
+
+   function Make_Return_Statement (Sloc : Source_Ptr;
+      Expression                   : Node_Id := Empty)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Return_Statement, Sloc);
+   begin
+      Set_Expression (N, Expression);
+      return N;
+   end Make_Return_Statement;
+
+   function Make_Package_Declaration (Sloc : Source_Ptr;
+      Specification                : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Package_Declaration, Sloc);
+   begin
+      Set_Specification (N, Specification);
+      return N;
+   end Make_Package_Declaration;
+
+   function Make_Package_Specification (Sloc : Source_Ptr;
+      Defining_Unit_Name           : Node_Id;
+      Visible_Declarations         : List_Id;
+      Private_Declarations         : List_Id := No_List;
+      End_Label                    : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Package_Specification, Sloc);
+   begin
+      Set_Defining_Unit_Name (N, Defining_Unit_Name);
+      Set_Visible_Declarations (N, Visible_Declarations);
+      Set_Private_Declarations (N, Private_Declarations);
+      Set_End_Label (N, End_Label);
+      return N;
+   end Make_Package_Specification;
+
+   function Make_Package_Body (Sloc : Source_Ptr;
+      Defining_Unit_Name           : Node_Id;
+      Declarations                 : List_Id;
+      Handled_Statement_Sequence   : Node_Id := Empty)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Package_Body, Sloc);
+   begin
+      Set_Defining_Unit_Name (N, Defining_Unit_Name);
+      Set_Declarations (N, Declarations);
+      Set_Handled_Statement_Sequence (N, Handled_Statement_Sequence);
+      return N;
+   end Make_Package_Body;
+
+   function Make_Private_Type_Declaration (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id;
+      Discriminant_Specifications  : List_Id := No_List;
+      Unknown_Discriminants_Present : Boolean := False;
+      Abstract_Present             : Boolean := False;
+      Tagged_Present               : Boolean := False;
+      Limited_Present              : Boolean := False)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Private_Type_Declaration, Sloc);
+   begin
+      Set_Defining_Identifier (N, Defining_Identifier);
+      Set_Discriminant_Specifications (N, Discriminant_Specifications);
+      Set_Unknown_Discriminants_Present
+        (N, Unknown_Discriminants_Present);
+      Set_Abstract_Present (N, Abstract_Present);
+      Set_Tagged_Present (N, Tagged_Present);
+      Set_Limited_Present (N, Limited_Present);
+      return N;
+   end Make_Private_Type_Declaration;
+
+   function Make_Private_Extension_Declaration (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id;
+      Discriminant_Specifications  : List_Id := No_List;
+      Unknown_Discriminants_Present : Boolean := False;
+      Abstract_Present             : Boolean := False;
+      Subtype_Indication           : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Private_Extension_Declaration, Sloc);
+   begin
+      Set_Defining_Identifier (N, Defining_Identifier);
+      Set_Discriminant_Specifications (N, Discriminant_Specifications);
+      Set_Unknown_Discriminants_Present
+        (N, Unknown_Discriminants_Present);
+      Set_Abstract_Present (N, Abstract_Present);
+      Set_Subtype_Indication (N, Subtype_Indication);
+      return N;
+   end Make_Private_Extension_Declaration;
+
+   function Make_Use_Package_Clause (Sloc : Source_Ptr;
+      Names                        : List_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Use_Package_Clause, Sloc);
+   begin
+      Set_Names (N, Names);
+      return N;
+   end Make_Use_Package_Clause;
+
+   function Make_Use_Type_Clause (Sloc : Source_Ptr;
+      Subtype_Marks                : List_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Use_Type_Clause, Sloc);
+   begin
+      Set_Subtype_Marks (N, Subtype_Marks);
+      return N;
+   end Make_Use_Type_Clause;
+
+   function Make_Object_Renaming_Declaration (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id;
+      Subtype_Mark                 : Node_Id;
+      Name                         : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Object_Renaming_Declaration, Sloc);
+   begin
+      Set_Defining_Identifier (N, Defining_Identifier);
+      Set_Subtype_Mark (N, Subtype_Mark);
+      Set_Name (N, Name);
+      return N;
+   end Make_Object_Renaming_Declaration;
+
+   function Make_Exception_Renaming_Declaration (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id;
+      Name                         : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Exception_Renaming_Declaration, Sloc);
+   begin
+      Set_Defining_Identifier (N, Defining_Identifier);
+      Set_Name (N, Name);
+      return N;
+   end Make_Exception_Renaming_Declaration;
+
+   function Make_Package_Renaming_Declaration (Sloc : Source_Ptr;
+      Defining_Unit_Name           : Node_Id;
+      Name                         : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Package_Renaming_Declaration, Sloc);
+   begin
+      Set_Defining_Unit_Name (N, Defining_Unit_Name);
+      Set_Name (N, Name);
+      return N;
+   end Make_Package_Renaming_Declaration;
+
+   function Make_Subprogram_Renaming_Declaration (Sloc : Source_Ptr;
+      Specification                : Node_Id;
+      Name                         : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Subprogram_Renaming_Declaration, Sloc);
+   begin
+      Set_Specification (N, Specification);
+      Set_Name (N, Name);
+      return N;
+   end Make_Subprogram_Renaming_Declaration;
+
+   function Make_Generic_Package_Renaming_Declaration (Sloc : Source_Ptr;
+      Defining_Unit_Name           : Node_Id;
+      Name                         : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Generic_Package_Renaming_Declaration, Sloc);
+   begin
+      Set_Defining_Unit_Name (N, Defining_Unit_Name);
+      Set_Name (N, Name);
+      return N;
+   end Make_Generic_Package_Renaming_Declaration;
+
+   function Make_Generic_Procedure_Renaming_Declaration (Sloc : Source_Ptr;
+      Defining_Unit_Name           : Node_Id;
+      Name                         : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Generic_Procedure_Renaming_Declaration, Sloc);
+   begin
+      Set_Defining_Unit_Name (N, Defining_Unit_Name);
+      Set_Name (N, Name);
+      return N;
+   end Make_Generic_Procedure_Renaming_Declaration;
+
+   function Make_Generic_Function_Renaming_Declaration (Sloc : Source_Ptr;
+      Defining_Unit_Name           : Node_Id;
+      Name                         : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Generic_Function_Renaming_Declaration, Sloc);
+   begin
+      Set_Defining_Unit_Name (N, Defining_Unit_Name);
+      Set_Name (N, Name);
+      return N;
+   end Make_Generic_Function_Renaming_Declaration;
+
+   function Make_Task_Type_Declaration (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id;
+      Discriminant_Specifications  : List_Id := No_List;
+      Task_Definition              : Node_Id := Empty)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Task_Type_Declaration, Sloc);
+   begin
+      Set_Defining_Identifier (N, Defining_Identifier);
+      Set_Discriminant_Specifications (N, Discriminant_Specifications);
+      Set_Task_Definition (N, Task_Definition);
+      return N;
+   end Make_Task_Type_Declaration;
+
+   function Make_Single_Task_Declaration (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id;
+      Task_Definition              : Node_Id := Empty)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Single_Task_Declaration, Sloc);
+   begin
+      Set_Defining_Identifier (N, Defining_Identifier);
+      Set_Task_Definition (N, Task_Definition);
+      return N;
+   end Make_Single_Task_Declaration;
+
+   function Make_Task_Definition (Sloc : Source_Ptr;
+      Visible_Declarations         : List_Id;
+      Private_Declarations         : List_Id := No_List;
+      End_Label                    : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Task_Definition, Sloc);
+   begin
+      Set_Visible_Declarations (N, Visible_Declarations);
+      Set_Private_Declarations (N, Private_Declarations);
+      Set_End_Label (N, End_Label);
+      return N;
+   end Make_Task_Definition;
+
+   function Make_Task_Body (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id;
+      Declarations                 : List_Id;
+      Handled_Statement_Sequence   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Task_Body, Sloc);
+   begin
+      Set_Defining_Identifier (N, Defining_Identifier);
+      Set_Declarations (N, Declarations);
+      Set_Handled_Statement_Sequence (N, Handled_Statement_Sequence);
+      return N;
+   end Make_Task_Body;
+
+   function Make_Protected_Type_Declaration (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id;
+      Discriminant_Specifications  : List_Id := No_List;
+      Protected_Definition         : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Protected_Type_Declaration, Sloc);
+   begin
+      Set_Defining_Identifier (N, Defining_Identifier);
+      Set_Discriminant_Specifications (N, Discriminant_Specifications);
+      Set_Protected_Definition (N, Protected_Definition);
+      return N;
+   end Make_Protected_Type_Declaration;
+
+   function Make_Single_Protected_Declaration (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id;
+      Protected_Definition         : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Single_Protected_Declaration, Sloc);
+   begin
+      Set_Defining_Identifier (N, Defining_Identifier);
+      Set_Protected_Definition (N, Protected_Definition);
+      return N;
+   end Make_Single_Protected_Declaration;
+
+   function Make_Protected_Definition (Sloc : Source_Ptr;
+      Visible_Declarations         : List_Id;
+      Private_Declarations         : List_Id := No_List;
+      End_Label                    : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Protected_Definition, Sloc);
+   begin
+      Set_Visible_Declarations (N, Visible_Declarations);
+      Set_Private_Declarations (N, Private_Declarations);
+      Set_End_Label (N, End_Label);
+      return N;
+   end Make_Protected_Definition;
+
+   function Make_Protected_Body (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id;
+      Declarations                 : List_Id;
+      End_Label                    : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Protected_Body, Sloc);
+   begin
+      Set_Defining_Identifier (N, Defining_Identifier);
+      Set_Declarations (N, Declarations);
+      Set_End_Label (N, End_Label);
+      return N;
+   end Make_Protected_Body;
+
+   function Make_Entry_Declaration (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id;
+      Discrete_Subtype_Definition  : Node_Id := Empty;
+      Parameter_Specifications     : List_Id := No_List)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Entry_Declaration, Sloc);
+   begin
+      Set_Defining_Identifier (N, Defining_Identifier);
+      Set_Discrete_Subtype_Definition (N, Discrete_Subtype_Definition);
+      Set_Parameter_Specifications (N, Parameter_Specifications);
+      return N;
+   end Make_Entry_Declaration;
+
+   function Make_Accept_Statement (Sloc : Source_Ptr;
+      Entry_Direct_Name            : Node_Id;
+      Entry_Index                  : Node_Id := Empty;
+      Parameter_Specifications     : List_Id := No_List;
+      Handled_Statement_Sequence   : Node_Id;
+      Declarations                 : List_Id := No_List)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Accept_Statement, Sloc);
+   begin
+      Set_Entry_Direct_Name (N, Entry_Direct_Name);
+      Set_Entry_Index (N, Entry_Index);
+      Set_Parameter_Specifications (N, Parameter_Specifications);
+      Set_Handled_Statement_Sequence (N, Handled_Statement_Sequence);
+      Set_Declarations (N, Declarations);
+      return N;
+   end Make_Accept_Statement;
+
+   function Make_Entry_Body (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id;
+      Entry_Body_Formal_Part       : Node_Id;
+      Declarations                 : List_Id;
+      Handled_Statement_Sequence   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Entry_Body, Sloc);
+   begin
+      Set_Defining_Identifier (N, Defining_Identifier);
+      Set_Entry_Body_Formal_Part (N, Entry_Body_Formal_Part);
+      Set_Declarations (N, Declarations);
+      Set_Handled_Statement_Sequence (N, Handled_Statement_Sequence);
+      return N;
+   end Make_Entry_Body;
+
+   function Make_Entry_Body_Formal_Part (Sloc : Source_Ptr;
+      Entry_Index_Specification    : Node_Id := Empty;
+      Parameter_Specifications     : List_Id := No_List;
+      Condition                    : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Entry_Body_Formal_Part, Sloc);
+   begin
+      Set_Entry_Index_Specification (N, Entry_Index_Specification);
+      Set_Parameter_Specifications (N, Parameter_Specifications);
+      Set_Condition (N, Condition);
+      return N;
+   end Make_Entry_Body_Formal_Part;
+
+   function Make_Entry_Index_Specification (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id;
+      Discrete_Subtype_Definition  : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Entry_Index_Specification, Sloc);
+   begin
+      Set_Defining_Identifier (N, Defining_Identifier);
+      Set_Discrete_Subtype_Definition (N, Discrete_Subtype_Definition);
+      return N;
+   end Make_Entry_Index_Specification;
+
+   function Make_Entry_Call_Statement (Sloc : Source_Ptr;
+      Name                         : Node_Id;
+      Parameter_Associations       : List_Id := No_List)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Entry_Call_Statement, Sloc);
+   begin
+      Set_Name (N, Name);
+      Set_Parameter_Associations (N, Parameter_Associations);
+      return N;
+   end Make_Entry_Call_Statement;
+
+   function Make_Requeue_Statement (Sloc : Source_Ptr;
+      Name                         : Node_Id;
+      Abort_Present                : Boolean := False)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Requeue_Statement, Sloc);
+   begin
+      Set_Name (N, Name);
+      Set_Abort_Present (N, Abort_Present);
+      return N;
+   end Make_Requeue_Statement;
+
+   function Make_Delay_Until_Statement (Sloc : Source_Ptr;
+      Expression                   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Delay_Until_Statement, Sloc);
+   begin
+      Set_Expression (N, Expression);
+      return N;
+   end Make_Delay_Until_Statement;
+
+   function Make_Delay_Relative_Statement (Sloc : Source_Ptr;
+      Expression                   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Delay_Relative_Statement, Sloc);
+   begin
+      Set_Expression (N, Expression);
+      return N;
+   end Make_Delay_Relative_Statement;
+
+   function Make_Selective_Accept (Sloc : Source_Ptr;
+      Select_Alternatives          : List_Id;
+      Else_Statements              : List_Id := No_List)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Selective_Accept, Sloc);
+   begin
+      Set_Select_Alternatives (N, Select_Alternatives);
+      Set_Else_Statements (N, Else_Statements);
+      return N;
+   end Make_Selective_Accept;
+
+   function Make_Accept_Alternative (Sloc : Source_Ptr;
+      Accept_Statement             : Node_Id;
+      Condition                    : Node_Id := Empty;
+      Statements                   : List_Id := Empty_List;
+      Pragmas_Before               : List_Id := No_List)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Accept_Alternative, Sloc);
+   begin
+      Set_Accept_Statement (N, Accept_Statement);
+      Set_Condition (N, Condition);
+      Set_Statements (N, Statements);
+      Set_Pragmas_Before (N, Pragmas_Before);
+      return N;
+   end Make_Accept_Alternative;
+
+   function Make_Delay_Alternative (Sloc : Source_Ptr;
+      Delay_Statement              : Node_Id;
+      Condition                    : Node_Id := Empty;
+      Statements                   : List_Id := Empty_List;
+      Pragmas_Before               : List_Id := No_List)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Delay_Alternative, Sloc);
+   begin
+      Set_Delay_Statement (N, Delay_Statement);
+      Set_Condition (N, Condition);
+      Set_Statements (N, Statements);
+      Set_Pragmas_Before (N, Pragmas_Before);
+      return N;
+   end Make_Delay_Alternative;
+
+   function Make_Terminate_Alternative (Sloc : Source_Ptr;
+      Condition                    : Node_Id := Empty;
+      Pragmas_Before               : List_Id := No_List;
+      Pragmas_After                : List_Id := No_List)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Terminate_Alternative, Sloc);
+   begin
+      Set_Condition (N, Condition);
+      Set_Pragmas_Before (N, Pragmas_Before);
+      Set_Pragmas_After (N, Pragmas_After);
+      return N;
+   end Make_Terminate_Alternative;
+
+   function Make_Timed_Entry_Call (Sloc : Source_Ptr;
+      Entry_Call_Alternative       : Node_Id;
+      Delay_Alternative            : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Timed_Entry_Call, Sloc);
+   begin
+      Set_Entry_Call_Alternative (N, Entry_Call_Alternative);
+      Set_Delay_Alternative (N, Delay_Alternative);
+      return N;
+   end Make_Timed_Entry_Call;
+
+   function Make_Entry_Call_Alternative (Sloc : Source_Ptr;
+      Entry_Call_Statement         : Node_Id;
+      Statements                   : List_Id := Empty_List;
+      Pragmas_Before               : List_Id := No_List)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Entry_Call_Alternative, Sloc);
+   begin
+      Set_Entry_Call_Statement (N, Entry_Call_Statement);
+      Set_Statements (N, Statements);
+      Set_Pragmas_Before (N, Pragmas_Before);
+      return N;
+   end Make_Entry_Call_Alternative;
+
+   function Make_Conditional_Entry_Call (Sloc : Source_Ptr;
+      Entry_Call_Alternative       : Node_Id;
+      Else_Statements              : List_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Conditional_Entry_Call, Sloc);
+   begin
+      Set_Entry_Call_Alternative (N, Entry_Call_Alternative);
+      Set_Else_Statements (N, Else_Statements);
+      return N;
+   end Make_Conditional_Entry_Call;
+
+   function Make_Asynchronous_Select (Sloc : Source_Ptr;
+      Triggering_Alternative       : Node_Id;
+      Abortable_Part               : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Asynchronous_Select, Sloc);
+   begin
+      Set_Triggering_Alternative (N, Triggering_Alternative);
+      Set_Abortable_Part (N, Abortable_Part);
+      return N;
+   end Make_Asynchronous_Select;
+
+   function Make_Triggering_Alternative (Sloc : Source_Ptr;
+      Triggering_Statement         : Node_Id;
+      Statements                   : List_Id := Empty_List;
+      Pragmas_Before               : List_Id := No_List)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Triggering_Alternative, Sloc);
+   begin
+      Set_Triggering_Statement (N, Triggering_Statement);
+      Set_Statements (N, Statements);
+      Set_Pragmas_Before (N, Pragmas_Before);
+      return N;
+   end Make_Triggering_Alternative;
+
+   function Make_Abortable_Part (Sloc : Source_Ptr;
+      Statements                   : List_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Abortable_Part, Sloc);
+   begin
+      Set_Statements (N, Statements);
+      return N;
+   end Make_Abortable_Part;
+
+   function Make_Abort_Statement (Sloc : Source_Ptr;
+      Names                        : List_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Abort_Statement, Sloc);
+   begin
+      Set_Names (N, Names);
+      return N;
+   end Make_Abort_Statement;
+
+   function Make_Compilation_Unit (Sloc : Source_Ptr;
+      Context_Items                : List_Id;
+      Private_Present              : Boolean := False;
+      Unit                         : Node_Id;
+      Aux_Decls_Node               : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Compilation_Unit, Sloc);
+   begin
+      Set_Context_Items (N, Context_Items);
+      Set_Private_Present (N, Private_Present);
+      Set_Unit (N, Unit);
+      Set_Aux_Decls_Node (N, Aux_Decls_Node);
+      return N;
+   end Make_Compilation_Unit;
+
+   function Make_Compilation_Unit_Aux (Sloc : Source_Ptr;
+      Declarations                 : List_Id := No_List;
+      Actions                      : List_Id := No_List;
+      Pragmas_After                : List_Id := No_List;
+      Config_Pragmas               : List_Id := Empty_List)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Compilation_Unit_Aux, Sloc);
+   begin
+      Set_Declarations (N, Declarations);
+      Set_Actions (N, Actions);
+      Set_Pragmas_After (N, Pragmas_After);
+      Set_Config_Pragmas (N, Config_Pragmas);
+      return N;
+   end Make_Compilation_Unit_Aux;
+
+   function Make_With_Clause (Sloc : Source_Ptr;
+      Name                         : Node_Id;
+      First_Name                   : Boolean := True;
+      Last_Name                    : Boolean := True;
+      Limited_Present              : Boolean := False)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_With_Clause, Sloc);
+   begin
+      Set_Name (N, Name);
+      Set_First_Name (N, First_Name);
+      Set_Last_Name (N, Last_Name);
+      Set_Limited_Present (N, Limited_Present);
+      return N;
+   end Make_With_Clause;
+
+   function Make_With_Type_Clause (Sloc : Source_Ptr;
+      Name                         : Node_Id;
+      Tagged_Present               : Boolean := False)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_With_Type_Clause, Sloc);
+   begin
+      Set_Name (N, Name);
+      Set_Tagged_Present (N, Tagged_Present);
+      return N;
+   end Make_With_Type_Clause;
+
+   function Make_Subprogram_Body_Stub (Sloc : Source_Ptr;
+      Specification                : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Subprogram_Body_Stub, Sloc);
+   begin
+      Set_Specification (N, Specification);
+      return N;
+   end Make_Subprogram_Body_Stub;
+
+   function Make_Package_Body_Stub (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Package_Body_Stub, Sloc);
+   begin
+      Set_Defining_Identifier (N, Defining_Identifier);
+      return N;
+   end Make_Package_Body_Stub;
+
+   function Make_Task_Body_Stub (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Task_Body_Stub, Sloc);
+   begin
+      Set_Defining_Identifier (N, Defining_Identifier);
+      return N;
+   end Make_Task_Body_Stub;
+
+   function Make_Protected_Body_Stub (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Protected_Body_Stub, Sloc);
+   begin
+      Set_Defining_Identifier (N, Defining_Identifier);
+      return N;
+   end Make_Protected_Body_Stub;
+
+   function Make_Subunit (Sloc : Source_Ptr;
+      Name                         : Node_Id;
+      Proper_Body                  : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Subunit, Sloc);
+   begin
+      Set_Name (N, Name);
+      Set_Proper_Body (N, Proper_Body);
+      return N;
+   end Make_Subunit;
+
+   function Make_Exception_Declaration (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Exception_Declaration, Sloc);
+   begin
+      Set_Defining_Identifier (N, Defining_Identifier);
+      return N;
+   end Make_Exception_Declaration;
+
+   function Make_Handled_Sequence_Of_Statements (Sloc : Source_Ptr;
+      Statements                   : List_Id;
+      End_Label                    : Node_Id := Empty;
+      Exception_Handlers           : List_Id := No_List;
+      At_End_Proc                  : Node_Id := Empty)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Handled_Sequence_Of_Statements, Sloc);
+   begin
+      Set_Statements (N, Statements);
+      Set_End_Label (N, End_Label);
+      Set_Exception_Handlers (N, Exception_Handlers);
+      Set_At_End_Proc (N, At_End_Proc);
+      return N;
+   end Make_Handled_Sequence_Of_Statements;
+
+   function Make_Exception_Handler (Sloc : Source_Ptr;
+      Choice_Parameter             : Node_Id := Empty;
+      Exception_Choices            : List_Id;
+      Statements                   : List_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Exception_Handler, Sloc);
+   begin
+      Set_Choice_Parameter (N, Choice_Parameter);
+      Set_Exception_Choices (N, Exception_Choices);
+      Set_Statements (N, Statements);
+      return N;
+   end Make_Exception_Handler;
+
+   function Make_Raise_Statement (Sloc : Source_Ptr;
+      Name                         : Node_Id := Empty)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Raise_Statement, Sloc);
+   begin
+      Set_Name (N, Name);
+      return N;
+   end Make_Raise_Statement;
+
+   function Make_Generic_Subprogram_Declaration (Sloc : Source_Ptr;
+      Specification                : Node_Id;
+      Generic_Formal_Declarations  : List_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Generic_Subprogram_Declaration, Sloc);
+   begin
+      Set_Specification (N, Specification);
+      Set_Generic_Formal_Declarations (N, Generic_Formal_Declarations);
+      return N;
+   end Make_Generic_Subprogram_Declaration;
+
+   function Make_Generic_Package_Declaration (Sloc : Source_Ptr;
+      Specification                : Node_Id;
+      Generic_Formal_Declarations  : List_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Generic_Package_Declaration, Sloc);
+   begin
+      Set_Specification (N, Specification);
+      Set_Generic_Formal_Declarations (N, Generic_Formal_Declarations);
+      return N;
+   end Make_Generic_Package_Declaration;
+
+   function Make_Package_Instantiation (Sloc : Source_Ptr;
+      Defining_Unit_Name           : Node_Id;
+      Name                         : Node_Id;
+      Generic_Associations         : List_Id := No_List)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Package_Instantiation, Sloc);
+   begin
+      Set_Defining_Unit_Name (N, Defining_Unit_Name);
+      Set_Name (N, Name);
+      Set_Generic_Associations (N, Generic_Associations);
+      return N;
+   end Make_Package_Instantiation;
+
+   function Make_Procedure_Instantiation (Sloc : Source_Ptr;
+      Defining_Unit_Name           : Node_Id;
+      Name                         : Node_Id;
+      Generic_Associations         : List_Id := No_List)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Procedure_Instantiation, Sloc);
+   begin
+      Set_Defining_Unit_Name (N, Defining_Unit_Name);
+      Set_Name (N, Name);
+      Set_Generic_Associations (N, Generic_Associations);
+      return N;
+   end Make_Procedure_Instantiation;
+
+   function Make_Function_Instantiation (Sloc : Source_Ptr;
+      Defining_Unit_Name           : Node_Id;
+      Name                         : Node_Id;
+      Generic_Associations         : List_Id := No_List)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Function_Instantiation, Sloc);
+   begin
+      Set_Defining_Unit_Name (N, Defining_Unit_Name);
+      Set_Name (N, Name);
+      Set_Generic_Associations (N, Generic_Associations);
+      return N;
+   end Make_Function_Instantiation;
+
+   function Make_Generic_Association (Sloc : Source_Ptr;
+      Selector_Name                : Node_Id := Empty;
+      Explicit_Generic_Actual_Parameter : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Generic_Association, Sloc);
+   begin
+      Set_Selector_Name (N, Selector_Name);
+      Set_Explicit_Generic_Actual_Parameter
+        (N, Explicit_Generic_Actual_Parameter);
+      return N;
+   end Make_Generic_Association;
+
+   function Make_Formal_Object_Declaration (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id;
+      In_Present                   : Boolean := False;
+      Out_Present                  : Boolean := False;
+      Subtype_Mark                 : Node_Id;
+      Expression                   : Node_Id := Empty)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Formal_Object_Declaration, Sloc);
+   begin
+      Set_Defining_Identifier (N, Defining_Identifier);
+      Set_In_Present (N, In_Present);
+      Set_Out_Present (N, Out_Present);
+      Set_Subtype_Mark (N, Subtype_Mark);
+      Set_Expression (N, Expression);
+      return N;
+   end Make_Formal_Object_Declaration;
+
+   function Make_Formal_Type_Declaration (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id;
+      Formal_Type_Definition       : Node_Id;
+      Discriminant_Specifications  : List_Id := No_List;
+      Unknown_Discriminants_Present : Boolean := False)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Formal_Type_Declaration, Sloc);
+   begin
+      Set_Defining_Identifier (N, Defining_Identifier);
+      Set_Formal_Type_Definition (N, Formal_Type_Definition);
+      Set_Discriminant_Specifications (N, Discriminant_Specifications);
+      Set_Unknown_Discriminants_Present
+        (N, Unknown_Discriminants_Present);
+      return N;
+   end Make_Formal_Type_Declaration;
+
+   function Make_Formal_Private_Type_Definition (Sloc : Source_Ptr;
+      Abstract_Present             : Boolean := False;
+      Tagged_Present               : Boolean := False;
+      Limited_Present              : Boolean := False)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Formal_Private_Type_Definition, Sloc);
+   begin
+      Set_Abstract_Present (N, Abstract_Present);
+      Set_Tagged_Present (N, Tagged_Present);
+      Set_Limited_Present (N, Limited_Present);
+      return N;
+   end Make_Formal_Private_Type_Definition;
+
+   function Make_Formal_Derived_Type_Definition (Sloc : Source_Ptr;
+      Subtype_Mark                 : Node_Id;
+      Private_Present              : Boolean := False;
+      Abstract_Present             : Boolean := False)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Formal_Derived_Type_Definition, Sloc);
+   begin
+      Set_Subtype_Mark (N, Subtype_Mark);
+      Set_Private_Present (N, Private_Present);
+      Set_Abstract_Present (N, Abstract_Present);
+      return N;
+   end Make_Formal_Derived_Type_Definition;
+
+   function Make_Formal_Discrete_Type_Definition (Sloc : Source_Ptr)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Formal_Discrete_Type_Definition, Sloc);
+   begin
+      return N;
+   end Make_Formal_Discrete_Type_Definition;
+
+   function Make_Formal_Signed_Integer_Type_Definition (Sloc : Source_Ptr)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Formal_Signed_Integer_Type_Definition, Sloc);
+   begin
+      return N;
+   end Make_Formal_Signed_Integer_Type_Definition;
+
+   function Make_Formal_Modular_Type_Definition (Sloc : Source_Ptr)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Formal_Modular_Type_Definition, Sloc);
+   begin
+      return N;
+   end Make_Formal_Modular_Type_Definition;
+
+   function Make_Formal_Floating_Point_Definition (Sloc : Source_Ptr)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Formal_Floating_Point_Definition, Sloc);
+   begin
+      return N;
+   end Make_Formal_Floating_Point_Definition;
+
+   function Make_Formal_Ordinary_Fixed_Point_Definition (Sloc : Source_Ptr)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Formal_Ordinary_Fixed_Point_Definition, Sloc);
+   begin
+      return N;
+   end Make_Formal_Ordinary_Fixed_Point_Definition;
+
+   function Make_Formal_Decimal_Fixed_Point_Definition (Sloc : Source_Ptr)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Formal_Decimal_Fixed_Point_Definition, Sloc);
+   begin
+      return N;
+   end Make_Formal_Decimal_Fixed_Point_Definition;
+
+   function Make_Formal_Subprogram_Declaration (Sloc : Source_Ptr;
+      Specification                : Node_Id;
+      Default_Name                 : Node_Id := Empty;
+      Box_Present                  : Boolean := False)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Formal_Subprogram_Declaration, Sloc);
+   begin
+      Set_Specification (N, Specification);
+      Set_Default_Name (N, Default_Name);
+      Set_Box_Present (N, Box_Present);
+      return N;
+   end Make_Formal_Subprogram_Declaration;
+
+   function Make_Formal_Package_Declaration (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id;
+      Name                         : Node_Id;
+      Generic_Associations         : List_Id := No_List;
+      Box_Present                  : Boolean := False)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Formal_Package_Declaration, Sloc);
+   begin
+      Set_Defining_Identifier (N, Defining_Identifier);
+      Set_Name (N, Name);
+      Set_Generic_Associations (N, Generic_Associations);
+      Set_Box_Present (N, Box_Present);
+      return N;
+   end Make_Formal_Package_Declaration;
+
+   function Make_Attribute_Definition_Clause (Sloc : Source_Ptr;
+      Name                         : Node_Id;
+      Chars                        : Name_Id;
+      Expression                   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Attribute_Definition_Clause, Sloc);
+   begin
+      Set_Name (N, Name);
+      Set_Chars (N, Chars);
+      Set_Expression (N, Expression);
+      return N;
+   end Make_Attribute_Definition_Clause;
+
+   function Make_Enumeration_Representation_Clause (Sloc : Source_Ptr;
+      Identifier                   : Node_Id;
+      Array_Aggregate              : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Enumeration_Representation_Clause, Sloc);
+   begin
+      Set_Identifier (N, Identifier);
+      Set_Array_Aggregate (N, Array_Aggregate);
+      return N;
+   end Make_Enumeration_Representation_Clause;
+
+   function Make_Record_Representation_Clause (Sloc : Source_Ptr;
+      Identifier                   : Node_Id;
+      Mod_Clause                   : Node_Id := Empty;
+      Component_Clauses            : List_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Record_Representation_Clause, Sloc);
+   begin
+      Set_Identifier (N, Identifier);
+      Set_Mod_Clause (N, Mod_Clause);
+      Set_Component_Clauses (N, Component_Clauses);
+      return N;
+   end Make_Record_Representation_Clause;
+
+   function Make_Component_Clause (Sloc : Source_Ptr;
+      Component_Name               : Node_Id;
+      Position                     : Node_Id;
+      First_Bit                    : Node_Id;
+      Last_Bit                     : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Component_Clause, Sloc);
+   begin
+      Set_Component_Name (N, Component_Name);
+      Set_Position (N, Position);
+      Set_First_Bit (N, First_Bit);
+      Set_Last_Bit (N, Last_Bit);
+      return N;
+   end Make_Component_Clause;
+
+   function Make_Code_Statement (Sloc : Source_Ptr;
+      Expression                   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Code_Statement, Sloc);
+   begin
+      Set_Expression (N, Expression);
+      return N;
+   end Make_Code_Statement;
+
+   function Make_Op_Rotate_Left (Sloc : Source_Ptr;
+      Left_Opnd                    : Node_Id;
+      Right_Opnd                   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Op_Rotate_Left, Sloc);
+   begin
+      Set_Left_Opnd (N, Left_Opnd);
+      Set_Right_Opnd (N, Right_Opnd);
+      Set_Chars (N, Name_Rotate_Left);
+      Set_Entity (N, Standard_Op_Rotate_Left);
+      return N;
+   end Make_Op_Rotate_Left;
+
+   function Make_Op_Rotate_Right (Sloc : Source_Ptr;
+      Left_Opnd                    : Node_Id;
+      Right_Opnd                   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Op_Rotate_Right, Sloc);
+   begin
+      Set_Left_Opnd (N, Left_Opnd);
+      Set_Right_Opnd (N, Right_Opnd);
+      Set_Chars (N, Name_Rotate_Right);
+      Set_Entity (N, Standard_Op_Rotate_Right);
+      return N;
+   end Make_Op_Rotate_Right;
+
+   function Make_Op_Shift_Left (Sloc : Source_Ptr;
+      Left_Opnd                    : Node_Id;
+      Right_Opnd                   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Op_Shift_Left, Sloc);
+   begin
+      Set_Left_Opnd (N, Left_Opnd);
+      Set_Right_Opnd (N, Right_Opnd);
+      Set_Chars (N, Name_Shift_Left);
+      Set_Entity (N, Standard_Op_Shift_Left);
+      return N;
+   end Make_Op_Shift_Left;
+
+   function Make_Op_Shift_Right_Arithmetic (Sloc : Source_Ptr;
+      Left_Opnd                    : Node_Id;
+      Right_Opnd                   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Op_Shift_Right_Arithmetic, Sloc);
+   begin
+      Set_Left_Opnd (N, Left_Opnd);
+      Set_Right_Opnd (N, Right_Opnd);
+      Set_Chars (N, Name_Shift_Right_Arithmetic);
+      Set_Entity (N, Standard_Op_Shift_Right_Arithmetic);
+      return N;
+   end Make_Op_Shift_Right_Arithmetic;
+
+   function Make_Op_Shift_Right (Sloc : Source_Ptr;
+      Left_Opnd                    : Node_Id;
+      Right_Opnd                   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Op_Shift_Right, Sloc);
+   begin
+      Set_Left_Opnd (N, Left_Opnd);
+      Set_Right_Opnd (N, Right_Opnd);
+      Set_Chars (N, Name_Shift_Right);
+      Set_Entity (N, Standard_Op_Shift_Right);
+      return N;
+   end Make_Op_Shift_Right;
+
+   function Make_Delta_Constraint (Sloc : Source_Ptr;
+      Delta_Expression             : Node_Id;
+      Range_Constraint             : Node_Id := Empty)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Delta_Constraint, Sloc);
+   begin
+      Set_Delta_Expression (N, Delta_Expression);
+      Set_Range_Constraint (N, Range_Constraint);
+      return N;
+   end Make_Delta_Constraint;
+
+   function Make_At_Clause (Sloc : Source_Ptr;
+      Identifier                   : Node_Id;
+      Expression                   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_At_Clause, Sloc);
+   begin
+      Set_Identifier (N, Identifier);
+      Set_Expression (N, Expression);
+      return N;
+   end Make_At_Clause;
+
+   function Make_Mod_Clause (Sloc : Source_Ptr;
+      Expression                   : Node_Id;
+      Pragmas_Before               : List_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Mod_Clause, Sloc);
+   begin
+      Set_Expression (N, Expression);
+      Set_Pragmas_Before (N, Pragmas_Before);
+      return N;
+   end Make_Mod_Clause;
+
+   function Make_Conditional_Expression (Sloc : Source_Ptr;
+      Expressions                  : List_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Conditional_Expression, Sloc);
+   begin
+      Set_Expressions (N, Expressions);
+      return N;
+   end Make_Conditional_Expression;
+
+   function Make_Expanded_Name (Sloc : Source_Ptr;
+      Chars                        : Name_Id;
+      Prefix                       : Node_Id;
+      Selector_Name                : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Expanded_Name, Sloc);
+   begin
+      Set_Chars (N, Chars);
+      Set_Prefix (N, Prefix);
+      Set_Selector_Name (N, Selector_Name);
+      return N;
+   end Make_Expanded_Name;
+
+   function Make_Free_Statement (Sloc : Source_Ptr;
+      Expression                   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Free_Statement, Sloc);
+   begin
+      Set_Expression (N, Expression);
+      return N;
+   end Make_Free_Statement;
+
+   function Make_Freeze_Entity (Sloc : Source_Ptr;
+      Actions                      : List_Id := No_List)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Freeze_Entity, Sloc);
+   begin
+      Set_Actions (N, Actions);
+      return N;
+   end Make_Freeze_Entity;
+
+   function Make_Implicit_Label_Declaration (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Implicit_Label_Declaration, Sloc);
+   begin
+      Set_Defining_Identifier (N, Defining_Identifier);
+      return N;
+   end Make_Implicit_Label_Declaration;
+
+   function Make_Itype_Reference (Sloc : Source_Ptr)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Itype_Reference, Sloc);
+   begin
+      return N;
+   end Make_Itype_Reference;
+
+   function Make_Raise_Constraint_Error (Sloc : Source_Ptr;
+      Condition                    : Node_Id := Empty;
+      Reason                       : Uint)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Raise_Constraint_Error, Sloc);
+   begin
+      Set_Condition (N, Condition);
+      Set_Reason (N, Reason);
+      return N;
+   end Make_Raise_Constraint_Error;
+
+   function Make_Raise_Program_Error (Sloc : Source_Ptr;
+      Condition                    : Node_Id := Empty;
+      Reason                       : Uint)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Raise_Program_Error, Sloc);
+   begin
+      Set_Condition (N, Condition);
+      Set_Reason (N, Reason);
+      return N;
+   end Make_Raise_Program_Error;
+
+   function Make_Raise_Storage_Error (Sloc : Source_Ptr;
+      Condition                    : Node_Id := Empty;
+      Reason                       : Uint)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Raise_Storage_Error, Sloc);
+   begin
+      Set_Condition (N, Condition);
+      Set_Reason (N, Reason);
+      return N;
+   end Make_Raise_Storage_Error;
+
+   function Make_Reference (Sloc : Source_Ptr;
+      Prefix                       : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Reference, Sloc);
+   begin
+      Set_Prefix (N, Prefix);
+      return N;
+   end Make_Reference;
+
+   function Make_Subprogram_Info (Sloc : Source_Ptr;
+      Identifier                   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Subprogram_Info, Sloc);
+   begin
+      Set_Identifier (N, Identifier);
+      return N;
+   end Make_Subprogram_Info;
+
+   function Make_Unchecked_Expression (Sloc : Source_Ptr;
+      Expression                   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Unchecked_Expression, Sloc);
+   begin
+      Set_Expression (N, Expression);
+      return N;
+   end Make_Unchecked_Expression;
+
+   function Make_Unchecked_Type_Conversion (Sloc : Source_Ptr;
+      Subtype_Mark                 : Node_Id;
+      Expression                   : Node_Id)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Unchecked_Type_Conversion, Sloc);
+   begin
+      Set_Subtype_Mark (N, Subtype_Mark);
+      Set_Expression (N, Expression);
+      return N;
+   end Make_Unchecked_Type_Conversion;
+
+   function Make_Validate_Unchecked_Conversion (Sloc : Source_Ptr)
+      return Node_Id
+   is
+      N : constant Node_Id :=
+            New_Node (N_Validate_Unchecked_Conversion, Sloc);
+   begin
+      return N;
+   end Make_Validate_Unchecked_Conversion;
+
+end Nmake;
--- gcc-3.4.0/obj-amd64-pld-linux/gcc/ada/nmake.ads.orig	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.4.0/obj-amd64-pld-linux/gcc/ada/nmake.ads	2004-06-02 00:52:35.000000000 +0200
@@ -0,0 +1,1351 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                         GNAT COMPILER COMPONENTS                         --
+--                                                                          --
+--                                N M A K E                                 --
+--                                                                          --
+--                                 S p e c                                  --
+--                                                                          --
+--          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --
+--                                                                          --
+-- GNAT is free software;  you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --
+-- for  more details.  You should have  received  a copy of the GNU General --
+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --
+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --
+-- MA 02111-1307, USA.                                                      --
+--                                                                          --
+-- GNAT was originally developed  by the GNAT team at  New York University. --
+-- Extensive contributions were provided by Ada Core Technologies Inc.      --
+--                                                                          --
+------------------------------------------------------------------------------
+
+pragma Style_Checks (All_Checks);
+--  Turn off subprogram order checking, since the routines here are
+--  generated automatically in order.
+
+
+with Nlists; use Nlists;
+with Types;  use Types;
+with Uintp;  use Uintp;
+with Urealp; use Urealp;
+
+package Nmake is
+
+--  This package contains a set of routines used to construct tree nodes
+--  using a functional style. There is one routine for each node type defined
+--  in Sinfo with the general interface:
+
+--    function Make_xxx (Sloc : Source_Ptr,
+--                       Field_Name_1 : Field_Name_1_Type [:= default]
+--                       Field_Name_2 : Field_Name_2_Type [:= default]
+--                       ...)
+--    return Node_Id
+
+--  Only syntactic fields are included (i.e. fields marked as "-Sem" or "-Lib"
+--  in the Sinfo spec are excluded). In addition, the following four syntactic
+--  fields are excluded:
+
+--    Prev_Ids
+--    More_Ids
+--    Comes_From_Source
+--    Paren_Count
+
+--  since they are very rarely set in expanded code. If they need to be set,
+--  to other than the default values (False, False, False, zero), then the
+--  appropriate Set_xxx procedures must be used on the returned value.
+
+--  Default values are provided only for flag fields (where the default is
+--  False), and for optional fields. An optional field is one where the
+--  comment line describing the field contains the string "(set to xxx if".
+--  For such fields, a default value of xxx is provided."
+
+--  Warning: since calls to Make_xxx routines are normal function calls, the
+--  arguments can be evaluated in any order. This means that at most one such
+--  argument can have side effects (e.g. be a call to a parse routine).
+
+   function Make_Unused_At_Start (Sloc : Source_Ptr)
+      return Node_Id;
+   pragma Inline (Make_Unused_At_Start);
+
+   function Make_Unused_At_End (Sloc : Source_Ptr)
+      return Node_Id;
+   pragma Inline (Make_Unused_At_End);
+
+   function Make_Identifier (Sloc : Source_Ptr;
+      Chars                        : Name_Id)
+      return Node_Id;
+   pragma Inline (Make_Identifier);
+
+   function Make_Integer_Literal (Sloc : Source_Ptr;
+      Intval                       : Uint)
+      return Node_Id;
+   pragma Inline (Make_Integer_Literal);
+
+   function Make_Real_Literal (Sloc : Source_Ptr;
+      Realval                      : Ureal)
+      return Node_Id;
+   pragma Inline (Make_Real_Literal);
+
+   function Make_Character_Literal (Sloc : Source_Ptr;
+      Chars                        : Name_Id;
+      Char_Literal_Value           : Char_Code)
+      return Node_Id;
+   pragma Inline (Make_Character_Literal);
+
+   function Make_String_Literal (Sloc : Source_Ptr;
+      Strval                       : String_Id)
+      return Node_Id;
+   pragma Inline (Make_String_Literal);
+
+   function Make_Pragma (Sloc : Source_Ptr;
+      Chars                        : Name_Id;
+      Pragma_Argument_Associations : List_Id := No_List;
+      Debug_Statement              : Node_Id := Empty)
+      return Node_Id;
+   pragma Inline (Make_Pragma);
+
+   function Make_Pragma_Argument_Association (Sloc : Source_Ptr;
+      Chars                        : Name_Id := No_Name;
+      Expression                   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Pragma_Argument_Association);
+
+   function Make_Defining_Identifier (Sloc : Source_Ptr;
+      Chars                        : Name_Id)
+      return Node_Id;
+   pragma Inline (Make_Defining_Identifier);
+
+   function Make_Full_Type_Declaration (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id;
+      Discriminant_Specifications  : List_Id := No_List;
+      Type_Definition              : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Full_Type_Declaration);
+
+   function Make_Subtype_Declaration (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id;
+      Subtype_Indication           : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Subtype_Declaration);
+
+   function Make_Subtype_Indication (Sloc : Source_Ptr;
+      Subtype_Mark                 : Node_Id;
+      Constraint                   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Subtype_Indication);
+
+   function Make_Object_Declaration (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id;
+      Aliased_Present              : Boolean := False;
+      Constant_Present             : Boolean := False;
+      Object_Definition            : Node_Id;
+      Expression                   : Node_Id := Empty)
+      return Node_Id;
+   pragma Inline (Make_Object_Declaration);
+
+   function Make_Number_Declaration (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id;
+      Expression                   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Number_Declaration);
+
+   function Make_Derived_Type_Definition (Sloc : Source_Ptr;
+      Abstract_Present             : Boolean := False;
+      Subtype_Indication           : Node_Id;
+      Record_Extension_Part        : Node_Id := Empty)
+      return Node_Id;
+   pragma Inline (Make_Derived_Type_Definition);
+
+   function Make_Range_Constraint (Sloc : Source_Ptr;
+      Range_Expression             : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Range_Constraint);
+
+   function Make_Range (Sloc : Source_Ptr;
+      Low_Bound                    : Node_Id;
+      High_Bound                   : Node_Id;
+      Includes_Infinities          : Boolean := False)
+      return Node_Id;
+   pragma Inline (Make_Range);
+
+   function Make_Enumeration_Type_Definition (Sloc : Source_Ptr;
+      Literals                     : List_Id;
+      End_Label                    : Node_Id := Empty)
+      return Node_Id;
+   pragma Inline (Make_Enumeration_Type_Definition);
+
+   function Make_Defining_Character_Literal (Sloc : Source_Ptr;
+      Chars                        : Name_Id)
+      return Node_Id;
+   pragma Inline (Make_Defining_Character_Literal);
+
+   function Make_Signed_Integer_Type_Definition (Sloc : Source_Ptr;
+      Low_Bound                    : Node_Id;
+      High_Bound                   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Signed_Integer_Type_Definition);
+
+   function Make_Modular_Type_Definition (Sloc : Source_Ptr;
+      Expression                   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Modular_Type_Definition);
+
+   function Make_Floating_Point_Definition (Sloc : Source_Ptr;
+      Digits_Expression            : Node_Id;
+      Real_Range_Specification     : Node_Id := Empty)
+      return Node_Id;
+   pragma Inline (Make_Floating_Point_Definition);
+
+   function Make_Real_Range_Specification (Sloc : Source_Ptr;
+      Low_Bound                    : Node_Id;
+      High_Bound                   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Real_Range_Specification);
+
+   function Make_Ordinary_Fixed_Point_Definition (Sloc : Source_Ptr;
+      Delta_Expression             : Node_Id;
+      Real_Range_Specification     : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Ordinary_Fixed_Point_Definition);
+
+   function Make_Decimal_Fixed_Point_Definition (Sloc : Source_Ptr;
+      Delta_Expression             : Node_Id;
+      Digits_Expression            : Node_Id;
+      Real_Range_Specification     : Node_Id := Empty)
+      return Node_Id;
+   pragma Inline (Make_Decimal_Fixed_Point_Definition);
+
+   function Make_Digits_Constraint (Sloc : Source_Ptr;
+      Digits_Expression            : Node_Id;
+      Range_Constraint             : Node_Id := Empty)
+      return Node_Id;
+   pragma Inline (Make_Digits_Constraint);
+
+   function Make_Unconstrained_Array_Definition (Sloc : Source_Ptr;
+      Subtype_Marks                : List_Id;
+      Component_Definition         : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Unconstrained_Array_Definition);
+
+   function Make_Constrained_Array_Definition (Sloc : Source_Ptr;
+      Discrete_Subtype_Definitions : List_Id;
+      Component_Definition         : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Constrained_Array_Definition);
+
+   function Make_Component_Definition (Sloc : Source_Ptr;
+      Aliased_Present              : Boolean := False;
+      Subtype_Indication           : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Component_Definition);
+
+   function Make_Discriminant_Specification (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id;
+      Discriminant_Type            : Node_Id;
+      Expression                   : Node_Id := Empty)
+      return Node_Id;
+   pragma Inline (Make_Discriminant_Specification);
+
+   function Make_Index_Or_Discriminant_Constraint (Sloc : Source_Ptr;
+      Constraints                  : List_Id)
+      return Node_Id;
+   pragma Inline (Make_Index_Or_Discriminant_Constraint);
+
+   function Make_Discriminant_Association (Sloc : Source_Ptr;
+      Selector_Names               : List_Id;
+      Expression                   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Discriminant_Association);
+
+   function Make_Record_Definition (Sloc : Source_Ptr;
+      End_Label                    : Node_Id := Empty;
+      Abstract_Present             : Boolean := False;
+      Tagged_Present               : Boolean := False;
+      Limited_Present              : Boolean := False;
+      Component_List               : Node_Id;
+      Null_Present                 : Boolean := False)
+      return Node_Id;
+   pragma Inline (Make_Record_Definition);
+
+   function Make_Component_List (Sloc : Source_Ptr;
+      Component_Items              : List_Id;
+      Variant_Part                 : Node_Id := Empty;
+      Null_Present                 : Boolean := False)
+      return Node_Id;
+   pragma Inline (Make_Component_List);
+
+   function Make_Component_Declaration (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id;
+      Component_Definition         : Node_Id;
+      Expression                   : Node_Id := Empty)
+      return Node_Id;
+   pragma Inline (Make_Component_Declaration);
+
+   function Make_Variant_Part (Sloc : Source_Ptr;
+      Name                         : Node_Id;
+      Variants                     : List_Id)
+      return Node_Id;
+   pragma Inline (Make_Variant_Part);
+
+   function Make_Variant (Sloc : Source_Ptr;
+      Discrete_Choices             : List_Id;
+      Component_List               : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Variant);
+
+   function Make_Others_Choice (Sloc : Source_Ptr)
+      return Node_Id;
+   pragma Inline (Make_Others_Choice);
+
+   function Make_Access_To_Object_Definition (Sloc : Source_Ptr;
+      All_Present                  : Boolean := False;
+      Subtype_Indication           : Node_Id;
+      Constant_Present             : Boolean := False)
+      return Node_Id;
+   pragma Inline (Make_Access_To_Object_Definition);
+
+   function Make_Access_Function_Definition (Sloc : Source_Ptr;
+      Protected_Present            : Boolean := False;
+      Parameter_Specifications     : List_Id := No_List;
+      Subtype_Mark                 : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Access_Function_Definition);
+
+   function Make_Access_Procedure_Definition (Sloc : Source_Ptr;
+      Protected_Present            : Boolean := False;
+      Parameter_Specifications     : List_Id := No_List)
+      return Node_Id;
+   pragma Inline (Make_Access_Procedure_Definition);
+
+   function Make_Access_Definition (Sloc : Source_Ptr;
+      Subtype_Mark                 : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Access_Definition);
+
+   function Make_Incomplete_Type_Declaration (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id;
+      Discriminant_Specifications  : List_Id := No_List;
+      Unknown_Discriminants_Present : Boolean := False)
+      return Node_Id;
+   pragma Inline (Make_Incomplete_Type_Declaration);
+
+   function Make_Explicit_Dereference (Sloc : Source_Ptr;
+      Prefix                       : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Explicit_Dereference);
+
+   function Make_Indexed_Component (Sloc : Source_Ptr;
+      Prefix                       : Node_Id;
+      Expressions                  : List_Id)
+      return Node_Id;
+   pragma Inline (Make_Indexed_Component);
+
+   function Make_Slice (Sloc : Source_Ptr;
+      Prefix                       : Node_Id;
+      Discrete_Range               : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Slice);
+
+   function Make_Selected_Component (Sloc : Source_Ptr;
+      Prefix                       : Node_Id;
+      Selector_Name                : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Selected_Component);
+
+   function Make_Attribute_Reference (Sloc : Source_Ptr;
+      Prefix                       : Node_Id;
+      Attribute_Name               : Name_Id;
+      Expressions                  : List_Id := No_List;
+      Must_Be_Byte_Aligned         : Boolean := False)
+      return Node_Id;
+   pragma Inline (Make_Attribute_Reference);
+
+   function Make_Aggregate (Sloc : Source_Ptr;
+      Expressions                  : List_Id := No_List;
+      Component_Associations       : List_Id := No_List;
+      Null_Record_Present          : Boolean := False)
+      return Node_Id;
+   pragma Inline (Make_Aggregate);
+
+   function Make_Component_Association (Sloc : Source_Ptr;
+      Choices                      : List_Id;
+      Expression                   : Node_Id;
+      Box_Present                  : Boolean := False)
+      return Node_Id;
+   pragma Inline (Make_Component_Association);
+
+   function Make_Extension_Aggregate (Sloc : Source_Ptr;
+      Ancestor_Part                : Node_Id;
+      Expressions                  : List_Id := No_List;
+      Component_Associations       : List_Id := No_List;
+      Null_Record_Present          : Boolean := False)
+      return Node_Id;
+   pragma Inline (Make_Extension_Aggregate);
+
+   function Make_Null (Sloc : Source_Ptr)
+      return Node_Id;
+   pragma Inline (Make_Null);
+
+   function Make_And_Then (Sloc : Source_Ptr;
+      Left_Opnd                    : Node_Id;
+      Right_Opnd                   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_And_Then);
+
+   function Make_Or_Else (Sloc : Source_Ptr;
+      Left_Opnd                    : Node_Id;
+      Right_Opnd                   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Or_Else);
+
+   function Make_In (Sloc : Source_Ptr;
+      Left_Opnd                    : Node_Id;
+      Right_Opnd                   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_In);
+
+   function Make_Not_In (Sloc : Source_Ptr;
+      Left_Opnd                    : Node_Id;
+      Right_Opnd                   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Not_In);
+
+   function Make_Op_And (Sloc : Source_Ptr;
+      Left_Opnd                    : Node_Id;
+      Right_Opnd                   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Op_And);
+
+   function Make_Op_Or (Sloc : Source_Ptr;
+      Left_Opnd                    : Node_Id;
+      Right_Opnd                   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Op_Or);
+
+   function Make_Op_Xor (Sloc : Source_Ptr;
+      Left_Opnd                    : Node_Id;
+      Right_Opnd                   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Op_Xor);
+
+   function Make_Op_Eq (Sloc : Source_Ptr;
+      Left_Opnd                    : Node_Id;
+      Right_Opnd                   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Op_Eq);
+
+   function Make_Op_Ne (Sloc : Source_Ptr;
+      Left_Opnd                    : Node_Id;
+      Right_Opnd                   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Op_Ne);
+
+   function Make_Op_Lt (Sloc : Source_Ptr;
+      Left_Opnd                    : Node_Id;
+      Right_Opnd                   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Op_Lt);
+
+   function Make_Op_Le (Sloc : Source_Ptr;
+      Left_Opnd                    : Node_Id;
+      Right_Opnd                   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Op_Le);
+
+   function Make_Op_Gt (Sloc : Source_Ptr;
+      Left_Opnd                    : Node_Id;
+      Right_Opnd                   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Op_Gt);
+
+   function Make_Op_Ge (Sloc : Source_Ptr;
+      Left_Opnd                    : Node_Id;
+      Right_Opnd                   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Op_Ge);
+
+   function Make_Op_Add (Sloc : Source_Ptr;
+      Left_Opnd                    : Node_Id;
+      Right_Opnd                   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Op_Add);
+
+   function Make_Op_Subtract (Sloc : Source_Ptr;
+      Left_Opnd                    : Node_Id;
+      Right_Opnd                   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Op_Subtract);
+
+   function Make_Op_Concat (Sloc : Source_Ptr;
+      Left_Opnd                    : Node_Id;
+      Right_Opnd                   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Op_Concat);
+
+   function Make_Op_Multiply (Sloc : Source_Ptr;
+      Left_Opnd                    : Node_Id;
+      Right_Opnd                   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Op_Multiply);
+
+   function Make_Op_Divide (Sloc : Source_Ptr;
+      Left_Opnd                    : Node_Id;
+      Right_Opnd                   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Op_Divide);
+
+   function Make_Op_Mod (Sloc : Source_Ptr;
+      Left_Opnd                    : Node_Id;
+      Right_Opnd                   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Op_Mod);
+
+   function Make_Op_Rem (Sloc : Source_Ptr;
+      Left_Opnd                    : Node_Id;
+      Right_Opnd                   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Op_Rem);
+
+   function Make_Op_Expon (Sloc : Source_Ptr;
+      Left_Opnd                    : Node_Id;
+      Right_Opnd                   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Op_Expon);
+
+   function Make_Op_Plus (Sloc : Source_Ptr;
+      Right_Opnd                   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Op_Plus);
+
+   function Make_Op_Minus (Sloc : Source_Ptr;
+      Right_Opnd                   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Op_Minus);
+
+   function Make_Op_Abs (Sloc : Source_Ptr;
+      Right_Opnd                   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Op_Abs);
+
+   function Make_Op_Not (Sloc : Source_Ptr;
+      Right_Opnd                   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Op_Not);
+
+   function Make_Type_Conversion (Sloc : Source_Ptr;
+      Subtype_Mark                 : Node_Id;
+      Expression                   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Type_Conversion);
+
+   function Make_Qualified_Expression (Sloc : Source_Ptr;
+      Subtype_Mark                 : Node_Id;
+      Expression                   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Qualified_Expression);
+
+   function Make_Allocator (Sloc : Source_Ptr;
+      Expression                   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Allocator);
+
+   function Make_Null_Statement (Sloc : Source_Ptr)
+      return Node_Id;
+   pragma Inline (Make_Null_Statement);
+
+   function Make_Label (Sloc : Source_Ptr;
+      Identifier                   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Label);
+
+   function Make_Assignment_Statement (Sloc : Source_Ptr;
+      Name                         : Node_Id;
+      Expression                   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Assignment_Statement);
+
+   function Make_If_Statement (Sloc : Source_Ptr;
+      Condition                    : Node_Id;
+      Then_Statements              : List_Id;
+      Elsif_Parts                  : List_Id := No_List;
+      Else_Statements              : List_Id := No_List;
+      End_Span                     : Uint := No_Uint)
+      return Node_Id;
+   pragma Inline (Make_If_Statement);
+
+   function Make_Elsif_Part (Sloc : Source_Ptr;
+      Condition                    : Node_Id;
+      Then_Statements              : List_Id)
+      return Node_Id;
+   pragma Inline (Make_Elsif_Part);
+
+   function Make_Case_Statement (Sloc : Source_Ptr;
+      Expression                   : Node_Id;
+      Alternatives                 : List_Id;
+      End_Span                     : Uint := No_Uint)
+      return Node_Id;
+   pragma Inline (Make_Case_Statement);
+
+   function Make_Case_Statement_Alternative (Sloc : Source_Ptr;
+      Discrete_Choices             : List_Id;
+      Statements                   : List_Id)
+      return Node_Id;
+   pragma Inline (Make_Case_Statement_Alternative);
+
+   function Make_Loop_Statement (Sloc : Source_Ptr;
+      Identifier                   : Node_Id := Empty;
+      Iteration_Scheme             : Node_Id := Empty;
+      Statements                   : List_Id;
+      End_Label                    : Node_Id;
+      Has_Created_Identifier       : Boolean := False;
+      Is_Null_Loop                 : Boolean := False)
+      return Node_Id;
+   pragma Inline (Make_Loop_Statement);
+
+   function Make_Iteration_Scheme (Sloc : Source_Ptr;
+      Condition                    : Node_Id := Empty;
+      Loop_Parameter_Specification : Node_Id := Empty)
+      return Node_Id;
+   pragma Inline (Make_Iteration_Scheme);
+
+   function Make_Loop_Parameter_Specification (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id;
+      Reverse_Present              : Boolean := False;
+      Discrete_Subtype_Definition  : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Loop_Parameter_Specification);
+
+   function Make_Block_Statement (Sloc : Source_Ptr;
+      Identifier                   : Node_Id := Empty;
+      Declarations                 : List_Id := No_List;
+      Handled_Statement_Sequence   : Node_Id;
+      Has_Created_Identifier       : Boolean := False;
+      Is_Task_Allocation_Block     : Boolean := False;
+      Is_Asynchronous_Call_Block   : Boolean := False)
+      return Node_Id;
+   pragma Inline (Make_Block_Statement);
+
+   function Make_Exit_Statement (Sloc : Source_Ptr;
+      Name                         : Node_Id := Empty;
+      Condition                    : Node_Id := Empty)
+      return Node_Id;
+   pragma Inline (Make_Exit_Statement);
+
+   function Make_Goto_Statement (Sloc : Source_Ptr;
+      Name                         : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Goto_Statement);
+
+   function Make_Subprogram_Declaration (Sloc : Source_Ptr;
+      Specification                : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Subprogram_Declaration);
+
+   function Make_Abstract_Subprogram_Declaration (Sloc : Source_Ptr;
+      Specification                : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Abstract_Subprogram_Declaration);
+
+   function Make_Function_Specification (Sloc : Source_Ptr;
+      Defining_Unit_Name           : Node_Id;
+      Parameter_Specifications     : List_Id := No_List;
+      Subtype_Mark                 : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Function_Specification);
+
+   function Make_Procedure_Specification (Sloc : Source_Ptr;
+      Defining_Unit_Name           : Node_Id;
+      Parameter_Specifications     : List_Id := No_List)
+      return Node_Id;
+   pragma Inline (Make_Procedure_Specification);
+
+   function Make_Designator (Sloc : Source_Ptr;
+      Name                         : Node_Id;
+      Identifier                   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Designator);
+
+   function Make_Defining_Program_Unit_Name (Sloc : Source_Ptr;
+      Name                         : Node_Id;
+      Defining_Identifier          : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Defining_Program_Unit_Name);
+
+   function Make_Operator_Symbol (Sloc : Source_Ptr;
+      Chars                        : Name_Id;
+      Strval                       : String_Id)
+      return Node_Id;
+   pragma Inline (Make_Operator_Symbol);
+
+   function Make_Defining_Operator_Symbol (Sloc : Source_Ptr;
+      Chars                        : Name_Id)
+      return Node_Id;
+   pragma Inline (Make_Defining_Operator_Symbol);
+
+   function Make_Parameter_Specification (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id;
+      In_Present                   : Boolean := False;
+      Out_Present                  : Boolean := False;
+      Parameter_Type               : Node_Id;
+      Expression                   : Node_Id := Empty)
+      return Node_Id;
+   pragma Inline (Make_Parameter_Specification);
+
+   function Make_Subprogram_Body (Sloc : Source_Ptr;
+      Specification                : Node_Id;
+      Declarations                 : List_Id;
+      Handled_Statement_Sequence   : Node_Id;
+      Bad_Is_Detected              : Boolean := False)
+      return Node_Id;
+   pragma Inline (Make_Subprogram_Body);
+
+   function Make_Procedure_Call_Statement (Sloc : Source_Ptr;
+      Name                         : Node_Id;
+      Parameter_Associations       : List_Id := No_List)
+      return Node_Id;
+   pragma Inline (Make_Procedure_Call_Statement);
+
+   function Make_Function_Call (Sloc : Source_Ptr;
+      Name                         : Node_Id;
+      Parameter_Associations       : List_Id := No_List)
+      return Node_Id;
+   pragma Inline (Make_Function_Call);
+
+   function Make_Parameter_Association (Sloc : Source_Ptr;
+      Selector_Name                : Node_Id;
+      Explicit_Actual_Parameter    : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Parameter_Association);
+
+   function Make_Return_Statement (Sloc : Source_Ptr;
+      Expression                   : Node_Id := Empty)
+      return Node_Id;
+   pragma Inline (Make_Return_Statement);
+
+   function Make_Package_Declaration (Sloc : Source_Ptr;
+      Specification                : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Package_Declaration);
+
+   function Make_Package_Specification (Sloc : Source_Ptr;
+      Defining_Unit_Name           : Node_Id;
+      Visible_Declarations         : List_Id;
+      Private_Declarations         : List_Id := No_List;
+      End_Label                    : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Package_Specification);
+
+   function Make_Package_Body (Sloc : Source_Ptr;
+      Defining_Unit_Name           : Node_Id;
+      Declarations                 : List_Id;
+      Handled_Statement_Sequence   : Node_Id := Empty)
+      return Node_Id;
+   pragma Inline (Make_Package_Body);
+
+   function Make_Private_Type_Declaration (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id;
+      Discriminant_Specifications  : List_Id := No_List;
+      Unknown_Discriminants_Present : Boolean := False;
+      Abstract_Present             : Boolean := False;
+      Tagged_Present               : Boolean := False;
+      Limited_Present              : Boolean := False)
+      return Node_Id;
+   pragma Inline (Make_Private_Type_Declaration);
+
+   function Make_Private_Extension_Declaration (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id;
+      Discriminant_Specifications  : List_Id := No_List;
+      Unknown_Discriminants_Present : Boolean := False;
+      Abstract_Present             : Boolean := False;
+      Subtype_Indication           : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Private_Extension_Declaration);
+
+   function Make_Use_Package_Clause (Sloc : Source_Ptr;
+      Names                        : List_Id)
+      return Node_Id;
+   pragma Inline (Make_Use_Package_Clause);
+
+   function Make_Use_Type_Clause (Sloc : Source_Ptr;
+      Subtype_Marks                : List_Id)
+      return Node_Id;
+   pragma Inline (Make_Use_Type_Clause);
+
+   function Make_Object_Renaming_Declaration (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id;
+      Subtype_Mark                 : Node_Id;
+      Name                         : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Object_Renaming_Declaration);
+
+   function Make_Exception_Renaming_Declaration (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id;
+      Name                         : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Exception_Renaming_Declaration);
+
+   function Make_Package_Renaming_Declaration (Sloc : Source_Ptr;
+      Defining_Unit_Name           : Node_Id;
+      Name                         : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Package_Renaming_Declaration);
+
+   function Make_Subprogram_Renaming_Declaration (Sloc : Source_Ptr;
+      Specification                : Node_Id;
+      Name                         : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Subprogram_Renaming_Declaration);
+
+   function Make_Generic_Package_Renaming_Declaration (Sloc : Source_Ptr;
+      Defining_Unit_Name           : Node_Id;
+      Name                         : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Generic_Package_Renaming_Declaration);
+
+   function Make_Generic_Procedure_Renaming_Declaration (Sloc : Source_Ptr;
+      Defining_Unit_Name           : Node_Id;
+      Name                         : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Generic_Procedure_Renaming_Declaration);
+
+   function Make_Generic_Function_Renaming_Declaration (Sloc : Source_Ptr;
+      Defining_Unit_Name           : Node_Id;
+      Name                         : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Generic_Function_Renaming_Declaration);
+
+   function Make_Task_Type_Declaration (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id;
+      Discriminant_Specifications  : List_Id := No_List;
+      Task_Definition              : Node_Id := Empty)
+      return Node_Id;
+   pragma Inline (Make_Task_Type_Declaration);
+
+   function Make_Single_Task_Declaration (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id;
+      Task_Definition              : Node_Id := Empty)
+      return Node_Id;
+   pragma Inline (Make_Single_Task_Declaration);
+
+   function Make_Task_Definition (Sloc : Source_Ptr;
+      Visible_Declarations         : List_Id;
+      Private_Declarations         : List_Id := No_List;
+      End_Label                    : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Task_Definition);
+
+   function Make_Task_Body (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id;
+      Declarations                 : List_Id;
+      Handled_Statement_Sequence   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Task_Body);
+
+   function Make_Protected_Type_Declaration (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id;
+      Discriminant_Specifications  : List_Id := No_List;
+      Protected_Definition         : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Protected_Type_Declaration);
+
+   function Make_Single_Protected_Declaration (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id;
+      Protected_Definition         : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Single_Protected_Declaration);
+
+   function Make_Protected_Definition (Sloc : Source_Ptr;
+      Visible_Declarations         : List_Id;
+      Private_Declarations         : List_Id := No_List;
+      End_Label                    : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Protected_Definition);
+
+   function Make_Protected_Body (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id;
+      Declarations                 : List_Id;
+      End_Label                    : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Protected_Body);
+
+   function Make_Entry_Declaration (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id;
+      Discrete_Subtype_Definition  : Node_Id := Empty;
+      Parameter_Specifications     : List_Id := No_List)
+      return Node_Id;
+   pragma Inline (Make_Entry_Declaration);
+
+   function Make_Accept_Statement (Sloc : Source_Ptr;
+      Entry_Direct_Name            : Node_Id;
+      Entry_Index                  : Node_Id := Empty;
+      Parameter_Specifications     : List_Id := No_List;
+      Handled_Statement_Sequence   : Node_Id;
+      Declarations                 : List_Id := No_List)
+      return Node_Id;
+   pragma Inline (Make_Accept_Statement);
+
+   function Make_Entry_Body (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id;
+      Entry_Body_Formal_Part       : Node_Id;
+      Declarations                 : List_Id;
+      Handled_Statement_Sequence   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Entry_Body);
+
+   function Make_Entry_Body_Formal_Part (Sloc : Source_Ptr;
+      Entry_Index_Specification    : Node_Id := Empty;
+      Parameter_Specifications     : List_Id := No_List;
+      Condition                    : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Entry_Body_Formal_Part);
+
+   function Make_Entry_Index_Specification (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id;
+      Discrete_Subtype_Definition  : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Entry_Index_Specification);
+
+   function Make_Entry_Call_Statement (Sloc : Source_Ptr;
+      Name                         : Node_Id;
+      Parameter_Associations       : List_Id := No_List)
+      return Node_Id;
+   pragma Inline (Make_Entry_Call_Statement);
+
+   function Make_Requeue_Statement (Sloc : Source_Ptr;
+      Name                         : Node_Id;
+      Abort_Present                : Boolean := False)
+      return Node_Id;
+   pragma Inline (Make_Requeue_Statement);
+
+   function Make_Delay_Until_Statement (Sloc : Source_Ptr;
+      Expression                   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Delay_Until_Statement);
+
+   function Make_Delay_Relative_Statement (Sloc : Source_Ptr;
+      Expression                   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Delay_Relative_Statement);
+
+   function Make_Selective_Accept (Sloc : Source_Ptr;
+      Select_Alternatives          : List_Id;
+      Else_Statements              : List_Id := No_List)
+      return Node_Id;
+   pragma Inline (Make_Selective_Accept);
+
+   function Make_Accept_Alternative (Sloc : Source_Ptr;
+      Accept_Statement             : Node_Id;
+      Condition                    : Node_Id := Empty;
+      Statements                   : List_Id := Empty_List;
+      Pragmas_Before               : List_Id := No_List)
+      return Node_Id;
+   pragma Inline (Make_Accept_Alternative);
+
+   function Make_Delay_Alternative (Sloc : Source_Ptr;
+      Delay_Statement              : Node_Id;
+      Condition                    : Node_Id := Empty;
+      Statements                   : List_Id := Empty_List;
+      Pragmas_Before               : List_Id := No_List)
+      return Node_Id;
+   pragma Inline (Make_Delay_Alternative);
+
+   function Make_Terminate_Alternative (Sloc : Source_Ptr;
+      Condition                    : Node_Id := Empty;
+      Pragmas_Before               : List_Id := No_List;
+      Pragmas_After                : List_Id := No_List)
+      return Node_Id;
+   pragma Inline (Make_Terminate_Alternative);
+
+   function Make_Timed_Entry_Call (Sloc : Source_Ptr;
+      Entry_Call_Alternative       : Node_Id;
+      Delay_Alternative            : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Timed_Entry_Call);
+
+   function Make_Entry_Call_Alternative (Sloc : Source_Ptr;
+      Entry_Call_Statement         : Node_Id;
+      Statements                   : List_Id := Empty_List;
+      Pragmas_Before               : List_Id := No_List)
+      return Node_Id;
+   pragma Inline (Make_Entry_Call_Alternative);
+
+   function Make_Conditional_Entry_Call (Sloc : Source_Ptr;
+      Entry_Call_Alternative       : Node_Id;
+      Else_Statements              : List_Id)
+      return Node_Id;
+   pragma Inline (Make_Conditional_Entry_Call);
+
+   function Make_Asynchronous_Select (Sloc : Source_Ptr;
+      Triggering_Alternative       : Node_Id;
+      Abortable_Part               : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Asynchronous_Select);
+
+   function Make_Triggering_Alternative (Sloc : Source_Ptr;
+      Triggering_Statement         : Node_Id;
+      Statements                   : List_Id := Empty_List;
+      Pragmas_Before               : List_Id := No_List)
+      return Node_Id;
+   pragma Inline (Make_Triggering_Alternative);
+
+   function Make_Abortable_Part (Sloc : Source_Ptr;
+      Statements                   : List_Id)
+      return Node_Id;
+   pragma Inline (Make_Abortable_Part);
+
+   function Make_Abort_Statement (Sloc : Source_Ptr;
+      Names                        : List_Id)
+      return Node_Id;
+   pragma Inline (Make_Abort_Statement);
+
+   function Make_Compilation_Unit (Sloc : Source_Ptr;
+      Context_Items                : List_Id;
+      Private_Present              : Boolean := False;
+      Unit                         : Node_Id;
+      Aux_Decls_Node               : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Compilation_Unit);
+
+   function Make_Compilation_Unit_Aux (Sloc : Source_Ptr;
+      Declarations                 : List_Id := No_List;
+      Actions                      : List_Id := No_List;
+      Pragmas_After                : List_Id := No_List;
+      Config_Pragmas               : List_Id := Empty_List)
+      return Node_Id;
+   pragma Inline (Make_Compilation_Unit_Aux);
+
+   function Make_With_Clause (Sloc : Source_Ptr;
+      Name                         : Node_Id;
+      First_Name                   : Boolean := True;
+      Last_Name                    : Boolean := True;
+      Limited_Present              : Boolean := False)
+      return Node_Id;
+   pragma Inline (Make_With_Clause);
+
+   function Make_With_Type_Clause (Sloc : Source_Ptr;
+      Name                         : Node_Id;
+      Tagged_Present               : Boolean := False)
+      return Node_Id;
+   pragma Inline (Make_With_Type_Clause);
+
+   function Make_Subprogram_Body_Stub (Sloc : Source_Ptr;
+      Specification                : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Subprogram_Body_Stub);
+
+   function Make_Package_Body_Stub (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Package_Body_Stub);
+
+   function Make_Task_Body_Stub (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Task_Body_Stub);
+
+   function Make_Protected_Body_Stub (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Protected_Body_Stub);
+
+   function Make_Subunit (Sloc : Source_Ptr;
+      Name                         : Node_Id;
+      Proper_Body                  : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Subunit);
+
+   function Make_Exception_Declaration (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Exception_Declaration);
+
+   function Make_Handled_Sequence_Of_Statements (Sloc : Source_Ptr;
+      Statements                   : List_Id;
+      End_Label                    : Node_Id := Empty;
+      Exception_Handlers           : List_Id := No_List;
+      At_End_Proc                  : Node_Id := Empty)
+      return Node_Id;
+   pragma Inline (Make_Handled_Sequence_Of_Statements);
+
+   function Make_Exception_Handler (Sloc : Source_Ptr;
+      Choice_Parameter             : Node_Id := Empty;
+      Exception_Choices            : List_Id;
+      Statements                   : List_Id)
+      return Node_Id;
+   pragma Inline (Make_Exception_Handler);
+
+   function Make_Raise_Statement (Sloc : Source_Ptr;
+      Name                         : Node_Id := Empty)
+      return Node_Id;
+   pragma Inline (Make_Raise_Statement);
+
+   function Make_Generic_Subprogram_Declaration (Sloc : Source_Ptr;
+      Specification                : Node_Id;
+      Generic_Formal_Declarations  : List_Id)
+      return Node_Id;
+   pragma Inline (Make_Generic_Subprogram_Declaration);
+
+   function Make_Generic_Package_Declaration (Sloc : Source_Ptr;
+      Specification                : Node_Id;
+      Generic_Formal_Declarations  : List_Id)
+      return Node_Id;
+   pragma Inline (Make_Generic_Package_Declaration);
+
+   function Make_Package_Instantiation (Sloc : Source_Ptr;
+      Defining_Unit_Name           : Node_Id;
+      Name                         : Node_Id;
+      Generic_Associations         : List_Id := No_List)
+      return Node_Id;
+   pragma Inline (Make_Package_Instantiation);
+
+   function Make_Procedure_Instantiation (Sloc : Source_Ptr;
+      Defining_Unit_Name           : Node_Id;
+      Name                         : Node_Id;
+      Generic_Associations         : List_Id := No_List)
+      return Node_Id;
+   pragma Inline (Make_Procedure_Instantiation);
+
+   function Make_Function_Instantiation (Sloc : Source_Ptr;
+      Defining_Unit_Name           : Node_Id;
+      Name                         : Node_Id;
+      Generic_Associations         : List_Id := No_List)
+      return Node_Id;
+   pragma Inline (Make_Function_Instantiation);
+
+   function Make_Generic_Association (Sloc : Source_Ptr;
+      Selector_Name                : Node_Id := Empty;
+      Explicit_Generic_Actual_Parameter : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Generic_Association);
+
+   function Make_Formal_Object_Declaration (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id;
+      In_Present                   : Boolean := False;
+      Out_Present                  : Boolean := False;
+      Subtype_Mark                 : Node_Id;
+      Expression                   : Node_Id := Empty)
+      return Node_Id;
+   pragma Inline (Make_Formal_Object_Declaration);
+
+   function Make_Formal_Type_Declaration (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id;
+      Formal_Type_Definition       : Node_Id;
+      Discriminant_Specifications  : List_Id := No_List;
+      Unknown_Discriminants_Present : Boolean := False)
+      return Node_Id;
+   pragma Inline (Make_Formal_Type_Declaration);
+
+   function Make_Formal_Private_Type_Definition (Sloc : Source_Ptr;
+      Abstract_Present             : Boolean := False;
+      Tagged_Present               : Boolean := False;
+      Limited_Present              : Boolean := False)
+      return Node_Id;
+   pragma Inline (Make_Formal_Private_Type_Definition);
+
+   function Make_Formal_Derived_Type_Definition (Sloc : Source_Ptr;
+      Subtype_Mark                 : Node_Id;
+      Private_Present              : Boolean := False;
+      Abstract_Present             : Boolean := False)
+      return Node_Id;
+   pragma Inline (Make_Formal_Derived_Type_Definition);
+
+   function Make_Formal_Discrete_Type_Definition (Sloc : Source_Ptr)
+      return Node_Id;
+   pragma Inline (Make_Formal_Discrete_Type_Definition);
+
+   function Make_Formal_Signed_Integer_Type_Definition (Sloc : Source_Ptr)
+      return Node_Id;
+   pragma Inline (Make_Formal_Signed_Integer_Type_Definition);
+
+   function Make_Formal_Modular_Type_Definition (Sloc : Source_Ptr)
+      return Node_Id;
+   pragma Inline (Make_Formal_Modular_Type_Definition);
+
+   function Make_Formal_Floating_Point_Definition (Sloc : Source_Ptr)
+      return Node_Id;
+   pragma Inline (Make_Formal_Floating_Point_Definition);
+
+   function Make_Formal_Ordinary_Fixed_Point_Definition (Sloc : Source_Ptr)
+      return Node_Id;
+   pragma Inline (Make_Formal_Ordinary_Fixed_Point_Definition);
+
+   function Make_Formal_Decimal_Fixed_Point_Definition (Sloc : Source_Ptr)
+      return Node_Id;
+   pragma Inline (Make_Formal_Decimal_Fixed_Point_Definition);
+
+   function Make_Formal_Subprogram_Declaration (Sloc : Source_Ptr;
+      Specification                : Node_Id;
+      Default_Name                 : Node_Id := Empty;
+      Box_Present                  : Boolean := False)
+      return Node_Id;
+   pragma Inline (Make_Formal_Subprogram_Declaration);
+
+   function Make_Formal_Package_Declaration (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id;
+      Name                         : Node_Id;
+      Generic_Associations         : List_Id := No_List;
+      Box_Present                  : Boolean := False)
+      return Node_Id;
+   pragma Inline (Make_Formal_Package_Declaration);
+
+   function Make_Attribute_Definition_Clause (Sloc : Source_Ptr;
+      Name                         : Node_Id;
+      Chars                        : Name_Id;
+      Expression                   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Attribute_Definition_Clause);
+
+   function Make_Enumeration_Representation_Clause (Sloc : Source_Ptr;
+      Identifier                   : Node_Id;
+      Array_Aggregate              : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Enumeration_Representation_Clause);
+
+   function Make_Record_Representation_Clause (Sloc : Source_Ptr;
+      Identifier                   : Node_Id;
+      Mod_Clause                   : Node_Id := Empty;
+      Component_Clauses            : List_Id)
+      return Node_Id;
+   pragma Inline (Make_Record_Representation_Clause);
+
+   function Make_Component_Clause (Sloc : Source_Ptr;
+      Component_Name               : Node_Id;
+      Position                     : Node_Id;
+      First_Bit                    : Node_Id;
+      Last_Bit                     : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Component_Clause);
+
+   function Make_Code_Statement (Sloc : Source_Ptr;
+      Expression                   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Code_Statement);
+
+   function Make_Op_Rotate_Left (Sloc : Source_Ptr;
+      Left_Opnd                    : Node_Id;
+      Right_Opnd                   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Op_Rotate_Left);
+
+   function Make_Op_Rotate_Right (Sloc : Source_Ptr;
+      Left_Opnd                    : Node_Id;
+      Right_Opnd                   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Op_Rotate_Right);
+
+   function Make_Op_Shift_Left (Sloc : Source_Ptr;
+      Left_Opnd                    : Node_Id;
+      Right_Opnd                   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Op_Shift_Left);
+
+   function Make_Op_Shift_Right_Arithmetic (Sloc : Source_Ptr;
+      Left_Opnd                    : Node_Id;
+      Right_Opnd                   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Op_Shift_Right_Arithmetic);
+
+   function Make_Op_Shift_Right (Sloc : Source_Ptr;
+      Left_Opnd                    : Node_Id;
+      Right_Opnd                   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Op_Shift_Right);
+
+   function Make_Delta_Constraint (Sloc : Source_Ptr;
+      Delta_Expression             : Node_Id;
+      Range_Constraint             : Node_Id := Empty)
+      return Node_Id;
+   pragma Inline (Make_Delta_Constraint);
+
+   function Make_At_Clause (Sloc : Source_Ptr;
+      Identifier                   : Node_Id;
+      Expression                   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_At_Clause);
+
+   function Make_Mod_Clause (Sloc : Source_Ptr;
+      Expression                   : Node_Id;
+      Pragmas_Before               : List_Id)
+      return Node_Id;
+   pragma Inline (Make_Mod_Clause);
+
+   function Make_Conditional_Expression (Sloc : Source_Ptr;
+      Expressions                  : List_Id)
+      return Node_Id;
+   pragma Inline (Make_Conditional_Expression);
+
+   function Make_Expanded_Name (Sloc : Source_Ptr;
+      Chars                        : Name_Id;
+      Prefix                       : Node_Id;
+      Selector_Name                : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Expanded_Name);
+
+   function Make_Free_Statement (Sloc : Source_Ptr;
+      Expression                   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Free_Statement);
+
+   function Make_Freeze_Entity (Sloc : Source_Ptr;
+      Actions                      : List_Id := No_List)
+      return Node_Id;
+   pragma Inline (Make_Freeze_Entity);
+
+   function Make_Implicit_Label_Declaration (Sloc : Source_Ptr;
+      Defining_Identifier          : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Implicit_Label_Declaration);
+
+   function Make_Itype_Reference (Sloc : Source_Ptr)
+      return Node_Id;
+   pragma Inline (Make_Itype_Reference);
+
+   function Make_Raise_Constraint_Error (Sloc : Source_Ptr;
+      Condition                    : Node_Id := Empty;
+      Reason                       : Uint)
+      return Node_Id;
+   pragma Inline (Make_Raise_Constraint_Error);
+
+   function Make_Raise_Program_Error (Sloc : Source_Ptr;
+      Condition                    : Node_Id := Empty;
+      Reason                       : Uint)
+      return Node_Id;
+   pragma Inline (Make_Raise_Program_Error);
+
+   function Make_Raise_Storage_Error (Sloc : Source_Ptr;
+      Condition                    : Node_Id := Empty;
+      Reason                       : Uint)
+      return Node_Id;
+   pragma Inline (Make_Raise_Storage_Error);
+
+   function Make_Reference (Sloc : Source_Ptr;
+      Prefix                       : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Reference);
+
+   function Make_Subprogram_Info (Sloc : Source_Ptr;
+      Identifier                   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Subprogram_Info);
+
+   function Make_Unchecked_Expression (Sloc : Source_Ptr;
+      Expression                   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Unchecked_Expression);
+
+   function Make_Unchecked_Type_Conversion (Sloc : Source_Ptr;
+      Subtype_Mark                 : Node_Id;
+      Expression                   : Node_Id)
+      return Node_Id;
+   pragma Inline (Make_Unchecked_Type_Conversion);
+
+   function Make_Validate_Unchecked_Conversion (Sloc : Source_Ptr)
+      return Node_Id;
+   pragma Inline (Make_Validate_Unchecked_Conversion);
+
+end Nmake;
--- gcc-3.4.0/obj-amd64-pld-linux/gcc/ada/treeprs.ads.orig	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.4.0/obj-amd64-pld-linux/gcc/ada/treeprs.ads	2004-06-02 00:54:11.000000000 +0200
@@ -0,0 +1,801 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                         GNAT COMPILER COMPONENTS                         --
+--                                                                          --
+--                              T R E E P R S                               --
+--                                                                          --
+--                                 S p e c                                  --
+--                                                                          --
+--          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --
+--                                                                          --
+-- GNAT is free software;  you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --
+-- for  more details.  You should have  received  a copy of the GNU General --
+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --
+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --
+-- MA 02111-1307, USA.                                                      --
+--                                                                          --
+-- GNAT was originally developed  by the GNAT team at  New York University. --
+-- Extensive contributions were provided by Ada Core Technologies Inc.      --
+--                                                                          --
+------------------------------------------------------------------------------
+
+
+--  This package contains the declaration of the string used by the Tree_Print
+--  package. It must be updated whenever the arrangements of the field names
+--  in package Sinfo is changed. The utility program XTREEPRS is used to
+--  do this update correctly using the template treeprs.adt as input.
+
+with Sinfo; use Sinfo;
+
+package Treeprs is
+
+   --------------------------------
+   -- String Data for Node Print --
+   --------------------------------
+
+   --  String data for print out. The Pchars array is a long string with the
+   --  the entry for each node type consisting of a single blank, followed by
+   --  a series of entries, one for each Op or Flag field used for the node.
+   --  Each entry has a single character which identifies the field, followed
+   --  by the synonym name. The starting location for a given node type is
+   --  found from the corresponding entry in the Pchars_Pos_Array.
+
+   --  The following characters identify the field. These are characters
+   --  which  could never occur in a field name, so they also mark the
+   --  end of the previous name.
+
+   subtype Fchar is Character range '#' .. '9';
+
+   F_Field1     : constant Fchar := '#'; -- Character'Val (16#23#)
+   F_Field2     : constant Fchar := '$'; -- Character'Val (16#24#)
+   F_Field3     : constant Fchar := '%'; -- Character'Val (16#25#)
+   F_Field4     : constant Fchar := '&'; -- Character'Val (16#26#)
+   F_Field5     : constant Fchar := '''; -- Character'Val (16#27#)
+   F_Flag1      : constant Fchar := '('; -- Character'Val (16#28#)
+   F_Flag2      : constant Fchar := ')'; -- Character'Val (16#29#)
+   F_Flag3      : constant Fchar := '*'; -- Character'Val (16#2A#)
+   F_Flag4      : constant Fchar := '+'; -- Character'Val (16#2B#)
+   F_Flag5      : constant Fchar := ','; -- Character'Val (16#2C#)
+   F_Flag6      : constant Fchar := '-'; -- Character'Val (16#2D#)
+   F_Flag7      : constant Fchar := '.'; -- Character'Val (16#2E#)
+   F_Flag8      : constant Fchar := '/'; -- Character'Val (16#2F#)
+   F_Flag9      : constant Fchar := '0'; -- Character'Val (16#30#)
+   F_Flag10     : constant Fchar := '1'; -- Character'Val (16#31#)
+   F_Flag11     : constant Fchar := '2'; -- Character'Val (16#32#)
+   F_Flag12     : constant Fchar := '3'; -- Character'Val (16#33#)
+   F_Flag13     : constant Fchar := '4'; -- Character'Val (16#34#)
+   F_Flag14     : constant Fchar := '5'; -- Character'Val (16#35#)
+   F_Flag15     : constant Fchar := '6'; -- Character'Val (16#36#)
+   F_Flag16     : constant Fchar := '7'; -- Character'Val (16#37#)
+   F_Flag17     : constant Fchar := '8'; -- Character'Val (16#38#)
+   F_Flag18     : constant Fchar := '9'; -- Character'Val (16#39#)
+
+   --  Note this table does not include entity field and flags whose access
+   --  functions are in Einfo (these are handled by the Print_Entity_Info
+   --  procedure in Treepr, which uses the routines in Einfo to get the
+   --  proper symbolic information). In addition, the following fields are
+   --  handled by Treepr, and do not appear in the Pchars array:
+
+   --    Analyzed
+   --    Cannot_Be_Constant
+   --    Chars
+   --    Comes_From_Source
+   --    Error_Posted
+   --    Etype
+   --    Is_Controlling_Actual
+   --    Is_Overloaded
+   --    Is_Static_Expression
+   --    Left_Opnd
+   --    Must_Check_Expr
+   --    Must_Not_Freeze
+   --    No_Overflow_Expr
+   --    Paren_Count
+   --    Raises_Constraint_Error
+   --    Right_Opnd
+
+   Pchars : constant String :=
+      --  Unused_At_Start
+      "" &
+      --  At_Clause
+      "#Identifier%Expression" &
+      --  Component_Clause
+      "#Component_Name$Position%First_Bit&Last_Bit" &
+      --  Enumeration_Representation_Clause
+      "#Identifier%Array_Aggregate&Next_Rep_Item" &
+      --  Mod_Clause
+      "%Expression&Pragmas_Before" &
+      --  Record_Representation_Clause
+      "#Identifier$Mod_Clause%Component_Clauses&Next_Rep_Item" &
+      --  Attribute_Definition_Clause
+      "$Name%Expression&Next_Rep_Item+From_At_Mod2Check_Address_Alignment" &
+      --  Empty
+      "" &
+      --  Pragma
+      "$Pragma_Argument_Associations%Debug_Statement&Next_Rep_Item" &
+      --  Pragma_Argument_Association
+      "%Expression" &
+      --  Error
+      "" &
+      --  Defining_Character_Literal
+      "$Next_Entity%Scope" &
+      --  Defining_Identifier
+      "$Next_Entity%Scope" &
+      --  Defining_Operator_Symbol
+      "$Next_Entity%Scope" &
+      --  Expanded_Name
+      "%Prefix$Selector_Name&Entity&Associated_Node4Redundant_Use2Has_Privat" &
+         "e_View" &
+      --  Identifier
+      "&Entity&Associated_Node$Original_Discriminant4Redundant_Use2Has_Priva" &
+         "te_View" &
+      --  Operator_Symbol
+      "%Strval&Entity&Associated_Node2Has_Private_View" &
+      --  Character_Literal
+      "$Char_Literal_Value&Entity&Associated_Node2Has_Private_View" &
+      --  Op_Add
+      "" &
+      --  Op_Concat
+      "4Is_Component_Left_Opnd5Is_Component_Right_Opnd" &
+      --  Op_Expon
+      "4Is_Power_Of_2_For_Shift" &
+      --  Op_Subtract
+      "" &
+      --  Op_Divide
+      "5Treat_Fixed_As_Integer4Do_Division_Check9Rounded_Result" &
+      --  Op_Mod
+      "5Treat_Fixed_As_Integer4Do_Division_Check" &
+      --  Op_Multiply
+      "5Treat_Fixed_As_Integer9Rounded_Result" &
+      --  Op_Rem
+      "5Treat_Fixed_As_Integer4Do_Division_Check" &
+      --  Op_And
+      "+Do_Length_Check" &
+      --  Op_Eq
+      "" &
+      --  Op_Ge
+      "" &
+      --  Op_Gt
+      "" &
+      --  Op_Le
+      "" &
+      --  Op_Lt
+      "" &
+      --  Op_Ne
+      "" &
+      --  Op_Or
+      "+Do_Length_Check" &
+      --  Op_Xor
+      "+Do_Length_Check" &
+      --  Op_Rotate_Left
+      "+Shift_Count_OK" &
+      --  Op_Rotate_Right
+      "+Shift_Count_OK" &
+      --  Op_Shift_Left
+      "+Shift_Count_OK" &
+      --  Op_Shift_Right
+      "+Shift_Count_OK" &
+      --  Op_Shift_Right_Arithmetic
+      "+Shift_Count_OK" &
+      --  Op_Abs
+      "" &
+      --  Op_Minus
+      "" &
+      --  Op_Not
+      "" &
+      --  Op_Plus
+      "" &
+      --  Attribute_Reference
+      "%Prefix$Attribute_Name#Expressions&Entity&Associated_Node8Do_Overflow" &
+         "_Check4Redundant_Use+OK_For_Stream5Must_Be_Byte_Aligned" &
+      --  And_Then
+      "#Actions" &
+      --  Conditional_Expression
+      "#Expressions$Then_Actions%Else_Actions" &
+      --  Explicit_Dereference
+      "%Prefix" &
+      --  Function_Call
+      "$Name%Parameter_Associations&First_Named_Actual#Controlling_Argument4" &
+         "Do_Tag_Check5No_Elaboration_Check8Parameter_List_Truncated9ABE_Is_" &
+         "Certain" &
+      --  In
+      "" &
+      --  Indexed_Component
+      "%Prefix#Expressions" &
+      --  Integer_Literal
+      "$Original_Entity%Intval4Print_In_Hex" &
+      --  Not_In
+      "" &
+      --  Null
+      "" &
+      --  Or_Else
+      "#Actions" &
+      --  Procedure_Call_Statement
+      "$Name%Parameter_Associations&First_Named_Actual#Controlling_Argument4" &
+         "Do_Tag_Check5No_Elaboration_Check8Parameter_List_Truncated9ABE_Is_" &
+         "Certain" &
+      --  Qualified_Expression
+      "&Subtype_Mark%Expression" &
+      --  Raise_Constraint_Error
+      "#Condition%Reason" &
+      --  Raise_Program_Error
+      "#Condition%Reason" &
+      --  Raise_Storage_Error
+      "#Condition%Reason" &
+      --  Aggregate
+      "#Expressions$Component_Associations8Null_Record_Present%Aggregate_Bou" &
+         "nds&Associated_Node+Static_Processing_OK9Compile_Time_Known_Aggreg" &
+         "ate2Expansion_Delayed" &
+      --  Allocator
+      "%Expression#Storage_Pool&Procedure_To_Call4No_Initialization8Do_Stora" &
+         "ge_Check" &
+      --  Extension_Aggregate
+      "%Ancestor_Part&Associated_Node#Expressions$Component_Associations8Nul" &
+         "l_Record_Present2Expansion_Delayed" &
+      --  Range
+      "#Low_Bound$High_Bound2Includes_Infinities" &
+      --  Real_Literal
+      "$Original_Entity%Realval&Corresponding_Integer_Value2Is_Machine_Numbe" &
+         "r" &
+      --  Reference
+      "%Prefix" &
+      --  Selected_Component
+      "%Prefix$Selector_Name&Associated_Node4Do_Discriminant_Check2Is_In_Dis" &
+         "criminant_Check" &
+      --  Slice
+      "%Prefix&Discrete_Range" &
+      --  String_Literal
+      "%Strval2Has_Wide_Character" &
+      --  Subprogram_Info
+      "#Identifier" &
+      --  Type_Conversion
+      "&Subtype_Mark%Expression4Do_Tag_Check+Do_Length_Check8Do_Overflow_Che" &
+         "ck2Float_Truncate9Rounded_Result5Conversion_OK" &
+      --  Unchecked_Expression
+      "%Expression" &
+      --  Unchecked_Type_Conversion
+      "&Subtype_Mark%Expression2Kill_Range_Check8No_Truncation" &
+      --  Subtype_Indication
+      "&Subtype_Mark%Constraint/Must_Not_Freeze" &
+      --  Component_Declaration
+      "#Defining_Identifier&Component_Definition%Expression,More_Ids-Prev_Id" &
+         "s" &
+      --  Entry_Declaration
+      "#Defining_Identifier&Discrete_Subtype_Definition%Parameter_Specificat" &
+         "ions'Corresponding_Body" &
+      --  Formal_Object_Declaration
+      "#Defining_Identifier6In_Present8Out_Present&Subtype_Mark%Expression,M" &
+         "ore_Ids-Prev_Ids" &
+      --  Formal_Type_Declaration
+      "#Defining_Identifier%Formal_Type_Definition&Discriminant_Specificatio" &
+         "ns4Unknown_Discriminants_Present" &
+      --  Full_Type_Declaration
+      "#Defining_Identifier&Discriminant_Specifications%Type_Definition2Disc" &
+         "r_Check_Funcs_Built" &
+      --  Incomplete_Type_Declaration
+      "#Defining_Identifier&Discriminant_Specifications4Unknown_Discriminant" &
+         "s_Present" &
+      --  Loop_Parameter_Specification
+      "#Defining_Identifier6Reverse_Present&Discrete_Subtype_Definition" &
+      --  Object_Declaration
+      "#Defining_Identifier+Aliased_Present8Constant_Present&Object_Definiti" &
+         "on%Expression$Handler_List_Entry'Corresponding_Generic_Association" &
+         ",More_Ids-Prev_Ids4No_Initialization6Assignment_OK2Exception_Junk5" &
+         "Delay_Finalize_Attach7Is_Subprogram_Descriptor" &
+      --  Protected_Type_Declaration
+      "#Defining_Identifier&Discriminant_Specifications%Protected_Definition" &
+         "'Corresponding_Body" &
+      --  Private_Extension_Declaration
+      "#Defining_Identifier&Discriminant_Specifications4Unknown_Discriminant" &
+         "s_Present+Abstract_Present'Subtype_Indication" &
+      --  Private_Type_Declaration
+      "#Defining_Identifier&Discriminant_Specifications4Unknown_Discriminant" &
+         "s_Present+Abstract_Present6Tagged_Present8Limited_Present" &
+      --  Subtype_Declaration
+      "#Defining_Identifier'Subtype_Indication&Generic_Parent_Type2Exception" &
+         "_Junk" &
+      --  Function_Specification
+      "#Defining_Unit_Name$Elaboration_Boolean%Parameter_Specifications&Subt" &
+         "ype_Mark'Generic_Parent" &
+      --  Procedure_Specification
+      "#Defining_Unit_Name$Elaboration_Boolean%Parameter_Specifications'Gene" &
+         "ric_Parent" &
+      --  Entry_Index_Specification
+      "#Defining_Identifier&Discrete_Subtype_Definition" &
+      --  Freeze_Entity
+      "&Entity$Access_Types_To_Process%TSS_Elist#Actions'First_Subtype_Link" &
+      --  Access_Function_Definition
+      "6Protected_Present%Parameter_Specifications&Subtype_Mark" &
+      --  Access_Procedure_Definition
+      "6Protected_Present%Parameter_Specifications" &
+      --  Task_Type_Declaration
+      "#Defining_Identifier$Task_Body_Procedure&Discriminant_Specifications%" &
+         "Task_Definition'Corresponding_Body" &
+      --  Package_Body_Stub
+      "#Defining_Identifier&Library_Unit'Corresponding_Body" &
+      --  Protected_Body_Stub
+      "#Defining_Identifier&Library_Unit'Corresponding_Body" &
+      --  Subprogram_Body_Stub
+      "#Specification&Library_Unit'Corresponding_Body" &
+      --  Task_Body_Stub
+      "#Defining_Identifier&Library_Unit'Corresponding_Body" &
+      --  Function_Instantiation
+      "#Defining_Unit_Name$Name%Generic_Associations&Parent_Spec'Instance_Sp" &
+         "ec9ABE_Is_Certain" &
+      --  Package_Instantiation
+      "#Defining_Unit_Name$Name%Generic_Associations&Parent_Spec'Instance_Sp" &
+         "ec9ABE_Is_Certain" &
+      --  Procedure_Instantiation
+      "#Defining_Unit_Name$Name&Parent_Spec%Generic_Associations'Instance_Sp" &
+         "ec9ABE_Is_Certain" &
+      --  Package_Body
+      "#Defining_Unit_Name$Declarations&Handled_Statement_Sequence'Correspon" &
+         "ding_Spec4Was_Originally_Stub" &
+      --  Subprogram_Body
+      "#Specification$Declarations&Handled_Statement_Sequence%Activation_Cha" &
+         "in_Entity'Corresponding_Spec+Acts_As_Spec6Bad_Is_Detected8Do_Stora" &
+         "ge_Check-Has_Priority_Pragma.Is_Protected_Subprogram_Body,Is_Task_" &
+         "Master4Was_Originally_Stub" &
+      --  Protected_Body
+      "#Defining_Identifier$Declarations&End_Label'Corresponding_Spec4Was_Or" &
+         "iginally_Stub" &
+      --  Task_Body
+      "#Defining_Identifier$Declarations&Handled_Statement_Sequence,Is_Task_" &
+         "Master%Activation_Chain_Entity'Corresponding_Spec4Was_Originally_S" &
+         "tub" &
+      --  Implicit_Label_Declaration
+      "#Defining_Identifier$Label_Construct" &
+      --  Package_Declaration
+      "#Specification'Corresponding_Body&Parent_Spec%Activation_Chain_Entity" &
+      --  Single_Task_Declaration
+      "#Defining_Identifier%Task_Definition" &
+      --  Subprogram_Declaration
+      "#Specification%Body_To_Inline'Corresponding_Body&Parent_Spec" &
+      --  Use_Package_Clause
+      "$Names%Next_Use_Clause&Hidden_By_Use_Clause" &
+      --  Generic_Package_Declaration
+      "#Specification'Corresponding_Body$Generic_Formal_Declarations&Parent_" &
+         "Spec%Activation_Chain_Entity" &
+      --  Generic_Subprogram_Declaration
+      "#Specification'Corresponding_Body$Generic_Formal_Declarations&Parent_" &
+         "Spec" &
+      --  Constrained_Array_Definition
+      "$Discrete_Subtype_Definitions&Component_Definition" &
+      --  Unconstrained_Array_Definition
+      "$Subtype_Marks&Component_Definition" &
+      --  Exception_Renaming_Declaration
+      "#Defining_Identifier$Name" &
+      --  Object_Renaming_Declaration
+      "#Defining_Identifier&Subtype_Mark$Name'Corresponding_Generic_Associat" &
+         "ion" &
+      --  Package_Renaming_Declaration
+      "#Defining_Unit_Name$Name&Parent_Spec" &
+      --  Subprogram_Renaming_Declaration
+      "#Specification$Name&Parent_Spec'Corresponding_Spec" &
+      --  Generic_Function_Renaming_Declaration
+      "#Defining_Unit_Name$Name&Parent_Spec" &
+      --  Generic_Package_Renaming_Declaration
+      "#Defining_Unit_Name$Name&Parent_Spec" &
+      --  Generic_Procedure_Renaming_Declaration
+      "#Defining_Unit_Name$Name&Parent_Spec" &
+      --  Abort_Statement
+      "$Names" &
+      --  Accept_Statement
+      "#Entry_Direct_Name'Entry_Index%Parameter_Specifications&Handled_State" &
+         "ment_Sequence$Declarations" &
+      --  Assignment_Statement
+      "$Name%Expression4Do_Tag_Check+Do_Length_Check,Forwards_OK-Backwards_O" &
+         "K.No_Ctrl_Actions" &
+      --  Asynchronous_Select
+      "#Triggering_Alternative$Abortable_Part" &
+      --  Block_Statement
+      "#Identifier$Declarations&Handled_Statement_Sequence,Is_Task_Master%Ac" &
+         "tivation_Chain_Entity6Has_Created_Identifier-Is_Task_Allocation_Bl" &
+         "ock.Is_Asynchronous_Call_Block" &
+      --  Case_Statement
+      "%Expression&Alternatives'End_Span" &
+      --  Code_Statement
+      "%Expression" &
+      --  Conditional_Entry_Call
+      "#Entry_Call_Alternative&Else_Statements" &
+      --  Delay_Relative_Statement
+      "%Expression" &
+      --  Delay_Until_Statement
+      "%Expression" &
+      --  Entry_Call_Statement
+      "$Name%Parameter_Associations&First_Named_Actual" &
+      --  Free_Statement
+      "%Expression#Storage_Pool&Procedure_To_Call" &
+      --  Goto_Statement
+      "$Name2Exception_Junk" &
+      --  Loop_Statement
+      "#Identifier$Iteration_Scheme%Statements&End_Label6Has_Created_Identif" &
+         "ier7Is_Null_Loop" &
+      --  Null_Statement
+      "" &
+      --  Raise_Statement
+      "$Name" &
+      --  Requeue_Statement
+      "$Name6Abort_Present" &
+      --  Return_Statement
+      "%Expression#Storage_Pool&Procedure_To_Call4Do_Tag_Check$Return_Type,B" &
+         "y_Ref" &
+      --  Selective_Accept
+      "#Select_Alternatives&Else_Statements" &
+      --  Timed_Entry_Call
+      "#Entry_Call_Alternative&Delay_Alternative" &
+      --  Exit_Statement
+      "$Name#Condition" &
+      --  If_Statement
+      "#Condition$Then_Statements%Elsif_Parts&Else_Statements'End_Span" &
+      --  Accept_Alternative
+      "$Accept_Statement#Condition%Statements&Pragmas_Before'Accept_Handler_" &
+         "Records" &
+      --  Delay_Alternative
+      "$Delay_Statement#Condition%Statements&Pragmas_Before" &
+      --  Elsif_Part
+      "#Condition$Then_Statements%Condition_Actions" &
+      --  Entry_Body_Formal_Part
+      "&Entry_Index_Specification%Parameter_Specifications#Condition" &
+      --  Iteration_Scheme
+      "#Condition%Condition_Actions&Loop_Parameter_Specification" &
+      --  Terminate_Alternative
+      "#Condition&Pragmas_Before'Pragmas_After" &
+      --  Abortable_Part
+      "%Statements" &
+      --  Abstract_Subprogram_Declaration
+      "#Specification" &
+      --  Access_Definition
+      "&Subtype_Mark" &
+      --  Access_To_Object_Definition
+      "6All_Present'Subtype_Indication8Constant_Present" &
+      --  Case_Statement_Alternative
+      "&Discrete_Choices%Statements" &
+      --  Compilation_Unit
+      "&Library_Unit#Context_Items6Private_Present$Unit'Aux_Decls_Node8Has_N" &
+         "o_Elaboration_Code4Body_Required+Acts_As_Spec%First_Inlined_Subpro" &
+         "gram" &
+      --  Compilation_Unit_Aux
+      "$Declarations#Actions'Pragmas_After&Config_Pragmas" &
+      --  Component_Association
+      "#Choices$Loop_Actions%Expression6Box_Present" &
+      --  Component_Definition
+      "+Aliased_Present'Subtype_Indication" &
+      --  Component_List
+      "%Component_Items&Variant_Part4Null_Present" &
+      --  Derived_Type_Definition
+      "+Abstract_Present'Subtype_Indication%Record_Extension_Part" &
+      --  Decimal_Fixed_Point_Definition
+      "%Delta_Expression$Digits_Expression&Real_Range_Specification" &
+      --  Defining_Program_Unit_Name
+      "$Name#Defining_Identifier" &
+      --  Delta_Constraint
+      "%Delta_Expression&Range_Constraint" &
+      --  Designator
+      "$Name#Identifier" &
+      --  Digits_Constraint
+      "$Digits_Expression&Range_Constraint" &
+      --  Discriminant_Association
+      "#Selector_Names%Expression" &
+      --  Discriminant_Specification
+      "#Defining_Identifier'Discriminant_Type%Expression,More_Ids-Prev_Ids" &
+      --  Enumeration_Type_Definition
+      "#Literals&End_Label" &
+      --  Entry_Body
+      "#Defining_Identifier'Entry_Body_Formal_Part$Declarations&Handled_Stat" &
+         "ement_Sequence%Activation_Chain_Entity" &
+      --  Entry_Call_Alternative
+      "#Entry_Call_Statement%Statements&Pragmas_Before" &
+      --  Exception_Declaration
+      "#Defining_Identifier%Expression,More_Ids-Prev_Ids" &
+      --  Exception_Handler
+      "$Choice_Parameter&Exception_Choices%Statements,Zero_Cost_Handling" &
+      --  Floating_Point_Definition
+      "$Digits_Expression&Real_Range_Specification" &
+      --  Formal_Decimal_Fixed_Point_Definition
+      "" &
+      --  Formal_Derived_Type_Definition
+      "&Subtype_Mark6Private_Present+Abstract_Present" &
+      --  Formal_Discrete_Type_Definition
+      "" &
+      --  Formal_Floating_Point_Definition
+      "" &
+      --  Formal_Modular_Type_Definition
+      "" &
+      --  Formal_Ordinary_Fixed_Point_Definition
+      "" &
+      --  Formal_Package_Declaration
+      "#Defining_Identifier$Name%Generic_Associations6Box_Present'Instance_S" &
+         "pec9ABE_Is_Certain" &
+      --  Formal_Private_Type_Definition
+      "+Abstract_Present6Tagged_Present8Limited_Present" &
+      --  Formal_Signed_Integer_Type_Definition
+      "" &
+      --  Formal_Subprogram_Declaration
+      "#Specification$Default_Name6Box_Present" &
+      --  Generic_Association
+      "$Selector_Name#Explicit_Generic_Actual_Parameter" &
+      --  Handled_Sequence_Of_Statements
+      "%Statements&End_Label'Exception_Handlers#At_End_Proc$First_Real_State" &
+         "ment,Zero_Cost_Handling" &
+      --  Index_Or_Discriminant_Constraint
+      "#Constraints" &
+      --  Itype_Reference
+      "#Itype" &
+      --  Label
+      "#Identifier2Exception_Junk" &
+      --  Modular_Type_Definition
+      "%Expression" &
+      --  Number_Declaration
+      "#Defining_Identifier%Expression,More_Ids-Prev_Ids" &
+      --  Ordinary_Fixed_Point_Definition
+      "%Delta_Expression&Real_Range_Specification" &
+      --  Others_Choice
+      "#Others_Discrete_Choices2All_Others" &
+      --  Package_Specification
+      "#Defining_Unit_Name$Visible_Declarations%Private_Declarations&End_Lab" &
+         "el'Generic_Parent9Limited_View_Installed" &
+      --  Parameter_Association
+      "$Selector_Name%Explicit_Actual_Parameter&Next_Named_Actual" &
+      --  Parameter_Specification
+      "#Defining_Identifier6In_Present8Out_Present$Parameter_Type%Expression" &
+         "4Do_Accessibility_Check,More_Ids-Prev_Ids'Default_Expression" &
+      --  Protected_Definition
+      "$Visible_Declarations%Private_Declarations&End_Label-Has_Priority_Pra" &
+         "gma" &
+      --  Range_Constraint
+      "&Range_Expression" &
+      --  Real_Range_Specification
+      "#Low_Bound$High_Bound" &
+      --  Record_Definition
+      "&End_Label+Abstract_Present6Tagged_Present8Limited_Present#Component_" &
+         "List4Null_Present" &
+      --  Signed_Integer_Type_Definition
+      "#Low_Bound$High_Bound" &
+      --  Single_Protected_Declaration
+      "#Defining_Identifier%Protected_Definition" &
+      --  Subunit
+      "$Name#Proper_Body%Corresponding_Stub" &
+      --  Task_Definition
+      "$Visible_Declarations%Private_Declarations&End_Label-Has_Priority_Pra" &
+         "gma,Has_Storage_Size_Pragma.Has_Task_Info_Pragma/Has_Task_Name_Pra" &
+         "gma" &
+      --  Triggering_Alternative
+      "#Triggering_Statement%Statements&Pragmas_Before" &
+      --  Use_Type_Clause
+      "$Subtype_Marks%Next_Use_Clause&Hidden_By_Use_Clause" &
+      --  Validate_Unchecked_Conversion
+      "#Source_Type$Target_Type" &
+      --  Variant
+      "&Discrete_Choices#Component_List$Enclosing_Variant%Present_Expr'Dchec" &
+         "k_Function" &
+      --  Variant_Part
+      "$Name#Variants" &
+      --  With_Clause
+      "$Name&Library_Unit'Corresponding_Spec,First_Name-Last_Name4Context_In" &
+         "stalled+Elaborate_Present6Elaborate_All_Present7Implicit_With8Limi" &
+         "ted_Present9Limited_View_Installed.Unreferenced_In_Spec/No_Entitie" &
+         "s_Ref_In_Spec" &
+      --  With_Type_Clause
+      "$Name6Tagged_Present" &
+      --  Unused_At_End
+      "";
+
+   type Pchar_Pos_Array is array (Node_Kind) of Positive;
+   Pchar_Pos : constant Pchar_Pos_Array := Pchar_Pos_Array'(
+      N_Unused_At_Start                        => 1,
+      N_At_Clause                              => 1,
+      N_Component_Clause                       => 23,
+      N_Enumeration_Representation_Clause      => 66,
+      N_Mod_Clause                             => 107,
+      N_Record_Representation_Clause           => 133,
+      N_Attribute_Definition_Clause            => 187,
+      N_Empty                                  => 253,
+      N_Pragma                                 => 253,
+      N_Pragma_Argument_Association            => 312,
+      N_Error                                  => 323,
+      N_Defining_Character_Literal             => 323,
+      N_Defining_Identifier                    => 341,
+      N_Defining_Operator_Symbol               => 359,
+      N_Expanded_Name                          => 377,
+      N_Identifier                             => 452,
+      N_Operator_Symbol                        => 528,
+      N_Character_Literal                      => 575,
+      N_Op_Add                                 => 634,
+      N_Op_Concat                              => 634,
+      N_Op_Expon                               => 681,
+      N_Op_Subtract                            => 705,
+      N_Op_Divide                              => 705,
+      N_Op_Mod                                 => 761,
+      N_Op_Multiply                            => 802,
+      N_Op_Rem                                 => 840,
+      N_Op_And                                 => 881,
+      N_Op_Eq                                  => 897,
+      N_Op_Ge                                  => 897,
+      N_Op_Gt                                  => 897,
+      N_Op_Le                                  => 897,
+      N_Op_Lt                                  => 897,
+      N_Op_Ne                                  => 897,
+      N_Op_Or                                  => 897,
+      N_Op_Xor                                 => 913,
+      N_Op_Rotate_Left                         => 929,
+      N_Op_Rotate_Right                        => 944,
+      N_Op_Shift_Left                          => 959,
+      N_Op_Shift_Right                         => 974,
+      N_Op_Shift_Right_Arithmetic              => 989,
+      N_Op_Abs                                 => 1004,
+      N_Op_Minus                               => 1004,
+      N_Op_Not                                 => 1004,
+      N_Op_Plus                                => 1004,
+      N_Attribute_Reference                    => 1004,
+      N_And_Then                               => 1128,
+      N_Conditional_Expression                 => 1136,
+      N_Explicit_Dereference                   => 1174,
+      N_Function_Call                          => 1181,
+      N_In                                     => 1323,
+      N_Indexed_Component                      => 1323,
+      N_Integer_Literal                        => 1342,
+      N_Not_In                                 => 1378,
+      N_Null                                   => 1378,
+      N_Or_Else                                => 1378,
+      N_Procedure_Call_Statement               => 1386,
+      N_Qualified_Expression                   => 1528,
+      N_Raise_Constraint_Error                 => 1552,
+      N_Raise_Program_Error                    => 1569,
+      N_Raise_Storage_Error                    => 1586,
+      N_Aggregate                              => 1603,
+      N_Allocator                              => 1759,
+      N_Extension_Aggregate                    => 1836,
+      N_Range                                  => 1939,
+      N_Real_Literal                           => 1980,
+      N_Reference                              => 2050,
+      N_Selected_Component                     => 2057,
+      N_Slice                                  => 2141,
+      N_String_Literal                         => 2163,
+      N_Subprogram_Info                        => 2189,
+      N_Type_Conversion                        => 2200,
+      N_Unchecked_Expression                   => 2315,
+      N_Unchecked_Type_Conversion              => 2326,
+      N_Subtype_Indication                     => 2381,
+      N_Component_Declaration                  => 2421,
+      N_Entry_Declaration                      => 2491,
+      N_Formal_Object_Declaration              => 2583,
+      N_Formal_Type_Declaration                => 2668,
+      N_Full_Type_Declaration                  => 2769,
+      N_Incomplete_Type_Declaration            => 2857,
+      N_Loop_Parameter_Specification           => 2935,
+      N_Object_Declaration                     => 2999,
+      N_Protected_Type_Declaration             => 3246,
+      N_Private_Extension_Declaration          => 3334,
+      N_Private_Type_Declaration               => 3448,
+      N_Subtype_Declaration                    => 3574,
+      N_Function_Specification                 => 3648,
+      N_Procedure_Specification                => 3740,
+      N_Entry_Index_Specification              => 3819,
+      N_Freeze_Entity                          => 3867,
+      N_Access_Function_Definition             => 3935,
+      N_Access_Procedure_Definition            => 3991,
+      N_Task_Type_Declaration                  => 4034,
+      N_Package_Body_Stub                      => 4137,
+      N_Protected_Body_Stub                    => 4189,
+      N_Subprogram_Body_Stub                   => 4241,
+      N_Task_Body_Stub                         => 4287,
+      N_Function_Instantiation                 => 4339,
+      N_Package_Instantiation                  => 4425,
+      N_Procedure_Instantiation                => 4511,
+      N_Package_Body                           => 4597,
+      N_Subprogram_Body                        => 4695,
+      N_Protected_Body                         => 4922,
+      N_Task_Body                              => 5004,
+      N_Implicit_Label_Declaration             => 5142,
+      N_Package_Declaration                    => 5178,
+      N_Single_Task_Declaration                => 5247,
+      N_Subprogram_Declaration                 => 5283,
+      N_Use_Package_Clause                     => 5343,
+      N_Generic_Package_Declaration            => 5386,
+      N_Generic_Subprogram_Declaration         => 5483,
+      N_Constrained_Array_Definition           => 5556,
+      N_Unconstrained_Array_Definition         => 5606,
+      N_Exception_Renaming_Declaration         => 5641,
+      N_Object_Renaming_Declaration            => 5666,
+      N_Package_Renaming_Declaration           => 5738,
+      N_Subprogram_Renaming_Declaration        => 5774,
+      N_Generic_Function_Renaming_Declaration  => 5824,
+      N_Generic_Package_Renaming_Declaration   => 5860,
+      N_Generic_Procedure_Renaming_Declaration => 5896,
+      N_Abort_Statement                        => 5932,
+      N_Accept_Statement                       => 5938,
+      N_Assignment_Statement                   => 6033,
+      N_Asynchronous_Select                    => 6119,
+      N_Block_Statement                        => 6157,
+      N_Case_Statement                         => 6322,
+      N_Code_Statement                         => 6355,
+      N_Conditional_Entry_Call                 => 6366,
+      N_Delay_Relative_Statement               => 6405,
+      N_Delay_Until_Statement                  => 6416,
+      N_Entry_Call_Statement                   => 6427,
+      N_Free_Statement                         => 6474,
+      N_Goto_Statement                         => 6516,
+      N_Loop_Statement                         => 6536,
+      N_Null_Statement                         => 6621,
+      N_Raise_Statement                        => 6621,
+      N_Requeue_Statement                      => 6626,
+      N_Return_Statement                       => 6645,
+      N_Selective_Accept                       => 6719,
+      N_Timed_Entry_Call                       => 6755,
+      N_Exit_Statement                         => 6796,
+      N_If_Statement                           => 6811,
+      N_Accept_Alternative                     => 6874,
+      N_Delay_Alternative                      => 6950,
+      N_Elsif_Part                             => 7002,
+      N_Entry_Body_Formal_Part                 => 7046,
+      N_Iteration_Scheme                       => 7107,
+      N_Terminate_Alternative                  => 7164,
+      N_Abortable_Part                         => 7203,
+      N_Abstract_Subprogram_Declaration        => 7214,
+      N_Access_Definition                      => 7228,
+      N_Access_To_Object_Definition            => 7241,
+      N_Case_Statement_Alternative             => 7289,
+      N_Compilation_Unit                       => 7317,
+      N_Compilation_Unit_Aux                   => 7456,
+      N_Component_Association                  => 7506,
+      N_Component_Definition                   => 7550,
+      N_Component_List                         => 7585,
+      N_Derived_Type_Definition                => 7627,
+      N_Decimal_Fixed_Point_Definition         => 7685,
+      N_Defining_Program_Unit_Name             => 7745,
+      N_Delta_Constraint                       => 7770,
+      N_Designator                             => 7804,
+      N_Digits_Constraint                      => 7820,
+      N_Discriminant_Association               => 7855,
+      N_Discriminant_Specification             => 7881,
+      N_Enumeration_Type_Definition            => 7948,
+      N_Entry_Body                             => 7967,
+      N_Entry_Call_Alternative                 => 8074,
+      N_Exception_Declaration                  => 8121,
+      N_Exception_Handler                      => 8170,
+      N_Floating_Point_Definition              => 8235,
+      N_Formal_Decimal_Fixed_Point_Definition  => 8278,
+      N_Formal_Derived_Type_Definition         => 8278,
+      N_Formal_Discrete_Type_Definition        => 8324,
+      N_Formal_Floating_Point_Definition       => 8324,
+      N_Formal_Modular_Type_Definition         => 8324,
+      N_Formal_Ordinary_Fixed_Point_Definition => 8324,
+      N_Formal_Package_Declaration             => 8324,
+      N_Formal_Private_Type_Definition         => 8411,
+      N_Formal_Signed_Integer_Type_Definition  => 8459,
+      N_Formal_Subprogram_Declaration          => 8459,
+      N_Generic_Association                    => 8498,
+      N_Handled_Sequence_Of_Statements         => 8546,
+      N_Index_Or_Discriminant_Constraint       => 8638,
+      N_Itype_Reference                        => 8650,
+      N_Label                                  => 8656,
+      N_Modular_Type_Definition                => 8682,
+      N_Number_Declaration                     => 8693,
+      N_Ordinary_Fixed_Point_Definition        => 8742,
+      N_Others_Choice                          => 8784,
+      N_Package_Specification                  => 8819,
+      N_Parameter_Association                  => 8928,
+      N_Parameter_Specification                => 8986,
+      N_Protected_Definition                   => 9115,
+      N_Range_Constraint                       => 9187,
+      N_Real_Range_Specification               => 9204,
+      N_Record_Definition                      => 9225,
+      N_Signed_Integer_Type_Definition         => 9311,
+      N_Single_Protected_Declaration           => 9332,
+      N_Subunit                                => 9373,
+      N_Task_Definition                        => 9409,
+      N_Triggering_Alternative                 => 9547,
+      N_Use_Type_Clause                        => 9594,
+      N_Validate_Unchecked_Conversion          => 9645,
+      N_Variant                                => 9669,
+      N_Variant_Part                           => 9748,
+      N_With_Clause                            => 9762,
+      N_With_Type_Clause                       => 9976,
+      N_Unused_At_End                          => 9996);
+
+end Treeprs;
