2002-08-17  H.J. Lu <hjl@gnu.org>

	* calls.c (PUSH_ARGS_REVERSED): Define only if not defined.
	* expr.c (PUSH_ARGS_REVERSED): Likewise.

2002-07-26  H.J. Lu <hjl@gnu.org>

	* config/i386/i386.h (PUSH_ARGS_REVERSED): Set to 1.

--- gcc/calls.c.var	Thu Apr  4 15:28:47 2002
+++ gcc/calls.c	Sat Aug 17 22:45:46 2002
@@ -46,9 +46,11 @@ Software Foundation, 59 Temple Place - S
 
 #ifdef PUSH_ROUNDING
 
+#ifndef PUSH_ARGS_REVERSED
 #if defined (STACK_GROWS_DOWNWARD) != defined (ARGS_GROW_DOWNWARD)
 #define PUSH_ARGS_REVERSED  PUSH_ARGS
 #endif
+#endif
 
 #endif
 
--- gcc/config/i386/i386.h.var	Sun Jul 14 23:54:36 2002
+++ gcc/config/i386/i386.h	Sat Aug 17 19:03:21 2002
@@ -1581,6 +1581,10 @@ enum reg_class
 
 #define PUSH_ARGS (TARGET_PUSH_ARGS && !ACCUMULATE_OUTGOING_ARGS)
 
+/* We want the stack and args grow in opposite directions, even if
+   PUSH_ARGS is 0.  */
+#define PUSH_ARGS_REVERSED 1
+
 /* Offset of first parameter from the argument pointer register value.  */
 #define FIRST_PARM_OFFSET(FNDECL) 0
 
--- gcc/expr.c.var	Mon May  6 22:43:11 2002
+++ gcc/expr.c	Sat Aug 17 22:52:27 2002
@@ -54,9 +54,11 @@ Software Foundation, 59 Temple Place - S
 
 #ifdef PUSH_ROUNDING
 
+#ifndef PUSH_ARGS_REVERSED
 #if defined (STACK_GROWS_DOWNWARD) != defined (ARGS_GROW_DOWNWARD)
 #define PUSH_ARGS_REVERSED	/* If it's last to first.  */
 #endif
+#endif
 
 #endif
 
2002-08-18  H.J. Lu <hjl@gnu.org>

	* calls.c (store_one_arg): Remove ATTRIBUTE_UNUSED on
	variable_size. Mark any slots used for the argument as in-use
	only if we can't pass all arguments to a library call in
	registers.

--- gcc/calls.c.copy	Sun Aug 18 07:35:11 2002
+++ gcc/calls.c	Sun Aug 18 08:27:29 2002
@@ -4270,7 +4270,7 @@ store_one_arg (arg, argblock, flags, var
      struct arg_data *arg;
      rtx argblock;
      int flags;
-     int variable_size ATTRIBUTE_UNUSED;
+     int variable_size;
      int reg_parm_stack_space;
 {
   tree pval = arg->tree_value;
@@ -4345,14 +4345,22 @@ store_one_arg (arg, argblock, flags, var
 		  emit_move_insn (arg->save_area, stack_area);
 		}
 	    }
+
+	  /* Now that we have saved any slots that will be overwritten
+	     by this store, mark all slots this store will use.  We
+	     must do this before we actually expand the argument since
+	     the expansion itself may trigger library calls which might
+	     need to use the same stack slot. We only do it if we can't
+	     pass all arguments to a library call in registers.  */
+	  if (arg->partial)
+	    {
+	      for (i = lower_bound; i < upper_bound; i++)
+		stack_usage_map[i] = 1;
+
+	      /* Set it so that we don't do it again.  */
+	      variable_size = 1;
+	    }
 	}
-      /* Now that we have saved any slots that will be overwritten by this
-	 store, mark all slots this store will use.  We must do this before
-	 we actually expand the argument since the expansion itself may
-	 trigger library calls which might need to use the same stack slot.  */
-      if (argblock && ! variable_size && arg->stack)
-	for (i = lower_bound; i < upper_bound; i++)
-	  stack_usage_map[i] = 1;
     }
 
   /* If this isn't going to be placed on both the stack and in registers,
@@ -4579,6 +4587,11 @@ store_one_arg (arg, argblock, flags, var
 	arg->value = arg->stack_slot;
     }
 
+  if (ACCUMULATE_OUTGOING_ARGS && !(flags & ECF_SIBCALL)
+      && argblock && ! variable_size && arg->stack)
+    for (i = lower_bound; i < upper_bound; i++)
+      stack_usage_map[i] = 1;
+
   /* Once we have pushed something, pops can't safely
      be deferred during the rest of the arguments.  */
   NO_DEFER_POP;
