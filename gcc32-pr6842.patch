2002-05-31  Jakub Jelinek  <jakub@redhat.com>

	PR optimization/6842
	* combine.c (combine_simplify_rtx) [SUBREG]: Don't ICE if VOIDmode
	operand subreg cannot be simplified.

	* gcc.dg/20020531-1.c: New test.

--- gcc/testsuite/gcc.dg/20020531-1.c.jj	Fri May 31 17:15:15 2002
+++ gcc/testsuite/gcc.dg/20020531-1.c	Fri May 31 17:13:50 2002
@@ -0,0 +1,21 @@
+/* PR optimization/6842
+   This testcase caused ICE when trying to optimize V8QI subreg of VOIDmode
+   CONST_DOUBLE.  */
+/* { dg-do compile { target i?86-*-* } } */
+/* { dg-options "-O2 -mmmx" } */
+
+typedef int __v8qi __attribute__ ((__mode__ (__V8QI__)));
+extern void abort (void);
+extern void exit (int);
+
+void foo (void)
+{
+  unsigned long long a = 0x0102030405060708LL;
+  unsigned long long b = 0x1020304050607080LL;
+  unsigned long long c;
+
+  c = (unsigned long long) __builtin_ia32_paddusb ((__v8qi) a, (__v8qi) b);
+  __builtin_ia32_emms ();
+  if (c != 0x1122334455667788)
+    abort ();
+}
--- gcc/combine.c.jj	Thu May 23 10:22:59 2002
+++ gcc/combine.c	Fri May 31 17:05:09 2002
@@ -3863,7 +3863,12 @@ combine_simplify_rtx (x, op0_mode, last,
 
       /* simplify_subreg can't use gen_lowpart_for_combine.  */
       if (CONSTANT_P (SUBREG_REG (x))
-	  && subreg_lowpart_offset (mode, op0_mode) == SUBREG_BYTE (x))
+	  && subreg_lowpart_offset (mode, op0_mode) == SUBREG_BYTE (x)
+	     /* Don't call gen_lowpart_for_combine if the inner mode
+		is VOIDmode and we cannot simplify it, as SUBREG without
+		inner mode is invalid.  */
+	  && (GET_MODE (SUBREG_REG (x)) != VOIDmode
+	      || gen_lowpart_common (mode, SUBREG_REG (x))))
 	return gen_lowpart_for_combine (mode, SUBREG_REG (x));
 
       if (GET_MODE_CLASS (GET_MODE (SUBREG_REG (x))) == MODE_CC)
