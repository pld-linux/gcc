#! /bin/sh -e

if [ $# -eq 3 -a "$2" = '-d' ]; then
    pdir="-d $3"
elif [ $# -ne 1 ]; then
    echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
    exit 1
fi
case "$1" in
    -patch) patch $pdir -f --no-backup-if-mismatch -p0 < $0;;
    -unpatch) patch $pdir -f --no-backup-if-mismatch -R -p0 < $0;;
    *)
	echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
	exit 1
esac
exit 0

To: gcc-patches at gcc dot gnu dot org
# DP: Subject: empty struct initializer fix
# DP: From: Richard Henderson <rth at twiddle dot net>
# DP: Date: Sun, 20 Feb 2000 00:33:40 -0800

Fixes

   struct empty { };
   struct something {
   	int spacer;
   	struct empty foo;
   	int bar;
   };
   
   struct something X = {
   	foo: (struct empty) { },
   	bar: 1,
   };

which used to abort.


r~

        * c-typeck.c (add_pending_init): Don't abort for multiple
        fields at the same offset.
        (pending_init_member): Test the correct member.

--- gcc/c-typeck.c.orig	Wed Feb 23 18:38:30 2000
+++ gcc/c-typeck.c	Wed Feb 23 18:38:35 2000
@@ -5846,7 +5846,7 @@
 	  p = *q;
 	  if (tree_int_cst_lt (purpose, p->purpose))
 	    q = &p->left;
-	  else if (tree_int_cst_lt (p->purpose, purpose))
+	  else if (p->purpose != purpose)
 	    q = &p->right;
 	  else
 	    abort ();
@@ -5860,8 +5860,7 @@
 	  if (tree_int_cst_lt (DECL_FIELD_BITPOS (purpose),
 			       DECL_FIELD_BITPOS (p->purpose)))
 	    q = &p->left;
-	  else if (tree_int_cst_lt (DECL_FIELD_BITPOS (p->purpose),
-				    DECL_FIELD_BITPOS (purpose)))
+	  else if (p->purpose != purpose)
 	    q = &p->right;
 	  else
 	    abort ();
@@ -6046,7 +6045,7 @@
     {
       while (p)
 	{
-	  if (tree_int_cst_equal (field, p->purpose))
+	  if (field == p->purpose)
 	    return 1;
 	  else if (tree_int_cst_lt (field, p->purpose))
 	    p = p->left;
