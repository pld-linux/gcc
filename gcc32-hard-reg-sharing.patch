2002-06-20  Jakub Jelinek  <jakub@redhat.com>

	* emit-rtl.c (init_emit_once): Register static_regno_reg_rtx
	with GC.
	* alias.c (init_alias_once): Register static_reg_base_value
	with GC.

2002-06-13  Jeffrey Law  <law@redhat.com>

	* rs6000.c (rs6000_frame_related): Avoid unwanted sharing
	of hard registers.

	* emit-rtl.c (static_regno_reg_rtx): Define.
	(init_emit_once): Initialize static_regno_reg_rtx.
	(init_emit): Copy static_regno_reg_rtx into regno_reg_rtx instead
	of building new hard reg objects once per function.
	(gen_rtx_REG): Try to share hard regs.
	* regclass.c (init_fake_stack_mems): New function broken out from
	init_regs.
	* rtl.h (init_fake_stack_mems): Declare.
	* toplev.c (lang_independent_init): Call init_regs before
	init_emit_once.  Call init_fake_stack_mems after init_emit_once.

	* alias.c (argument_registers): Remove.
	(init_alias_once): Initialize static_reg_base_value here.  Remove
	initialization of argument_registers.
	(init_alias_once_per_function): Remove.
	(init_alias_analysis): Copy all the entries from static_reg_base_value
	into new_reg_base_value all at once.
	* rtl.h (init_alias_once_per_function): Remove declaration.
	* function.c (prepare_function_start): Do not call
	init_alias_once_per_function.

	* caller-save.c (init_caller_save): Use gen_rtx_INSN instead of
	starting a sequence and emitting an INSN.

2002-06-11  Jeffrey Law <law@redhat.com>

	* caller-save.c (init_caller_save): Move creation of SAVEINSN
	and RESTINSN into into the scope of the sequence.

	* loop.c (loop_regs_scan): Avoid useless generation of REG objects.

2002-06-10  Jeffrey Law  <law@redhat.com>

	* alias.c (static_reg_base_value): New to hold RTL for
	items allocated once per function for the aliasing code.
	(init_alias_once_per_function): Initialize static_reg_base_value.
	(init_alias_analysis): Avoid throw-away allocations of RTL by
	using pre-computed values in static_reg_base_value.
	* function.c (prepare_function_start): Call
	init_alias_once_per_function appropriately.
	* rtl.h (init_alias_once_per_function): Declare.
	* caller-save (init_caller_save): Restructure slightly to
	avoid lots of silly RTL generation.
	* expr.c (init_expr_once): Likewise.
	* reload1.c (reload_cse_regs_1): Allocate throw-away register
	RTL object here.  Pass it into children.
	(reload_cse_simplify_operands): Use passed-in register RTL
	object.
	(reload_cse_simplify): Pass through throw-away register
	RTL object.

2002-06-07  Jeff Law  <law@redhat.com>

	* emit-rtl.c (init_emit): Add hard registers to regno_reg_rtx.
	* combine.c (move_deaths): Use regno_reg_rtx for hard regs rather
	than creating a new register.
	(distribute_notes): Likewise.
	* df.c (df_reg_use_gen): Likewise.
	(df_reg_clobber_gen): Likewise.
	(df_ref_record): Likewise.
	* expr.c (use_regs): Likewise.
	* flow.c (propagate_one_insn): Likewise.
	(mark_set_1): Likewise.
	(mark_used_reg): Likewise.
	* reload.c (emit_reload_insns): Likewise.

--- gcc/df.c.jj	Tue Apr  2 21:23:50 2002
+++ gcc/df.c	Thu Jun 20 14:12:05 2002
@@ -633,8 +633,7 @@ static rtx df_reg_use_gen (regno)
   rtx reg;
   rtx use;
 
-  reg = regno >= FIRST_PSEUDO_REGISTER
-    ? regno_reg_rtx[regno] : gen_rtx_REG (reg_raw_mode[regno], regno);
+  reg = regno_reg_rtx[regno];
 
   use = gen_rtx_USE (GET_MODE (reg), reg);
   return use;
@@ -648,8 +647,7 @@ static rtx df_reg_clobber_gen (regno)
   rtx reg;
   rtx use;
 
-  reg = regno >= FIRST_PSEUDO_REGISTER
-    ? regno_reg_rtx[regno] : gen_rtx_REG (reg_raw_mode[regno], regno);
+  reg = regno_reg_rtx[regno];
 
   use = gen_rtx_CLOBBER (GET_MODE (reg), reg);
   return use;
@@ -905,7 +903,7 @@ df_ref_record (df, reg, loc, insn, ref_t
       endregno = regno + HARD_REGNO_NREGS (regno, GET_MODE (reg));
 
       for (i = regno; i < endregno; i++)
-	df_ref_record_1 (df, gen_rtx_REG (reg_raw_mode[i], i),
+	df_ref_record_1 (df, regno_reg_rtx[i],
 			 loc, insn, ref_type, ref_flags);
     }
   else
--- gcc/config/rs6000/rs6000.c.jj	Sat May 25 00:01:52 2002
+++ gcc/config/rs6000/rs6000.c	Thu Jun 20 18:23:59 2002
@@ -8531,6 +8531,14 @@ rs6000_frame_related (insn, reg, val, re
 {
   rtx real, temp;
 
+  /* copy_rtx will not make unique copies of registers, so we need to
+     ensure we don't have unwanted sharing here.  */
+  if (reg == reg2)
+    reg = gen_raw_REG (GET_MODE (reg), REGNO (reg));
+
+  if (reg == rreg)
+    reg = gen_raw_REG (GET_MODE (reg), REGNO (reg));
+
   real = copy_rtx (PATTERN (insn));
 
   real = replace_rtx (real, reg, 
--- gcc/combine.c.jj	Tue Jun  4 15:02:15 2002
+++ gcc/combine.c	Thu Jun 20 14:12:38 2002
@@ -11908,7 +11908,7 @@ move_deaths (x, maybe_kill_insn, from_cu
 		if (i < regno || i >= ourend)
 		  REG_NOTES (where_dead)
 		    = gen_rtx_EXPR_LIST (REG_DEAD,
-					 gen_rtx_REG (reg_raw_mode[i], i),
+					 regno_reg_rtx[i],
 					 REG_NOTES (where_dead));
 	    }
 
@@ -11935,7 +11935,7 @@ move_deaths (x, maybe_kill_insn, from_cu
 		offset = 1;
 
 	      for (i = regno + offset; i < ourend; i++)
-		move_deaths (gen_rtx_REG (reg_raw_mode[i], i),
+		move_deaths (regno_reg_rtx[i],
 			     maybe_kill_insn, from_cuid, to_insn, &oldnotes);
 	    }
 
@@ -12557,7 +12557,7 @@ distribute_notes (notes, from_insn, i3, 
 		      for (i = regno; i < endregno;
 			   i += HARD_REGNO_NREGS (i, reg_raw_mode[i]))
 			{
-			  rtx piece = gen_rtx_REG (reg_raw_mode[i], i);
+			  rtx piece = regno_reg_rtx[i];
 			  basic_block bb = BASIC_BLOCK (this_basic_block);
 
 			  if (! dead_or_set_p (place, piece)
--- gcc/emit-rtl.c.jj	Thu May 23 10:28:12 2002
+++ gcc/emit-rtl.c	Thu Jun 20 18:38:08 2002
@@ -92,6 +92,12 @@ static int no_line_numbers;
 
 rtx global_rtl[GR_MAX];
 
+/* Commonly used RTL for hard registers.  These objects are not necessarily
+   unique, so we allocate them separately from global_rtl.  They are
+   initialized once per compilation unit, then copied into regno_reg_rtx
+   at the beginning of each function.  */
+static rtx static_regno_reg_rtx[FIRST_PSEUDO_REGISTER];
+
 /* We record floating-point CONST_DOUBLEs in each floating-point mode for
    the values of 0, 1, and 2.  For the integer entries and VOIDmode, we
    record a copy of const[012]_rtx.  */
@@ -427,6 +433,15 @@ gen_rtx_REG (mode, regno)
 	return stack_pointer_rtx;
     }
 
+  /* If the per-function register table has been set up, try to re-use
+     an existing entry in that table to avoid useless generation of RTL.  */
+  if (0 && cfun
+      && cfun->emit
+      && regno_reg_rtx
+      && regno >= 0 && regno < FIRST_PSEUDO_REGISTER
+      && reg_raw_mode[regno] == mode)
+    return regno_reg_rtx[regno];
+
   return gen_raw_REG (mode, regno);
 }
 
@@ -4841,6 +4856,11 @@ init_emit ()
   f->emit->regno_decl
     = (tree *) xcalloc (f->emit->regno_pointer_align_length, sizeof (tree));
 
+  /* Put copies of all the hard registers into regno_reg_rtx.  */
+  memcpy (regno_reg_rtx,
+	  static_regno_reg_rtx,
+	  FIRST_PSEUDO_REGISTER * sizeof (rtx));
+
   /* Put copies of all the virtual register rtx into regno_reg_rtx.  */
   init_virtual_regs (f->emit);
 
@@ -5015,8 +5035,14 @@ init_emit_once (line_numbers)
     gen_raw_REG (Pmode, VIRTUAL_OUTGOING_ARGS_REGNUM);
   virtual_cfa_rtx = gen_raw_REG (Pmode, VIRTUAL_CFA_REGNUM);
 
+  /* Initialize RTL for commonly used hard registers.  These are
+     copied into regno_reg_rtx as we begin to compile each function.  */
+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)
+    static_regno_reg_rtx[i] = gen_raw_REG (reg_raw_mode[i], i);
+
   /* These rtx must be roots if GC is enabled.  */
   ggc_add_rtx_root (global_rtl, GR_MAX);
+  ggc_add_rtx_root (static_regno_reg_rtx, (int) FIRST_PSEUDO_REGISTER);
 
 #ifdef INIT_EXPANDERS
   /* This is to initialize {init|mark|free}_machine_status before the first
--- gcc/expr.c.jj	Tue May  7 12:45:49 2002
+++ gcc/expr.c	Thu Jun 20 17:04:00 2002
@@ -208,6 +208,7 @@ init_expr_once ()
   enum machine_mode mode;
   int num_clobbers;
   rtx mem, mem1;
+  rtx reg;
 
   start_sequence ();
 
@@ -217,6 +218,10 @@ init_expr_once ()
   mem = gen_rtx_MEM (VOIDmode, stack_pointer_rtx);
   mem1 = gen_rtx_MEM (VOIDmode, frame_pointer_rtx);
 
+  /* A scratch register we can modify in-place below to avoid
+     useless RTL allocations.  */
+  reg = gen_raw_REG (VOIDmode, -1);
+
   insn = emit_insn (gen_rtx_SET (0, NULL_RTX, NULL_RTX));
   pat = PATTERN (insn);
 
@@ -224,11 +229,11 @@ init_expr_once ()
        mode = (enum machine_mode) ((int) mode + 1))
     {
       int regno;
-      rtx reg;
 
       direct_load[(int) mode] = direct_store[(int) mode] = 0;
       PUT_MODE (mem, mode);
       PUT_MODE (mem1, mode);
+      PUT_MODE (reg, mode);
 
       /* See if there is some register that can be used in this mode and
 	 directly loaded or stored from memory.  */
@@ -241,7 +246,7 @@ init_expr_once ()
 	    if (! HARD_REGNO_MODE_OK (regno, mode))
 	      continue;
 
-	    reg = gen_rtx_REG (mode, regno);
+	    REGNO (reg) = regno;
 
 	    SET_SRC (pat) = mem;
 	    SET_DEST (pat) = reg;
@@ -2280,7 +2285,7 @@ use_regs (call_fusage, regno, nregs)
     abort ();
 
   for (i = 0; i < nregs; i++)
-    use_reg (call_fusage, gen_rtx_REG (reg_raw_mode[regno + i], regno + i));
+    use_reg (call_fusage, regno_reg_rtx[regno + i]);
 }
 
 /* Add USE expressions to *CALL_FUSAGE for each REG contained in the
--- gcc/flow.c.jj	Tue Apr 23 20:26:35 2002
+++ gcc/flow.c	Thu Jun 20 14:12:05 2002
@@ -1721,8 +1721,7 @@ propagate_one_insn (pbi, insn)
 	    if (TEST_HARD_REG_BIT (regs_invalidated_by_call, i))
 	      {
 		/* We do not want REG_UNUSED notes for these registers.  */
-		mark_set_1 (pbi, CLOBBER, gen_rtx_REG (reg_raw_mode[i], i),
-			    cond, insn,
+		mark_set_1 (pbi, CLOBBER, regno_reg_rtx[i], cond, insn,
 			    pbi->flags & ~(PROP_DEATH_NOTES | PROP_REG_INFO));
 	      }
 	}
@@ -1770,8 +1769,7 @@ propagate_one_insn (pbi, insn)
 	     so they are made live.  */
 	  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)
 	    if (global_regs[i])
-	      mark_used_reg (pbi, gen_rtx_REG (reg_raw_mode[i], i),
-			     cond, insn);
+	      mark_used_reg (pbi, regno_reg_rtx[i], cond, insn);
 	}
     }
 
@@ -2769,7 +2767,7 @@ mark_set_1 (pbi, code, reg, cond, insn, 
 		    if (! REGNO_REG_SET_P (pbi->reg_live, i))
 		      REG_NOTES (insn)
 			= alloc_EXPR_LIST (REG_UNUSED,
-					   gen_rtx_REG (reg_raw_mode[i], i),
+					   regno_reg_rtx[i],
 					   REG_NOTES (insn));
 		}
 	    }
@@ -3577,7 +3575,7 @@ mark_used_reg (pbi, reg, cond, insn)
 		&& ! dead_or_set_regno_p (insn, i))
 	      REG_NOTES (insn)
 		= alloc_EXPR_LIST (REG_DEAD,
-				   gen_rtx_REG (reg_raw_mode[i], i),
+				   regno_reg_rtx[i],
 				   REG_NOTES (insn));
 	}
     }
--- gcc/reload1.c.jj	Wed May 22 14:17:55 2002
+++ gcc/reload1.c	Thu Jun 20 17:05:46 2002
@@ -444,7 +444,7 @@ static int constraint_accepts_reg_p	PARA
 static void reload_cse_regs_1		PARAMS ((rtx));
 static int reload_cse_noop_set_p	PARAMS ((rtx));
 static int reload_cse_simplify_set	PARAMS ((rtx, rtx));
-static int reload_cse_simplify_operands	PARAMS ((rtx));
+static int reload_cse_simplify_operands	PARAMS ((rtx, rtx));
 static void reload_combine		PARAMS ((void));
 static void reload_combine_note_use	PARAMS ((rtx *, rtx));
 static void reload_combine_note_store	PARAMS ((rtx, rtx, void *));
@@ -459,7 +459,7 @@ static HOST_WIDE_INT sext_for_mode	PARAM
 static void failed_reload		PARAMS ((rtx, int));
 static int set_reload_reg		PARAMS ((int, int));
 static void reload_cse_delete_noop_set	PARAMS ((rtx, rtx));
-static void reload_cse_simplify		PARAMS ((rtx));
+static void reload_cse_simplify		PARAMS ((rtx, rtx));
 void fixup_abnormal_edges		PARAMS ((void));
 extern void dump_needs			PARAMS ((struct insn_chain *));
 
@@ -7161,8 +7161,7 @@ emit_reload_insns (chain)
 		    for (k = 1; k < nnr; k++)
 		      reg_last_reload_reg[nregno + k]
 			= (nr == nnr
-			   ? gen_rtx_REG (reg_raw_mode[REGNO (rld[r].reg_rtx) + k],
-					  REGNO (rld[r].reg_rtx) + k)
+			   ? regno_reg_rtx[REGNO (rld[r].reg_rtx) + k]
 			   : 0);
 
 		  /* Now do the inverse operation.  */
@@ -7211,8 +7210,7 @@ emit_reload_insns (chain)
 		    for (k = 1; k < nnr; k++)
 		      reg_last_reload_reg[nregno + k]
 			= (nr == nnr
-			   ? gen_rtx_REG (reg_raw_mode[REGNO (rld[r].reg_rtx) + k],
-					  REGNO (rld[r].reg_rtx) + k)
+			   ? regno_reg_rtx[REGNO (rld[r].reg_rtx) + k]
 			   : 0);
 
 		  /* Unless we inherited this reload, show we haven't
@@ -8061,8 +8059,9 @@ reload_cse_noop_set_p (set)
 
 /* Try to simplify INSN.  */
 static void
-reload_cse_simplify (insn)
+reload_cse_simplify (insn, testreg)
      rtx insn;
+     rtx testreg;
 {
   rtx body = PATTERN (insn);
 
@@ -8089,7 +8088,7 @@ reload_cse_simplify (insn)
       if (count > 0)
 	apply_change_group ();
       else
-	reload_cse_simplify_operands (insn);
+	reload_cse_simplify_operands (insn, testreg);
     }
   else if (GET_CODE (body) == PARALLEL)
     {
@@ -8132,7 +8131,7 @@ reload_cse_simplify (insn)
       if (count > 0)
 	apply_change_group ();
       else
-	reload_cse_simplify_operands (insn);
+	reload_cse_simplify_operands (insn, testreg);
     }
 }
 
@@ -8158,6 +8157,7 @@ reload_cse_regs_1 (first)
      rtx first;
 {
   rtx insn;
+  rtx testreg = gen_raw_REG (VOIDmode, -1);
 
   cselib_init ();
   init_alias_analysis ();
@@ -8165,7 +8165,7 @@ reload_cse_regs_1 (first)
   for (insn = first; insn; insn = NEXT_INSN (insn))
     {
       if (INSN_P (insn))
-	reload_cse_simplify (insn);
+	reload_cse_simplify (insn, testreg);
 
       cselib_process_insn (insn);
     }
@@ -8336,8 +8336,9 @@ reload_cse_simplify_set (set, insn)
    hard registers.  */
 
 static int
-reload_cse_simplify_operands (insn)
+reload_cse_simplify_operands (insn, testreg)
      rtx insn;
+     rtx testreg;
 {
   int i, j;
 
@@ -8357,7 +8358,6 @@ reload_cse_simplify_operands (insn)
   int *op_alt_regno[MAX_RECOG_OPERANDS];
   /* Array of alternatives, sorted in order of decreasing desirability.  */
   int *alternative_order;
-  rtx reg = gen_rtx_REG (VOIDmode, -1);
 
   extract_insn (insn);
 
@@ -8441,8 +8441,8 @@ reload_cse_simplify_operands (insn)
 	  if (! TEST_HARD_REG_BIT (equiv_regs[i], regno))
 	    continue;
 
-	  REGNO (reg) = regno;
-	  PUT_MODE (reg, mode);
+	  REGNO (testreg) = regno;
+	  PUT_MODE (testreg, mode);
 
 	  /* We found a register equal to this operand.  Now look for all
 	     alternatives that can accept this register and have not been
@@ -8484,10 +8484,10 @@ reload_cse_simplify_operands (insn)
 		     alternative yet and the operand being replaced is not
 		     a cheap CONST_INT.  */
 		  if (op_alt_regno[i][j] == -1
-		      && reg_fits_class_p (reg, class, 0, mode)
+		      && reg_fits_class_p (testreg, class, 0, mode)
 		      && (GET_CODE (recog_data.operand[i]) != CONST_INT
 			  || (rtx_cost (recog_data.operand[i], SET)
-			      > rtx_cost (reg, SET))))
+			      > rtx_cost (testreg, SET))))
 		    {
 		      alternative_nregs[j]++;
 		      op_alt_regno[i][j] = regno;
--- gcc/alias.c.jj	Thu Jun 20 12:43:03 2002
+++ gcc/alias.c	Thu Jun 20 18:36:24 2002
@@ -149,6 +149,10 @@ static rtx *reg_base_value;
 static rtx *new_reg_base_value;
 static unsigned int reg_base_value_size; /* size of reg_base_value array */
 
+/* Static hunks of RTL used by the aliasing code; these are initialized
+   once per function to avoid unnecessary RTL allocations.  */
+static rtx static_reg_base_value[FIRST_PSEUDO_REGISTER];
+
 #define REG_BASE_VALUE(X) \
   (REGNO (X) < reg_base_value_size \
    ? reg_base_value[REGNO (X)] : 0)
@@ -2429,8 +2433,6 @@ mark_constant_function ()
 }
 
 
-static HARD_REG_SET argument_registers;
-
 void
 init_alias_once ()
 {
@@ -2439,13 +2441,26 @@ init_alias_once ()
 #ifndef OUTGOING_REGNO
 #define OUTGOING_REGNO(N) N
 #endif
+  ggc_add_rtx_root (static_reg_base_value, (int) FIRST_PSEUDO_REGISTER);
   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)
     /* Check whether this register can hold an incoming pointer
        argument.  FUNCTION_ARG_REGNO_P tests outgoing register
        numbers, so translate if necessary due to register windows.  */
     if (FUNCTION_ARG_REGNO_P (OUTGOING_REGNO (i))
 	&& HARD_REGNO_MODE_OK (i, Pmode))
-      SET_HARD_REG_BIT (argument_registers, i);
+      static_reg_base_value[i]
+	= gen_rtx_ADDRESS (VOIDmode, gen_rtx_REG (Pmode, i));
+
+  static_reg_base_value[STACK_POINTER_REGNUM]
+    = gen_rtx_ADDRESS (Pmode, stack_pointer_rtx);
+  static_reg_base_value[ARG_POINTER_REGNUM]
+    = gen_rtx_ADDRESS (Pmode, arg_pointer_rtx);
+  static_reg_base_value[FRAME_POINTER_REGNUM]
+    = gen_rtx_ADDRESS (Pmode, frame_pointer_rtx);
+#if HARD_FRAME_POINTER_REGNUM != FRAME_POINTER_REGNUM
+  static_reg_base_value[HARD_FRAME_POINTER_REGNUM]
+    = gen_rtx_ADDRESS (Pmode, hard_frame_pointer_rtx);
+#endif
 
   alias_sets = splay_tree_new (splay_tree_compare_ints, 0, 0);
 }
@@ -2535,21 +2550,8 @@ init_alias_analysis ()
 	 The address expression is VOIDmode for an argument and
 	 Pmode for other registers.  */
 
-      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)
-	if (TEST_HARD_REG_BIT (argument_registers, i))
-	  new_reg_base_value[i] = gen_rtx_ADDRESS (VOIDmode,
-						   gen_rtx_REG (Pmode, i));
-
-      new_reg_base_value[STACK_POINTER_REGNUM]
-	= gen_rtx_ADDRESS (Pmode, stack_pointer_rtx);
-      new_reg_base_value[ARG_POINTER_REGNUM]
-	= gen_rtx_ADDRESS (Pmode, arg_pointer_rtx);
-      new_reg_base_value[FRAME_POINTER_REGNUM]
-	= gen_rtx_ADDRESS (Pmode, frame_pointer_rtx);
-#if HARD_FRAME_POINTER_REGNUM != FRAME_POINTER_REGNUM
-      new_reg_base_value[HARD_FRAME_POINTER_REGNUM]
-	= gen_rtx_ADDRESS (Pmode, hard_frame_pointer_rtx);
-#endif
+      memcpy (new_reg_base_value, static_reg_base_value,
+	      FIRST_PSEUDO_REGISTER * sizeof (rtx));
 
       /* Walk the insns adding values to the new_reg_base_value array.  */
       for (insn = get_insns (); insn; insn = NEXT_INSN (insn))
--- gcc/caller-save.c.jj	Wed Jan  2 12:47:35 2002
+++ gcc/caller-save.c	Thu Jun 20 17:49:47 2002
@@ -115,6 +115,9 @@ init_caller_save ()
   rtx address;
   int i, j;
   enum machine_mode mode;
+  rtx savepat, restpat;
+  rtx test_reg, test_mem;
+  rtx saveinsn, restinsn;
 
   /* First find all the registers that we need to deal with and all
      the modes that they can have.  If we can't find a mode to use,
@@ -179,22 +182,30 @@ init_caller_save ()
     address = addr_reg;
 
   /* Next we try to form an insn to save and restore the register.  We
-     see if such an insn is recognized and meets its constraints.  */
+     see if such an insn is recognized and meets its constraints. 
 
-  start_sequence ();
+     To avoid lots of unnecessary RTL allocation, we construct all the RTL
+     once, then modify the memory and register operands in-place.  */
+
+  test_reg = gen_rtx_REG (VOIDmode, 0);
+  test_mem = gen_rtx_MEM (VOIDmode, address);
+  savepat = gen_rtx_SET (VOIDmode, test_mem, test_reg);
+  restpat = gen_rtx_SET (VOIDmode, test_reg, test_mem);
+  saveinsn = gen_rtx_INSN (VOIDmode, 0, 0, 0, savepat, -1, 0, 0);
+  restinsn = gen_rtx_INSN (VOIDmode, 0, 0, 0, restpat, -1, 0, 0);
 
   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)
     for (mode = 0 ; mode < MAX_MACHINE_MODE; mode++)
       if (HARD_REGNO_MODE_OK (i, mode))
         {
-	  rtx mem = gen_rtx_MEM (mode, address);
-	  rtx reg = gen_rtx_REG (mode, i);
-	  rtx savepat = gen_rtx_SET (VOIDmode, mem, reg);
-	  rtx restpat = gen_rtx_SET (VOIDmode, reg, mem);
-	  rtx saveinsn = emit_insn (savepat);
-	  rtx restinsn = emit_insn (restpat);
 	  int ok;
 
+	  /* Update the register number and modes of the register
+	     and memory operand.  */
+	  REGNO (test_reg) = i;
+	  PUT_MODE (test_reg, mode);
+	  PUT_MODE (test_mem, mode);
+
 	  reg_save_code[i][mode] = recog_memoized (saveinsn);
 	  reg_restore_code[i][mode] = recog_memoized (restinsn);
 
@@ -232,8 +243,6 @@ init_caller_save ()
 	      SET_HARD_REG_BIT (call_fixed_reg_set, i);
 	    }
 	}
-
-  end_sequence ();
 }
 
 /* Initialize save areas by showing that we haven't allocated any yet.  */
--- gcc/rtl.h.jj	Tue May 21 20:19:51 2002
+++ gcc/rtl.h	Thu Jun 20 18:01:01 2002
@@ -1964,6 +1964,7 @@ extern int reg_classes_intersect_p	PARAM
 extern int reg_class_subset_p		PARAMS ((enum reg_class, enum reg_class));
 extern void globalize_reg		PARAMS ((int));
 extern void init_regs			PARAMS ((void));
+extern void init_fake_stack_mems	PARAMS ((void));
 extern void init_reg_sets		PARAMS ((void));
 extern void regset_release_memory	PARAMS ((void));
 extern void regclass_init		PARAMS ((void));
--- gcc/regclass.c.jj	Wed Jun 19 15:11:11 2002
+++ gcc/regclass.c	Thu Jun 20 18:01:01 2002
@@ -605,11 +605,16 @@ init_regs ()
   init_reg_sets_1 ();
 
   init_reg_modes ();
+}
 
+/* Initialize some fake stack-frame MEM references for use in
+   memory_move_secondary_cost.  */
+
+void
+init_fake_stack_mems ()
+{
 #ifdef HAVE_SECONDARY_RELOADS
   {
-    /* Make some fake stack-frame MEM references for use in
-       memory_move_secondary_cost.  */
     int i;
 
     for (i = 0; i < MAX_MACHINE_MODE; i++)
--- gcc/toplev.c.jj	Thu May 30 11:08:44 2002
+++ gcc/toplev.c	Thu Jun 20 18:01:01 2002
@@ -5058,6 +5058,9 @@ lang_independent_init ()
   init_stringpool ();
   init_obstacks ();
 
+  /* init_emit_once uses reg_raw_mode and therefore must be called
+     after init_regs which initialized reg_raw_mode.  */
+  init_regs ();
   init_emit_once (debug_info_level == DINFO_LEVEL_NORMAL
 		  || debug_info_level == DINFO_LEVEL_VERBOSE
 #ifdef VMS_DEBUGGING_INFO
@@ -5066,7 +5069,7 @@ lang_independent_init ()
 #endif
 		    || flag_test_coverage
 		    || warn_notreached);
-  init_regs ();
+  init_fake_stack_mems ();
   init_alias_once ();
   init_stmt ();
   init_loop ();
--- gcc/loop.c.jj	Wed Jun 19 15:10:51 2002
+++ gcc/loop.c	Thu Jun 20 18:22:01 2002
@@ -9541,7 +9541,7 @@ loop_regs_scan (loop, extra_size)
   if (LOOP_INFO (loop)->has_call)
     for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)
       if (TEST_HARD_REG_BIT (regs_invalidated_by_call, i)
-          && rtx_varies_p (gen_rtx_REG (Pmode, i), /*for_alias=*/1))
+          && rtx_varies_p (regno_reg_rtx[i], 1))
         {
           regs->array[i].may_not_optimize = 1;
           regs->array[i].set_in_loop = 1;
