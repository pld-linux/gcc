diff -urN gcc-2.95.2.org/gcc/reload1.c gcc-2.95.2/gcc/reload1.c
--- gcc-2.95.2.org/gcc/reload1.c	Sat Nov 25 01:48:15 2000
+++ gcc-2.95.2/gcc/reload1.c	Sat Nov 25 01:52:07 2000
@@ -423,6 +423,7 @@
 static int reload_reg_reaches_end_p	PROTO((int, int, enum reload_type));
 static int allocate_reload_reg		PROTO((struct insn_chain *, int, int,
 					       int));
+static int conflicts_with_override	PROTO((rtx));
 static void choose_reload_regs		PROTO((struct insn_chain *));
 static void merge_assigned_reloads	PROTO((rtx));
 static void emit_reload_insns		PROTO((struct insn_chain *));
@@ -5594,6 +5595,21 @@
 
   return 1;
 }
+
+/* Determine whether the reload reg X overlaps any rtx'es used for
+   overriding inheritance.  Return nonzero if so.  */
+
+static int
+conflicts_with_override (x)
+     rtx x;
+{
+  int i;
+  for (i = 0; i < n_reloads; i++)
+    if (reload_override_in[i]
+       && reg_overlap_mentioned_p (x, reload_override_in[i]))
+      return 1;
+  return 0;
+}
 
 /* Assign hard reg targets for the pseudo-registers we must reload
    into hard regs for this insn.
@@ -6791,6 +6807,7 @@
 		   && dead_or_set_p (insn, old)
 		   /* This is unsafe if some other reload
 		      uses the same reg first.  */
+		   && ! conflicts_with_override (reloadreg)
 		   && reload_reg_free_for_value_p (REGNO (reloadreg),
 						   reload_opnum[j],
 						   reload_when_needed[j], 

