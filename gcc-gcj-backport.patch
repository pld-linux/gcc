#! /bin/sh -e

# DP: J*va patch set for gcc-2.95.2 
# DP: taken from http://waitaki.otago.ac.nz/~bryce/gcj/
# DP:
# DP: This patch consists of new J*va features and fixes extracted
# DP: from cvs and back-ported to gcc-2.95.2. It allows compilation of the
# DP: latest libgcj snapshots and cvs tree without the problems of the
# DP: current unstable cvs gcc tree (last update 1999-10-31).

if [ $# -eq 3 -a "$2" = '-d' ]; then
    pdir="-d $3"
elif [ $# -ne 1 ]; then
    echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
    exit 1
fi
case "$1" in
    -patch) patch $pdir -f --no-backup-if-mismatch -p1 < $0;;
    -unpatch) patch $pdir -f --no-backup-if-mismatch -R -p1 < $0;;
    *)
	echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
	exit 1
esac
exit 0

Only in gcc-2.95.2/: build
diff -u -r gcc-2.95.2-orig/gcc/java/ChangeLog gcc-2.95.2/gcc/java/ChangeLog
--- gcc-2.95.2-orig/gcc/java/ChangeLog	Mon Oct 25 19:59:13 1999
+++ gcc-2.95.2/gcc/java/ChangeLog	Sun Oct 31 19:09:00 1999
@@ -1,3 +1,286 @@
+Fri Oct 29 14:35:18 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>
+
+	* class.c (add_method_1): Set DECL_INLINE to 1 for private, static
+ 	and final method.
+	
+Fri Oct 29 14:23:32 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>
+
+        * parse.y (expression_statement:): Call function to report
+        improper invocation of a constructor.
+        (parse_ctor_invocation_error): New function.
+
+1999-10-04  Tom Tromey  <tromey@cygnus.com>
+
+        * lex.h (BUILD_OPERATOR2): Return ASSIGN_ANY_TK in `lite' case as
+        well.  Fixes Java PR gcj/59.
+        * parse-scan.y (yyerror): Report errors.
+
+Thu Oct 21 01:27:31 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>
+
+        * parse.y (resolve_qualified_expression_name): Handle MODIFY_EXPR.
+        (qualify_ambiguous_name): Likewise.
+
+1999-10-21  Tom Tromey  <tromey@cygnus.com>
+
+        * jvgenmain.c (main): _Jv_Compiler_Properties now an extern; set
+        in generated `main'.
+
+Tue Oct 12 22:28:10 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>
+
+	* jcf-write.c (RELOCATION_VALUE_1): Fixed integer value from 0 to 1.
+	
+1999-10-07  Anthony Green  <green@cygnus.com>
+
+	* jcf-write.c (generate_classfile): Use UNSAFE_PUTx in cases
+	where CHECK_PUT may fail for valid reasons.
+
+	* jcf-write.c (UNSAFE_PUT1, UNSAFE_PUT2, UNSAFE_PUT3,
+ 	UNSAFE_PUTN): New macros.
+
+Tue Sep 14 16:24:19 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>
+
+        * jcf-write.c: (RELOCATION_VALUE_0): New macro.
+        (RELOCATION_VALUE_1): Likewise.
+        (emit_iinc, emit_reloc, push_constant1, push_constant2,
+        push_in_const, push_long_const): Prototyped.
+        (push_constant1): Argument `index' is of type HOST_WIDE_INT.
+        (push_constant2): Likewise.
+        (push_int_const): Cast find_constant1's integer arguments to `jword'.
+        (find_constant_wide): Cast find_constant2's integer arguments to
+        `jword'.
+        (find_constant_index): Cast find_constant2's and find_constant2's
+        integer arguments to `jword'.
+        (emit_pop): Argument `value' is of type HOST_WIDE_INT.
+        (emit_switch_reloc): Use RELOCATION_VALUE_0.
+        (emit_if): Use RELOCATION_VALUE_1.
+        (emit_goto): Likewise.
+        (emit_jsr): Likewise.
+        (generate_bytecode_insns): Use RELOCATION_VALUE_0. Cast second
+        argument to push_long_const to HOST_WIDE_INT.
+
+Thu Sep 16 15:42:39 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>
+
+        * parse.y (java_method_add_stmt): Test against GET_CURRENT_BLOCK
+        instead of fndecl.
+
+Sat Sep 11 16:46:44 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>
+
+        * parse.y (find_applicable_accessible_methods_list): Search
+        abstract classes as interfaces.
+
+Thu Sep  9 17:33:28 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>
+
+        * class.c (finish_class): We're now outside a valid method
+        declaration. Tell the rest of gcc so.
+
+1999-09-07  Tom Tromey  <tromey@cygnus.com>
+
+        * gjavah.c (add_class_decl): Generate include for gcj/array.h, not
+        java-array.h.
+        (decode_signature_piece): Don't emit "::" in JArray<>.
+        (print_namelet): Only print trailing `;' when printing a class.
+
+1999-09-03  Tom Tromey  <tromey@cygnus.com>
+
+        * parse.y (strip_out_static_field_access_decl): Return operand if
+        it satisfies JDECL_P.
+
+1999-09-02  Tom Tromey  <tromey@cygnus.com>
+
+        * gjavah.c (decode_signature_piece): Emit "::" in JArray<>.
+        Handle nested arrays, like `[[I'.
+
+1999-08-26  Tom Tromey  <tromey@cygnus.com>
+
+        * gjavah.c (print_cxx_classname): Print "::" before qualified
+        name.
+	
+1999-10-19  Tom Tromey  <tromey@cygnus.com>
+
+        * jcf-parse.c (parse_source_file): Call jcf_dependency_add_file.
+        From Mike Moreton <mike@pillim.demon.co.uk>.
+
+1999-09-23  Tom Tromey  <tromey@cygnus.com>
+
+        * jvspec.c (lang_specific_driver): Don't read spec file if
+        -fsyntax-only given.
+
+1999-09-22  Tom Tromey  <tromey@cygnus.com>
+
+        * lang-specs.h: Added `%(jc1)' to the jc1 spec.
+
+1999-08-25  Tom Tromey  <tromey@cygnus.com>
+
+        * jvspec.c (lang_specific_driver): Correctly handle --help again.
+
+1999-10-14  Tom Tromey  <tromey@cygnus.com>
+
+        * jvgenmain.c (usage): New function.
+        (main): Use it.  Also, handle `-D' options.
+        * jvspec.c (lang_specific_driver): Recognize -D.
+        (jvgenmain_spec): Added `%{D*}' to jvgenmain invocation.
+
+Thu Aug 26 09:10:58 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>
+
+        * parse.y (lookup_cl): Changed leading comment. Now does its best
+        to set the column number.
+        (qualify_ambiguous_name): Take WFL wrappers into account.
+
+Wed Aug 25 15:37:15 1999  Gregg Townsend  <gmt@cs.arizona.edu>
+
+	* verify.c (verify_jvm_instructions): Don't check instruction
+	validity beyond end of method.
+
+Sun Aug 22 11:07:41 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>
+
+        * parse.y (check_method_redefinition): Changed leading comment.
+        (check_abstract_method_definitions): New function.
+        (java_check_abstract_method_definitions): New function.
+        (java_check_regular_methods): Call it.
+        (verify_constructor_super): Fixed indentation.
+        (lookup_method_invoke): Likewise.
+
+Thu Aug 19 10:26:18 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>
+
+        * parse.y (method_header): Return a null pointer if the current
+        class node is null.
+        (finish_method_declaration): Return if the current function decl
+        is null.
+        (source_start_java_method): Likewise.
+        (java_method_add_stmt): Likewise.
+
+Wed Aug 18 13:17:15 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>
+
+        * class.c (emit_register_class): Removed unnecessary call to
+        start_sequence.
+        * parse.y (labeled_block_contains_loop_p): Removed unused local
+        variable.
+
+Tue Aug 17 22:51:44 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>
+
+        * parse.y (java_refold): Added prototype.
+
+Tue Aug 17 21:48:41 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>
+
+        * parse.y (BINOP_COMPOUND_CANDIDATES): New macro.
+        (java_stabilize_reference): Removed unnecessary `else'.
+        (java_complete_lhs): Set flag to remember boolean. Call
+        java_refold. Added comments.
+        (java_decl_equiv): New function.
+        (binop_compound_p): Likewise.
+        (java_refold): Likewise.
+        (patch_unaryop): Striped static field access assigned to decl and
+        op. Changed promotion scheme for ++/-- operators.
+        (search_loop): New function.
+        (labeled_block_contains_loop_p): Likewise.
+        (patch_loop_statement): Call labeled_block_contains_loop_p. Added
+        comment.
+        (patch_bc_statement): Call search_loop. Fixed comment.
+
+1999-08-15  Anthony Green  <green@cygnus.com>
+
+        * expr.c (java_lang_expand_expr): Mark static array data as
+        referenced.
+
+1999-07-25  Anthony Green  <green@cygnus.com>
+
+        * gjavah.c (print_stub): New function.
+        (METHOD_IS_NATIVE): New macro.
+        (print_mangled_classname): Make static.
+        (HANDLE_END_FIELD): Don't emit fields during stub generation.
+        (process_file): Perform stub generation.
+        (HANDLE_METHOD): Don't emit class decls during stub
+        generation.
+        (HANDLE_END_METHOD): Take into account stub generation.
+        (print_method_info): Handle stub generation.
+        (print_stub): New function.
+        (print_cxx_classname): Make signature consistant with others.
+        (help): Describe -stubs option.
+        (main): Create stub file.
+        (version): Use version.c.
+        (print_full_cxx_name): New function.
+        (print_c_decl): Use print_full_cxx_name.
+
+Thu Jul 22 12:41:12 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>
+
+        * check-init.c (check_init): Handle MAX_EXPR.
+
+1999-07-15  Andrew Haley  <aph@cygnus.com>
+
+        * lang.c (flag_use_divide_subroutine): New variable.
+        * typeck.c: (convert_ieee_real_to_integer): Bounds check
+        fp-to-integer conversion.
+        (convert): Call convert_ieee_real_to_integer when flag_fast_math
+        is not set.
+
+        * expr.c (build_java_soft_divmod): New function.
+        (build_java_binop): Call build_java_soft_divmod if
+        flag_use_divide_subroutine is set.
+        * decl.c: soft_idiv_node, soft_irem_node, soft_ldiv_node, tree
+        soft_lrem_node: new builtin functions.
+        (init_decl_processing) Initialize the new builtins.
+        * java-tree.h soft_idiv_node, soft_irem_node, soft_ldiv_node, tree
+        soft_lrem_node: new builtin functions.
+        (build_java_soft_divmod): New function.
+        * parse.y: Call build_java_soft_divmod if
+        flag_use_divide_subroutine is set.
+        * parse.c: Rebuilt.
+
+        * jvspec.c (lang_specific_driver): Always allow an extra arg (for
+        a --specs= arg) even if not linking.
+        * lang-options.h (DEFINE_LANG_NAME ("Java")): Add
+        -fuse-divide-subroutine
+
+Tue Jul 20 13:20:05 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>
+
+        * parse.y (resolve_and_layout): Check methods only once.
+        (resolve_qualified_expression_name): Verify thrown exceptions
+        compatibility.
+        (check_thrown_exceptions): Reject exceptions thrown in
+        initializer. Error message tuned.
+
+1999-07-14  Andrew Haley  <aph@cygnus.com>
+
+        * expr.c (expand_expr): Do not return the last statement in a
+        block as the block's value.
+
+Sat Jul  3 22:26:32 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>
+
+        * expr.c (force_evaluation_order): Save the COMPOUND_EXPR'ed
+        CALL_EXPR, to avoid order of evaluation changes.
+
+Fri Jul  2 17:44:08 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>
+
+        * parse.y (qualify_ambiguous_name): Do not use
+        IDENTIFIER_LOCAL_VALUE when name is a STRING_CST.
+
+Thu Jul  1 23:31:16 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>
+
+        * check-init.c (check_init): Handle MAX_EXPR.
+        * expr.c (force_evaluation_order): Force method call arguments to
+        be evaluated in left-to-right order.
+        * parse.y (qualify_ambiguous_name): Loop again to qualify
+        NEW_ARRAY_EXPR properly.
+
+Wed Jun 30 17:27:58 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>
+
+        * parse.y (patch_invoke): Resolve unresolved invoked method
+        returned type.
+        (qualify_ambiguous_name): STRING_CST to qualify expression for
+        type name resolution.
+
+1999-06-24  Andrew Haley  <aph@cygnus.com>
+
+        * java/class.c (finish_class): Whenever a deferred method is
+        output, rescan the list of methods to see if a new candidate for
+        output can be found.
+
+
+======================================================================
+
+
+
+
 Sun Oct 24 23:54:10 PDT 1999 Jeff Law  (law@cygnus.com)
 
 	* gcc-2.95.2 Released.
diff -u -r gcc-2.95.2-orig/gcc/java/check-init.c gcc-2.95.2/gcc/java/check-init.c
--- gcc-2.95.2-orig/gcc/java/check-init.c	Sat May 15 01:44:08 1999
+++ gcc-2.95.2/gcc/java/check-init.c	Sun Oct 31 12:32:14 1999
@@ -643,6 +643,8 @@
     case GE_EXPR:
     case LT_EXPR:
     case LE_EXPR:
+    case MAX_EXPR:
+    case MIN_EXPR:
     case ARRAY_REF:
     binop:
       check_init (TREE_OPERAND (exp, 0), before);
diff -u -r gcc-2.95.2-orig/gcc/java/class.c gcc-2.95.2/gcc/java/class.c
--- gcc-2.95.2-orig/gcc/java/class.c	Fri Jun 25 15:27:08 1999
+++ gcc-2.95.2/gcc/java/class.c	Sun Oct 31 19:08:09 1999
@@ -425,10 +425,13 @@
 
   if (access_flags & ACC_PUBLIC) METHOD_PUBLIC (fndecl) = 1;
   if (access_flags & ACC_PROTECTED) METHOD_PROTECTED (fndecl) = 1;
-  if (access_flags & ACC_PRIVATE) METHOD_PRIVATE (fndecl) = 1;
+  if (access_flags & ACC_PRIVATE)
+    METHOD_PRIVATE (fndecl) = DECL_INLINE (fndecl) = 1;
   if (access_flags & ACC_NATIVE) METHOD_NATIVE (fndecl) = 1;
-  if (access_flags & ACC_STATIC) METHOD_STATIC (fndecl) = 1;
-  if (access_flags & ACC_FINAL) METHOD_FINAL (fndecl) = 1;
+  if (access_flags & ACC_STATIC) 
+    METHOD_STATIC (fndecl) = DECL_INLINE (fndecl) = 1;
+  if (access_flags & ACC_FINAL) 
+    METHOD_FINAL (fndecl) = DECL_INLINE (fndecl) = 1;
   if (access_flags & ACC_SYNCHRONIZED) METHOD_SYNCHRONIZED (fndecl) = 1;
   if (access_flags & ACC_ABSTRACT) METHOD_ABSTRACT (fndecl) = 1;
   if (access_flags & ACC_TRANSIENT) METHOD_TRANSIENT (fndecl) = 1;
@@ -1200,10 +1203,10 @@
      tree cl;
 {
   tree method;
+  tree type_methods = TYPE_METHODS (CLASS_TO_HANDLE_TYPE (current_class));
 
-  /* Emit deferred inline methods. */
-  for ( method = TYPE_METHODS (CLASS_TO_HANDLE_TYPE (current_class));
-	method != NULL_TREE; method = TREE_CHAIN (method))
+  /* Emit deferred inline methods. */  
+  for (method = type_methods; method != NULL_TREE; )
     {
       if (! TREE_ASM_WRITTEN (method) && DECL_SAVED_INSNS (method) != 0)
 	{
@@ -1215,10 +1218,16 @@
 	      temporary_allocation ();
 	      output_inline_function (method);
 	      permanent_allocation (1);
+            /* Scan the list again to see if there are any earlier
+                 methods to emit. */
+            method = type_methods;
+            continue;
 	    }
 	}
+      method = TREE_CHAIN (method);
     }
 
+  current_function_decl = NULL_TREE;
   make_class_data (current_class);
   register_class ();
   rest_of_decl_compilation (TYPE_NAME (current_class), (char*) 0, 1, 0);
@@ -1721,7 +1730,6 @@
   tree init_decl;
   tree t;
 
-  start_sequence ();
   init_decl = build_decl (FUNCTION_DECL, init_name, init_type);
   DECL_ASSEMBLER_NAME (init_decl) = init_name;
   TREE_STATIC (init_decl) = 1;
Only in gcc-2.95.2/gcc/java: class.c.orig
diff -u -r gcc-2.95.2-orig/gcc/java/decl.c gcc-2.95.2/gcc/java/decl.c
--- gcc-2.95.2-orig/gcc/java/decl.c	Sat Jun  5 20:18:17 1999
+++ gcc-2.95.2/gcc/java/decl.c	Sat Oct 30 19:53:18 1999
@@ -365,6 +365,11 @@
 tree soft_lookupinterfacemethod_node;
 tree soft_fmod_node;
 tree soft_exceptioninfo_call_node;
+tree soft_idiv_node;
+tree soft_irem_node;
+tree soft_ldiv_node;
+tree soft_lrem_node;
+
 
 /* Build (and pushdecl) a "promoted type" for all standard
    types shorter than int.  */
@@ -812,6 +817,26 @@
 			BUILT_IN_FMOD, "fmodf");
 #endif
     
+  soft_idiv_node
+    = builtin_function ("_Jv_divI",
+                      build_function_type (int_type_node, t),
+                      NOT_BUILT_IN, NULL_PTR);
+
+  soft_irem_node
+    = builtin_function ("_Jv_remI",
+                      build_function_type (int_type_node, t),
+                      NOT_BUILT_IN, NULL_PTR);
+
+  soft_ldiv_node
+    = builtin_function ("_Jv_divJ",
+                      build_function_type (long_type_node, t),
+                      NOT_BUILT_IN, NULL_PTR);
+
+  soft_lrem_node
+    = builtin_function ("_Jv_remJ",
+                      build_function_type (long_type_node, t),
+                      NOT_BUILT_IN, NULL_PTR);
+
   init_class_processing ();
 }
 
Only in gcc-2.95.2/gcc/java: decl.c.orig
diff -u -r gcc-2.95.2-orig/gcc/java/expr.c gcc-2.95.2/gcc/java/expr.c
--- gcc-2.95.2-orig/gcc/java/expr.c	Sat Jun  5 20:18:19 1999
+++ gcc-2.95.2/gcc/java/expr.c	Sun Oct 31 13:00:28 1999
@@ -1052,6 +1052,53 @@
     expand_assignment (local_var, res, 0, 0);
 }
 
+      
+tree
+build_java_soft_divmod (op, type, op1, op2)
+    enum tree_code op;
+    tree type, op1, op2;
+{
+  tree call = NULL;
+  tree arg1 = convert (type, op1);
+  tree arg2 = convert (type, op2);
+
+  if (type == int_type_node)
+    {   
+      switch (op)
+      {
+      case TRUNC_DIV_EXPR:
+        call = soft_idiv_node;
+        break;
+      case TRUNC_MOD_EXPR:
+        call = soft_irem_node;
+        break;
+      }
+    }
+  else if (type == long_type_node)
+    {   
+      switch (op)
+      {
+      case TRUNC_DIV_EXPR:
+        call = soft_ldiv_node;
+        break;
+      case TRUNC_MOD_EXPR:
+        call = soft_lrem_node;
+        break;
+      }
+    }
+
+  if (! call)
+    fatal ("Internal compiler error in build_java_soft_divmod");
+                
+  call = build (CALL_EXPR, type,
+              build_address_of (call),
+              tree_cons (NULL_TREE, arg1,
+                         build_tree_list (NULL_TREE, arg2)),
+              NULL_TREE);
+        
+  return call;
+}
+
 tree
 build_java_binop (op, type, arg1, arg2)
      enum tree_code op;
@@ -1100,10 +1147,11 @@
 					    integer_zero_node));
 	return fold (build (COND_EXPR, int_type_node,
 			    ifexp1, integer_negative_one_node, second_compare));
-      }
-
+      }      
+    case TRUNC_DIV_EXPR:
     case TRUNC_MOD_EXPR:
-      if (TREE_CODE (type) == REAL_TYPE)
+      if (TREE_CODE (type) == REAL_TYPE
+        && op == TRUNC_MOD_EXPR)
 	{
 	  tree call;
 	  if (type != double_type_node)
@@ -1120,6 +1168,12 @@
 	    call = convert (type, call);
 	  return call;
 	}
+      
+      if (TREE_CODE (type) == INTEGER_TYPE
+        && flag_use_divide_subroutine
+        && ! flag_syntax_only)
+      return build_java_soft_divmod (op, type, arg1, arg2);
+      
       break;
     default:  ;
     }
@@ -1881,6 +1935,7 @@
 	    DECL_INITIAL (init_decl) = init;
 	    DECL_IGNORED_P (init_decl) = 1;
 	    TREE_READONLY (init_decl) = 1;
+           TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (init_decl)) = 1;
 	    make_decl_rtl (init_decl, NULL, 1);
 	    init = init_decl;
 	  }
@@ -1895,7 +1950,6 @@
 	{
 	  tree local;
 	  tree body = BLOCK_EXPR_BODY (exp);
-	  struct rtx_def *to_return;
 	  pushlevel (2);	/* 2 and above */
 	  expand_start_bindings (0);
 	  local = BLOCK_EXPR_DECLS (exp);
@@ -1913,10 +1967,11 @@
 	      emit_queue ();
 	      body = TREE_OPERAND (body, 1);
 	    }
-	  to_return = expand_expr (body, target, tmode, modifier);
+        expand_expr (body, const0_rtx, VOIDmode, 0);
+        emit_queue ();
 	  poplevel (1, 1, 0);
 	  expand_end_bindings (getdecls (), 1, 0);
-	  return to_return;
+        return const0_rtx;
 	}
       break;
 
@@ -2578,6 +2633,10 @@
 
    We fix this by using save_expr.  This forces the sub-operand to be
    copied into a fresh virtual register,
+
+   For method invocation, we modify the arguments so that a
+   left-to-right order evaluation is performed. Saved expressions
+   will, in CALL_EXPR order, be reused when the call will be expanded.
 */
 
 tree
@@ -2593,19 +2652,30 @@
     }
   else if (TREE_CODE (node) == CALL_EXPR || TREE_CODE (node) == NEW_CLASS_EXPR)
     {
-      tree last_side_effecting_arg = NULL_TREE;
-      tree arg = TREE_OPERAND (node, 1);
-      for (; arg != NULL_TREE; arg = TREE_CHAIN (arg))
+      tree arg, cmp;
+
+      if (!TREE_OPERAND (node, 1))
+       return node;
+
+      /* This reverses the evaluation order. This is a desired effect. */
+      for (cmp = NULL_TREE, arg = TREE_OPERAND (node, 1); 
+          arg; arg = TREE_CHAIN (arg))
 	{
-	  if (TREE_SIDE_EFFECTS (TREE_VALUE (arg)))
-	    last_side_effecting_arg = arg;
+         tree saved = save_expr (TREE_VALUE (arg));
+         cmp = (cmp == NULL_TREE ? saved :
+                build (COMPOUND_EXPR, void_type_node, cmp, saved));
+         TREE_VALUE (arg) = saved;
 	}
-      arg = TREE_OPERAND (node, 1);
-      for (; arg != NULL_TREE;  arg = TREE_CHAIN (arg))
+      
+      if (cmp && TREE_CODE (cmp) == COMPOUND_EXPR)
+       TREE_SIDE_EFFECTS (cmp) = 1;
+
+      if (cmp)
 	{
-	  if (arg == last_side_effecting_arg)
-	    break;
-	  TREE_VALUE (arg) = save_expr (TREE_VALUE (arg)); 
+         cmp = save_expr (build (COMPOUND_EXPR, TREE_TYPE (node), cmp, node));
+         CAN_COMPLETE_NORMALLY (cmp) = CAN_COMPLETE_NORMALLY (node);
+         TREE_SIDE_EFFECTS (cmp) = 1;
+         node = cmp;
 	}
     }
   return node;
Only in gcc-2.95.2/gcc/java: expr.c.orig
Only in gcc-2.95.2/gcc/java: expr.c.rej
diff -u -r gcc-2.95.2-orig/gcc/java/gjavah.c gcc-2.95.2/gcc/java/gjavah.c
--- gcc-2.95.2-orig/gcc/java/gjavah.c	Fri May 14 00:05:02 1999
+++ gcc-2.95.2/gcc/java/gjavah.c	Sat Oct 30 15:06:45 1999
@@ -33,6 +33,8 @@
 #include "java-tree.h"
 #include "java-opcodes.h"
 
+#include "version.c"
+
 /* The output file.  */
 FILE *out = NULL;
 
@@ -88,6 +90,11 @@
 #define METHOD_IS_FINAL(Class, Method) \
    (((Class) & ACC_FINAL) || ((Method) & (ACC_FINAL | ACC_PRIVATE)))
 
+/* Pass this macro the flags for a method.  It will return true if the
+   method is native.  */
+#define METHOD_IS_NATIVE(Method) \
+   ((Method) & ACC_NATIVE)
+
 /* We keep a linked list of all method names we have seen.  This lets
    us determine if a method name and a field name are in conflict.  */
 struct method_name
@@ -100,11 +107,15 @@
 /* List of method names we've seen.  */
 static struct method_name *method_name_list;
 
-static void print_field_info PROTO ((FILE *, JCF*, int, int, JCF_u2));
-static void print_method_info PROTO ((FILE *, JCF*, int, int, JCF_u2));
+static void print_field_info PROTO ((FILE*, JCF*, int, int, JCF_u2));
+static void print_mangled_classname PROTO ((FILE*, JCF*, const char*, int));
+static int  print_cxx_classname PROTO ((FILE*, const char*, JCF*, int));
+static void print_method_info PROTO ((FILE*, JCF*, int, int, JCF_u2));
 static void print_c_decl PROTO ((FILE*, JCF*, int, int, int, const char *));
-static void decompile_method PROTO ((FILE *, JCF *, int));
-static void add_class_decl PROTO ((FILE *, JCF *, JCF_u2));
+static void print_stub PROTO ((FILE*, JCF*, int, int, int, const char *));
+static void print_full_cxx_name PROTO ((FILE*, JCF*, int, int, int, const char *));
+static void decompile_method PROTO ((FILE*, JCF*, int));
+static void add_class_decl PROTO ((FILE*, JCF*, JCF_u2));
 
 static int java_float_finite PROTO ((jfloat));
 static int java_double_finite PROTO ((jdouble));
@@ -130,13 +141,13 @@
 #define HANDLE_END_FIELD()						      \
   if (field_pass)							      \
     {									      \
-      if (out)								      \
+      if (out && ! stubs)                                                    \
 	print_field_info (out, jcf, current_field_name,			      \
 			  current_field_signature,			      \
 			  current_field_flags);				      \
     }									      \
   else									      \
-    add_class_decl (out, jcf, current_field_signature);
+    if (! stubs) add_class_decl (out, jcf, current_field_signature);
 
 #define HANDLE_CONSTANTVALUE(VALUEINDEX) current_field_value = (VALUEINDEX)
 
@@ -151,14 +162,14 @@
         print_method_info (out, jcf, NAME, SIGNATURE, ACCESS_FLAGS);	      \
     }									      \
   else									      \
-    add_class_decl (out, jcf, SIGNATURE);
+    if (! stubs) add_class_decl (out, jcf, SIGNATURE);
 
 #define HANDLE_CODE_ATTRIBUTE(MAX_STACK, MAX_LOCALS, CODE_LENGTH) \
   if (out && method_declared) decompile_method (out, jcf, CODE_LENGTH);
 
 static int decompiled = 0;
 #define HANDLE_END_METHOD() \
-  if (out && method_printed) fputs (decompiled ? "\n" : ";\n", out);
+  if (out && method_printed) fputs (decompiled || stubs ? "\n" : ";\n", out);
 
 #include "jcf-reader.c"
 
@@ -562,24 +573,36 @@
 	return;
     }
 
-  method_printed = 1;
-  generate_access (stream, flags);
-
-  fputs ("  ", out);
-  if ((flags & ACC_STATIC))
-    fputs ("static ", out);
-  else if (! METHOD_IS_FINAL (jcf->access_flags, flags))
+  if (! stubs)
     {
-      /* Don't print `virtual' if we have a constructor.  */
-      if (! is_init)
-	fputs ("virtual ", out);
-    }
-  print_c_decl (out, jcf, name_index, sig_index, is_init, override);
+      method_printed = 1;
 
-  if ((flags & ACC_ABSTRACT))
-    fputs (" = 0", out);
+      generate_access (stream, flags);
+      
+      fputs ("  ", out);
+      if ((flags & ACC_STATIC))
+       fputs ("static ", out);
+      else if (! METHOD_IS_FINAL (jcf->access_flags, flags))
+       {
+         /* Don't print `virtual' if we have a constructor.  */
+         if (! is_init)
+           fputs ("virtual ", out);
+       }
+      print_c_decl (out, jcf, name_index, sig_index, is_init, override);
+      
+      if ((flags & ACC_ABSTRACT))
+       fputs (" = 0", out);
+      else
+       method_declared = 1;
+    }
   else
-    method_declared = 1;
+    {
+      if (METHOD_IS_NATIVE(flags)) 
+       {
+         method_printed = 1;
+         print_stub (out, jcf, name_index, sig_index, is_init, override);
+       }
+    }
 }
 
 /* Try to decompile a method body.  Right now we just try to handle a
@@ -653,10 +676,13 @@
      int *need_space;
 {
   const char *ctype;
+  int array_depth = 0;
 
   switch (signature[0])
     {
     case '[':
+      /* More spaghetti.  */
+    array_loop:
       for (signature++; (signature < limit
 			 && *signature >= '0'
 			 && *signature <= '9'); signature++)
@@ -671,13 +697,17 @@
 	case 'S': ctype = "jshortArray";  goto printit;
 	case 'J': ctype = "jlongArray";  goto printit;
 	case 'Z': ctype = "jbooleanArray";  goto printit;
-	case '[': ctype = "jobjectArray"; goto printit;
+       case '[':
+         /* We have a nested array.  */
+         ++array_depth;
+         fputs ("JArray<", stream);
+         goto array_loop;
+
 	case 'L':
-	  /* We have to generate a reference to JArray here,
-	     so that our output matches what the compiler
-	     does.  */
+         /* We have to generate a reference to JArray here, so that
+            our output matches what the compiler does.  */
 	  ++signature;
-	  fputs ("JArray<", stream);
+         fputs ("JArray<", stream);
 	  while (signature < limit && *signature != ';')
 	    {
 	      int ch = UTF8_GET (signature, limit);
@@ -711,6 +741,8 @@
     case 'Z': ctype = "jboolean";  goto printit;
     case 'V': ctype = "void";  goto printit;
     case 'L':
+      /* Print a leading "::" so we look in the right namespace.  */
+      fputs ("::", stream);
       ++signature;
       while (*signature && *signature != ';')
 	{
@@ -737,6 +769,9 @@
       break;
     }
 
+  while (array_depth-- > 0)
+    fputs ("> *", stream);
+
   return signature;
 }
 
@@ -791,40 +826,121 @@
       /* Now print the name of the thing.  */
       if (need_space)
 	fputs (" ", stream);
-      if (name_override)
-	fputs (name_override, stream);
-      else if (name_index)
-	{
-	  /* Declare constructors specially.  */
-	  if (is_init)
-	    print_base_classname (stream, jcf, jcf->this_class);
-	  else
-	    print_name (stream, jcf, name_index);
-	}
+      print_full_cxx_name (stream, jcf, name_index, 
+                          signature_index, is_init, name_override);
+    }
+}
 
-      if (is_method)
+// Print the unqualified method name followed by the signature.
+static void
+DEFUN(print_full_cxx_name, (stream, jcf, name_index, signature_index, is_init, name_override),
+      FILE* stream AND JCF* jcf
+      AND int name_index AND int signature_index AND int is_init 
+      AND const char *name_override)
+{
+  int length = JPOOL_UTF_LENGTH (jcf, signature_index);
+  unsigned char *str0 = JPOOL_UTF_DATA (jcf, signature_index);
+  register  unsigned char *str = str0;
+  unsigned char *limit = str + length;
+  int need_space = 0;
+  int is_method = str[0] == '(';
+  unsigned char *next;
+
+  if (name_override)
+    fputs (name_override, stream);
+  else if (name_index)
+    {
+      /* Declare constructors specially.  */
+      if (is_init)
+       print_base_classname (stream, jcf, jcf->this_class);
+      else
+       print_name (stream, jcf, name_index);
+    }
+  
+  if (is_method)
+    {
+      /* Have a method or a constructor.  Print signature pieces
+        until done.  */
+      fputs (" (", stream);
+      str = str0 + 1;
+      while (str < limit && *str != ')')
 	{
-	  /* Have a method or a constructor.  Print signature pieces
-	     until done.  */
-	  fputs (" (", stream);
-	  str = str0 + 1;
-	  while (str < limit && *str != ')')
+         next = decode_signature_piece (stream, str, limit, &need_space);
+         if (! next)
 	    {
-	      next = decode_signature_piece (stream, str, limit, &need_space);
-	      if (! next)
-		{
-		  fprintf (stderr, "unparseable signature: `%s'\n", str0);
-		  found_error = 1;
-		  return;
-		}
+             fprintf (stderr, "unparseable signature: `%s'\n", str0);
+             found_error = 1;
+             return;
+           }
+         
+         if (next < limit && *next != ')')
+           fputs (", ", stream);
+         str = next;
+       }
+      
+      fputs (")", stream);
+    }
+}
+      
+static void
+DEFUN(print_stub, (stream, jcf, name_index, signature_index, is_init,
+                    name_override),
+      FILE* stream AND JCF* jcf
+      AND int name_index AND int signature_index
+      AND int is_init AND const char *name_override)
+{
+  if (JPOOL_TAG (jcf, signature_index) != CONSTANT_Utf8)
+    {
+      fprintf (stream, "<not a UTF8 constant>");
+      found_error = 1;
+    }
+  else
+    {
+      int length = JPOOL_UTF_LENGTH (jcf, signature_index);
+      unsigned char *str0 = JPOOL_UTF_DATA (jcf, signature_index);
+      register  unsigned char *str = str0;
+      unsigned char *limit = str + length;
+      int need_space = 0;
+      int is_method = str[0] == '(';
+      unsigned char *next;
 
-	      if (next < limit && *next != ')')
-		fputs (", ", stream);
-	      str = next;
+      /* If printing a method, skip to the return signature and print
+        that first.  However, there is no return value if this is a
+        constructor.  */
+      if (is_method && ! is_init)
+       {
+         while (str < limit)
+           {
+             int ch = *str++;
+             if (ch == ')')
+               break;
 	    }
+       }
 
-	  fputs (")", stream);
+      /* If printing a field or an ordinary method, then print the
+        "return value" now.  */
+      if (! is_method || ! is_init)
+       {
+         next = decode_signature_piece (stream, str, limit, &need_space);
+         if (! next)
+           {
+             fprintf (stderr, "unparseable signature: `%s'\n", str0);
+             found_error = 1;
+             return;
+           }
 	}
+
+      /* Now print the name of the thing.  */
+      print_cxx_classname (stream, "\n", jcf, jcf->this_class);
+      fputs ("::", stream);
+      print_full_cxx_name (stream, jcf, name_index, 
+                          signature_index, is_init, name_override);
+      fputs ("\n{\n  JvFail (\"", stream);
+      print_cxx_classname (stream, "", jcf, jcf->this_class);
+      fputs ("::", stream);
+      print_full_cxx_name (stream, jcf, name_index, 
+                          signature_index, is_init, name_override);
+      fputs (" not implemented\");\n}\n\n", stream);
     }
 }
 
@@ -846,7 +962,7 @@
 static int
 print_cxx_classname (stream, prefix, jcf, index)
      FILE *stream;
-     char *prefix;
+     const char *prefix;
      JCF *jcf;
      int index;
 {
@@ -865,6 +981,10 @@
     return 0;
 
   fputs (prefix, stream);
+
+  /* Print a leading "::" so we look in the right namespace.  */
+  fputs ("::", stream);
+
   while (s < limit)
     {
       c = UTF8_GET (s, limit);
@@ -1071,7 +1191,10 @@
 	{
 	  for (i = 0; i < depth; ++i)
 	    fputc (' ', out);
-	  fputs ("};\n", out);
+         fputs ("}\n", out);
+         /* Only print a `;' when printing a class.  C++ is evil.  */
+         if (name->is_class)
+           fputs (";", out);
 	}
 
       free (name->name);
@@ -1103,7 +1226,7 @@
       /* If we see an array, then we include the array header.  */
       if (s[i] == '[')
 	{
-	  print_include (out, "java-array", -1);
+         print_include (out, "gcj/array", -1);
 	  continue;
 	}
 
@@ -1204,30 +1327,49 @@
   jcf_parse_class (jcf);
 
   if (written_class_count++ == 0 && out)
-    fputs ("// DO NOT EDIT THIS FILE - it is machine generated -*- c++ -*-\n\n",
-	   out);
+    if (! stubs)
+      fputs ("// DO NOT EDIT THIS FILE - it is machine generated -*- c++ -*-\n\n",
+            out);
+    else
+      {
+       fputs ("// This file was created by `gcjh -stubs'.  It is -*- c++ -*-.
+//
+// This file is intended to give you a head start on implementing native 
+// methods using CNI.  
+// Be aware: running `gcjh -stubs' once more for this class may overwrite any 
+// edits you have made to this file.\n\n", out);
+      }
 
   if (out)
     {
-      print_mangled_classname (out, jcf, "#ifndef __", jcf->this_class);
-      fprintf (out, "__\n");
-
-      print_mangled_classname (out, jcf, "#define __", jcf->this_class);
-      fprintf (out, "__\n\n");
-
-      /* We do this to ensure that inline methods won't be `outlined'
-	 by g++.  This works as long as method and fields are not
-	 added by the user.  */
-      fprintf (out, "#pragma interface\n");
-    }
-
-  if (jcf->super_class && out)
-    {
-      int super_length;
-      unsigned char *supername = super_class_name (jcf, &super_length);
-
-      fputs ("\n", out);
-      print_include (out, supername, super_length);
+      if (! stubs)
+       {
+         print_mangled_classname (out, jcf, "#ifndef __", jcf->this_class);
+         fprintf (out, "__\n");
+         
+         print_mangled_classname (out, jcf, "#define __", jcf->this_class);
+         fprintf (out, "__\n\n");
+         
+         /* We do this to ensure that inline methods won't be `outlined'
+            by g++.  This works as long as method and fields are not
+            added by the user.  */
+         fprintf (out, "#pragma interface\n");
+         
+         if (jcf->super_class)
+           {
+             int super_length;
+             unsigned char *supername = super_class_name (jcf, &super_length);
+             
+             fputs ("\n", out);
+             print_include (out, supername, super_length);
+           }
+       }
+      else
+       {
+         /* Strip off the ".class" portion of the name when printing
+            the include file name.  */
+         print_include (out, jcf->classname, strlen (jcf->classname) - 6);
+       }
     }
 
   /* We want to parse the methods first.  But we need to find where
@@ -1246,31 +1388,37 @@
   if (out)
     {
       fputs ("\n", out);
-      print_class_decls (out, jcf, jcf->this_class);
+
+      if (! stubs)
+       print_class_decls (out, jcf, jcf->this_class);
 
       for (i = 0; i < prepend_count; ++i)
 	fprintf (out, "%s\n", prepend_specs[i]);
       if (prepend_count > 0)
 	fputc ('\n', out);
-    }
-
-  if (out && ! print_cxx_classname (out, "class ", jcf, jcf->this_class))
-    {
-      fprintf (stderr, "class is of array type\n");
-      found_error = 1;
-      return;
-    }
-  if (out && jcf->super_class)
-    {
-      if (! print_cxx_classname (out, " : public ", jcf, jcf->super_class))
+      
+      if (! stubs)
 	{
-	  fprintf (stderr, "base class is of array type\n");
-	  found_error = 1;
-	  return;
+         if (! print_cxx_classname (out, "class ", jcf, jcf->this_class))
+           {
+             fprintf (stderr, "class is of array type\n");
+             found_error = 1;
+             return;
+           }
+         if (jcf->super_class)
+           {
+             if (! print_cxx_classname (out, " : public ", 
+                                        jcf, jcf->super_class))
+               {
+                 fprintf (stderr, "base class is of array type\n");
+                 found_error = 1;
+                 return;
+               }
+           }
+
+         fputs ("\n{\n", out);
 	}
     }
-  if (out)
-    fputs ("\n{\n", out);
 
   /* Now go back for second pass over methods and fields.  */
   JCF_SEEK (jcf, method_start);
@@ -1297,15 +1445,20 @@
       for (i = 0; i < add_count; ++i)
 	fprintf (out, "  %s\n", add_specs[i]);
 
-      fputs ("};\n", out);
+      if (! stubs)
+       fputs ("};\n", out);
 
       if (append_count > 0)
 	fputc ('\n', out);
       for (i = 0; i < append_count; ++i)
 	fprintf (out, "%s\n", append_specs[i]);
 
-      print_mangled_classname (out, jcf, "\n#endif /* __", jcf->this_class);
-      fprintf (out, "__ */\n");
+      if (!stubs)
+       {
+         print_mangled_classname (out, jcf, 
+                                  "\n#endif /* __", jcf->this_class);
+         fprintf (out, "__ */\n");
+       }
     }
 }
 
@@ -1327,6 +1480,7 @@
   printf ("  -d DIRECTORY            Set output directory name\n");
   printf ("  --help                  Print this help, then exit\n");
   printf ("  -o FILE                 Set output file name\n");
+  printf ("  -stubs                  Generate a C++ implementation stub file\n");
   printf ("  -td DIRECTORY           Set temporary directory name\n");
   printf ("  -v, --verbose           Print extra information while running\n");
   printf ("  --version               Print version number, then exit\n");
@@ -1346,8 +1500,8 @@
 version ()
 {
   /* FIXME: use version.c?  */
-  printf ("gcjh (GNU gcc) 0.0\n\n");
-  printf ("Copyright (C) 1998 Free Software Foundation, Inc.\n");
+  printf ("gcjh (%s)\n\n", version_string);
+  printf ("Copyright (C) 1998, 1999 Free Software Foundation, Inc.\n");
   printf ("This is free software; see the source for copying conditions.  There is NO\n");
   printf ("warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n");
   exit (0);
@@ -1548,7 +1702,7 @@
 	{
 	  int dir_len = strlen (output_directory);
 	  int i, classname_length = strlen (classname);
-	  current_output_file = (char*) ALLOC (dir_len + classname_length + 4);
+         current_output_file = (char*) ALLOC (dir_len + classname_length + 5);
 	  strcpy (current_output_file, output_directory);
 	  if (dir_len > 0 && output_directory[dir_len-1] != '/')
 	    current_output_file[dir_len++] = '/';
@@ -1574,7 +1728,8 @@
 		  jcf_dependency_set_dep_file (current_output_file);
 		}
 	    }
-	  strcpy (current_output_file + dir_len, ".h");
+         strcpy (current_output_file + dir_len, 
+                 stubs ? ".cc" : ".h");
 	  jcf_dependency_set_target (current_output_file);
 	  if (! suppress_output)
 	    {
@@ -1601,10 +1756,9 @@
 
 /* TODO:
 
- * Do whatever the javah -stubs flag does.
-
  * Emit "structure forward declarations" when needed.
 
  * Generate C headers, like javah
 
  */
+
Only in gcc-2.95.2/gcc/java: gjavah.c.orig
Only in gcc-2.95.2/gcc/java: gjavah.c.rej
diff -u -r gcc-2.95.2-orig/gcc/java/java-tree.h gcc-2.95.2/gcc/java/java-tree.h
--- gcc-2.95.2-orig/gcc/java/java-tree.h	Fri May 14 02:33:28 1999
+++ gcc-2.95.2/gcc/java/java-tree.h	Sat Oct 30 19:45:50 1999
@@ -141,6 +141,9 @@
 extern int flag_not_overriding;
 extern int flag_static_local_jdk1_1;
 
+/* When non zero, call a library routine to do integer divisions. */
+extern int flag_use_divide_subroutine;
+
 /* The Java .class file that provides main_class;  the main input file. */
 extern struct JCF *current_jcf;
 
@@ -283,6 +286,10 @@
 extern tree soft_lookupinterfacemethod_node;
 extern tree soft_fmod_node;
 extern tree soft_exceptioninfo_call_node;
+extern tree soft_idiv_node;
+extern tree soft_irem_node;
+extern tree soft_ldiv_node;
+extern tree soft_lrem_node;
 
 extern tree access_flags_type_node;
 
@@ -544,6 +551,7 @@
 extern tree build_field_ref PROTO ((tree, tree, tree));
 extern void pushdecl_force_head PROTO ((tree));
 extern tree build_java_binop PROTO ((enum tree_code, tree, tree, tree));
+extern tree build_java_soft_divmod PROTO ((enum tree_code, tree, tree, tree));
 extern tree binary_numeric_promotion PROTO ((tree, tree, tree *, tree *));
 extern tree build_java_arrayaccess PROTO ((tree, tree, tree));
 extern tree build_newarray PROTO ((int, tree));
Only in gcc-2.95.2/gcc/java: java-tree.h.orig
diff -u -r gcc-2.95.2-orig/gcc/java/jcf-parse.c gcc-2.95.2/gcc/java/jcf-parse.c
--- gcc-2.95.2-orig/gcc/java/jcf-parse.c	Thu Apr 22 01:49:42 1999
+++ gcc-2.95.2/gcc/java/jcf-parse.c	Sat Oct 30 14:02:11 1999
@@ -748,6 +748,8 @@
   /* Mark the file as parsed */
   HAS_BEEN_ALREADY_PARSED_P (file) = 1;
 
+  jcf_dependency_add_file (input_filename, 0);
+
   lang_init_source (1);		    /* Error msgs have no method prototypes */
 
   java_init_lex ();		    /* Initialize the parser */
diff -u -r gcc-2.95.2-orig/gcc/java/jcf-write.c gcc-2.95.2/gcc/java/jcf-write.c
--- gcc-2.95.2-orig/gcc/java/jcf-write.c	Sun Mar 21 18:09:14 1999
+++ gcc-2.95.2/gcc/java/jcf-write.c	Sun Oct 31 18:54:12 1999
@@ -186,6 +186,9 @@
   struct jcf_block *label;
 };
 
+#define RELOCATION_VALUE_0 ((HOST_WIDE_INT)0)
+#define RELOCATION_VALUE_1 ((HOST_WIDE_INT)1)
+
 /* State for single catch clause. */
 
 struct jcf_handler
@@ -299,8 +302,14 @@
 static void init_jcf_method PROTO ((struct jcf_partial *, tree));
 static void release_jcf_state PROTO ((struct jcf_partial *));
 static struct chunk * generate_classfile PROTO ((tree, struct jcf_partial *));
+static void emit_iinc PROTO ((tree, HOST_WIDE_INT, struct jcf_partial *));
+static void emit_reloc PROTO ((HOST_WIDE_INT, int, struct jcf_block *, 
+                               struct jcf_partial *));
+static void push_constant1 PROTO ((HOST_WIDE_INT, struct jcf_partial *));
+static void push_constant2 PROTO ((HOST_WIDE_INT, struct jcf_partial *));
 
-
+static void push_long_const PROTO ((HOST_WIDE_INT, HOST_WIDE_INT, 
+                                   struct jcf_partial *));
 /* Utility macros for appending (big-endian) data to a buffer.
    We assume a local variable 'ptr' points into where we want to
    write next, and we assume enoygh space has been allocated. */
@@ -326,7 +335,13 @@
 #define PUT4(X)  (PUT2((X) >> 16), PUT2((X) & 0xFFFF))
 #define PUTN(P, N)  (CHECK_PUT(ptr, state, N), memcpy(ptr, P, N), ptr += (N))
 
-
+/* There are some cases below where CHECK_PUT is guaranteed to fail.
+   Use the following macros in those specific cases.  */
+#define UNSAFE_PUT1(X)  (*ptr++ = (X))
+#define UNSAFE_PUT2(X)  (UNSAFE_PUT1((X) >> 8), UNSAFE_PUT1((X) & 0xFF))
+#define UNSAFE_PUT4(X)  (UNSAFE_PUT2((X) >> 16), UNSAFE_PUT2((X) & 0xFFFF))
+#define UNSAFE_PUTN(P, N)  (memcpy(ptr, P, N), ptr += (N))
+
 /* Allocate a new chunk on obstack WORK, and link it in after LAST.
    Set the data and size fields to DATA and SIZE, respectively.
    However, if DATA is NULL and SIZE>0, allocate a buffer as well. */
@@ -665,7 +680,7 @@
 
 static void
 push_constant1 (index, state)
-     int index;
+     HOST_WIDE_INT index;
      struct jcf_partial *state;
 {
   RESERVE (3);
@@ -686,7 +701,7 @@
 
 static void
 push_constant2 (index, state)
-     int index;
+     HOST_WIDE_INT index;
      struct jcf_partial *state;
 {
   RESERVE (3);
@@ -717,7 +732,8 @@
     }
   else
     {
-      i = find_constant1 (&state->cpool, CONSTANT_Integer, i & 0xFFFFFFFF);
+      i = find_constant1 (&state->cpool, CONSTANT_Integer, 
+                         (jword)(i & 0xFFFFFFFF));
       push_constant1 (i, state);
     }
 }
@@ -730,7 +746,7 @@
   HOST_WIDE_INT w1, w2;
   lshift_double (lo, hi, -32, 64, &w1, &w2, 1);
   return find_constant2 (&state->cpool, CONSTANT_Long,
-			 w1 & 0xFFFFFFFF, lo & 0xFFFFFFFF);
+                        (jword)(w1 & 0xFFFFFFFF), (jword)(lo & 0xFFFFFFFF));
 }
 
 /* Find or allocate a constant pool entry for the given VALUE.
@@ -745,7 +761,7 @@
     {
       if (TYPE_PRECISION (TREE_TYPE (value)) <= 32)
 	return find_constant1 (&state->cpool, CONSTANT_Integer,
-			       TREE_INT_CST_LOW (value) & 0xFFFFFFFF);
+                              (jword)(TREE_INT_CST_LOW (value) & 0xFFFFFFFF));
       else
 	return find_constant_wide (TREE_INT_CST_LOW (value),
 				   TREE_INT_CST_HIGH (value), state);
@@ -756,14 +772,17 @@
       if (TYPE_PRECISION (TREE_TYPE (value)) == 32)
 	{
 	  words[0] = etarsingle (TREE_REAL_CST (value)) & 0xFFFFFFFF;
-	  return find_constant1 (&state->cpool, CONSTANT_Float, words[0]);
+         return find_constant1 (&state->cpool, CONSTANT_Float, 
+                                (jword)words[0]);
 	}
       else
 	{
 	  etardouble (TREE_REAL_CST (value), words);
 	  return find_constant2 (&state->cpool, CONSTANT_Double,
-				 words[1-FLOAT_WORDS_BIG_ENDIAN] & 0xFFFFFFFF,
-				 words[FLOAT_WORDS_BIG_ENDIAN] & 0xFFFFFFFF);
+                                (jword)(words[1-FLOAT_WORDS_BIG_ENDIAN] & 
+                                        0xFFFFFFFF),
+                                (jword)(words[FLOAT_WORDS_BIG_ENDIAN] & 
+                                        0xFFFFFFFF));
 	}
     }
   else if (TREE_CODE (value) == STRING_CST)
@@ -906,7 +925,7 @@
 static void
 emit_iinc (var, value, state)
      tree var;
-     int value;
+     HOST_WIDE_INT value;
      struct jcf_partial *state;
 {
   int slot = DECL_LOCAL_INDEX (var);
@@ -1012,7 +1031,7 @@
      struct jcf_block *label;
      struct jcf_partial *state;
 {
-  emit_reloc (0, BLOCK_START_RELOC, label, state);
+  emit_reloc (RELOCATION_VALUE_0, BLOCK_START_RELOC, label, state);
 }
 
 /* Similar to emit_switch_reloc,
@@ -1041,8 +1060,8 @@
      struct jcf_partial *state;
 {
   OP1 (opcode);
-  // value is 1 byte from reloc back to start of instruction.
-  emit_reloc (1, - inv_opcode, target, state);
+  /* value is 1 byte from reloc back to start of instruction. */
+  emit_reloc (RELOCATION_VALUE_1, - inv_opcode, target, state);
 }
 
 static void
@@ -1051,8 +1070,8 @@
      struct jcf_partial *state;
 {
   OP1 (OPCODE_goto);
- // Value is 1 byte from reloc back to start of instruction.
-  emit_reloc (1, OPCODE_goto_w, target, state);
+  /* Value is 1 byte from reloc back to start of instruction.  */
+  emit_reloc (RELOCATION_VALUE_1, OPCODE_goto_w, target, state);
 }
 
 static void
@@ -1061,8 +1080,8 @@
      struct jcf_partial *state;
 {
   OP1 (OPCODE_jsr);
- // Value is 1 byte from reloc back to start of instruction.
-  emit_reloc (1, OPCODE_jsr_w, target, state);
+  /* Value is 1 byte from reloc back to start of instruction.  */
+  emit_reloc (RELOCATION_VALUE_1, OPCODE_jsr_w, target, state);
 }
 
 /* Generate code to evaluate EXP.  If the result is true,
@@ -1690,7 +1709,8 @@
 		int index = 0;
 		RESERVE (13 + 4 * (sw_state.max_case - sw_state.min_case + 1));
 		OP1 (OPCODE_tableswitch);
-		emit_reloc (0, SWITCH_ALIGN_RELOC, NULL, state);
+               emit_reloc (RELOCATION_VALUE_0, 
+                           SWITCH_ALIGN_RELOC, NULL, state);
 		emit_switch_reloc (sw_state.default_label, state);
 		OP4 (sw_state.min_case);
 		OP4 (sw_state.max_case);
@@ -1713,7 +1733,8 @@
 	      { /* Use lookupswitch. */
 		RESERVE(9 + 8 * sw_state.num_cases);
 		OP1 (OPCODE_lookupswitch);
-		emit_reloc (0, SWITCH_ALIGN_RELOC, NULL, state);
+               emit_reloc (RELOCATION_VALUE_0,
+                           SWITCH_ALIGN_RELOC, NULL, state);
 		emit_switch_reloc (sw_state.default_label, state);
 		OP4 (sw_state.num_cases);
 		for (i = 0;  i < sw_state.num_cases;  i++)
@@ -1886,7 +1907,7 @@
       if (size == 1)
 	push_int_const (value, state);
       else
-	push_long_const (value, value >= 0 ? 0 : -1, state);
+       push_long_const (value, (HOST_WIDE_INT)(value >= 0 ? 0 : -1), state);
       NOTE_PUSH (size);
       emit_binop (OPCODE_iadd + adjust_typed_op (type, 3), type, state);
       if (target != IGNORE_TARGET && ! post_op)
@@ -2775,7 +2796,7 @@
 	}
       fields_count++;
     }
-  ptr = fields_count_ptr;  PUT2 (fields_count);
+  ptr = fields_count_ptr;  UNSAFE_PUT2 (fields_count);
 
   ptr = methods_count_ptr = append_chunk (NULL, 2, state);
   PUT2 (0);
@@ -2841,10 +2862,10 @@
 	      code_attributes_count++;
 	      i += 8 + 10 * state->lvar_count;
 	    }
-	  PUT4 (i); /* attribute_length */
-	  PUT2 (state->code_SP_max);  /* max_stack */
-	  PUT2 (localvar_max);  /* max_locals */
-	  PUT4 (state->code_length);
+         UNSAFE_PUT4 (i); /* attribute_length */
+         UNSAFE_PUT2 (state->code_SP_max);  /* max_stack */
+         UNSAFE_PUT2 (localvar_max);  /* max_locals */
+         UNSAFE_PUT4 (state->code_length);
 
 	  /* Emit the exception table. */
 	  ptr = append_chunk (NULL, 2 + 8 * state->num_handlers, state);
@@ -2934,7 +2955,7 @@
       methods_count++;
       current_function_decl = save_function;
     }
-  ptr = methods_count_ptr;  PUT2 (methods_count);
+  ptr = methods_count_ptr;  UNSAFE_PUT2 (methods_count);
 
   source_file = DECL_SOURCE_FILE (TYPE_NAME (clas));
   for (ptr = source_file;  ;  ptr++)
Only in gcc-2.95.2/gcc/java: jcf-write.c.orig
Only in gcc-2.95.2/gcc/java: jcf-write.c.rej
diff -u -r gcc-2.95.2-orig/gcc/java/jvgenmain.c gcc-2.95.2/gcc/java/jvgenmain.c
--- gcc-2.95.2-orig/gcc/java/jvgenmain.c	Wed Aug 11 17:08:32 1999
+++ gcc-2.95.2/gcc/java/jvgenmain.c	Sat Oct 30 14:02:48 1999
@@ -1,5 +1,5 @@
 /* Program to generate "main" a Java(TM) class containing a main method.
-   Copyright (C) 1998 Free Software Foundation, Inc.
+   Copyright (C) 1998, 1999 Free Software Foundation, Inc.
 
 This file is part of GNU CC.
 
@@ -79,19 +79,37 @@
 		  (void (*) ()) OBSTACK_CHUNK_FREE);
 }
 
+static void
+usage (const char *name)
+{
+  fprintf (stderr, "Usage: %s [OPTIONS]... CLASSNAME [OUTFILE]\n", name);
+  exit (1);
+}
+
 int
 main (int argc, const char **argv)
 {
   const char *classname;
   FILE *stream;
   char *mangled_classname;
+  int i, last_arg;
 
-  if (argc < 2 || argc > 3)
+  if (argc < 2)
+    usage (argv[0]);  
+  for (i = 1; i < argc; ++i)
     {
-      fprintf (stderr, "Usage: %s CLASSNAME [OUTFILE]\n", argv[0]);
-      exit(-1);
+      if (! strncmp (argv[i], "-D", 2))
+       {
+         /* Handled later.  */
+       }
+      else
+       break;    
     }
 
+  if (i < argc - 2 || i == argc)
+    usage (argv[0]);
+  last_arg = i;
+
   classname = argv[1];
 
   gcc_obstack_init (&name_obstack);
@@ -99,23 +117,46 @@
   obstack_1grow (&name_obstack, '\0');
   mangled_classname = obstack_finish (&name_obstack);
 
-  if (argc > 2 && strcmp (argv[2], "-") != 0)
+  if (i < argc - 1 && strcmp (argv[i + 1], "-") != 0)
     {
-      const char *outfile = argv[2];
+      const char *outfile = argv[i + 1];
       stream = fopen (outfile, "w");
       if (stream == NULL)
 	{
 	  fprintf (stderr, "%s: Cannot open output file: %s\n",
 		   argv[0], outfile);
-	  exit (-1);
+	  exit (1);
 	}
     }
   else
     stream = stdout;
+    
+  /* At this point every element of ARGV from 1 to LAST_ARG is a `-D'
+     option.  Process them appropriately.  */
+  fprintf (stream, "extern const char **_Jv_Compiler_Properties;\n");
+  fprintf (stream, "static const char *props[] =\n{\n");
+  for (i = 1; i < last_arg; ++i)
+    {
+      const char *p;
+      fprintf (stream, "  \"");
+      for (p = &argv[i][2]; *p; ++p)
+       {
+         if (! isascii (*p))
+           fprintf (stream, "\\%o", *p);
+         else if (*p == '\\' || *p == '"')
+           fprintf (stream, "\\%c", *p);
+         else
+           putc (*p, stream);
+       }
+      fprintf (stream, "\",\n");
+    }
+  fprintf (stream, "  0\n};\n\n");
+  
   fprintf (stream, "extern struct Class %s%s;\n",
 	   class_mangling_prefix, mangled_classname);
   fprintf (stream, "int main (int argc, const char **argv)\n");
   fprintf (stream, "{\n");
+  fprintf (stream, "   _Jv_Compiler_Properties = props;\n");
   fprintf (stream, "   JvRunMain (&%s%s, argc, argv);\n",
 	   class_mangling_prefix, mangled_classname);
   fprintf (stream, "}\n");
@@ -123,7 +164,7 @@
     {
       fprintf (stderr, "%s: Failed to close output file %s\n",
 	       argv[0], argv[2]);
-      exit (-1);
+      exit (1);
     }
   return 0;
 }
Only in gcc-2.95.2/gcc/java: jvgenmain.c.orig
diff -u -r gcc-2.95.2-orig/gcc/java/jvspec.c gcc-2.95.2/gcc/java/jvspec.c
--- gcc-2.95.2-orig/gcc/java/jvspec.c	Sun Oct 17 10:18:28 1999
+++ gcc-2.95.2/gcc/java/jvspec.c	Sat Oct 30 20:09:50 1999
@@ -54,7 +54,7 @@
 #define COMBINE_INPUTS 0
 
 char jvgenmain_spec[] =
-  "jvgenmain %i %{!pipe:%umain.i} |\n\
+  "jvgenmain %{D*} %i %{!pipe:%umain.i} |\n\
    cc1 %{!pipe:%Umain.i} %1 \
 		   %{!Q:-quiet} -dumpbase %b.c %{d*} %{m*} %{a*}\
 		   %{g*} %{O*} \
@@ -167,6 +167,9 @@
   int saw_O = 0;
   int saw_g = 0;
 
+  /* Saw a `-D' option.  */
+  int saw_D = 0;
+
   /* An array used to flag each argument that needs a bit set for
      LANGSPEC, MATHLIB, WITHLIBC, or GCLIB.  */
   int *args;
@@ -186,6 +189,9 @@
   /* Non-zero if linking is supposed to happen.  */
   int will_link = 1;
 
+  /* Non-zero if we want to find the spec file.  */
+  int want_spec_file = 1;
+
   /* The argument we use to specify the spec file.  */
   char *spec_file = NULL;
 
@@ -224,7 +230,7 @@
 	      added--;
 	    }
 	  else if (strcmp (argv[i], "-fhelp") == 0)
-	    will_link = 0;
+           want_spec_file = 0;
 	  else if (strcmp (argv[i], "-v") == 0)
 	    {
 	      saw_verbose_flag = 1;
@@ -240,6 +246,7 @@
 	  else if (strcmp (argv[i], "-C") == 0)
 	    {
 	      saw_C = 1;
+             want_spec_file = 0;
 #if COMBINE_INPUTS
 	      combine_inputs = 1;
 #endif
@@ -248,6 +255,8 @@
 	      library = 0;
 	      will_link = 0;
 	    }
+         else if (argv[i][1] == 'D')
+           saw_D = 1;
 	  else if (argv[i][1] == 'g')
 	    saw_g = 1;
 	  else if (argv[i][1] == 'O')
@@ -288,6 +297,7 @@
 	  else if (strcmp (argv[i], "-fsyntax-only") == 0
 		   || strcmp (argv[i], "--syntax-only") == 0)
 	    {
+             want_spec_file = 0;
 	      library = 0;
 	      will_link = 0;
 	      continue;
@@ -331,6 +341,9 @@
   if (quote)
     (*fn) ("argument to `%s' missing\n", quote);
 
+  if (saw_D && ! main_class_name)
+    fatal ("can't specify `-D' without `--main'\n");
+
   num_args = argc + added;
   if (saw_C)
     {
@@ -376,8 +389,7 @@
     }
   if (saw_g + saw_O == 0)
     num_args++;
-  if (will_link)
-    num_args++;
+  num_args++;
   arglist = (char **) xmalloc ((num_args + 1) * sizeof (char *));
 
   for (i = 0, j = 0; i < argc; i++, j++)
@@ -408,7 +420,7 @@
 	  continue;
 	}
 
-      if (will_link && spec_file == NULL && strncmp (argv[i], "-L", 2) == 0)
+      if (spec_file == NULL && strncmp (argv[i], "-L", 2) == 0)
 	spec_file = find_spec_file (argv[i] + 2);
 
       if (strncmp (argv[i], "-fmain=", 7) == 0)
@@ -453,10 +465,10 @@
   if (saw_g + saw_O == 0)
     arglist[j++] = "-g1";
 
-  /* Read the specs file corresponding to libgcj, but only if linking.
+  /* Read the specs file corresponding to libgcj.
      If we didn't find the spec file on the -L path, then we hope it
      is somewhere in the standard install areas.  */
-  if (will_link)
+  if (want_spec_file)
     arglist[j++] = spec_file == NULL ? "-specs=libgcj.spec" : spec_file;
 
   if (saw_C)
Only in gcc-2.95.2/gcc/java: jvspec.c.orig
Only in gcc-2.95.2/gcc/java: jvspec.c.rej
diff -u -r gcc-2.95.2-orig/gcc/java/lang-options.h gcc-2.95.2/gcc/java/lang-options.h
--- gcc-2.95.2-orig/gcc/java/lang-options.h	Tue May 11 20:50:13 1999
+++ gcc-2.95.2/gcc/java/lang-options.h	Sat Oct 30 19:45:50 1999
@@ -43,6 +43,8 @@
   { "-fCLASSPATH", "Set class path" },
   { "-I", "Add directory to class path" },
   { "-foutput-class-dir", "Directory where class files should be written" },
+  { "-fuse-divide-subroutine", "" },
+  { "-fno-use-divide-subroutine", "Use built-in instructions for division" },
   { "-Wredundant-modifiers", 
     "Warn if modifiers are specified when not necessary"},
-  { "-Wunsupported-jdk11", "Warn if `final' local variables are specified"},
+  { "-Wunsupported-jdk11", "Warn if `final' local variables are specified"},
Only in gcc-2.95.2/gcc/java: lang-options.h.orig
diff -u -r gcc-2.95.2-orig/gcc/java/lang-specs.h gcc-2.95.2/gcc/java/lang-specs.h
--- gcc-2.95.2-orig/gcc/java/lang-specs.h	Mon Feb  1 06:46:51 1999
+++ gcc-2.95.2/gcc/java/lang-specs.h	Sat Oct 30 20:07:34 1999
@@ -30,7 +30,7 @@
   {".zip",    {"@java"} },
   {".jar",    {"@java"} },
   {"@java",
-   {"%{!E:jc1 %i %1 %{!Q:-quiet} %{d*} %{m*} %{a}\
+   {"%{!E:jc1 %i %1 %(jc1) %{!Q:-quiet} %{d*} %{m*} %{a}\
 		    %{g*} %{O*} %{W*} %{w} %{pedantic*} %{ansi}\
 		    %{traditional} %{v:-version} %{pg:-p} %{p}\
 		    %{f*} %{+e*} %{aux-info*} %{Qn:-fno-ident}\
Only in gcc-2.95.2/gcc/java: lang-specs.h.orig
Only in gcc-2.95.2/gcc/java: lang-specs.h.rej
diff -u -r gcc-2.95.2-orig/gcc/java/lang.c gcc-2.95.2/gcc/java/lang.c
--- gcc-2.95.2-orig/gcc/java/lang.c	Sat May 15 01:44:09 1999
+++ gcc-2.95.2/gcc/java/lang.c	Sat Oct 30 19:45:50 1999
@@ -105,6 +105,9 @@
 /* When non zero, warns that final local are treated as non final.  */
 int flag_static_local_jdk1_1 = 0;
 
+/* When non zero, call a library routine to do integer divisions. */
+int flag_use_divide_subroutine = 1;
+
 /* From gcc/flags.h, and indicates if exceptions are turned on or not.  */
 
 extern int flag_new_exceptions;
@@ -123,6 +126,7 @@
   {"assume-compiled", &flag_assume_compiled, 1},
   {"emit-class-file", &flag_emit_class_files, 1},
   {"emit-class-files", &flag_emit_class_files, 1},
+  {"use-divide-subroutine", &flag_use_divide_subroutine, 1},
 };
 
 JCF *current_jcf;
Only in gcc-2.95.2/gcc/java: lang.c.orig
diff -u -r gcc-2.95.2-orig/gcc/java/lex.h gcc-2.95.2/gcc/java/lex.h
--- gcc-2.95.2-orig/gcc/java/lex.h	Thu May 13 04:52:35 1999
+++ gcc-2.95.2/gcc/java/lex.h	Sun Oct 31 18:48:35 1999
@@ -123,7 +123,7 @@
 #define SET_MODIFIER_CTX(TOKEN) java_lval->value = (TOKEN)
 #define GET_TYPE_PRECISION(NODE) 4
 #define BUILD_OPERATOR(TOKEN)	return TOKEN
-#define BUILD_OPERATOR2(TOKEN)	return TOKEN
+#define BUILD_OPERATOR2(TOKEN) return ASSIGN_ANY_TK
 #define SET_LVAL_NODE(NODE)
 #define SET_LVAL_NODE_TYPE(NODE, TYPE)
 #define BUILD_ID_WFL(EXP) (EXP)
diff -u -r gcc-2.95.2-orig/gcc/java/parse-scan.c gcc-2.95.2/gcc/java/parse-scan.c
--- gcc-2.95.2-orig/gcc/java/parse-scan.c	Mon Oct 25 21:02:09 1999
+++ gcc-2.95.2/gcc/java/parse-scan.c	Sun Oct 31 19:10:26 1999
@@ -1,117 +1,116 @@
 
 /*  A Bison parser, made from ./parse-scan.y
- by  GNU Bison version 1.25
-  */
+    by GNU Bison version 1.28  */
 
 #define YYBISON 1  /* Identify Bison output.  */
 
-#define	PLUS_TK	258
-#define	MINUS_TK	259
-#define	MULT_TK	260
-#define	DIV_TK	261
-#define	REM_TK	262
-#define	LS_TK	263
-#define	SRS_TK	264
-#define	ZRS_TK	265
-#define	AND_TK	266
-#define	XOR_TK	267
-#define	OR_TK	268
-#define	BOOL_AND_TK	269
-#define	BOOL_OR_TK	270
-#define	EQ_TK	271
-#define	NEQ_TK	272
-#define	GT_TK	273
-#define	GTE_TK	274
-#define	LT_TK	275
-#define	LTE_TK	276
-#define	PLUS_ASSIGN_TK	277
-#define	MINUS_ASSIGN_TK	278
-#define	MULT_ASSIGN_TK	279
-#define	DIV_ASSIGN_TK	280
-#define	REM_ASSIGN_TK	281
-#define	LS_ASSIGN_TK	282
-#define	SRS_ASSIGN_TK	283
-#define	ZRS_ASSIGN_TK	284
-#define	AND_ASSIGN_TK	285
-#define	XOR_ASSIGN_TK	286
-#define	OR_ASSIGN_TK	287
-#define	PUBLIC_TK	288
-#define	PRIVATE_TK	289
-#define	PROTECTED_TK	290
-#define	STATIC_TK	291
-#define	FINAL_TK	292
-#define	SYNCHRONIZED_TK	293
-#define	VOLATILE_TK	294
-#define	TRANSIENT_TK	295
-#define	NATIVE_TK	296
-#define	PAD_TK	297
-#define	ABSTRACT_TK	298
-#define	MODIFIER_TK	299
-#define	DECR_TK	300
-#define	INCR_TK	301
-#define	DEFAULT_TK	302
-#define	IF_TK	303
-#define	THROW_TK	304
-#define	BOOLEAN_TK	305
-#define	DO_TK	306
-#define	IMPLEMENTS_TK	307
-#define	THROWS_TK	308
-#define	BREAK_TK	309
-#define	IMPORT_TK	310
-#define	ELSE_TK	311
-#define	INSTANCEOF_TK	312
-#define	RETURN_TK	313
-#define	VOID_TK	314
-#define	CATCH_TK	315
-#define	INTERFACE_TK	316
-#define	CASE_TK	317
-#define	EXTENDS_TK	318
-#define	FINALLY_TK	319
-#define	SUPER_TK	320
-#define	WHILE_TK	321
-#define	CLASS_TK	322
-#define	SWITCH_TK	323
-#define	CONST_TK	324
-#define	TRY_TK	325
-#define	FOR_TK	326
-#define	NEW_TK	327
-#define	CONTINUE_TK	328
-#define	GOTO_TK	329
-#define	PACKAGE_TK	330
-#define	THIS_TK	331
-#define	BYTE_TK	332
-#define	SHORT_TK	333
-#define	INT_TK	334
-#define	LONG_TK	335
-#define	CHAR_TK	336
-#define	INTEGRAL_TK	337
-#define	FLOAT_TK	338
-#define	DOUBLE_TK	339
-#define	FP_TK	340
-#define	ID_TK	341
-#define	REL_QM_TK	342
-#define	REL_CL_TK	343
-#define	NOT_TK	344
-#define	NEG_TK	345
-#define	ASSIGN_ANY_TK	346
-#define	ASSIGN_TK	347
-#define	OP_TK	348
-#define	CP_TK	349
-#define	OCB_TK	350
-#define	CCB_TK	351
-#define	OSB_TK	352
-#define	CSB_TK	353
-#define	SC_TK	354
-#define	C_TK	355
-#define	DOT_TK	356
-#define	STRING_LIT_TK	357
-#define	CHAR_LIT_TK	358
-#define	INT_LIT_TK	359
-#define	FP_LIT_TK	360
-#define	TRUE_TK	361
-#define	FALSE_TK	362
-#define	BOOL_LIT_TK	363
-#define	NULL_TK	364
+#define	PLUS_TK	257
+#define	MINUS_TK	258
+#define	MULT_TK	259
+#define	DIV_TK	260
+#define	REM_TK	261
+#define	LS_TK	262
+#define	SRS_TK	263
+#define	ZRS_TK	264
+#define	AND_TK	265
+#define	XOR_TK	266
+#define	OR_TK	267
+#define	BOOL_AND_TK	268
+#define	BOOL_OR_TK	269
+#define	EQ_TK	270
+#define	NEQ_TK	271
+#define	GT_TK	272
+#define	GTE_TK	273
+#define	LT_TK	274
+#define	LTE_TK	275
+#define	PLUS_ASSIGN_TK	276
+#define	MINUS_ASSIGN_TK	277
+#define	MULT_ASSIGN_TK	278
+#define	DIV_ASSIGN_TK	279
+#define	REM_ASSIGN_TK	280
+#define	LS_ASSIGN_TK	281
+#define	SRS_ASSIGN_TK	282
+#define	ZRS_ASSIGN_TK	283
+#define	AND_ASSIGN_TK	284
+#define	XOR_ASSIGN_TK	285
+#define	OR_ASSIGN_TK	286
+#define	PUBLIC_TK	287
+#define	PRIVATE_TK	288
+#define	PROTECTED_TK	289
+#define	STATIC_TK	290
+#define	FINAL_TK	291
+#define	SYNCHRONIZED_TK	292
+#define	VOLATILE_TK	293
+#define	TRANSIENT_TK	294
+#define	NATIVE_TK	295
+#define	PAD_TK	296
+#define	ABSTRACT_TK	297
+#define	MODIFIER_TK	298
+#define	DECR_TK	299
+#define	INCR_TK	300
+#define	DEFAULT_TK	301
+#define	IF_TK	302
+#define	THROW_TK	303
+#define	BOOLEAN_TK	304
+#define	DO_TK	305
+#define	IMPLEMENTS_TK	306
+#define	THROWS_TK	307
+#define	BREAK_TK	308
+#define	IMPORT_TK	309
+#define	ELSE_TK	310
+#define	INSTANCEOF_TK	311
+#define	RETURN_TK	312
+#define	VOID_TK	313
+#define	CATCH_TK	314
+#define	INTERFACE_TK	315
+#define	CASE_TK	316
+#define	EXTENDS_TK	317
+#define	FINALLY_TK	318
+#define	SUPER_TK	319
+#define	WHILE_TK	320
+#define	CLASS_TK	321
+#define	SWITCH_TK	322
+#define	CONST_TK	323
+#define	TRY_TK	324
+#define	FOR_TK	325
+#define	NEW_TK	326
+#define	CONTINUE_TK	327
+#define	GOTO_TK	328
+#define	PACKAGE_TK	329
+#define	THIS_TK	330
+#define	BYTE_TK	331
+#define	SHORT_TK	332
+#define	INT_TK	333
+#define	LONG_TK	334
+#define	CHAR_TK	335
+#define	INTEGRAL_TK	336
+#define	FLOAT_TK	337
+#define	DOUBLE_TK	338
+#define	FP_TK	339
+#define	ID_TK	340
+#define	REL_QM_TK	341
+#define	REL_CL_TK	342
+#define	NOT_TK	343
+#define	NEG_TK	344
+#define	ASSIGN_ANY_TK	345
+#define	ASSIGN_TK	346
+#define	OP_TK	347
+#define	CP_TK	348
+#define	OCB_TK	349
+#define	CCB_TK	350
+#define	OSB_TK	351
+#define	CSB_TK	352
+#define	SC_TK	353
+#define	C_TK	354
+#define	DOT_TK	355
+#define	STRING_LIT_TK	356
+#define	CHAR_LIT_TK	357
+#define	INT_LIT_TK	358
+#define	FP_LIT_TK	359
+#define	TRUE_TK	360
+#define	FALSE_TK	361
+#define	BOOL_LIT_TK	362
+#define	NULL_TK	363
 
 #line 37 "./parse-scan.y"
 
@@ -200,7 +199,7 @@
 #define	YYFLAG		-32768
 #define	YYNTBASE	110
 
-#define YYTRANSLATE(x) ((unsigned)(x) <= 364 ? yytranslate[x] : 253)
+#define YYTRANSLATE(x) ((unsigned)(x) <= 363 ? yytranslate[x] : 253)
 
 static const char yytranslate[] = {     0,
      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
@@ -228,18 +227,18 @@
      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     1,     2,     3,     4,     5,
-     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,
-    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,
-    26,    27,    28,    29,    30,    31,    32,    33,    34,    35,
-    36,    37,    38,    39,    40,    41,    42,    43,    44,    45,
-    46,    47,    48,    49,    50,    51,    52,    53,    54,    55,
-    56,    57,    58,    59,    60,    61,    62,    63,    64,    65,
-    66,    67,    68,    69,    70,    71,    72,    73,    74,    75,
-    76,    77,    78,    79,    80,    81,    82,    83,    84,    85,
-    86,    87,    88,    89,    90,    91,    92,    93,    94,    95,
-    96,    97,    98,    99,   100,   101,   102,   103,   104,   105,
-   106,   107,   108,   109
+     2,     2,     2,     2,     2,     1,     3,     4,     5,     6,
+     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,
+    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,
+    27,    28,    29,    30,    31,    32,    33,    34,    35,    36,
+    37,    38,    39,    40,    41,    42,    43,    44,    45,    46,
+    47,    48,    49,    50,    51,    52,    53,    54,    55,    56,
+    57,    58,    59,    60,    61,    62,    63,    64,    65,    66,
+    67,    68,    69,    70,    71,    72,    73,    74,    75,    76,
+    77,    78,    79,    80,    81,    82,    83,    84,    85,    86,
+    87,    88,    89,    90,    91,    92,    93,    94,    95,    96,
+    97,    98,    99,   100,   101,   102,   103,   104,   105,   106,
+   107,   108,   109
 };
 
 #if YYDEBUG != 0
@@ -1375,7 +1374,8 @@
 #define YYPURE 1
 
 /* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
-#line 3 "/usr/cygnus/gnupro-98r2/share/bison.simple"
+#line 3 "/usr/lib/bison.simple"
+/* This file comes from bison-1.28.  */
 
 /* Skeleton output parser for bison,
    Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.
@@ -1392,46 +1392,66 @@
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
 
 /* As a special exception, when this file is copied by Bison into a
    Bison output file, you may use that output file without restriction.
    This special exception was added by the Free Software Foundation
    in version 1.24 of Bison.  */
 
-#ifndef alloca
+/* This is the parser code that is written into each bison parser
+  when the %semantic_parser declaration is not specified in the grammar.
+  It was written by Richard Stallman by simplifying the hairy parser
+  used when %semantic_parser is specified.  */
+
+#ifndef YYSTACK_USE_ALLOCA
+#ifdef alloca
+#define YYSTACK_USE_ALLOCA
+#else /* alloca not defined */
 #ifdef __GNUC__
+#define YYSTACK_USE_ALLOCA
 #define alloca __builtin_alloca
 #else /* not GNU C.  */
-#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi)
+#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi) || (defined (__sun) && defined (__i386))
+#define YYSTACK_USE_ALLOCA
 #include <alloca.h>
 #else /* not sparc */
-#if defined (MSDOS) && !defined (__TURBOC__)
+/* We think this test detects Watcom and Microsoft C.  */
+/* This used to test MSDOS, but that is a bad idea
+   since that symbol is in the user namespace.  */
+#if (defined (_MSDOS) || defined (_MSDOS_)) && !defined (__TURBOC__)
+#if 0 /* No need for malloc.h, which pollutes the namespace;
+	 instead, just don't use alloca.  */
 #include <malloc.h>
+#endif
 #else /* not MSDOS, or __TURBOC__ */
 #if defined(_AIX)
-#include <malloc.h>
+/* I don't know what this was needed for, but it pollutes the namespace.
+   So I turned it off.   rms, 2 May 1997.  */
+/* #include <malloc.h>  */
  #pragma alloca
-#else /* not MSDOS, __TURBOC__, or _AIX */
-#ifdef __hpux
-#ifdef __cplusplus
-extern "C" {
-void *alloca (unsigned int);
-};
-#else /* not __cplusplus */
-void *alloca ();
-#endif /* not __cplusplus */
+#define YYSTACK_USE_ALLOCA
+#else /* not MSDOS, or __TURBOC__, or _AIX */
+#if 0
+#ifdef __hpux /* haible@ilog.fr says this works for HPUX 9.05 and up,
+		 and on HPUX 10.  Eventually we can turn this on.  */
+#define YYSTACK_USE_ALLOCA
+#define alloca __builtin_alloca
 #endif /* __hpux */
+#endif
 #endif /* not _AIX */
 #endif /* not MSDOS, or __TURBOC__ */
-#endif /* not sparc.  */
-#endif /* not GNU C.  */
-#endif /* alloca not defined.  */
+#endif /* not sparc */
+#endif /* not GNU C */
+#endif /* alloca not defined */
+#endif /* YYSTACK_USE_ALLOCA not defined */
 
-/* This is the parser code that is written into each bison parser
-  when the %semantic_parser declaration is not specified in the grammar.
-  It was written by Richard Stallman by simplifying the hairy parser
-  used when %semantic_parser is specified.  */
+#ifdef YYSTACK_USE_ALLOCA
+#define YYSTACK_ALLOC alloca
+#else
+#define YYSTACK_ALLOC malloc
+#endif
 
 /* Note: there must be only one dollar sign in this file.
    It is replaced by the list of actions, each action
@@ -1441,8 +1461,8 @@
 #define yyclearin	(yychar = YYEMPTY)
 #define YYEMPTY		-2
 #define YYEOF		0
-#define YYACCEPT	return(0)
-#define YYABORT 	return(1)
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT 	goto yyabortlab
 #define YYERROR		goto yyerrlab1
 /* Like YYERROR except do call yyerror.
    This remains here temporarily to ease the
@@ -1523,12 +1543,12 @@
 #ifndef YYMAXDEPTH
 #define YYMAXDEPTH 10000
 #endif
-
-/* Prevent warning if -Wstrict-prototypes.  */
-#ifdef __GNUC__
-int yyparse (void);
-#endif
 
+/* Define __yy_memcpy.  Note that the size argument
+   should be passed with type unsigned int, because that is what the non-GCC
+   definitions require.  With GCC, __builtin_memcpy takes an arg
+   of type size_t, but it can handle unsigned int.  */
+
 #if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
 #define __yy_memcpy(TO,FROM,COUNT)	__builtin_memcpy(TO,FROM,COUNT)
 #else				/* not GNU C or C++ */
@@ -1540,7 +1560,7 @@
 __yy_memcpy (to, from, count)
      char *to;
      char *from;
-     int count;
+     unsigned int count;
 {
   register char *f = from;
   register char *t = to;
@@ -1555,10 +1575,10 @@
 /* This is the most reliable way to avoid incompatibilities
    in available built-in functions on various systems.  */
 static void
-__yy_memcpy (char *to, char *from, int count)
+__yy_memcpy (char *to, char *from, unsigned int count)
 {
-  register char *f = from;
   register char *t = to;
+  register char *f = from;
   register int i = count;
 
   while (i-- > 0)
@@ -1568,7 +1588,7 @@
 #endif
 #endif
 
-#line 196 "/usr/cygnus/gnupro-98r2/share/bison.simple"
+#line 217 "/usr/lib/bison.simple"
 
 /* The user can define YYPARSE_PARAM as the name of an argument to be passed
    into yyparse.  The argument should have type void *.
@@ -1589,6 +1609,15 @@
 #define YYPARSE_PARAM_DECL
 #endif /* not YYPARSE_PARAM */
 
+/* Prevent warning if -Wstrict-prototypes.  */
+#ifdef __GNUC__
+#ifdef YYPARSE_PARAM
+int yyparse (void *);
+#else
+int yyparse (void);
+#endif
+#endif
+
 int
 yyparse(YYPARSE_PARAM_ARG)
      YYPARSE_PARAM_DECL
@@ -1617,6 +1646,7 @@
 #endif
 
   int yystacksize = YYINITDEPTH;
+  int yyfree_stacks = 0;
 
 #ifdef YYPURE
   int yychar;
@@ -1701,18 +1731,32 @@
       if (yystacksize >= YYMAXDEPTH)
 	{
 	  yyerror("parser stack overflow");
+	  if (yyfree_stacks)
+	    {
+	      free (yyss);
+	      free (yyvs);
+#ifdef YYLSP_NEEDED
+	      free (yyls);
+#endif
+	    }
 	  return 2;
 	}
       yystacksize *= 2;
       if (yystacksize > YYMAXDEPTH)
 	yystacksize = YYMAXDEPTH;
-      yyss = (short *) alloca (yystacksize * sizeof (*yyssp));
-      __yy_memcpy ((char *)yyss, (char *)yyss1, size * sizeof (*yyssp));
-      yyvs = (YYSTYPE *) alloca (yystacksize * sizeof (*yyvsp));
-      __yy_memcpy ((char *)yyvs, (char *)yyvs1, size * sizeof (*yyvsp));
+#ifndef YYSTACK_USE_ALLOCA
+      yyfree_stacks = 1;
+#endif
+      yyss = (short *) YYSTACK_ALLOC (yystacksize * sizeof (*yyssp));
+      __yy_memcpy ((char *)yyss, (char *)yyss1,
+		   size * (unsigned int) sizeof (*yyssp));
+      yyvs = (YYSTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yyvsp));
+      __yy_memcpy ((char *)yyvs, (char *)yyvs1,
+		   size * (unsigned int) sizeof (*yyvsp));
 #ifdef YYLSP_NEEDED
-      yyls = (YYLTYPE *) alloca (yystacksize * sizeof (*yylsp));
-      __yy_memcpy ((char *)yyls, (char *)yyls1, size * sizeof (*yylsp));
+      yyls = (YYLTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yylsp));
+      __yy_memcpy ((char *)yyls, (char *)yyls1,
+		   size * (unsigned int) sizeof (*yylsp));
 #endif
 #endif /* no yyoverflow */
 
@@ -2156,7 +2200,7 @@
     break;}
 }
    /* the action file gets copied in in place of this dollarsign */
-#line 498 "/usr/cygnus/gnupro-98r2/share/bison.simple"
+#line 543 "/usr/lib/bison.simple"
 
   yyvsp -= yylen;
   yyssp -= yylen;
@@ -2351,6 +2395,30 @@
 
   yystate = yyn;
   goto yynewstate;
+
+ yyacceptlab:
+  /* YYACCEPT comes here.  */
+  if (yyfree_stacks)
+    {
+      free (yyss);
+      free (yyvs);
+#ifdef YYLSP_NEEDED
+      free (yyls);
+#endif
+    }
+  return 0;
+
+ yyabortlab:
+  /* YYABORT comes here.  */
+  if (yyfree_stacks)
+    {
+      free (yyss);
+      free (yyvs);
+#ifdef YYLSP_NEEDED
+      free (yyls);
+#endif
+    }
+  return 1;
 }
 #line 1105 "./parse-scan.y"
 
@@ -2434,6 +2502,8 @@
 yyerror (msg)
      char *msg ATTRIBUTE_UNUSED;
 {
+  fprintf (stderr, "%s: %d: %s\n", input_filename, lineno, msg);
+  exit (1);
 }
 
 char *
diff -u -r gcc-2.95.2-orig/gcc/java/parse-scan.y gcc-2.95.2/gcc/java/parse-scan.y
--- gcc-2.95.2-orig/gcc/java/parse-scan.y	Tue May  4 04:59:16 1999
+++ gcc-2.95.2/gcc/java/parse-scan.y	Sun Oct 31 18:48:35 1999
@@ -1183,6 +1183,8 @@
 yyerror (msg)
      char *msg ATTRIBUTE_UNUSED;
 {
+  fprintf (stderr, "%s: %d: %s\n", input_filename, lineno, msg);
+  exit (1);
 }
 
 char *
Only in gcc-2.95.2/gcc/java: parse-scan.y.orig
diff -u -r gcc-2.95.2-orig/gcc/java/parse.c gcc-2.95.2/gcc/java/parse.c
--- gcc-2.95.2-orig/gcc/java/parse.c	Mon Oct 25 21:02:09 1999
+++ gcc-2.95.2/gcc/java/parse.c	Sun Oct 31 21:39:17 1999
@@ -1,7 +1,6 @@
 
 /*  A Bison parser, made from ./parse.y
- by  GNU Bison version 1.27
-  */
+    by GNU Bison version 1.28  */
 
 #define YYBISON 1  /* Identify Bison output.  */
 
@@ -167,6 +166,7 @@
 static void parse_warning_context PVPROTO ((tree cl, const char *msg, ...))
   ATTRIBUTE_PRINTF_2;
 static void issue_warning_error_from_context PROTO ((tree, const char *msg, va_list));
+static void parse_ctor_invocation_error PROTO ((void));
 static tree parse_jdk1_1_error PROTO ((char *));
 static void complete_class_report_errors PROTO ((jdep *));
 static int process_imports PROTO ((void));
@@ -319,6 +319,7 @@
 static tree strip_out_static_field_access_decl PROTO ((tree));
 static jdeplist *reverse_jdep_list PROTO ((struct parser_ctxt *));
 static void static_ref_err PROTO ((tree, tree, tree));
+static tree java_refold PROTO ((tree));
 
 /* Number of error found so far. */
 int java_error_count; 
@@ -350,6 +351,10 @@
   binop_lookup [((VALUE) - PLUS_TK)%					\
 		(sizeof (binop_lookup) / sizeof (binop_lookup[0]))]
 
+/* This is the end index for binary operators that can also be used
+   in compound assignements. */
+#define BINOP_COMPOUND_CANDIDATES 11
+
 /* Fake WFL used to report error message. It is initialized once if
    needed and reused with it's location information is overriden.  */
 tree wfl_operator = NULL_TREE;
@@ -376,7 +381,7 @@
 static tree current_static_block = NULL_TREE;
 
 
-#line 304 "./parse.y"
+#line 310 "./parse.y"
 typedef union {
   tree node;
   int sub_token;
@@ -386,7 +391,7 @@
   } operator;
   int value;
 } YYSTYPE;
-#line 314 "./parse.y"
+#line 320 "./parse.y"
 
 #include "lex.c"
 #ifndef YYDEBUG
@@ -684,57 +689,57 @@
 
 #if YYDEBUG != 0
 static const short yyrline[] = { 0,
-   458,   464,   466,   467,   468,   469,   470,   474,   476,   479,
-   481,   482,   485,   487,   490,   494,   498,   502,   508,   510,
-   512,   514,   519,   521,   524,   528,   533,   538,   540,   541,
-   542,   543,   544,   545,   546,   549,   554,   560,   562,   565,
-   568,   570,   574,   576,   579,   606,   608,   612,   625,   627,
-   631,   638,   643,   645,   655,   660,   675,   679,   682,   685,
-   688,   690,   692,   697,   701,   703,   705,   707,   711,   713,
-   715,   722,   728,   733,   737,   746,   756,   758,   761,   763,
-   764,   765,   769,   771,   773,   774,   776,   781,   784,   794,
-   797,   799,   803,   806,   813,   819,   827,   829,   831,   833,
-   835,   839,   841,   845,   852,   853,   857,   860,   862,   864,
-   866,   868,   870,   872,   874,   881,   884,   886,   895,   897,
-   901,   906,   911,   915,   920,   925,   927,   934,   936,   938,
-   942,   945,   947,   951,   953,   954,   959,   965,   972,   980,
-   987,   990,   993,   997,  1000,  1004,  1013,  1015,  1017,  1021,
-  1023,  1026,  1033,  1041,  1043,  1047,  1054,  1064,  1068,  1071,
-  1074,  1077,  1080,  1083,  1086,  1089,  1091,  1095,  1101,  1106,
-  1108,  1112,  1115,  1119,  1121,  1124,  1126,  1127,  1129,  1133,
-  1137,  1143,  1148,  1151,  1153,  1157,  1163,  1167,  1172,  1181,
-  1185,  1190,  1202,  1204,  1207,  1209,  1211,  1215,  1219,  1222,
-  1226,  1228,  1229,  1230,  1231,  1232,  1236,  1238,  1239,  1240,
-  1241,  1245,  1247,  1248,  1249,  1250,  1251,  1252,  1253,  1254,
-  1255,  1256,  1259,  1264,  1275,  1278,  1282,  1289,  1299,  1305,
-  1311,  1317,  1319,  1325,  1327,  1333,  1335,  1337,  1339,  1341,
-  1345,  1347,  1348,  1349,  1350,  1351,  1352,  1355,  1361,  1363,
-  1365,  1369,  1374,  1379,  1385,  1395,  1401,  1403,  1405,  1412,
-  1415,  1417,  1419,  1423,  1425,  1428,  1432,  1434,  1437,  1444,
-  1450,  1452,  1454,  1458,  1466,  1469,  1471,  1473,  1477,  1482,
-  1491,  1496,  1499,  1506,  1508,  1510,  1514,  1517,  1526,  1533,
-  1535,  1539,  1552,  1554,  1560,  1566,  1570,  1572,  1576,  1579,
-  1581,  1585,  1588,  1590,  1592,  1596,  1599,  1601,  1603,  1607,
-  1610,  1612,  1614,  1618,  1624,  1626,  1630,  1637,  1639,  1641,
-  1643,  1647,  1655,  1658,  1660,  1665,  1669,  1671,  1678,  1686,
-  1703,  1705,  1707,  1711,  1714,  1719,  1721,  1724,  1726,  1728,
-  1730,  1731,  1732,  1733,  1737,  1739,  1741,  1746,  1748,  1750,
-  1752,  1754,  1758,  1761,  1766,  1768,  1773,  1774,  1775,  1776,
-  1777,  1779,  1781,  1783,  1785,  1787,  1791,  1793,  1796,  1802,
-  1807,  1811,  1814,  1816,  1818,  1822,  1824,  1826,  1828,  1832,
-  1835,  1839,  1845,  1847,  1855,  1882,  1884,  1888,  1893,  1900,
-  1904,  1907,  1909,  1920,  1931,  1936,  1945,  1947,  1951,  1954,
-  1956,  1961,  1966,  1971,  1978,  1980,  1981,  1982,  1985,  1990,
-  1995,  1997,  1998,  2000,  2002,  2003,  2005,  2009,  2012,  2016,
-  2019,  2023,  2025,  2027,  2029,  2030,  2032,  2036,  2045,  2047,
-  2049,  2062,  2064,  2070,  2072,  2074,  2078,  2080,  2085,  2090,
-  2095,  2097,  2099,  2103,  2105,  2110,  2115,  2117,  2121,  2123,
-  2128,  2133,  2138,  2140,  2142,  2146,  2148,  2153,  2158,  2163,
-  2168,  2170,  2172,  2174,  2176,  2178,  2182,  2184,  2189,  2194,
-  2196,  2200,  2202,  2207,  2211,  2213,  2218,  2222,  2224,  2229,
-  2233,  2235,  2240,  2244,  2246,  2251,  2255,  2257,  2262,  2268,
-  2270,  2274,  2276,  2279,  2282,  2290,  2292,  2293,  2296,  2298,
-  2301,  2305
+   464,   470,   472,   473,   474,   475,   476,   480,   482,   485,
+   487,   488,   491,   493,   496,   500,   504,   508,   514,   516,
+   518,   520,   525,   527,   530,   534,   539,   544,   546,   547,
+   548,   549,   550,   551,   552,   555,   560,   566,   568,   571,
+   574,   576,   580,   582,   585,   612,   614,   618,   631,   633,
+   637,   644,   649,   651,   661,   666,   681,   685,   688,   691,
+   694,   696,   698,   703,   707,   709,   711,   713,   717,   719,
+   721,   728,   734,   739,   743,   752,   762,   764,   767,   769,
+   770,   771,   775,   777,   779,   780,   782,   787,   790,   800,
+   803,   805,   809,   812,   819,   825,   833,   835,   837,   839,
+   841,   845,   847,   851,   858,   859,   863,   866,   868,   870,
+   872,   874,   876,   878,   880,   887,   890,   892,   901,   903,
+   907,   912,   917,   921,   926,   931,   933,   940,   942,   944,
+   948,   951,   953,   957,   959,   960,   965,   971,   978,   986,
+   993,   996,   999,  1003,  1006,  1010,  1019,  1021,  1023,  1027,
+  1029,  1032,  1039,  1047,  1049,  1053,  1060,  1070,  1074,  1077,
+  1080,  1083,  1086,  1089,  1092,  1095,  1097,  1101,  1107,  1112,
+  1114,  1118,  1121,  1125,  1127,  1130,  1132,  1133,  1135,  1139,
+  1143,  1149,  1154,  1157,  1159,  1163,  1169,  1173,  1178,  1187,
+  1191,  1196,  1208,  1210,  1213,  1215,  1217,  1221,  1225,  1228,
+  1232,  1234,  1235,  1236,  1237,  1238,  1242,  1244,  1245,  1246,
+  1247,  1251,  1253,  1254,  1255,  1256,  1257,  1258,  1259,  1260,
+  1261,  1262,  1265,  1270,  1281,  1284,  1288,  1295,  1305,  1311,
+  1317,  1323,  1325,  1330,  1332,  1337,  1339,  1341,  1343,  1345,
+  1349,  1351,  1352,  1353,  1354,  1355,  1356,  1359,  1365,  1367,
+  1369,  1373,  1378,  1383,  1389,  1399,  1405,  1407,  1409,  1416,
+  1419,  1421,  1423,  1427,  1429,  1432,  1436,  1438,  1441,  1448,
+  1454,  1456,  1458,  1462,  1470,  1473,  1475,  1477,  1481,  1486,
+  1495,  1500,  1503,  1510,  1512,  1514,  1518,  1521,  1530,  1537,
+  1539,  1543,  1556,  1558,  1564,  1570,  1574,  1576,  1580,  1583,
+  1585,  1589,  1592,  1594,  1596,  1600,  1603,  1605,  1607,  1611,
+  1614,  1616,  1618,  1622,  1628,  1630,  1634,  1641,  1643,  1645,
+  1647,  1651,  1659,  1662,  1664,  1669,  1673,  1675,  1682,  1690,
+  1707,  1709,  1711,  1715,  1718,  1723,  1725,  1728,  1730,  1732,
+  1734,  1735,  1736,  1737,  1741,  1743,  1745,  1750,  1752,  1754,
+  1756,  1758,  1762,  1765,  1770,  1772,  1777,  1778,  1779,  1780,
+  1781,  1783,  1785,  1787,  1789,  1791,  1795,  1797,  1800,  1806,
+  1811,  1815,  1818,  1820,  1822,  1826,  1828,  1830,  1832,  1836,
+  1839,  1843,  1849,  1851,  1859,  1886,  1888,  1892,  1897,  1904,
+  1908,  1911,  1913,  1924,  1935,  1940,  1949,  1951,  1955,  1958,
+  1960,  1965,  1970,  1975,  1982,  1984,  1985,  1986,  1989,  1994,
+  1999,  2001,  2002,  2004,  2006,  2007,  2009,  2013,  2016,  2020,
+  2023,  2027,  2029,  2031,  2033,  2034,  2036,  2040,  2049,  2051,
+  2053,  2066,  2068,  2074,  2076,  2078,  2082,  2084,  2089,  2094,
+  2099,  2101,  2103,  2107,  2109,  2114,  2119,  2121,  2125,  2127,
+  2132,  2137,  2142,  2144,  2146,  2150,  2152,  2157,  2162,  2167,
+  2172,  2174,  2176,  2178,  2180,  2182,  2186,  2188,  2193,  2198,
+  2200,  2204,  2206,  2211,  2215,  2217,  2222,  2226,  2228,  2233,
+  2237,  2239,  2244,  2248,  2250,  2255,  2259,  2261,  2266,  2272,
+  2274,  2278,  2280,  2283,  2286,  2294,  2296,  2297,  2300,  2302,
+  2305,  2309
 };
 #endif
 
@@ -2213,7 +2218,7 @@
 
 /* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
 #line 3 "/usr/lib/bison.simple"
-/* This file comes from bison-1.27.  */
+/* This file comes from bison-1.28.  */
 
 /* Skeleton output parser for bison,
    Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.
@@ -2426,7 +2431,7 @@
 #endif
 #endif
 
-#line 216 "/usr/lib/bison.simple"
+#line 217 "/usr/lib/bison.simple"
 
 /* The user can define YYPARSE_PARAM as the name of an argument to be passed
    into yyparse.  The argument should have type void *.
@@ -2755,66 +2760,66 @@
   switch (yyn) {
 
 case 1:
-#line 460 "./parse.y"
+#line 466 "./parse.y"
 {;
     break;}
 case 18:
-#line 504 "./parse.y"
+#line 510 "./parse.y"
 { 
 		  yyval.node = build_java_array_type (yyvsp[-2].node, -1);
 		  CLASS_LOADED_P (yyval.node) = 1;
 		;
     break;}
 case 19:
-#line 509 "./parse.y"
+#line 515 "./parse.y"
 { yyval.node = build_unresolved_array_type (yyvsp[-2].node); ;
     break;}
 case 20:
-#line 511 "./parse.y"
+#line 517 "./parse.y"
 { yyval.node = build_unresolved_array_type (yyvsp[-2].node); ;
     break;}
 case 21:
-#line 513 "./parse.y"
+#line 519 "./parse.y"
 {RULE ("']' expected"); RECOVER;;
     break;}
 case 22:
-#line 515 "./parse.y"
+#line 521 "./parse.y"
 {RULE ("']' expected"); RECOVER;;
     break;}
 case 26:
-#line 530 "./parse.y"
+#line 536 "./parse.y"
 { yyval.node = make_qualified_name (yyvsp[-2].node, yyvsp[0].node, yyvsp[-1].operator.location); ;
     break;}
 case 28:
-#line 539 "./parse.y"
+#line 545 "./parse.y"
 {yyval.node = NULL;;
     break;}
 case 36:
-#line 551 "./parse.y"
+#line 557 "./parse.y"
 {
 		  yyval.node = NULL;
 		;
     break;}
 case 37:
-#line 555 "./parse.y"
+#line 561 "./parse.y"
 {
 		  yyval.node = NULL;
 		;
     break;}
 case 40:
-#line 567 "./parse.y"
+#line 573 "./parse.y"
 { ctxp->package = EXPR_WFL_NODE (yyvsp[-1].node); ;
     break;}
 case 41:
-#line 569 "./parse.y"
+#line 575 "./parse.y"
 {yyerror ("Missing name"); RECOVER;;
     break;}
 case 42:
-#line 571 "./parse.y"
+#line 577 "./parse.y"
 {yyerror ("';' expected"); RECOVER;;
     break;}
 case 45:
-#line 581 "./parse.y"
+#line 587 "./parse.y"
 {
 		  tree name = EXPR_WFL_NODE (yyvsp[-1].node), node, last_name;
 		  int   i = IDENTIFIER_LENGTH (name)-1;
@@ -2842,15 +2847,15 @@
 		;
     break;}
 case 46:
-#line 607 "./parse.y"
+#line 613 "./parse.y"
 {yyerror ("Missing name"); RECOVER;;
     break;}
 case 47:
-#line 609 "./parse.y"
+#line 615 "./parse.y"
 {yyerror ("';' expected"); RECOVER;;
     break;}
 case 48:
-#line 614 "./parse.y"
+#line 620 "./parse.y"
 {
 		  tree name = EXPR_WFL_NODE (yyvsp[-3].node);
 		  /* Don't import java.lang.* twice. */
@@ -2864,15 +2869,15 @@
 		;
     break;}
 case 49:
-#line 626 "./parse.y"
+#line 632 "./parse.y"
 {yyerror ("'*' expected"); RECOVER;;
     break;}
 case 50:
-#line 628 "./parse.y"
+#line 634 "./parse.y"
 {yyerror ("';' expected"); RECOVER;;
     break;}
 case 51:
-#line 633 "./parse.y"
+#line 639 "./parse.y"
 {
 		  maybe_generate_finit ();
 		  maybe_generate_clinit ();
@@ -2880,31 +2885,31 @@
 		;
     break;}
 case 52:
-#line 639 "./parse.y"
+#line 645 "./parse.y"
 {
 		  maybe_generate_clinit ();
 		  yyval.node = yyvsp[0].node;
 		;
     break;}
 case 53:
-#line 644 "./parse.y"
+#line 650 "./parse.y"
 { yyval.node = NULL; ;
     break;}
 case 54:
-#line 646 "./parse.y"
+#line 652 "./parse.y"
 {
 		  YYERROR_NOW;
 		  yyerror ("Class or interface declaration expected");
 		;
     break;}
 case 55:
-#line 657 "./parse.y"
+#line 663 "./parse.y"
 {
 		  yyval.value = (1 << yyvsp[0].value);
 		;
     break;}
 case 56:
-#line 661 "./parse.y"
+#line 667 "./parse.y"
 {
 		  int acc = (1 << yyvsp[0].value);
 		  if (yyval.value & acc)
@@ -2918,95 +2923,95 @@
 		;
     break;}
 case 57:
-#line 677 "./parse.y"
+#line 683 "./parse.y"
 { create_class (yyvsp[-4].value, yyvsp[-2].node, yyvsp[-1].node, yyvsp[0].node); ;
     break;}
 case 58:
-#line 679 "./parse.y"
+#line 685 "./parse.y"
 { 
 		  yyval.node = yyvsp[0].node;
 		;
     break;}
 case 59:
-#line 683 "./parse.y"
+#line 689 "./parse.y"
 { create_class (0, yyvsp[-2].node, yyvsp[-1].node, yyvsp[0].node); ;
     break;}
 case 60:
-#line 685 "./parse.y"
+#line 691 "./parse.y"
 { 	
 		  yyval.node = yyvsp[0].node;
 		;
     break;}
 case 61:
-#line 689 "./parse.y"
+#line 695 "./parse.y"
 {yyerror ("Missing class name"); RECOVER;;
     break;}
 case 62:
-#line 691 "./parse.y"
+#line 697 "./parse.y"
 {yyerror ("Missing class name"); RECOVER;;
     break;}
 case 63:
-#line 693 "./parse.y"
+#line 699 "./parse.y"
 {
 		  if (!ctxp->class_err) yyerror ("'{' expected"); 
 		  DRECOVER(class1);
 		;
     break;}
 case 64:
-#line 698 "./parse.y"
+#line 704 "./parse.y"
 {if (!ctxp->class_err) yyerror ("'{' expected"); RECOVER;;
     break;}
 case 65:
-#line 702 "./parse.y"
+#line 708 "./parse.y"
 { yyval.node = NULL; ;
     break;}
 case 66:
-#line 704 "./parse.y"
+#line 710 "./parse.y"
 { yyval.node = yyvsp[0].node; ;
     break;}
 case 67:
-#line 706 "./parse.y"
+#line 712 "./parse.y"
 {yyerror ("'{' expected"); ctxp->class_err=1;;
     break;}
 case 68:
-#line 708 "./parse.y"
+#line 714 "./parse.y"
 {yyerror ("Missing super class name"); ctxp->class_err=1;;
     break;}
 case 69:
-#line 712 "./parse.y"
+#line 718 "./parse.y"
 { yyval.node = NULL_TREE; ;
     break;}
 case 70:
-#line 714 "./parse.y"
+#line 720 "./parse.y"
 { yyval.node = yyvsp[0].node; ;
     break;}
 case 71:
-#line 716 "./parse.y"
+#line 722 "./parse.y"
 {
 		  ctxp->class_err=1;
 		  yyerror ("Missing interface name"); 
 		;
     break;}
 case 72:
-#line 724 "./parse.y"
+#line 730 "./parse.y"
 { 
 		  ctxp->interface_number = 1;
 		  yyval.node = build_tree_list (yyvsp[0].node, NULL_TREE);
 		;
     break;}
 case 73:
-#line 729 "./parse.y"
+#line 735 "./parse.y"
 { 
 		  ctxp->interface_number++;
 		  yyval.node = chainon (yyvsp[-2].node, build_tree_list (yyvsp[0].node, NULL_TREE));
 		;
     break;}
 case 74:
-#line 734 "./parse.y"
+#line 740 "./parse.y"
 {yyerror ("Missing interface name"); RECOVER;;
     break;}
 case 75:
-#line 739 "./parse.y"
+#line 745 "./parse.y"
 { 
 		  /* Store the location of the `}' when doing xrefs */
 		  if (flag_emit_xref)
@@ -3016,7 +3021,7 @@
 		;
     break;}
 case 76:
-#line 747 "./parse.y"
+#line 753 "./parse.y"
 { 
 		  /* Store the location of the `}' when doing xrefs */
 		  if (flag_emit_xref)
@@ -3026,27 +3031,27 @@
 		;
     break;}
 case 82:
-#line 766 "./parse.y"
+#line 772 "./parse.y"
 { yyval.node = parse_jdk1_1_error ("instance initializer"); ;
     break;}
 case 84:
-#line 772 "./parse.y"
+#line 778 "./parse.y"
 { yyval.node = yyvsp[-1].node; ;
     break;}
 case 86:
-#line 775 "./parse.y"
+#line 781 "./parse.y"
 { yyval.node = parse_jdk1_1_error ("inner classe declaration"); ;
     break;}
 case 87:
-#line 777 "./parse.y"
+#line 783 "./parse.y"
 { yyval.node = parse_jdk1_1_error ("inner interface declaration"); ;
     break;}
 case 88:
-#line 783 "./parse.y"
+#line 789 "./parse.y"
 { register_fields (0, yyvsp[-2].node, yyvsp[-1].node); ;
     break;}
 case 89:
-#line 785 "./parse.y"
+#line 791 "./parse.y"
 {
 		  check_modifiers 
 		    ("Illegal modifier `%s' for field declaration",
@@ -3056,19 +3061,19 @@
 		;
     break;}
 case 91:
-#line 798 "./parse.y"
+#line 804 "./parse.y"
 { yyval.node = chainon (yyvsp[-2].node, yyvsp[0].node); ;
     break;}
 case 92:
-#line 800 "./parse.y"
+#line 806 "./parse.y"
 {yyerror ("Missing term"); RECOVER;;
     break;}
 case 93:
-#line 805 "./parse.y"
+#line 811 "./parse.y"
 { yyval.node = build_tree_list (yyvsp[0].node, NULL_TREE); ;
     break;}
 case 94:
-#line 807 "./parse.y"
+#line 813 "./parse.y"
 { 
 		  if (java_error_count)
 		    yyvsp[0].node = NULL_TREE;
@@ -3077,7 +3082,7 @@
 		;
     break;}
 case 95:
-#line 814 "./parse.y"
+#line 820 "./parse.y"
 {
 		  yyerror ("Missing variable initializer");
 		  yyval.node = build_tree_list (yyvsp[-2].node, NULL_TREE);
@@ -3085,7 +3090,7 @@
 		;
     break;}
 case 96:
-#line 820 "./parse.y"
+#line 826 "./parse.y"
 {
 		  yyerror ("';' expected");
 		  yyval.node = build_tree_list (yyvsp[-3].node, NULL_TREE);
@@ -3093,85 +3098,85 @@
 		;
     break;}
 case 98:
-#line 830 "./parse.y"
+#line 836 "./parse.y"
 { yyval.node = build_unresolved_array_type (yyvsp[-2].node); ;
     break;}
 case 99:
-#line 832 "./parse.y"
+#line 838 "./parse.y"
 {yyerror ("Invalid declaration"); DRECOVER(vdi);;
     break;}
 case 100:
-#line 834 "./parse.y"
+#line 840 "./parse.y"
 {yyerror ("']' expected"); DRECOVER(vdi);;
     break;}
 case 101:
-#line 836 "./parse.y"
+#line 842 "./parse.y"
 {yyerror ("Unbalanced ']'"); DRECOVER(vdi);;
     break;}
 case 104:
-#line 847 "./parse.y"
+#line 853 "./parse.y"
 {
 		  current_function_decl = yyvsp[0].node;
 		  source_start_java_method (current_function_decl);
 		;
     break;}
 case 105:
-#line 852 "./parse.y"
+#line 858 "./parse.y"
 { finish_method_declaration (yyvsp[0].node); ;
     break;}
 case 106:
-#line 854 "./parse.y"
+#line 860 "./parse.y"
 {YYNOT_TWICE yyerror ("'{' expected"); RECOVER;;
     break;}
 case 107:
-#line 859 "./parse.y"
+#line 865 "./parse.y"
 { yyval.node = method_header (0, yyvsp[-2].node, yyvsp[-1].node, yyvsp[0].node); ;
     break;}
 case 108:
-#line 861 "./parse.y"
+#line 867 "./parse.y"
 { yyval.node = method_header (0, void_type_node, yyvsp[-1].node, yyvsp[0].node); ;
     break;}
 case 109:
-#line 863 "./parse.y"
+#line 869 "./parse.y"
 { yyval.node = method_header (yyvsp[-3].value, yyvsp[-2].node, yyvsp[-1].node, yyvsp[0].node); ;
     break;}
 case 110:
-#line 865 "./parse.y"
+#line 871 "./parse.y"
 { yyval.node = method_header (yyvsp[-3].value, void_type_node, yyvsp[-1].node, yyvsp[0].node); ;
     break;}
 case 111:
-#line 867 "./parse.y"
+#line 873 "./parse.y"
 {RECOVER;;
     break;}
 case 112:
-#line 869 "./parse.y"
+#line 875 "./parse.y"
 {RECOVER;;
     break;}
 case 113:
-#line 871 "./parse.y"
+#line 877 "./parse.y"
 {yyerror ("Identifier expected"); RECOVER;;
     break;}
 case 114:
-#line 873 "./parse.y"
+#line 879 "./parse.y"
 {yyerror ("Identifier expected"); RECOVER;;
     break;}
 case 115:
-#line 875 "./parse.y"
+#line 881 "./parse.y"
 {
 		  yyerror ("Invalid method declaration, return type required");
 		  RECOVER;
 		;
     break;}
 case 116:
-#line 883 "./parse.y"
+#line 889 "./parse.y"
 { yyval.node = method_declarator (yyvsp[-2].node, NULL_TREE); ;
     break;}
 case 117:
-#line 885 "./parse.y"
+#line 891 "./parse.y"
 { yyval.node = method_declarator (yyvsp[-3].node, yyvsp[-1].node); ;
     break;}
 case 118:
-#line 887 "./parse.y"
+#line 893 "./parse.y"
 {
 		  EXPR_WFL_LINECOL (wfl_operator) = yyvsp[-1].operator.location;
 		  TREE_PURPOSE (yyvsp[-2].node) = 
@@ -3182,150 +3187,150 @@
 		;
     break;}
 case 119:
-#line 896 "./parse.y"
+#line 902 "./parse.y"
 {yyerror ("')' expected"); DRECOVER(method_declarator);;
     break;}
 case 120:
-#line 898 "./parse.y"
+#line 904 "./parse.y"
 {yyerror ("']' expected"); RECOVER;;
     break;}
 case 121:
-#line 903 "./parse.y"
+#line 909 "./parse.y"
 {
 		  ctxp->formal_parameter_number = 1;
 		;
     break;}
 case 122:
-#line 907 "./parse.y"
+#line 913 "./parse.y"
 {
 		  ctxp->formal_parameter_number += 1;
 		  yyval.node = chainon (yyvsp[-2].node, yyvsp[0].node);
 		;
     break;}
 case 123:
-#line 912 "./parse.y"
+#line 918 "./parse.y"
 {yyerror ("Missing formal parameter term"); RECOVER;;
     break;}
 case 124:
-#line 917 "./parse.y"
+#line 923 "./parse.y"
 {
 		  yyval.node = build_tree_list (yyvsp[0].node, yyvsp[-1].node);
 		;
     break;}
 case 125:
-#line 921 "./parse.y"
+#line 927 "./parse.y"
 { 
 		  parse_jdk1_1_error ("final parameters");
 		  yyval.node = build_tree_list (yyvsp[0].node, yyvsp[-1].node);
 		;
     break;}
 case 126:
-#line 926 "./parse.y"
+#line 932 "./parse.y"
 {yyerror ("Missing identifier"); RECOVER;;
     break;}
 case 127:
-#line 928 "./parse.y"
+#line 934 "./parse.y"
 {
 		  SOURCE_FRONTEND_DEBUG (("Modifiers: %d", yyvsp[-2].value));
 		  yyerror ("Missing identifier"); RECOVER;
 		;
     break;}
 case 128:
-#line 935 "./parse.y"
+#line 941 "./parse.y"
 { yyval.node = NULL_TREE; ;
     break;}
 case 129:
-#line 937 "./parse.y"
+#line 943 "./parse.y"
 { yyval.node = yyvsp[0].node; ;
     break;}
 case 130:
-#line 939 "./parse.y"
+#line 945 "./parse.y"
 {yyerror ("Missing class type term"); RECOVER;;
     break;}
 case 131:
-#line 944 "./parse.y"
+#line 950 "./parse.y"
 { yyval.node = build_tree_list (yyvsp[0].node, yyvsp[0].node); ;
     break;}
 case 132:
-#line 946 "./parse.y"
+#line 952 "./parse.y"
 { yyval.node = tree_cons (yyvsp[0].node, yyvsp[0].node, yyvsp[-2].node); ;
     break;}
 case 133:
-#line 948 "./parse.y"
+#line 954 "./parse.y"
 {yyerror ("Missing class type term"); RECOVER;;
     break;}
 case 136:
-#line 955 "./parse.y"
+#line 961 "./parse.y"
 { yyval.node = NULL_TREE; ;
     break;}
 case 137:
-#line 961 "./parse.y"
+#line 967 "./parse.y"
 {
 		  TREE_CHAIN (yyvsp[0].node) = ctxp->static_initialized;
 		  ctxp->static_initialized = yyvsp[0].node;
 		;
     break;}
 case 138:
-#line 966 "./parse.y"
+#line 972 "./parse.y"
 {
 		  TREE_CHAIN (yyvsp[-1].node) = ctxp->static_initialized;
 		  ctxp->static_initialized = yyvsp[-1].node;
 		;
     break;}
 case 139:
-#line 974 "./parse.y"
+#line 980 "./parse.y"
 {
 		  SOURCE_FRONTEND_DEBUG (("Modifiers: %d", yyvsp[0].value));
 		;
     break;}
 case 140:
-#line 982 "./parse.y"
+#line 988 "./parse.y"
 {
 		  current_function_decl = yyvsp[0].node;
 		  source_start_java_method (current_function_decl);
 		;
     break;}
 case 141:
-#line 987 "./parse.y"
+#line 993 "./parse.y"
 { finish_method_declaration (yyvsp[0].node); ;
     break;}
 case 142:
-#line 992 "./parse.y"
+#line 998 "./parse.y"
 { yyval.node = method_header (0, NULL_TREE, yyvsp[-1].node, yyvsp[0].node); ;
     break;}
 case 143:
-#line 994 "./parse.y"
+#line 1000 "./parse.y"
 { yyval.node = method_header (yyvsp[-2].value, NULL_TREE, yyvsp[-1].node, yyvsp[0].node); ;
     break;}
 case 144:
-#line 999 "./parse.y"
+#line 1005 "./parse.y"
 { yyval.node = method_declarator (yyvsp[-2].node, NULL_TREE); ;
     break;}
 case 145:
-#line 1001 "./parse.y"
+#line 1007 "./parse.y"
 { yyval.node = method_declarator (yyvsp[-3].node, yyvsp[-1].node); ;
     break;}
 case 146:
-#line 1009 "./parse.y"
+#line 1015 "./parse.y"
 { 
 		  BLOCK_EXPR_BODY (yyvsp[0].node) = empty_stmt_node;
 		  yyval.node = yyvsp[0].node;
 		;
     break;}
 case 147:
-#line 1014 "./parse.y"
+#line 1020 "./parse.y"
 { yyval.node = yyvsp[0].node; ;
     break;}
 case 148:
-#line 1016 "./parse.y"
+#line 1022 "./parse.y"
 { yyval.node = yyvsp[0].node; ;
     break;}
 case 149:
-#line 1018 "./parse.y"
+#line 1024 "./parse.y"
 { yyval.node = yyvsp[0].node; ;
     break;}
 case 152:
-#line 1028 "./parse.y"
+#line 1034 "./parse.y"
 { 
 		  yyval.node = build_method_invocation (yyvsp[-3].node, NULL_TREE); 
 		  yyval.node = build_debugable_stmt (EXPR_WFL_LINECOL (yyvsp[-3].node), yyval.node);
@@ -3333,7 +3338,7 @@
 		;
     break;}
 case 153:
-#line 1034 "./parse.y"
+#line 1040 "./parse.y"
 { 
 		  yyval.node = build_method_invocation (yyvsp[-4].node, yyvsp[-2].node); 
 		  yyval.node = build_debugable_stmt (EXPR_WFL_LINECOL (yyvsp[-4].node), yyval.node);
@@ -3341,15 +3346,15 @@
 		;
     break;}
 case 154:
-#line 1042 "./parse.y"
+#line 1048 "./parse.y"
 {yyval.node = parse_jdk1_1_error ("explicit constructor invocation"); ;
     break;}
 case 155:
-#line 1044 "./parse.y"
+#line 1050 "./parse.y"
 {yyval.node = parse_jdk1_1_error ("explicit constructor invocation"); ;
     break;}
 case 156:
-#line 1049 "./parse.y"
+#line 1055 "./parse.y"
 {
 		  tree wfl = build_wfl_node (this_identifier_node);
 		  EXPR_WFL_LINECOL (wfl) = yyvsp[0].operator.location;
@@ -3357,7 +3362,7 @@
 		;
     break;}
 case 157:
-#line 1055 "./parse.y"
+#line 1061 "./parse.y"
 {
 		  tree wfl = build_wfl_node (super_identifier_node);
 		  EXPR_WFL_LINECOL (wfl) = yyvsp[0].operator.location;
@@ -3365,133 +3370,133 @@
 		;
     break;}
 case 158:
-#line 1066 "./parse.y"
+#line 1072 "./parse.y"
 { create_interface (0, yyvsp[0].node, NULL_TREE); ;
     break;}
 case 159:
-#line 1068 "./parse.y"
+#line 1074 "./parse.y"
 {
 		  yyval.node = yyvsp[0].node;
 		;
     break;}
 case 160:
-#line 1072 "./parse.y"
+#line 1078 "./parse.y"
 { create_interface (yyvsp[-2].value, yyvsp[0].node, NULL_TREE); ;
     break;}
 case 161:
-#line 1074 "./parse.y"
+#line 1080 "./parse.y"
 {
 		  yyval.node = yyvsp[0].node;
 		;
     break;}
 case 162:
-#line 1078 "./parse.y"
+#line 1084 "./parse.y"
 { create_interface (0, yyvsp[-1].node, yyvsp[0].node);	;
     break;}
 case 163:
-#line 1080 "./parse.y"
+#line 1086 "./parse.y"
 {
 		  yyval.node = yyvsp[0].node;
 		;
     break;}
 case 164:
-#line 1084 "./parse.y"
+#line 1090 "./parse.y"
 { create_interface (yyvsp[-3].value, yyvsp[-1].node, yyvsp[0].node); ;
     break;}
 case 165:
-#line 1086 "./parse.y"
+#line 1092 "./parse.y"
 {
 		  yyval.node = yyvsp[0].node;
 		;
     break;}
 case 166:
-#line 1090 "./parse.y"
+#line 1096 "./parse.y"
 {yyerror ("'{' expected"); RECOVER;;
     break;}
 case 167:
-#line 1092 "./parse.y"
+#line 1098 "./parse.y"
 {yyerror ("'{' expected"); RECOVER;;
     break;}
 case 168:
-#line 1097 "./parse.y"
+#line 1103 "./parse.y"
 { 
 		  ctxp->interface_number = 1;
 		  yyval.node = build_tree_list (yyvsp[0].node, NULL_TREE);
 		;
     break;}
 case 169:
-#line 1102 "./parse.y"
+#line 1108 "./parse.y"
 { 
 		  ctxp->interface_number++;
 		  yyval.node = chainon (yyvsp[-2].node, build_tree_list (yyvsp[0].node, NULL_TREE));
 		;
     break;}
 case 170:
-#line 1107 "./parse.y"
+#line 1113 "./parse.y"
 {yyerror ("Invalid interface type"); RECOVER;;
     break;}
 case 171:
-#line 1109 "./parse.y"
+#line 1115 "./parse.y"
 {yyerror ("Missing term"); RECOVER;;
     break;}
 case 172:
-#line 1114 "./parse.y"
+#line 1120 "./parse.y"
 { yyval.node = NULL_TREE; ;
     break;}
 case 173:
-#line 1116 "./parse.y"
+#line 1122 "./parse.y"
 { yyval.node = NULL_TREE; ;
     break;}
 case 178:
-#line 1128 "./parse.y"
+#line 1134 "./parse.y"
 { yyval.node = parse_jdk1_1_error ("inner class declaration"); ;
     break;}
 case 179:
-#line 1130 "./parse.y"
+#line 1136 "./parse.y"
 { yyval.node = parse_jdk1_1_error ("inner interface declaration"); ;
     break;}
 case 181:
-#line 1139 "./parse.y"
+#line 1145 "./parse.y"
 { 
 		  check_abstract_method_header (yyvsp[-1].node);
 		  current_function_decl = NULL_TREE; /* FIXME ? */
 		;
     break;}
 case 182:
-#line 1144 "./parse.y"
+#line 1150 "./parse.y"
 {yyerror ("';' expected"); RECOVER;;
     break;}
 case 183:
-#line 1150 "./parse.y"
+#line 1156 "./parse.y"
 { yyval.node = build_new_array_init (yyvsp[-1].operator.location, NULL_TREE); ;
     break;}
 case 184:
-#line 1152 "./parse.y"
+#line 1158 "./parse.y"
 { yyval.node = build_new_array_init (yyvsp[-2].operator.location, yyvsp[-1].node); ;
     break;}
 case 185:
-#line 1154 "./parse.y"
+#line 1160 "./parse.y"
 { yyval.node = build_new_array_init (yyvsp[-3].operator.location, yyvsp[-2].node); ;
     break;}
 case 186:
-#line 1159 "./parse.y"
+#line 1165 "./parse.y"
 { 
 		  yyval.node = tree_cons (maybe_build_array_element_wfl (yyvsp[0].node), 
 				  yyvsp[0].node, NULL_TREE);
 		;
     break;}
 case 187:
-#line 1164 "./parse.y"
+#line 1170 "./parse.y"
 {
 		  yyval.node = tree_cons (maybe_build_array_element_wfl (yyvsp[0].node), yyvsp[0].node, yyvsp[-2].node);
 		;
     break;}
 case 188:
-#line 1168 "./parse.y"
+#line 1174 "./parse.y"
 {yyerror ("Missing term"); RECOVER;;
     break;}
 case 189:
-#line 1174 "./parse.y"
+#line 1180 "./parse.y"
 { 
 		  /* Store the location of the `}' when doing xrefs */
 		  if (current_function_decl && flag_emit_xref)
@@ -3501,15 +3506,15 @@
 		;
     break;}
 case 190:
-#line 1182 "./parse.y"
+#line 1188 "./parse.y"
 { yyval.node = yyvsp[0].node; ;
     break;}
 case 191:
-#line 1187 "./parse.y"
+#line 1193 "./parse.y"
 { enter_block (); ;
     break;}
 case 192:
-#line 1192 "./parse.y"
+#line 1198 "./parse.y"
 { 
 		  maybe_absorb_scoping_blocks ();
 		  /* Store the location of the `}' when doing xrefs */
@@ -3520,35 +3525,35 @@
 		;
     break;}
 case 196:
-#line 1210 "./parse.y"
+#line 1216 "./parse.y"
 { java_method_add_stmt (current_function_decl, yyvsp[0].node); ;
     break;}
 case 197:
-#line 1212 "./parse.y"
+#line 1218 "./parse.y"
 { parse_jdk1_1_error ("inner class declaration"); ;
     break;}
 case 199:
-#line 1221 "./parse.y"
+#line 1227 "./parse.y"
 { declare_local_variables (0, yyvsp[-1].node, yyvsp[0].node); ;
     break;}
 case 200:
-#line 1223 "./parse.y"
+#line 1229 "./parse.y"
 { declare_local_variables (yyvsp[-2].value, yyvsp[-1].node, yyvsp[0].node); ;
     break;}
 case 206:
-#line 1233 "./parse.y"
+#line 1239 "./parse.y"
 { yyval.node = exit_block (); ;
     break;}
 case 211:
-#line 1242 "./parse.y"
+#line 1248 "./parse.y"
 { yyval.node = exit_block (); ;
     break;}
 case 223:
-#line 1261 "./parse.y"
+#line 1267 "./parse.y"
 { yyval.node = empty_stmt_node; ;
     break;}
 case 224:
-#line 1266 "./parse.y"
+#line 1272 "./parse.y"
 {
 		  yyval.node = build_labeled_block (EXPR_WFL_LINECOL (yyvsp[-1].node), 
 					    EXPR_WFL_NODE (yyvsp[-1].node));
@@ -3558,19 +3563,19 @@
 		;
     break;}
 case 225:
-#line 1277 "./parse.y"
+#line 1283 "./parse.y"
 { yyval.node = finish_labeled_statement (yyvsp[-1].node, yyvsp[0].node); ;
     break;}
 case 226:
-#line 1279 "./parse.y"
+#line 1285 "./parse.y"
 {yyerror ("':' expected"); RECOVER;;
     break;}
 case 227:
-#line 1284 "./parse.y"
+#line 1290 "./parse.y"
 { yyval.node = finish_labeled_statement (yyvsp[-1].node, yyvsp[0].node); ;
     break;}
 case 228:
-#line 1291 "./parse.y"
+#line 1297 "./parse.y"
 {
 		  /* We have a statement. Generate a WFL around it so
 		     we can debug it */
@@ -3581,7 +3586,7 @@
 		;
     break;}
 case 229:
-#line 1300 "./parse.y"
+#line 1306 "./parse.y"
 {
 		  if (ctxp->prevent_ese != lineno)
 		    yyerror ("Invalid expression statement");
@@ -3589,7 +3594,7 @@
 		;
     break;}
 case 230:
-#line 1306 "./parse.y"
+#line 1312 "./parse.y"
 {
 		  if (ctxp->prevent_ese != lineno)
 		    yyerror ("Invalid expression statement");
@@ -3597,7 +3602,7 @@
 		;
     break;}
 case 231:
-#line 1312 "./parse.y"
+#line 1318 "./parse.y"
 {
 		  if (ctxp->prevent_ese != lineno)
 		    yyerror ("Invalid expression statement");
@@ -3605,84 +3610,82 @@
 		;
     break;}
 case 232:
-#line 1318 "./parse.y"
+#line 1324 "./parse.y"
 {yyerror ("')' expected"); RECOVER;;
     break;}
 case 233:
-#line 1320 "./parse.y"
+#line 1326 "./parse.y"
 {
-		  yyerror ("Constructor invocation must be first "
-			   "thing in a constructor"); 
+                  parse_ctor_invocation_error ();		
 		  RECOVER;
 		;
     break;}
 case 234:
-#line 1326 "./parse.y"
+#line 1331 "./parse.y"
 {yyerror ("')' expected"); RECOVER;;
     break;}
 case 235:
-#line 1328 "./parse.y"
+#line 1333 "./parse.y"
 {
-		  yyerror ("Constructor invocation must be first "
-			   "thing in a constructor"); 
+		  parse_ctor_invocation_error ();			   
 		  RECOVER;
 		;
     break;}
 case 236:
-#line 1334 "./parse.y"
+#line 1338 "./parse.y"
 {yyerror ("'(' expected"); RECOVER;;
     break;}
 case 237:
-#line 1336 "./parse.y"
+#line 1340 "./parse.y"
 {yyerror ("')' expected"); RECOVER;;
     break;}
 case 238:
-#line 1338 "./parse.y"
+#line 1342 "./parse.y"
 {yyerror ("')' expected"); RECOVER;;
     break;}
 case 239:
-#line 1340 "./parse.y"
+#line 1344 "./parse.y"
 {yyerror ("';' expected"); RECOVER;;
     break;}
 case 240:
-#line 1342 "./parse.y"
+#line 1346 "./parse.y"
 {yyerror ("';' expected"); RECOVER;;
     break;}
 case 248:
-#line 1357 "./parse.y"
+#line 1361 "./parse.y"
 { 
 		  yyval.node = build_if_else_statement (yyvsp[-3].operator.location, yyvsp[-2].node, 
 						yyvsp[0].node, NULL_TREE);
 		;
     break;}
 case 249:
-#line 1362 "./parse.y"
+#line 1366 "./parse.y"
 {yyerror ("'(' expected"); RECOVER;;
     break;}
 case 250:
-#line 1364 "./parse.y"
+#line 1368 "./parse.y"
 {yyerror ("Missing term"); RECOVER;;
     break;}
 case 251:
-#line 1366 "./parse.y"
+#line 1370 "./parse.y"
 {yyerror ("')' expected"); RECOVER;;
     break;}
 case 252:
-#line 1371 "./parse.y"
+#line 1375 "./parse.y"
 { yyval.node = build_if_else_statement (yyvsp[-5].operator.location, yyvsp[-4].node, yyvsp[-2].node, yyvsp[0].node); ;
     break;}
 case 253:
-#line 1376 "./parse.y"
+#line 1380 "./parse.y"
 { yyval.node = build_if_else_statement (yyvsp[-5].operator.location, yyvsp[-4].node, yyvsp[-2].node, yyvsp[0].node); ;
     break;}
 case 254:
-#line 1381 "./parse.y"
+#line 1385 "./parse.y"
 {
 		  enter_block ();
 		;
     break;}
 case 255:
-#line 1385 "./parse.y"
+#line 1389 "./parse.y"
 { 
 		  /* Make into "proper list" of COMPOUND_EXPRs.
 		     I.e. make the last statment also have its own
@@ -3693,42 +3696,42 @@
 		;
     break;}
 case 256:
-#line 1397 "./parse.y"
+#line 1401 "./parse.y"
 { 
 		  yyval.node = build (SWITCH_EXPR, NULL_TREE, yyvsp[-1].node, NULL_TREE);
 		  EXPR_WFL_LINECOL (yyval.node) = yyvsp[-2].operator.location;
 		;
     break;}
 case 257:
-#line 1402 "./parse.y"
+#line 1406 "./parse.y"
 {yyerror ("'(' expected"); RECOVER;;
     break;}
 case 258:
-#line 1404 "./parse.y"
+#line 1408 "./parse.y"
 {yyerror ("Missing term or ')'"); DRECOVER(switch_statement);;
     break;}
 case 259:
-#line 1406 "./parse.y"
+#line 1410 "./parse.y"
 {yyerror ("'{' expected"); RECOVER;;
     break;}
 case 260:
-#line 1414 "./parse.y"
+#line 1418 "./parse.y"
 { yyval.node = NULL_TREE; ;
     break;}
 case 261:
-#line 1416 "./parse.y"
+#line 1420 "./parse.y"
 { yyval.node = NULL_TREE; ;
     break;}
 case 262:
-#line 1418 "./parse.y"
+#line 1422 "./parse.y"
 { yyval.node = NULL_TREE; ;
     break;}
 case 263:
-#line 1420 "./parse.y"
+#line 1424 "./parse.y"
 { yyval.node = NULL_TREE; ;
     break;}
 case 269:
-#line 1439 "./parse.y"
+#line 1443 "./parse.y"
 { 
 		  tree lab = build1 (CASE_EXPR, NULL_TREE, yyvsp[-1].node);
 		  EXPR_WFL_LINECOL (lab) = yyvsp[-2].operator.location;
@@ -3736,7 +3739,7 @@
 		;
     break;}
 case 270:
-#line 1445 "./parse.y"
+#line 1449 "./parse.y"
 { 
 		  tree lab = build1 (DEFAULT_EXPR, NULL_TREE, NULL_TREE);
 		  EXPR_WFL_LINECOL (lab) = yyvsp[-1].operator.location;
@@ -3744,61 +3747,61 @@
 		;
     break;}
 case 271:
-#line 1451 "./parse.y"
+#line 1455 "./parse.y"
 {yyerror ("Missing or invalid constant expression"); RECOVER;;
     break;}
 case 272:
-#line 1453 "./parse.y"
+#line 1457 "./parse.y"
 {yyerror ("':' expected"); RECOVER;;
     break;}
 case 273:
-#line 1455 "./parse.y"
+#line 1459 "./parse.y"
 {yyerror ("':' expected"); RECOVER;;
     break;}
 case 274:
-#line 1460 "./parse.y"
+#line 1464 "./parse.y"
 { 
 		  tree body = build_loop_body (yyvsp[-2].operator.location, yyvsp[-1].node, 0);
 		  yyval.node = build_new_loop (body);
 		;
     break;}
 case 275:
-#line 1468 "./parse.y"
+#line 1472 "./parse.y"
 { yyval.node = finish_loop_body (0, NULL_TREE, yyvsp[0].node, 0); ;
     break;}
 case 276:
-#line 1470 "./parse.y"
+#line 1474 "./parse.y"
 {YYERROR_NOW; yyerror ("'(' expected"); RECOVER;;
     break;}
 case 277:
-#line 1472 "./parse.y"
+#line 1476 "./parse.y"
 {yyerror ("Missing term and ')' expected"); RECOVER;;
     break;}
 case 278:
-#line 1474 "./parse.y"
+#line 1478 "./parse.y"
 {yyerror ("')' expected"); RECOVER;;
     break;}
 case 279:
-#line 1479 "./parse.y"
+#line 1483 "./parse.y"
 { yyval.node = finish_loop_body (0, NULL_TREE, yyvsp[0].node, 0); ;
     break;}
 case 280:
-#line 1484 "./parse.y"
+#line 1488 "./parse.y"
 { 
 		  tree body = build_loop_body (0, NULL_TREE, 1);
 		  yyval.node = build_new_loop (body);
 		;
     break;}
 case 281:
-#line 1493 "./parse.y"
+#line 1497 "./parse.y"
 { yyval.node = finish_loop_body (yyvsp[-3].operator.location, yyvsp[-2].node, yyvsp[-5].node, 1); ;
     break;}
 case 282:
-#line 1498 "./parse.y"
+#line 1502 "./parse.y"
 { yyval.node = finish_for_loop (EXPR_WFL_LINECOL (yyvsp[-4].node), yyvsp[-4].node, yyvsp[-2].node, yyvsp[0].node); ;
     break;}
 case 283:
-#line 1500 "./parse.y"
+#line 1504 "./parse.y"
 { 
 		  yyval.node = finish_for_loop (0, NULL_TREE, yyvsp[-2].node, yyvsp[0].node);
 		  /* We have not condition, so we get rid of the EXIT_EXPR */
@@ -3807,23 +3810,23 @@
 		;
     break;}
 case 284:
-#line 1507 "./parse.y"
+#line 1511 "./parse.y"
 {yyerror ("Invalid control expression"); RECOVER;;
     break;}
 case 285:
-#line 1509 "./parse.y"
+#line 1513 "./parse.y"
 {yyerror ("Invalid update expression"); RECOVER;;
     break;}
 case 286:
-#line 1511 "./parse.y"
+#line 1515 "./parse.y"
 {yyerror ("Invalid update expression"); RECOVER;;
     break;}
 case 287:
-#line 1516 "./parse.y"
+#line 1520 "./parse.y"
 { yyval.node = finish_for_loop (EXPR_WFL_LINECOL (yyvsp[-4].node), yyvsp[-4].node, yyvsp[-2].node, yyvsp[0].node);;
     break;}
 case 288:
-#line 1518 "./parse.y"
+#line 1522 "./parse.y"
 { 
 		  yyval.node = finish_for_loop (0, NULL_TREE, yyvsp[-2].node, yyvsp[0].node);
 		  /* We have not condition, so we get rid of the EXIT_EXPR */
@@ -3832,7 +3835,7 @@
 		;
     break;}
 case 289:
-#line 1528 "./parse.y"
+#line 1532 "./parse.y"
 { 
 		  /* This scope defined for local variable that may be
                      defined within the scope of the for loop */
@@ -3840,15 +3843,15 @@
 		;
     break;}
 case 290:
-#line 1534 "./parse.y"
+#line 1538 "./parse.y"
 {yyerror ("'(' expected"); DRECOVER(for_1);;
     break;}
 case 291:
-#line 1536 "./parse.y"
+#line 1540 "./parse.y"
 {yyerror ("Invalid init statement"); RECOVER;;
     break;}
 case 292:
-#line 1541 "./parse.y"
+#line 1545 "./parse.y"
 { 
 		  /* We now declare the loop body. The loop is
                      declared as a for loop. */
@@ -3861,11 +3864,11 @@
 		;
     break;}
 case 293:
-#line 1553 "./parse.y"
+#line 1557 "./parse.y"
 { yyval.node = empty_stmt_node; ;
     break;}
 case 294:
-#line 1555 "./parse.y"
+#line 1559 "./parse.y"
 { 
 		  /* Init statement recorded within the previously
                      defined block scope */
@@ -3873,7 +3876,7 @@
 		;
     break;}
 case 295:
-#line 1561 "./parse.y"
+#line 1565 "./parse.y"
 { 
 		  /* Local variable are recorded within the previously
 		     defined block scope */
@@ -3881,94 +3884,94 @@
 		;
     break;}
 case 296:
-#line 1567 "./parse.y"
+#line 1571 "./parse.y"
 {yyerror ("';' expected"); DRECOVER(for_init_1);;
     break;}
 case 297:
-#line 1571 "./parse.y"
+#line 1575 "./parse.y"
 {yyval.node = empty_stmt_node;;
     break;}
 case 298:
-#line 1573 "./parse.y"
+#line 1577 "./parse.y"
 { yyval.node = build_debugable_stmt (BUILD_LOCATION (), yyvsp[0].node); ;
     break;}
 case 299:
-#line 1578 "./parse.y"
+#line 1582 "./parse.y"
 { yyval.node = add_stmt_to_compound (NULL_TREE, NULL_TREE, yyvsp[0].node); ;
     break;}
 case 300:
-#line 1580 "./parse.y"
+#line 1584 "./parse.y"
 { yyval.node = add_stmt_to_compound (yyvsp[-2].node, NULL_TREE, yyvsp[0].node); ;
     break;}
 case 301:
-#line 1582 "./parse.y"
+#line 1586 "./parse.y"
 {yyerror ("Missing term"); RECOVER;;
     break;}
 case 302:
-#line 1587 "./parse.y"
+#line 1591 "./parse.y"
 { yyval.node = build_bc_statement (yyvsp[-1].operator.location, 1, NULL_TREE); ;
     break;}
 case 303:
-#line 1589 "./parse.y"
+#line 1593 "./parse.y"
 { yyval.node = build_bc_statement (yyvsp[-2].operator.location, 1, yyvsp[-1].node); ;
     break;}
 case 304:
-#line 1591 "./parse.y"
+#line 1595 "./parse.y"
 {yyerror ("Missing term"); RECOVER;;
     break;}
 case 305:
-#line 1593 "./parse.y"
+#line 1597 "./parse.y"
 {yyerror ("';' expected"); RECOVER;;
     break;}
 case 306:
-#line 1598 "./parse.y"
+#line 1602 "./parse.y"
 { yyval.node = build_bc_statement (yyvsp[-1].operator.location, 0, NULL_TREE); ;
     break;}
 case 307:
-#line 1600 "./parse.y"
+#line 1604 "./parse.y"
 { yyval.node = build_bc_statement (yyvsp[-2].operator.location, 0, yyvsp[-1].node); ;
     break;}
 case 308:
-#line 1602 "./parse.y"
+#line 1606 "./parse.y"
 {yyerror ("Missing term"); RECOVER;;
     break;}
 case 309:
-#line 1604 "./parse.y"
+#line 1608 "./parse.y"
 {yyerror ("';' expected"); RECOVER;;
     break;}
 case 310:
-#line 1609 "./parse.y"
+#line 1613 "./parse.y"
 { yyval.node = build_return (yyvsp[-1].operator.location, NULL_TREE); ;
     break;}
 case 311:
-#line 1611 "./parse.y"
+#line 1615 "./parse.y"
 { yyval.node = build_return (yyvsp[-2].operator.location, yyvsp[-1].node); ;
     break;}
 case 312:
-#line 1613 "./parse.y"
+#line 1617 "./parse.y"
 {yyerror ("Missing term"); RECOVER;;
     break;}
 case 313:
-#line 1615 "./parse.y"
+#line 1619 "./parse.y"
 {yyerror ("';' expected"); RECOVER;;
     break;}
 case 314:
-#line 1620 "./parse.y"
+#line 1624 "./parse.y"
 { 
 		  yyval.node = build1 (THROW_EXPR, NULL_TREE, yyvsp[-1].node);
 		  EXPR_WFL_LINECOL (yyval.node) = yyvsp[-2].operator.location;
 		;
     break;}
 case 315:
-#line 1625 "./parse.y"
+#line 1629 "./parse.y"
 {yyerror ("Missing term"); RECOVER;;
     break;}
 case 316:
-#line 1627 "./parse.y"
+#line 1631 "./parse.y"
 {yyerror ("';' expected"); RECOVER;;
     break;}
 case 317:
-#line 1632 "./parse.y"
+#line 1636 "./parse.y"
 { 
 		  yyval.node = build (SYNCHRONIZED_EXPR, NULL_TREE, yyvsp[-2].node, yyvsp[0].node);
 		  EXPR_WFL_LINECOL (yyval.node) = 
@@ -3976,56 +3979,56 @@
 		;
     break;}
 case 318:
-#line 1638 "./parse.y"
+#line 1642 "./parse.y"
 {yyerror ("'{' expected"); RECOVER;;
     break;}
 case 319:
-#line 1640 "./parse.y"
+#line 1644 "./parse.y"
 {yyerror ("'(' expected"); RECOVER;;
     break;}
 case 320:
-#line 1642 "./parse.y"
+#line 1646 "./parse.y"
 {yyerror ("Missing term"); RECOVER;;
     break;}
 case 321:
-#line 1644 "./parse.y"
+#line 1648 "./parse.y"
 {yyerror ("Missing term"); RECOVER;;
     break;}
 case 322:
-#line 1649 "./parse.y"
+#line 1653 "./parse.y"
 {
 		  if ((1 << yyvsp[0].value) != ACC_SYNCHRONIZED)
 		    fatal ("synchronized was '%d' - yyparse", (1 << yyvsp[0].value));
 		;
     break;}
 case 323:
-#line 1657 "./parse.y"
+#line 1661 "./parse.y"
 { yyval.node = build_try_statement (yyvsp[-2].operator.location, yyvsp[-1].node, yyvsp[0].node); ;
     break;}
 case 324:
-#line 1659 "./parse.y"
+#line 1663 "./parse.y"
 { yyval.node = build_try_finally_statement (yyvsp[-2].operator.location, yyvsp[-1].node, yyvsp[0].node); ;
     break;}
 case 325:
-#line 1661 "./parse.y"
+#line 1665 "./parse.y"
 { yyval.node = build_try_finally_statement 
 		    (yyvsp[-3].operator.location, build_try_statement (yyvsp[-3].operator.location,
 						       yyvsp[-2].node, yyvsp[-1].node), yyvsp[0].node);
 		;
     break;}
 case 326:
-#line 1666 "./parse.y"
+#line 1670 "./parse.y"
 {yyerror ("'{' expected"); DRECOVER (try_statement);;
     break;}
 case 328:
-#line 1672 "./parse.y"
+#line 1676 "./parse.y"
 { 
 		  TREE_CHAIN (yyvsp[0].node) = yyvsp[-1].node;
 		  yyval.node = yyvsp[0].node;
 		;
     break;}
 case 329:
-#line 1680 "./parse.y"
+#line 1684 "./parse.y"
 { 
 		  java_method_add_stmt (current_function_decl, yyvsp[0].node);
 		  exit_block ();
@@ -4033,7 +4036,7 @@
 		;
     break;}
 case 330:
-#line 1688 "./parse.y"
+#line 1692 "./parse.y"
 { 
 		  /* We add a block to define a scope for
 		     formal_parameter (CCBP). The formal parameter is
@@ -4051,176 +4054,176 @@
 		;
     break;}
 case 331:
-#line 1704 "./parse.y"
+#line 1708 "./parse.y"
 {yyerror ("'(' expected"); RECOVER;;
     break;}
 case 332:
-#line 1706 "./parse.y"
+#line 1710 "./parse.y"
 {yyerror ("Missing term or ')' expected"); DRECOVER (2);;
     break;}
 case 333:
-#line 1708 "./parse.y"
+#line 1712 "./parse.y"
 {yyerror ("')' expected"); DRECOVER (1);;
     break;}
 case 334:
-#line 1713 "./parse.y"
+#line 1717 "./parse.y"
 { yyval.node = yyvsp[0].node; ;
     break;}
 case 335:
-#line 1715 "./parse.y"
+#line 1719 "./parse.y"
 {yyerror ("'{' expected"); RECOVER; ;
     break;}
 case 339:
-#line 1727 "./parse.y"
+#line 1731 "./parse.y"
 { yyval.node = build_this (yyvsp[0].operator.location); ;
     break;}
 case 340:
-#line 1729 "./parse.y"
+#line 1733 "./parse.y"
 {yyval.node = yyvsp[-1].node;;
     break;}
 case 345:
-#line 1738 "./parse.y"
+#line 1742 "./parse.y"
 { yyval.node = parse_jdk1_1_error ("named class literals"); ;
     break;}
 case 346:
-#line 1740 "./parse.y"
+#line 1744 "./parse.y"
 { yyval.node = build_class_ref (yyvsp[-2].node); ;
     break;}
 case 347:
-#line 1742 "./parse.y"
+#line 1746 "./parse.y"
 { yyval.node = build_class_ref (void_type_node); ;
     break;}
 case 348:
-#line 1747 "./parse.y"
+#line 1751 "./parse.y"
 { yyval.node = parse_jdk1_1_error ("class literals"); ;
     break;}
 case 349:
-#line 1749 "./parse.y"
+#line 1753 "./parse.y"
 {yyerror ("')' expected"); RECOVER;;
     break;}
 case 350:
-#line 1751 "./parse.y"
+#line 1755 "./parse.y"
 {yyerror ("'class' or 'this' expected" ); RECOVER;;
     break;}
 case 351:
-#line 1753 "./parse.y"
+#line 1757 "./parse.y"
 {yyerror ("'class' expected" ); RECOVER;;
     break;}
 case 352:
-#line 1755 "./parse.y"
+#line 1759 "./parse.y"
 {yyerror ("'class' expected" ); RECOVER;;
     break;}
 case 353:
-#line 1760 "./parse.y"
+#line 1764 "./parse.y"
 { yyval.node = build_new_invocation (yyvsp[-3].node, yyvsp[-1].node); ;
     break;}
 case 354:
-#line 1762 "./parse.y"
+#line 1766 "./parse.y"
 { yyval.node = build_new_invocation (yyvsp[-2].node, NULL_TREE); ;
     break;}
 case 355:
-#line 1767 "./parse.y"
+#line 1771 "./parse.y"
 { yyval.node = parse_jdk1_1_error ("inner class instance creation"); ;
     break;}
 case 356:
-#line 1769 "./parse.y"
+#line 1773 "./parse.y"
 { yyval.node = parse_jdk1_1_error ("inner class instance creation"); ;
     break;}
 case 361:
-#line 1778 "./parse.y"
+#line 1782 "./parse.y"
 {yyerror ("'(' expected"); DRECOVER(new_1);;
     break;}
 case 362:
-#line 1780 "./parse.y"
+#line 1784 "./parse.y"
 {yyerror ("'(' expected"); RECOVER;;
     break;}
 case 363:
-#line 1782 "./parse.y"
+#line 1786 "./parse.y"
 {yyerror ("')' or term expected"); RECOVER;;
     break;}
 case 364:
-#line 1784 "./parse.y"
+#line 1788 "./parse.y"
 {yyerror ("')' expected"); RECOVER;;
     break;}
 case 365:
-#line 1786 "./parse.y"
+#line 1790 "./parse.y"
 {YYERROR_NOW; yyerror ("Identifier expected"); RECOVER;;
     break;}
 case 366:
-#line 1788 "./parse.y"
+#line 1792 "./parse.y"
 {yyerror ("'(' expected"); RECOVER;;
     break;}
 case 369:
-#line 1798 "./parse.y"
+#line 1802 "./parse.y"
 { 
 		  yyval.node = tree_cons (NULL_TREE, yyvsp[0].node, NULL_TREE);
 		  ctxp->formal_parameter_number = 1; 
 		;
     break;}
 case 370:
-#line 1803 "./parse.y"
+#line 1807 "./parse.y"
 {
 		  ctxp->formal_parameter_number += 1;
 		  yyval.node = tree_cons (NULL_TREE, yyvsp[0].node, yyvsp[-2].node);
 		;
     break;}
 case 371:
-#line 1808 "./parse.y"
+#line 1812 "./parse.y"
 {yyerror ("Missing term"); RECOVER;;
     break;}
 case 372:
-#line 1813 "./parse.y"
+#line 1817 "./parse.y"
 { yyval.node = build_newarray_node (yyvsp[-1].node, yyvsp[0].node, 0); ;
     break;}
 case 373:
-#line 1815 "./parse.y"
+#line 1819 "./parse.y"
 { yyval.node = build_newarray_node (yyvsp[-1].node, yyvsp[0].node, 0); ;
     break;}
 case 374:
-#line 1817 "./parse.y"
+#line 1821 "./parse.y"
 { yyval.node = build_newarray_node (yyvsp[-2].node, yyvsp[-1].node, CURRENT_OSB (ctxp));;
     break;}
 case 375:
-#line 1819 "./parse.y"
+#line 1823 "./parse.y"
 { yyval.node = build_newarray_node (yyvsp[-2].node, yyvsp[-1].node, CURRENT_OSB (ctxp));;
     break;}
 case 376:
-#line 1823 "./parse.y"
+#line 1827 "./parse.y"
 { yyval.node = parse_jdk1_1_error ("anonymous array"); ;
     break;}
 case 377:
-#line 1825 "./parse.y"
+#line 1829 "./parse.y"
 { yyval.node = parse_jdk1_1_error ("anonymous array"); ;
     break;}
 case 378:
-#line 1827 "./parse.y"
+#line 1831 "./parse.y"
 {yyerror ("'[' expected"); DRECOVER ("]");;
     break;}
 case 379:
-#line 1829 "./parse.y"
+#line 1833 "./parse.y"
 {yyerror ("']' expected"); RECOVER;;
     break;}
 case 380:
-#line 1834 "./parse.y"
+#line 1838 "./parse.y"
 { yyval.node = build_tree_list (NULL_TREE, yyvsp[0].node); ;
     break;}
 case 381:
-#line 1836 "./parse.y"
+#line 1840 "./parse.y"
 { yyval.node = tree_cons (NULL_TREE, yyvsp[0].node, yyval.node); ;
     break;}
 case 382:
-#line 1841 "./parse.y"
+#line 1845 "./parse.y"
 { 
 		  EXPR_WFL_LINECOL (yyvsp[-1].node) = yyvsp[-2].operator.location;
 		  yyval.node = yyvsp[-1].node;
 		;
     break;}
 case 383:
-#line 1846 "./parse.y"
+#line 1850 "./parse.y"
 {yyerror ("']' expected"); RECOVER;;
     break;}
 case 384:
-#line 1848 "./parse.y"
+#line 1852 "./parse.y"
 {
 		  yyerror ("Missing term");
 		  yyerror ("']' expected");
@@ -4228,7 +4231,7 @@
 		;
     break;}
 case 385:
-#line 1857 "./parse.y"
+#line 1861 "./parse.y"
 { 
 		  int allocate = 0;
 		  /* If not initialized, allocate memory for the osb
@@ -4256,19 +4259,19 @@
 		;
     break;}
 case 386:
-#line 1883 "./parse.y"
+#line 1887 "./parse.y"
 { CURRENT_OSB (ctxp)++; ;
     break;}
 case 387:
-#line 1885 "./parse.y"
+#line 1889 "./parse.y"
 { yyerror ("']' expected"); RECOVER;;
     break;}
 case 388:
-#line 1890 "./parse.y"
+#line 1894 "./parse.y"
 { yyval.node = make_qualified_primary (yyvsp[-2].node, yyvsp[0].node, yyvsp[-1].operator.location); ;
     break;}
 case 389:
-#line 1894 "./parse.y"
+#line 1898 "./parse.y"
 {
 		  tree super_wfl = 
 		    build_wfl_node (super_identifier_node);
@@ -4277,19 +4280,19 @@
 		;
     break;}
 case 390:
-#line 1901 "./parse.y"
+#line 1905 "./parse.y"
 {yyerror ("Field expected"); DRECOVER (super_field_acces);;
     break;}
 case 391:
-#line 1906 "./parse.y"
+#line 1910 "./parse.y"
 { yyval.node = build_method_invocation (yyvsp[-2].node, NULL_TREE); ;
     break;}
 case 392:
-#line 1908 "./parse.y"
+#line 1912 "./parse.y"
 { yyval.node = build_method_invocation (yyvsp[-3].node, yyvsp[-1].node); ;
     break;}
 case 393:
-#line 1910 "./parse.y"
+#line 1914 "./parse.y"
 { 
 		  if (TREE_CODE (yyvsp[-4].node) == THIS_EXPR)
 		    yyval.node = build_this_super_qualified_invocation 
@@ -4302,7 +4305,7 @@
 		;
     break;}
 case 394:
-#line 1921 "./parse.y"
+#line 1925 "./parse.y"
 { 
 		  if (TREE_CODE (yyvsp[-5].node) == THIS_EXPR)
 		    yyval.node = build_this_super_qualified_invocation 
@@ -4315,121 +4318,121 @@
 		;
     break;}
 case 395:
-#line 1932 "./parse.y"
+#line 1936 "./parse.y"
 { 
 		  yyval.node = build_this_super_qualified_invocation 
 		    (0, yyvsp[-2].node, NULL_TREE, yyvsp[-4].operator.location, yyvsp[-3].operator.location);
 		;
     break;}
 case 396:
-#line 1937 "./parse.y"
+#line 1941 "./parse.y"
 {
 		  yyval.node = build_this_super_qualified_invocation 
 		    (0, yyvsp[-3].node, yyvsp[-1].node, yyvsp[-5].operator.location, yyvsp[-4].operator.location);
 		;
     break;}
 case 397:
-#line 1946 "./parse.y"
+#line 1950 "./parse.y"
 { yyerror ("'(' expected"); DRECOVER (method_invocation); ;
     break;}
 case 398:
-#line 1948 "./parse.y"
+#line 1952 "./parse.y"
 { yyerror ("'(' expected"); DRECOVER (method_invocation); ;
     break;}
 case 399:
-#line 1953 "./parse.y"
+#line 1957 "./parse.y"
 { yyval.node = build_array_ref (yyvsp[-2].operator.location, yyvsp[-3].node, yyvsp[-1].node); ;
     break;}
 case 400:
-#line 1955 "./parse.y"
+#line 1959 "./parse.y"
 { yyval.node = build_array_ref (yyvsp[-2].operator.location, yyvsp[-3].node, yyvsp[-1].node); ;
     break;}
 case 401:
-#line 1957 "./parse.y"
+#line 1961 "./parse.y"
 {
 		  yyerror ("Missing term and ']' expected");
 		  DRECOVER(array_access);
 		;
     break;}
 case 402:
-#line 1962 "./parse.y"
+#line 1966 "./parse.y"
 {
 		  yyerror ("']' expected");
 		  DRECOVER(array_access);
 		;
     break;}
 case 403:
-#line 1967 "./parse.y"
+#line 1971 "./parse.y"
 {
 		  yyerror ("Missing term and ']' expected");
 		  DRECOVER(array_access);
 		;
     break;}
 case 404:
-#line 1972 "./parse.y"
+#line 1976 "./parse.y"
 {
 		  yyerror ("']' expected");
 		  DRECOVER(array_access);
 		;
     break;}
 case 409:
-#line 1987 "./parse.y"
+#line 1991 "./parse.y"
 { yyval.node = build_incdec (yyvsp[0].operator.token, yyvsp[0].operator.location, yyvsp[-1].node, 1); ;
     break;}
 case 410:
-#line 1992 "./parse.y"
+#line 1996 "./parse.y"
 { yyval.node = build_incdec (yyvsp[0].operator.token, yyvsp[0].operator.location, yyvsp[-1].node, 1); ;
     break;}
 case 413:
-#line 1999 "./parse.y"
+#line 2003 "./parse.y"
 {yyval.node = build_unaryop (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node); ;
     break;}
 case 414:
-#line 2001 "./parse.y"
+#line 2005 "./parse.y"
 {yyval.node = build_unaryop (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node); ;
     break;}
 case 416:
-#line 2004 "./parse.y"
+#line 2008 "./parse.y"
 {yyerror ("Missing term"); RECOVER;
     break;}
 case 417:
-#line 2006 "./parse.y"
+#line 2010 "./parse.y"
 {yyerror ("Missing term"); RECOVER;
     break;}
 case 418:
-#line 2011 "./parse.y"
+#line 2015 "./parse.y"
 {yyval.node = build_incdec (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node, 0); ;
     break;}
 case 419:
-#line 2013 "./parse.y"
+#line 2017 "./parse.y"
 {yyerror ("Missing term"); RECOVER;
     break;}
 case 420:
-#line 2018 "./parse.y"
+#line 2022 "./parse.y"
 {yyval.node = build_incdec (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node, 0); ;
     break;}
 case 421:
-#line 2020 "./parse.y"
+#line 2024 "./parse.y"
 {yyerror ("Missing term"); RECOVER;
     break;}
 case 423:
-#line 2026 "./parse.y"
+#line 2030 "./parse.y"
 {yyval.node = build_unaryop (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node); ;
     break;}
 case 424:
-#line 2028 "./parse.y"
+#line 2032 "./parse.y"
 {yyval.node = build_unaryop (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node); ;
     break;}
 case 426:
-#line 2031 "./parse.y"
+#line 2035 "./parse.y"
 {yyerror ("Missing term"); RECOVER;
     break;}
 case 427:
-#line 2033 "./parse.y"
+#line 2037 "./parse.y"
 {yyerror ("Missing term"); RECOVER;
     break;}
 case 428:
-#line 2038 "./parse.y"
+#line 2042 "./parse.y"
 { 
 		  tree type = yyvsp[-3].node;
 		  while (CURRENT_OSB (ctxp)--)
@@ -4439,15 +4442,15 @@
 		;
     break;}
 case 429:
-#line 2046 "./parse.y"
+#line 2050 "./parse.y"
 { yyval.node = build_cast (yyvsp[-3].operator.location, yyvsp[-2].node, yyvsp[0].node); ;
     break;}
 case 430:
-#line 2048 "./parse.y"
+#line 2052 "./parse.y"
 { yyval.node = build_cast (yyvsp[-3].operator.location, yyvsp[-2].node, yyvsp[0].node); ;
     break;}
 case 431:
-#line 2050 "./parse.y"
+#line 2054 "./parse.y"
 { 
 		  char *ptr;
 		  while (CURRENT_OSB (ctxp)--)
@@ -4462,11 +4465,11 @@
 		;
     break;}
 case 432:
-#line 2063 "./parse.y"
+#line 2067 "./parse.y"
 {yyerror ("']' expected, invalid type expression");;
     break;}
 case 433:
-#line 2065 "./parse.y"
+#line 2069 "./parse.y"
 {
 	          if (ctxp->prevent_ese != lineno)
 		    yyerror ("Invalid type expression"); RECOVER;
@@ -4474,243 +4477,243 @@
 		;
     break;}
 case 434:
-#line 2071 "./parse.y"
+#line 2075 "./parse.y"
 {yyerror ("Missing term"); RECOVER;;
     break;}
 case 435:
-#line 2073 "./parse.y"
+#line 2077 "./parse.y"
 {yyerror ("Missing term"); RECOVER;;
     break;}
 case 436:
-#line 2075 "./parse.y"
+#line 2079 "./parse.y"
 {yyerror ("Missing term"); RECOVER;;
     break;}
 case 438:
-#line 2081 "./parse.y"
+#line 2085 "./parse.y"
 { 
 		  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), 
 				    yyvsp[-1].operator.location, yyvsp[-2].node, yyvsp[0].node);
 		;
     break;}
 case 439:
-#line 2086 "./parse.y"
+#line 2090 "./parse.y"
 {
 		  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,
 				    yyvsp[-2].node, yyvsp[0].node); 
 		;
     break;}
 case 440:
-#line 2091 "./parse.y"
+#line 2095 "./parse.y"
 {
 		  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,
 				    yyvsp[-2].node, yyvsp[0].node); 
 		;
     break;}
 case 441:
-#line 2096 "./parse.y"
+#line 2100 "./parse.y"
 {yyerror ("Missing term"); RECOVER;;
     break;}
 case 442:
-#line 2098 "./parse.y"
+#line 2102 "./parse.y"
 {yyerror ("Missing term"); RECOVER;;
     break;}
 case 443:
-#line 2100 "./parse.y"
+#line 2104 "./parse.y"
 {yyerror ("Missing term"); RECOVER;;
     break;}
 case 445:
-#line 2106 "./parse.y"
+#line 2110 "./parse.y"
 {
 		  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,
 				    yyvsp[-2].node, yyvsp[0].node); 
 		;
     break;}
 case 446:
-#line 2111 "./parse.y"
+#line 2115 "./parse.y"
 {
 		  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,
 				    yyvsp[-2].node, yyvsp[0].node); 
 		;
     break;}
 case 447:
-#line 2116 "./parse.y"
+#line 2120 "./parse.y"
 {yyerror ("Missing term"); RECOVER;;
     break;}
 case 448:
-#line 2118 "./parse.y"
+#line 2122 "./parse.y"
 {yyerror ("Missing term"); RECOVER;;
     break;}
 case 450:
-#line 2124 "./parse.y"
+#line 2128 "./parse.y"
 {
 		  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,
 				    yyvsp[-2].node, yyvsp[0].node); 
 		;
     break;}
 case 451:
-#line 2129 "./parse.y"
+#line 2133 "./parse.y"
 {
 		  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,
 				    yyvsp[-2].node, yyvsp[0].node); 
 		;
     break;}
 case 452:
-#line 2134 "./parse.y"
+#line 2138 "./parse.y"
 {
 		  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,
 				    yyvsp[-2].node, yyvsp[0].node); 
 		;
     break;}
 case 453:
-#line 2139 "./parse.y"
+#line 2143 "./parse.y"
 {yyerror ("Missing term"); RECOVER;;
     break;}
 case 454:
-#line 2141 "./parse.y"
+#line 2145 "./parse.y"
 {yyerror ("Missing term"); RECOVER;;
     break;}
 case 455:
-#line 2143 "./parse.y"
+#line 2147 "./parse.y"
 {yyerror ("Missing term"); RECOVER;;
     break;}
 case 457:
-#line 2149 "./parse.y"
+#line 2153 "./parse.y"
 {
 		  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,
 				    yyvsp[-2].node, yyvsp[0].node); 
 		;
     break;}
 case 458:
-#line 2154 "./parse.y"
+#line 2158 "./parse.y"
 {
 		  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,
 				    yyvsp[-2].node, yyvsp[0].node); 
 		;
     break;}
 case 459:
-#line 2159 "./parse.y"
+#line 2163 "./parse.y"
 {
 		  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,
 				    yyvsp[-2].node, yyvsp[0].node); 
 		;
     break;}
 case 460:
-#line 2164 "./parse.y"
+#line 2168 "./parse.y"
 {
 		  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,
 				    yyvsp[-2].node, yyvsp[0].node); 
 		;
     break;}
 case 461:
-#line 2169 "./parse.y"
+#line 2173 "./parse.y"
 { yyval.node = build_binop (INSTANCEOF_EXPR, yyvsp[-1].operator.location, yyvsp[-2].node, yyvsp[0].node); ;
     break;}
 case 462:
-#line 2171 "./parse.y"
+#line 2175 "./parse.y"
 {yyerror ("Missing term"); RECOVER;;
     break;}
 case 463:
-#line 2173 "./parse.y"
+#line 2177 "./parse.y"
 {yyerror ("Missing term"); RECOVER;;
     break;}
 case 464:
-#line 2175 "./parse.y"
+#line 2179 "./parse.y"
 {yyerror ("Missing term"); RECOVER;;
     break;}
 case 465:
-#line 2177 "./parse.y"
+#line 2181 "./parse.y"
 {yyerror ("Missing term"); RECOVER;;
     break;}
 case 466:
-#line 2179 "./parse.y"
+#line 2183 "./parse.y"
 {yyerror ("Invalid reference type"); RECOVER;;
     break;}
 case 468:
-#line 2185 "./parse.y"
+#line 2189 "./parse.y"
 {
 		  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,
 				    yyvsp[-2].node, yyvsp[0].node); 
 		;
     break;}
 case 469:
-#line 2190 "./parse.y"
+#line 2194 "./parse.y"
 {
 		  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,
 				    yyvsp[-2].node, yyvsp[0].node); 
 		;
     break;}
 case 470:
-#line 2195 "./parse.y"
+#line 2199 "./parse.y"
 {yyerror ("Missing term"); RECOVER;;
     break;}
 case 471:
-#line 2197 "./parse.y"
+#line 2201 "./parse.y"
 {yyerror ("Missing term"); RECOVER;;
     break;}
 case 473:
-#line 2203 "./parse.y"
+#line 2207 "./parse.y"
 {
 		  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,
 				    yyvsp[-2].node, yyvsp[0].node); 
 		;
     break;}
 case 474:
-#line 2208 "./parse.y"
+#line 2212 "./parse.y"
 {yyerror ("Missing term"); RECOVER;;
     break;}
 case 476:
-#line 2214 "./parse.y"
+#line 2218 "./parse.y"
 {
 		  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,
 				    yyvsp[-2].node, yyvsp[0].node); 
 		;
     break;}
 case 477:
-#line 2219 "./parse.y"
+#line 2223 "./parse.y"
 {yyerror ("Missing term"); RECOVER;;
     break;}
 case 479:
-#line 2225 "./parse.y"
+#line 2229 "./parse.y"
 {
 		  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,
 				    yyvsp[-2].node, yyvsp[0].node); 
 		;
     break;}
 case 480:
-#line 2230 "./parse.y"
+#line 2234 "./parse.y"
 {yyerror ("Missing term"); RECOVER;;
     break;}
 case 482:
-#line 2236 "./parse.y"
+#line 2240 "./parse.y"
 {
 		  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,
 				    yyvsp[-2].node, yyvsp[0].node); 
 		;
     break;}
 case 483:
-#line 2241 "./parse.y"
+#line 2245 "./parse.y"
 {yyerror ("Missing term"); RECOVER;;
     break;}
 case 485:
-#line 2247 "./parse.y"
+#line 2251 "./parse.y"
 {
 		  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,
 				    yyvsp[-2].node, yyvsp[0].node); 
 		;
     break;}
 case 486:
-#line 2252 "./parse.y"
+#line 2256 "./parse.y"
 {yyerror ("Missing term"); RECOVER;;
     break;}
 case 488:
-#line 2258 "./parse.y"
+#line 2262 "./parse.y"
 {
 		  yyval.node = build (CONDITIONAL_EXPR, NULL_TREE, yyvsp[-4].node, yyvsp[-2].node, yyvsp[0].node);
 		  EXPR_WFL_LINECOL (yyval.node) = yyvsp[-3].operator.location;
 		;
     break;}
 case 489:
-#line 2263 "./parse.y"
+#line 2267 "./parse.y"
 {
 		  YYERROR_NOW;
 		  yyerror ("Missing term");
@@ -4718,19 +4721,19 @@
 		;
     break;}
 case 490:
-#line 2269 "./parse.y"
+#line 2273 "./parse.y"
 {yyerror ("Missing term"); DRECOVER (2);;
     break;}
 case 491:
-#line 2271 "./parse.y"
+#line 2275 "./parse.y"
 {yyerror ("Missing term"); DRECOVER (3);;
     break;}
 case 494:
-#line 2281 "./parse.y"
+#line 2285 "./parse.y"
 { yyval.node = build_assignment (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[-2].node, yyvsp[0].node); ;
     break;}
 case 495:
-#line 2283 "./parse.y"
+#line 2287 "./parse.y"
 {
 		  if (ctxp->prevent_ese != lineno)
 		    yyerror ("Missing term");
@@ -4739,7 +4742,7 @@
     break;}
 }
    /* the action file gets copied in in place of this dollarsign */
-#line 542 "/usr/lib/bison.simple"
+#line 543 "/usr/lib/bison.simple"
 
   yyvsp -= yylen;
   yyssp -= yylen;
@@ -4959,7 +4962,7 @@
     }
   return 1;
 }
-#line 2309 "./parse.y"
+#line 2313 "./parse.y"
 
 
 
@@ -5063,7 +5066,17 @@
     free (toFree);
 }
 
-/* Reporting JDK1.1 features not implemented */
+/* Reporting an constructor invocation error.  */
+static void
+parse_ctor_invocation_error ()
+{
+  if (DECL_CONSTRUCTOR_P (current_function_decl))
+    yyerror ("Constructor invocation must be first thing in a constructor"); 
+  else
+    yyerror ("Only constructors can invoke constructors");
+}
+
+/* Reporting JDK1.1 features not implemented.  */
 
 static tree
 parse_jdk1_1_error (msg)
@@ -5972,13 +5985,18 @@
 {
   tree meth = TREE_VALUE (mdecl);
   tree id = TREE_PURPOSE (mdecl);
-  tree this_class = TREE_TYPE (ctxp->current_parsed_class);
   tree type_wfl = NULL_TREE;
-  tree meth_name = NULL_TREE, current, orig_arg;
+  tree meth_name = NULL_TREE;
+  tree current, orig_arg, this_class;
   int saved_lineno;
   int constructor_ok = 0, must_chain;
   
   check_modifiers_consistency (flags);
+
+  if (ctxp->current_parsed_class)
+    this_class = TREE_TYPE (ctxp->current_parsed_class);
+  else
+    return NULL_TREE;
   
   /* There are some forbidden modifiers for an abstract method and its
      class must be abstract as well.  */
@@ -6174,7 +6192,12 @@
 finish_method_declaration (method_body)
      tree method_body;
 {
-  int flags = get_access_flags_from_decl (current_function_decl);
+  int flags;
+
+  if (!current_function_decl)
+    return;
+
+  flags = get_access_flags_from_decl (current_function_decl);
 
   /* 8.4.5 Method Body */
   if ((flags & ACC_ABSTRACT || flags & ACC_NATIVE) && method_body)
@@ -6989,7 +7012,9 @@
 
   /* Resolve and layout if necessary */
   layout_class_methods (TREE_TYPE (decl));
-  if (CLASS_FROM_SOURCE_P (TREE_TYPE (decl)))
+  /* Check methods, but only once */
+  if (CLASS_FROM_SOURCE_P (TREE_TYPE (decl)) 
+      && !CLASS_LOADED_P (TREE_TYPE (decl)))
     CHECK_METHODS (decl);
   if (TREE_TYPE (decl) != current_class && !CLASS_LOADED_P (TREE_TYPE (decl)))
     safe_layout_class (TREE_TYPE (decl));
@@ -7170,7 +7195,7 @@
 
 /* Track method being redefined inside the same class. As a side
    effect, set DECL_NAME to an IDENTIFIER (prior entering this
-   function it's a FWL, so we can track errors more accurately */
+   function it's a FWL, so we can track errors more accurately.)  */
 
 static int
 check_method_redefinition (class, method)
@@ -7206,9 +7231,126 @@
   return 0;
 }
 
-/* Check all the methods of CLASS. Methods are first completed then
-   checked according to regular method existance rules.
-   If no constructor were encountered, then build its declaration. */
+static void
+check_abstract_method_definitions (do_interface, class_decl, type)
+     int do_interface;
+     tree class_decl, type;
+{
+  tree class = TREE_TYPE (class_decl);
+  tree method, end_type;
+
+  end_type = (do_interface ? object_type_node : type);
+  for (method = TYPE_METHODS (type); method; method = TREE_CHAIN (method))
+    {
+      tree other_super, other_method, method_sig, method_name;
+      int found = 0;
+      
+      if (!METHOD_ABSTRACT (method) || METHOD_FINAL (method))
+       continue;
+      
+      /* Now verify that somewhere in between TYPE and CLASS,
+        abstract method METHOD gets a non abstract definition
+        that is inherited by CLASS.  */
+      
+      method_sig = build_java_signature (TREE_TYPE (method));
+      method_name = DECL_NAME (method);
+      if (TREE_CODE (method_name) == EXPR_WITH_FILE_LOCATION)
+       method_name = EXPR_WFL_NODE (method_name);
+
+      for (other_super = class; other_super != end_type; 
+          other_super = CLASSTYPE_SUPER (other_super))
+       {
+         for (other_method = TYPE_METHODS (other_super); other_method;
+              other_method = TREE_CHAIN (other_method))
+           {
+             tree s = build_java_signature (TREE_TYPE (other_method));
+             tree other_name = DECL_NAME (other_method);
+
+             if (TREE_CODE (other_name) == EXPR_WITH_FILE_LOCATION)
+               other_name = EXPR_WFL_NODE (other_name);
+             if (!IS_CLINIT (other_method)
+                 && !DECL_CONSTRUCTOR_P (other_method)
+                 && method_name == other_name && method_sig == s)
+               {
+                 found = 1;
+                 break;
+               }
+           }
+       }
+      
+      /* Report that abstract METHOD didn't find an implementation
+        that CLASS can use. */
+      if (!found)
+       {
+         char *t = strdup (lang_printable_name 
+                           (TREE_TYPE (TREE_TYPE (method)), 0));
+         tree ccn = DECL_NAME (TYPE_NAME (DECL_CONTEXT (method)));
+         tree saved_wfl = NULL_TREE;
+         
+         if (TREE_CODE (DECL_NAME (method)) == EXPR_WITH_FILE_LOCATION)
+           {
+             saved_wfl = DECL_NAME (method);
+             DECL_NAME (method) = EXPR_WFL_NODE (DECL_NAME (method));
+           }
+         
+         parse_error_context 
+           (lookup_cl (class_decl),
+            "Class `%s' doesn't define the abstract method `%s %s' from "
+            "%s `%s'. This method must be defined or %s `%s' must be "
+            "declared abstract",
+            IDENTIFIER_POINTER (DECL_NAME (class_decl)),
+            t, lang_printable_name (method, 0), 
+            (CLASS_INTERFACE (TYPE_NAME (DECL_CONTEXT (method))) ? 
+             "interface" : "class"),
+            IDENTIFIER_POINTER (ccn),
+            (CLASS_INTERFACE (class_decl) ? "interface" : "class"),
+            IDENTIFIER_POINTER (DECL_NAME (class_decl)));
+         
+         free (t);
+         
+         if (saved_wfl)
+           DECL_NAME (method) = saved_wfl;
+       }
+    }
+}
+
+/* Check that CLASS_DECL somehoow implements all inherited abstract
+   methods.  */
+
+static void
+java_check_abstract_method_definitions (class_decl)
+     tree class_decl;
+{
+  tree class = TREE_TYPE (class_decl);
+  tree super, vector;
+  int i;
+
+  if (CLASS_ABSTRACT (class_decl))
+    return;
+
+  /* Check for inherited types */
+  for (super = CLASSTYPE_SUPER (class); super != object_type_node; 
+       super = CLASSTYPE_SUPER (super))
+    {
+      if (!CLASS_ABSTRACT (TYPE_NAME (super)))
+       continue;
+
+      check_abstract_method_definitions (0, class_decl, super);
+    }
+
+  /* Check for implemented interfaces. */
+  vector = TYPE_BINFO_BASETYPES (class);
+  for (i = 1; i < TREE_VEC_LENGTH (vector); i++)
+    {
+      super = BINFO_TYPE (TREE_VEC_ELT (vector, i));
+      check_abstract_method_definitions (1, class_decl, super);
+    }
+}
+
+/* Check all the methods of CLASS_DECL. Methods are first completed
+   then checked according to regular method existance rules.  If no
+   constructor for CLASS_DECL were encountered, then build its
+   declaration.  */
 
 static void
 java_check_regular_methods (class_decl)
@@ -7384,7 +7526,7 @@
   
   /* Don't forget eventual pending found and saved_found_wfl. Take
      into account that we might have exited because we saw an
-     aritifical method as the last entry. */
+     artificial method as the last entry. */
 
   if (found && !DECL_ARTIFICIAL (found) && saved_found_wfl)
     DECL_NAME (found) = saved_found_wfl;
@@ -7392,6 +7534,10 @@
   if (!TYPE_NVIRTUALS (class))
     TYPE_METHODS (class) = nreverse (TYPE_METHODS (class));
 
+  /* Search for inherited abstract method not yet implemented in this
+     class.  */
+  java_check_abstract_method_definitions (class_decl);
+
   if (!saw_constructor)
     {
       /* No constructor seen, we craft one, at line 0. Since this
@@ -7597,14 +7743,15 @@
   return NULL_TREE;
 }
 
-/* Return the line that matches DECL line number. Used during error
-   report */
+/* Return the line that matches DECL line number, and try its best to
+   position the column number. Used during error reports.  */
 
 static tree
 lookup_cl (decl)
      tree decl;
 {
   static tree cl = NULL_TREE;
+  char *line, *found;
   
   if (!decl)
     return NULL_TREE;
@@ -7615,6 +7762,14 @@
   EXPR_WFL_FILENAME_NODE (cl) = get_identifier (DECL_SOURCE_FILE (decl));
   EXPR_WFL_SET_LINECOL (cl, DECL_SOURCE_LINE_FIRST (decl), -1);
 
+  line = java_get_line_col (IDENTIFIER_POINTER (EXPR_WFL_FILENAME_NODE (cl)),
+                           EXPR_WFL_LINENO (cl), EXPR_WFL_COLNO (cl));
+
+  found = strstr ((const char *)line, 
+                 (const char *)IDENTIFIER_POINTER (DECL_NAME (decl)));
+  if (found)
+    EXPR_WFL_SET_LINECOL (cl, EXPR_WFL_LINENO (cl), found - line);
+
   return cl;
 }
 
@@ -8149,6 +8304,9 @@
   tree parm_decl;
   int i;
 
+  if (!fndecl)
+    return;
+
   current_function_decl = fndecl;
 
   /* New scope for the function */
@@ -8268,6 +8426,9 @@
   tree fndecl = current_function_decl;
   int flag_asynchronous_exceptions = asynchronous_exceptions;
 
+  if (!fndecl)
+    return;
+
   java_parser_context_save_global ();
   lineno = ctxp->last_ccb_indent1;
 
@@ -8323,6 +8484,8 @@
 java_method_add_stmt (fndecl, expr)
      tree fndecl, expr;
 {
+  if (!GET_CURRENT_BLOCK (fndecl))
+    return NULL_TREE;
   return add_stmt_to_block (GET_CURRENT_BLOCK (fndecl), NULL_TREE, expr);
 }
 
@@ -8721,7 +8884,8 @@
       for (mdecl = TYPE_METHODS (class); mdecl; mdecl = TREE_CHAIN (mdecl))
 	{
 	  if (DECL_CONSTRUCTOR_P (mdecl)
-	      && TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (mdecl))) == end_params_node)
+             && TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (mdecl))) 
+                == end_params_node)
 	    return 0;
 	}
     }
@@ -9064,6 +9228,8 @@
 	       == soft_initclass_node)
 	     return TREE_OPERAND (op1, 1);
 	 }
+      else if (JDECL_P (op1))
+       return op1;
     }
   return node;
 }
@@ -9085,6 +9251,8 @@
   for (q = EXPR_WFL_QUALIFICATION (wfl); q; q = TREE_CHAIN (q))
     {
       tree qual_wfl = QUAL_WFL (q);
+      tree ret_decl;           /* for EH checking */
+      int location;            /* for EH checking */
 
       /* 15.10.1 Field Access Using a Primary */
       switch (TREE_CODE (qual_wfl))
@@ -9103,14 +9271,21 @@
 	  /* And code for the function call */
 	  if (complete_function_arguments (qual_wfl))
 	    return 1;
+         
 	  if (from_super && TREE_CODE (qual_wfl) == CALL_EXPR)
 	    CALL_USING_SUPER (qual_wfl) = 1;
-	  *where_found = 
-	    patch_method_invocation (qual_wfl, decl, type, &is_static, NULL);
+         location = (TREE_CODE (qual_wfl) == CALL_EXPR ?
+                     EXPR_WFL_LINECOL (TREE_OPERAND (qual_wfl, 0)) : 0);
+         *where_found = patch_method_invocation (qual_wfl, decl, type, 
+                                                 &is_static, &ret_decl);
 	  if (*where_found == error_mark_node)
 	    return 1;
 	  *type_found = type = QUAL_DECL_TYPE (*where_found);
 
+         /* EH check */
+         if (location)
+           check_thrown_exceptions (location, ret_decl);
+
 	  /* If the previous call was static and this one is too,
 	     build a compound expression to hold the two (because in
 	     that case, previous function calls aren't transported as
@@ -9145,6 +9320,7 @@
 
 	case CONDITIONAL_EXPR:
 	case STRING_CST:
+	case MODIFY_EXPR:
 	  *where_found = decl = java_complete_tree (qual_wfl);
 	  if (decl == error_mark_node)
 	    return 1;
@@ -9882,6 +10058,11 @@
     if (JPRIMITIVE_TYPE_P (TREE_TYPE (TREE_VALUE (ta))) &&
 	TREE_TYPE (TREE_VALUE (ta)) != TREE_VALUE (t))
       TREE_VALUE (ta) = convert (TREE_VALUE (t), TREE_VALUE (ta));
+
+  /* Resolve unresolved returned type isses */
+  t = TREE_TYPE (TREE_TYPE (method));
+  if (TREE_CODE (t) == POINTER_TYPE && !CLASS_LOADED_P (TREE_TYPE (t)))
+    resolve_and_layout (TREE_TYPE (t), NULL);
   
   if (flag_emit_class_files || flag_emit_xref)
     func = method;
@@ -10042,7 +10223,7 @@
   parse_error_context (cl, "Can't find %s `%s(%s)' in class `%s'%s",
 		       (lc ? "constructor" : "method"),
 		       (lc ? 
-			IDENTIFIER_POINTER(DECL_NAME (TYPE_NAME (class))) :
+                       IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (class))) :
 			IDENTIFIER_POINTER (name)),
 		       IDENTIFIER_POINTER (signature),
 		       IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (class))),
@@ -10061,7 +10242,8 @@
   tree list = NULL_TREE, all_list = NULL_TREE;
 
   /* Search interfaces */
-  if (CLASS_INTERFACE (TYPE_NAME (class)))
+  if (CLASS_INTERFACE (TYPE_NAME (class)) 
+      || CLASS_ABSTRACT (TYPE_NAME (class)))
     {
       static tree searched_interfaces = NULL_TREE;
       static int search_not_done = 0;
@@ -10292,7 +10474,7 @@
 	break;
       case NEW_ARRAY_EXPR:
 	qual = TREE_CHAIN (qual);
-	new_array_found = 1;
+       again = new_array_found = 1;
 	continue;
       case NEW_CLASS_EXPR:
       case CONVERT_EXPR:
@@ -10320,12 +10502,8 @@
 	&& TREE_CODE (TREE_TYPE (qual_wfl)) == EXPR_WITH_FILE_LOCATION)
       name = EXPR_WFL_NODE (TREE_TYPE (qual_wfl));
 
-    else if (code == ARRAY_REF &&
-	     TREE_CODE (TREE_OPERAND (qual_wfl, 0)) == EXPR_WITH_FILE_LOCATION)
-      name = EXPR_WFL_NODE (TREE_OPERAND (qual_wfl, 0));
-
-    else if (code == CALL_EXPR && 
-	     TREE_CODE (TREE_OPERAND (qual_wfl, 0)) == EXPR_WITH_FILE_LOCATION)
+    else if ((code == ARRAY_REF || code == CALL_EXPR || code == MODIFY_EXPR) &&
+    	TREE_CODE (TREE_OPERAND (qual_wfl, 0)) == EXPR_WITH_FILE_LOCATION)
       name = EXPR_WFL_NODE (TREE_OPERAND (qual_wfl, 0));
 
     else if (code == STRING_CST || code == CONDITIONAL_EXPR)
@@ -10335,8 +10513,15 @@
 	again = 1;
       }
     else 
-      name = EXPR_WFL_NODE (qual_wfl);
-    
+      {
+       name = EXPR_WFL_NODE (qual_wfl);
+       if (!name)
+         {
+           qual = EXPR_WFL_QUALIFICATION (qual_wfl);
+           again = 1;
+         }
+      }
+
     /* If we have a THIS (from a primary), we set the context accordingly */
     if (name == this_identifier_node)
       {
@@ -10370,7 +10555,8 @@
      declaration or parameter declaration, then it is an expression
      name. We don't carry this test out if we're in the context of the
      use of SUPER or THIS */
-  if (!this_found && !super_found && (decl = IDENTIFIER_LOCAL_VALUE (name)))
+  if (!this_found && !super_found && 
+      TREE_CODE (name) != STRING_CST && (decl = IDENTIFIER_LOCAL_VALUE (name)))
     {
       RESOLVE_EXPRESSION_NAME_P (qual_wfl) = 1;
       QUAL_RESOLUTION (qual) = decl;
@@ -10387,15 +10573,17 @@
       QUAL_RESOLUTION (qual) = (new_array_found ? NULL_TREE : decl);
     }
 
-  /* We reclassify NAME as a type name if:
+  /* We reclassify NAME as yielding to a type name resolution if:
      - NAME is a class/interface declared within the compilation
        unit containing NAME,
      - NAME is imported via a single-type-import declaration,
      - NAME is declared in an another compilation unit of the package
        of the compilation unit containing NAME,
      - NAME is declared by exactly on type-import-on-demand declaration
-     of the compilation unit containing NAME. */
-  else if ((decl = resolve_and_layout (name, NULL_TREE)))
+     of the compilation unit containing NAME. 
+     - NAME is actually a STRING_CST. */
+  else if (TREE_CODE (name) == STRING_CST ||
+          (decl = resolve_and_layout (name, NULL_TREE)))
     {
       RESOLVE_TYPE_NAME_P (qual_wfl) = 1;
       QUAL_RESOLUTION (qual) = decl;
@@ -10480,7 +10668,9 @@
     {
       tree value = DECL_INITIAL (node);
       DECL_INITIAL (node) = NULL_TREE;
+      push_obstacks (&permanent_obstack, &permanent_obstack);
       value = fold_constant_for_init (value, node);
+      pop_obstacks ();
       DECL_INITIAL (node) = value;
       if (value != NULL_TREE)
 	return value;
@@ -10500,8 +10690,7 @@
       TREE_OPERAND (node, 1) = java_stabilize_reference (op1);
       return node;
     }
-  else
-    return stabilize_reference (node);
+  return stabilize_reference (node);
 }
 
 /* Patch tree nodes in a function body. When a BLOCK is found, push
@@ -10683,8 +10872,12 @@
 	  && JDECL_P (TREE_OPERAND (cn, 1))
 	  && FIELD_FINAL (TREE_OPERAND (cn, 1))
 	  && DECL_INITIAL (TREE_OPERAND (cn, 1)))
-	cn = fold_constant_for_init (DECL_INITIAL (TREE_OPERAND (cn, 1)),
-				     TREE_OPERAND (cn, 1));
+       {
+         push_obstacks (&permanent_obstack, &permanent_obstack);
+         cn = fold_constant_for_init (DECL_INITIAL (TREE_OPERAND (cn, 1)),
+                                      TREE_OPERAND (cn, 1));
+         pop_obstacks ();
+       }
 
       if (!TREE_CONSTANT (cn) && !flag_emit_xref)
 	{
@@ -10937,7 +11130,11 @@
 	  && TREE_CODE (nn) == VAR_DECL && TREE_STATIC (nn)
 	  && DECL_INITIAL (nn) != NULL_TREE)
 	{
-	  tree value = fold_constant_for_init (nn, nn);
+         tree value;
+         
+         push_obstacks (&permanent_obstack, &permanent_obstack);
+         value = fold_constant_for_init (nn, nn);
+         pop_obstacks ();
 	  if (value != NULL_TREE)
 	    {
 	      tree type = TREE_TYPE (value);
@@ -10951,14 +11148,17 @@
       if (TREE_OPERAND (node, 0) == error_mark_node)
 	return error_mark_node;
 
-      if (COMPOUND_ASSIGN_P (wfl_op2))
+      flag = COMPOUND_ASSIGN_P (wfl_op2);
+      if (flag)
 	{
 	  tree lvalue = java_stabilize_reference (TREE_OPERAND (node, 0)); 
 
 	  /* Hand stablize the lhs on both places */
 	  TREE_OPERAND (node, 0) = lvalue;
-	  TREE_OPERAND (TREE_OPERAND (node, 1), 0) = lvalue;
+         TREE_OPERAND (TREE_OPERAND (node, 1), 0) = 
+           (flag_emit_class_files ? lvalue : save_expr (lvalue));
 
+         /* 15.25.2.a: Left hand is not an array access. FIXME */
 	  /* Now complete the RHS. We write it back later on. */
 	  nn = java_complete_tree (TREE_OPERAND (node, 1));
 
@@ -10969,6 +11169,8 @@
 	     E1 = (T)(E1 op E2), with T being the type of E1. */
 	  nn = java_complete_tree (build_cast (EXPR_WFL_LINECOL (wfl_op2), 
 					       TREE_TYPE (lvalue), nn));
+
+         /* 15.25.2.b: Left hand is an array access. FIXME */
 	}
 
       /* If we're about to patch a NEW_ARRAY_INIT, we call a special
@@ -10992,6 +11194,10 @@
       if ((nn = patch_string (TREE_OPERAND (node, 1))))
 	TREE_OPERAND (node, 1) = nn;
       node = patch_assignment (node, wfl_op1, wfl_op2);
+      /* Reorganize the tree if necessary. */
+      if (flag && (!JREFERENCE_TYPE_P (TREE_TYPE (node)) 
+                  || JSTRING_P (TREE_TYPE (node))))
+       node = java_refold (node);
       CAN_COMPLETE_NORMALLY (node) = 1;
       return node;
 
@@ -12000,6 +12206,81 @@
 #undef BUILD_OPERATOR_STRING
 }
 
+/* Return 1 if VAR_ACCESS1 is equivalent to VAR_ACCESS2.  */
+
+static int
+java_decl_equiv (var_acc1, var_acc2)
+     tree var_acc1, var_acc2;
+{
+  if (JDECL_P (var_acc1))
+    return (var_acc1 == var_acc2);
+  
+  return (TREE_CODE (var_acc1) == COMPONENT_REF
+         && TREE_CODE (var_acc2) == COMPONENT_REF
+         && TREE_OPERAND (TREE_OPERAND (var_acc1, 0), 0)
+            == TREE_OPERAND (TREE_OPERAND (var_acc2, 0), 0)
+         && TREE_OPERAND (var_acc1, 1) == TREE_OPERAND (var_acc2, 1));
+}
+
+/* Return a non zero value if CODE is one of the operators that can be
+   used in conjunction with the `=' operator in a compound assignment.  */
+
+static int
+binop_compound_p (code)
+    enum tree_code code;
+{
+  int i;
+  for (i = 0; i < BINOP_COMPOUND_CANDIDATES; i++)
+    if (binop_lookup [i] == code)
+      break;
+
+  return i < BINOP_COMPOUND_CANDIDATES;
+}
+
+/* Reorganize after a fold to get SAVE_EXPR to generate what we want.  */
+
+static tree
+java_refold (t)
+     tree t;
+{
+  tree c, b, ns, decl;
+
+  if (TREE_CODE (t) != MODIFY_EXPR)
+    return t;
+
+  c = TREE_OPERAND (t, 1);
+  if (! (c && TREE_CODE (c) == COMPOUND_EXPR
+        && TREE_CODE (TREE_OPERAND (c, 0)) == MODIFY_EXPR
+        && binop_compound_p (TREE_CODE (TREE_OPERAND (c, 1)))))
+    return t;
+
+  /* Now the left branch of the binary operator. */
+  b = TREE_OPERAND (TREE_OPERAND (c, 1), 0);
+  if (! (b && TREE_CODE (b) == NOP_EXPR 
+        && TREE_CODE (TREE_OPERAND (b, 0)) == SAVE_EXPR))
+    return t;
+
+  ns = TREE_OPERAND (TREE_OPERAND (b, 0), 0);
+  if (! (ns && TREE_CODE (ns) == NOP_EXPR
+        && TREE_CODE (TREE_OPERAND (ns, 0)) == SAVE_EXPR))
+    return t;
+
+  decl = TREE_OPERAND (TREE_OPERAND (ns, 0), 0);
+  if ((JDECL_P (decl) || TREE_CODE (decl) == COMPONENT_REF)
+      /* It's got to be the an equivalent decl */
+      && java_decl_equiv (decl, TREE_OPERAND (TREE_OPERAND (c, 0), 0)))
+    {
+      /* Shorten the NOP_EXPR/SAVE_EXPR path. */
+      TREE_OPERAND (TREE_OPERAND (c, 1), 0) = TREE_OPERAND (ns, 0);
+      /* Substitute the COMPOUND_EXPR by the BINOP_EXPR */
+      TREE_OPERAND (t, 1) = TREE_OPERAND (c, 1);
+      /* Change the right part of the BINOP_EXPR */
+      TREE_OPERAND (TREE_OPERAND (t, 1), 1) = TREE_OPERAND (c, 0);
+    }
+
+  return t;
+}
+
 /* Binary operators (15.16 up to 15.18). We return error_mark_node on
    errors but we modify NODE so that it contains the type computed
    according to the expression, when it's fixed. Otherwise, we write
@@ -12046,6 +12327,12 @@
       if (code == RDIV_EXPR && TREE_CODE (prom_type) == INTEGER_TYPE)
 	TREE_SET_CODE (node, TRUNC_DIV_EXPR);
 
+      if (TREE_CODE (prom_type) == INTEGER_TYPE
+        && flag_use_divide_subroutine
+        && ! flag_emit_class_files
+        && (code == RDIV_EXPR || code == TRUNC_MOD_EXPR))
+      return build_java_soft_divmod (TREE_CODE (node), prom_type, op1, op2);
+ 
       /* This one is more complicated. FLOATs are processed by a
 	 function call to soft_fmod. Duplicate the value of the
 	 COMPOUND_ASSIGN_P flag. */
@@ -12658,7 +12945,7 @@
     case PREINCREMENT_EXPR:
       /* 15.14.2 Prefix Decrement Operator -- */
     case PREDECREMENT_EXPR:
-      decl = strip_out_static_field_access_decl (op);
+      op = decl = strip_out_static_field_access_decl (op);
       /* We really should have a JAVA_ARRAY_EXPR to avoid this */
       if (!JDECL_P (decl) 
 	  && TREE_CODE (decl) != COMPONENT_REF
@@ -12697,15 +12984,28 @@
       else
 	{
 	  /* Before the addition, binary numeric promotion is performed on
-	     both operands */
-	  value = build_int_2 (1, 0);
-	  TREE_TYPE (node) = 
-	    binary_numeric_promotion (op_type, TREE_TYPE (value), &op, &value);
-	  /* And write the promoted incremented and increment */
+            both operands, if really necessary */
+         if (JINTEGRAL_TYPE_P (op_type))
+           {
+             value = build_int_2 (1, 0);
+             TREE_TYPE (value) = TREE_TYPE (node) = op_type;
+           }
+         else
+           {
+             value = build_int_2 (1, 0);
+             TREE_TYPE (node) = 
+               binary_numeric_promotion (op_type, 
+                                         TREE_TYPE (value), &op, &value);
+           }
+         /* And write back into the node. */
 	  TREE_OPERAND (node, 0) = op;
 	  TREE_OPERAND (node, 1) = value;
-	  /* Convert the overall back into its original type. */
-	  return fold (convert (op_type, node));
+         /* Convert the overall back into its original type, if
+             necessary, and return */
+         if (JINTEGRAL_TYPE_P (op_type))
+           return fold (node);
+         else
+           return fold (convert (op_type, node));
 	}
       break;
 
@@ -13210,6 +13510,7 @@
   new_value = NULL_TREE;
   wfl_value = TREE_VALUE (entry);
 
+  push_obstacks (&permanent_obstack, &permanent_obstack);
   value = java_complete_tree (TREE_VALUE (entry));
   /* patch_string return error_mark_node if arg is error_mark_node */
   if ((patched = patch_string (value)))
@@ -13225,7 +13526,8 @@
   new_value = try_builtin_assignconv (wfl_operator, type, value);
   if (!new_value && (new_value = try_reference_assignconv (type, value)))
     type_value = promote_type (type);
-  
+
+  pop_obstacks ();
   /* Check and report errors */
   if (!new_value)
     {
@@ -13564,6 +13866,54 @@
   return loop;
 }
 
+/* Try to find the loop a block might be related to. This comprises
+   the case where the LOOP_EXPR is found as the second operand of a
+   COMPOUND_EXPR, because the loop happens to have an initialization
+   part, then expressed as the first operand of the COMPOUND_EXPR. If
+   the search finds something, 1 is returned. Otherwise, 0 is
+   returned. The search is assumed to start from a
+   LABELED_BLOCK_EXPR's block.  */
+
+static tree
+search_loop (statement)
+    tree statement;
+{
+  if (TREE_CODE (statement) == LOOP_EXPR)
+    return statement;
+
+  if (TREE_CODE (statement) == BLOCK)
+    statement = BLOCK_SUBBLOCKS (statement);
+  else
+    return NULL_TREE;
+
+  if (statement && TREE_CODE (statement) == COMPOUND_EXPR)
+    while (statement && TREE_CODE (statement) == COMPOUND_EXPR)
+      statement = TREE_OPERAND (statement, 1);
+
+  return (TREE_CODE (statement) == LOOP_EXPR
+         && IS_FOR_LOOP_P (statement) ? statement : NULL_TREE);
+}
+
+/* Return 1 if LOOP can be found in the labeled block BLOCK. 0 is
+   returned otherwise.  */
+
+static int
+labeled_block_contains_loop_p (block, loop)
+    tree block, loop;
+{
+  if (!block)
+    return 0;
+
+  if (LABELED_BLOCK_BODY (block) == loop)
+    return 1;
+
+  if (IS_FOR_LOOP_P (loop) 
+      && search_loop (LABELED_BLOCK_BODY (block)) == loop)
+    return 1;
+
+  return 0;
+}
+
 /* If the loop isn't surrounded by a labeled statement, create one and
    insert LOOP as its body.  */
 
@@ -13572,33 +13922,17 @@
      tree loop;
 {
   tree loop_label;
-  tree block = ctxp->current_labeled_block;
+
   TREE_TYPE (loop) = void_type_node;
-  if (block != NULL_TREE)
-    {
-      tree block_body = LABELED_BLOCK_BODY (block);
-      if (IS_FOR_LOOP_P (loop))
-	{
-	  if (TREE_CODE (block_body) == BLOCK)
-	    {
-	      block_body = BLOCK_EXPR_BODY (block_body);
-	      if (block_body == loop
-		  || (TREE_CODE (block_body) == COMPOUND_EXPR
-		      && TREE_OPERAND (block_body, 1) == loop))
-		return loop;
-	    }
-	}
-      else
-	{
-	  if (block_body == loop)
-	    return loop;
-	}
-    }
+  if (labeled_block_contains_loop_p (ctxp->current_labeled_block, loop))
+    return loop;
+
   loop_label = build_labeled_block (0, NULL_TREE);
+  /* LOOP is an EXPR node, so it should have a valid EXPR_WFL_LINECOL
+     that LOOP_LABEL could enquire about, for a better accuracy. FIXME */
   LABELED_BLOCK_BODY (loop_label) = loop;
   PUSH_LABELED_BLOCK (loop_label);
-  loop = loop_label;
-  return loop;
+  return loop_label;
 }
 
 /* 14.13, 14.14: break and continue Statements */
@@ -13690,7 +14024,7 @@
 	    }
 	  target_stmt = LABELED_BLOCK_BODY (labeled_block);
 	  if (TREE_CODE (target_stmt) == SWITCH_EXPR
-	      || TREE_CODE (target_stmt) == LOOP_EXPR)
+             || search_loop (target_stmt))
 	    {
 	      bc_label = labeled_block;
 	      break;
@@ -13704,7 +14038,7 @@
   /* Our break/continue don't return values. */
   TREE_TYPE (node) = void_type_node;
   /* Encapsulate the break within a compound statement so that it's
-     expanded all the times by expand_expr (and not clobered
+     expanded all the times by expand_expr (and not clobbered
      sometimes, like after a if statement) */
   node = add_stmt_to_compound (NULL_TREE, void_type_node, node);
   TREE_SIDE_EFFECTS (node) = 1;
@@ -14099,11 +14433,20 @@
 	  continue;
 #endif
 	EXPR_WFL_LINECOL (wfl_operator) = location;
-	parse_error_context 
-	  (wfl_operator, "Exception `%s' must be caught, or it must be "
-	   "declared in the `throws' clause of `%s'", 
-	   lang_printable_name (TREE_VALUE (throws), 0),
-	   IDENTIFIER_POINTER (DECL_NAME (current_function_decl)));
+       if (DECL_NAME (current_function_decl) == finit_identifier_node)
+         parse_error_context
+            (wfl_operator, "Exception `%s' can't be thrown in initializer",
+            lang_printable_name (TREE_VALUE (throws), 0));
+       else 
+         {
+           parse_error_context 
+             (wfl_operator, "Exception `%s' must be caught, or it must be "
+              "declared in the `throws' clause of `%s'", 
+              lang_printable_name (TREE_VALUE (throws), 0),
+              (DECL_NAME (current_function_decl) == init_identifier_node ?
+               IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (current_class))) :
+               IDENTIFIER_POINTER (DECL_NAME (current_function_decl))));
+         }
       }
 }
 
Only in gcc-2.95.2/gcc/java: parse.c.orig
Only in gcc-2.95.2/gcc/java: parse.c.rej
diff -u -r gcc-2.95.2-orig/gcc/java/parse.y gcc-2.95.2/gcc/java/parse.y
--- gcc-2.95.2-orig/gcc/java/parse.y	Mon Jun 28 15:56:22 1999
+++ gcc-2.95.2/gcc/java/parse.y	Sun Oct 31 21:27:43 1999
@@ -91,6 +91,7 @@
 static void parse_warning_context PVPROTO ((tree cl, const char *msg, ...))
   ATTRIBUTE_PRINTF_2;
 static void issue_warning_error_from_context PROTO ((tree, const char *msg, va_list));
+static void parse_ctor_invocation_error PROTO ((void));
 static tree parse_jdk1_1_error PROTO ((char *));
 static void complete_class_report_errors PROTO ((jdep *));
 static int process_imports PROTO ((void));
@@ -243,6 +244,7 @@
 static tree strip_out_static_field_access_decl PROTO ((tree));
 static jdeplist *reverse_jdep_list PROTO ((struct parser_ctxt *));
 static void static_ref_err PROTO ((tree, tree, tree));
+static tree java_refold PROTO ((tree));
 
 /* Number of error found so far. */
 int java_error_count; 
@@ -274,6 +276,10 @@
   binop_lookup [((VALUE) - PLUS_TK)%					\
 		(sizeof (binop_lookup) / sizeof (binop_lookup[0]))]
 
+/* This is the end index for binary operators that can also be used
+   in compound assignements. */
+#define BINOP_COMPOUND_CANDIDATES 11
+
 /* Fake WFL used to report error message. It is initialized once if
    needed and reused with it's location information is overriden.  */
 tree wfl_operator = NULL_TREE;
@@ -1318,16 +1324,14 @@
 		{yyerror ("')' expected"); RECOVER;}
 |       this_or_super OP_TK CP_TK error
 		{
-		  yyerror ("Constructor invocation must be first "
-			   "thing in a constructor"); 
+                  parse_ctor_invocation_error ();		
 		  RECOVER;
 		}
 |       this_or_super OP_TK argument_list error
 		{yyerror ("')' expected"); RECOVER;}
 |       this_or_super OP_TK argument_list CP_TK error
 		{
-		  yyerror ("Constructor invocation must be first "
-			   "thing in a constructor"); 
+		  parse_ctor_invocation_error ();			   
 		  RECOVER;
 		}
 |	name DOT_TK SUPER_TK error
@@ -2409,7 +2413,17 @@
     free (toFree);
 }
 
-/* Reporting JDK1.1 features not implemented */
+/* Reporting an constructor invocation error.  */
+static void
+parse_ctor_invocation_error ()
+{
+  if (DECL_CONSTRUCTOR_P (current_function_decl))
+    yyerror ("Constructor invocation must be first thing in a constructor"); 
+  else
+    yyerror ("Only constructors can invoke constructors");
+}
+
+/* Reporting JDK1.1 features not implemented.  */
 
 static tree
 parse_jdk1_1_error (msg)
@@ -3318,13 +3332,18 @@
 {
   tree meth = TREE_VALUE (mdecl);
   tree id = TREE_PURPOSE (mdecl);
-  tree this_class = TREE_TYPE (ctxp->current_parsed_class);
   tree type_wfl = NULL_TREE;
-  tree meth_name = NULL_TREE, current, orig_arg;
+  tree meth_name = NULL_TREE;
+  tree current, orig_arg, this_class;
   int saved_lineno;
   int constructor_ok = 0, must_chain;
   
   check_modifiers_consistency (flags);
+
+  if (ctxp->current_parsed_class)
+    this_class = TREE_TYPE (ctxp->current_parsed_class);
+  else
+    return NULL_TREE;
   
   /* There are some forbidden modifiers for an abstract method and its
      class must be abstract as well.  */
@@ -3520,7 +3539,12 @@
 finish_method_declaration (method_body)
      tree method_body;
 {
-  int flags = get_access_flags_from_decl (current_function_decl);
+  int flags;
+
+  if (!current_function_decl)
+    return;
+
+  flags = get_access_flags_from_decl (current_function_decl);
 
   /* 8.4.5 Method Body */
   if ((flags & ACC_ABSTRACT || flags & ACC_NATIVE) && method_body)
@@ -4335,7 +4359,9 @@
 
   /* Resolve and layout if necessary */
   layout_class_methods (TREE_TYPE (decl));
-  if (CLASS_FROM_SOURCE_P (TREE_TYPE (decl)))
+  /* Check methods, but only once */
+  if (CLASS_FROM_SOURCE_P (TREE_TYPE (decl)) 
+      && !CLASS_LOADED_P (TREE_TYPE (decl)))
     CHECK_METHODS (decl);
   if (TREE_TYPE (decl) != current_class && !CLASS_LOADED_P (TREE_TYPE (decl)))
     safe_layout_class (TREE_TYPE (decl));
@@ -4516,7 +4542,7 @@
 
 /* Track method being redefined inside the same class. As a side
    effect, set DECL_NAME to an IDENTIFIER (prior entering this
-   function it's a FWL, so we can track errors more accurately */
+   function it's a FWL, so we can track errors more accurately.)  */
 
 static int
 check_method_redefinition (class, method)
@@ -4552,9 +4578,126 @@
   return 0;
 }
 
-/* Check all the methods of CLASS. Methods are first completed then
-   checked according to regular method existance rules.
-   If no constructor were encountered, then build its declaration. */
+static void
+check_abstract_method_definitions (do_interface, class_decl, type)
+     int do_interface;
+     tree class_decl, type;
+{
+  tree class = TREE_TYPE (class_decl);
+  tree method, end_type;
+
+  end_type = (do_interface ? object_type_node : type);
+  for (method = TYPE_METHODS (type); method; method = TREE_CHAIN (method))
+    {
+      tree other_super, other_method, method_sig, method_name;
+      int found = 0;
+      
+      if (!METHOD_ABSTRACT (method) || METHOD_FINAL (method))
+       continue;
+      
+      /* Now verify that somewhere in between TYPE and CLASS,
+        abstract method METHOD gets a non abstract definition
+        that is inherited by CLASS.  */
+      
+      method_sig = build_java_signature (TREE_TYPE (method));
+      method_name = DECL_NAME (method);
+      if (TREE_CODE (method_name) == EXPR_WITH_FILE_LOCATION)
+       method_name = EXPR_WFL_NODE (method_name);
+
+      for (other_super = class; other_super != end_type; 
+          other_super = CLASSTYPE_SUPER (other_super))
+       {
+         for (other_method = TYPE_METHODS (other_super); other_method;
+              other_method = TREE_CHAIN (other_method))
+           {
+             tree s = build_java_signature (TREE_TYPE (other_method));
+             tree other_name = DECL_NAME (other_method);
+
+             if (TREE_CODE (other_name) == EXPR_WITH_FILE_LOCATION)
+               other_name = EXPR_WFL_NODE (other_name);
+             if (!IS_CLINIT (other_method)
+                 && !DECL_CONSTRUCTOR_P (other_method)
+                 && method_name == other_name && method_sig == s)
+               {
+                 found = 1;
+                 break;
+               }
+           }
+       }
+      
+      /* Report that abstract METHOD didn't find an implementation
+        that CLASS can use. */
+      if (!found)
+       {
+         char *t = strdup (lang_printable_name 
+                           (TREE_TYPE (TREE_TYPE (method)), 0));
+         tree ccn = DECL_NAME (TYPE_NAME (DECL_CONTEXT (method)));
+         tree saved_wfl = NULL_TREE;
+         
+         if (TREE_CODE (DECL_NAME (method)) == EXPR_WITH_FILE_LOCATION)
+           {
+             saved_wfl = DECL_NAME (method);
+             DECL_NAME (method) = EXPR_WFL_NODE (DECL_NAME (method));
+           }
+         
+         parse_error_context 
+           (lookup_cl (class_decl),
+            "Class `%s' doesn't define the abstract method `%s %s' from "
+            "%s `%s'. This method must be defined or %s `%s' must be "
+            "declared abstract",
+            IDENTIFIER_POINTER (DECL_NAME (class_decl)),
+            t, lang_printable_name (method, 0), 
+            (CLASS_INTERFACE (TYPE_NAME (DECL_CONTEXT (method))) ? 
+             "interface" : "class"),
+            IDENTIFIER_POINTER (ccn),
+            (CLASS_INTERFACE (class_decl) ? "interface" : "class"),
+            IDENTIFIER_POINTER (DECL_NAME (class_decl)));
+         
+         free (t);
+         
+         if (saved_wfl)
+           DECL_NAME (method) = saved_wfl;
+       }
+    }
+}
+
+/* Check that CLASS_DECL somehoow implements all inherited abstract
+   methods.  */
+
+static void
+java_check_abstract_method_definitions (class_decl)
+     tree class_decl;
+{
+  tree class = TREE_TYPE (class_decl);
+  tree super, vector;
+  int i;
+
+  if (CLASS_ABSTRACT (class_decl))
+    return;
+
+  /* Check for inherited types */
+  for (super = CLASSTYPE_SUPER (class); super != object_type_node; 
+       super = CLASSTYPE_SUPER (super))
+    {
+      if (!CLASS_ABSTRACT (TYPE_NAME (super)))
+       continue;
+
+      check_abstract_method_definitions (0, class_decl, super);
+    }
+
+  /* Check for implemented interfaces. */
+  vector = TYPE_BINFO_BASETYPES (class);
+  for (i = 1; i < TREE_VEC_LENGTH (vector); i++)
+    {
+      super = BINFO_TYPE (TREE_VEC_ELT (vector, i));
+      check_abstract_method_definitions (1, class_decl, super);
+    }
+}
+
+/* Check all the methods of CLASS_DECL. Methods are first completed
+   then checked according to regular method existance rules.  If no
+   constructor for CLASS_DECL were encountered, then build its
+   declaration.  */
 
 static void
 java_check_regular_methods (class_decl)
@@ -4730,7 +4873,7 @@
   
   /* Don't forget eventual pending found and saved_found_wfl. Take
      into account that we might have exited because we saw an
-     aritifical method as the last entry. */
+     artificial method as the last entry. */
 
   if (found && !DECL_ARTIFICIAL (found) && saved_found_wfl)
     DECL_NAME (found) = saved_found_wfl;
@@ -4738,6 +4881,10 @@
   if (!TYPE_NVIRTUALS (class))
     TYPE_METHODS (class) = nreverse (TYPE_METHODS (class));
 
+  /* Search for inherited abstract method not yet implemented in this
+     class.  */
+  java_check_abstract_method_definitions (class_decl);
+
   if (!saw_constructor)
     {
       /* No constructor seen, we craft one, at line 0. Since this
@@ -4943,14 +5090,15 @@
   return NULL_TREE;
 }
 
-/* Return the line that matches DECL line number. Used during error
-   report */
+/* Return the line that matches DECL line number, and try its best to
+   position the column number. Used during error reports.  */
 
 static tree
 lookup_cl (decl)
      tree decl;
 {
   static tree cl = NULL_TREE;
+  char *line, *found;
   
   if (!decl)
     return NULL_TREE;
@@ -4961,6 +5109,14 @@
   EXPR_WFL_FILENAME_NODE (cl) = get_identifier (DECL_SOURCE_FILE (decl));
   EXPR_WFL_SET_LINECOL (cl, DECL_SOURCE_LINE_FIRST (decl), -1);
 
+  line = java_get_line_col (IDENTIFIER_POINTER (EXPR_WFL_FILENAME_NODE (cl)),
+                           EXPR_WFL_LINENO (cl), EXPR_WFL_COLNO (cl));
+
+  found = strstr ((const char *)line, 
+                 (const char *)IDENTIFIER_POINTER (DECL_NAME (decl)));
+  if (found)
+    EXPR_WFL_SET_LINECOL (cl, EXPR_WFL_LINENO (cl), found - line);
+
   return cl;
 }
 
@@ -5495,6 +5651,9 @@
   tree parm_decl;
   int i;
 
+  if (!fndecl)
+    return;
+
   current_function_decl = fndecl;
 
   /* New scope for the function */
@@ -5614,6 +5773,9 @@
   tree fndecl = current_function_decl;
   int flag_asynchronous_exceptions = asynchronous_exceptions;
 
+  if (!fndecl)
+    return;
+
   java_parser_context_save_global ();
   lineno = ctxp->last_ccb_indent1;
 
@@ -5669,6 +5831,8 @@
 java_method_add_stmt (fndecl, expr)
      tree fndecl, expr;
 {
+  if (!GET_CURRENT_BLOCK (fndecl))
+    return NULL_TREE;
   return add_stmt_to_block (GET_CURRENT_BLOCK (fndecl), NULL_TREE, expr);
 }
 
@@ -6067,7 +6231,8 @@
       for (mdecl = TYPE_METHODS (class); mdecl; mdecl = TREE_CHAIN (mdecl))
 	{
 	  if (DECL_CONSTRUCTOR_P (mdecl)
-	      && TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (mdecl))) == end_params_node)
+             && TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (mdecl))) 
+                == end_params_node)
 	    return 0;
 	}
     }
@@ -6410,6 +6575,8 @@
 	       == soft_initclass_node)
 	     return TREE_OPERAND (op1, 1);
 	 }
+      else if (JDECL_P (op1))
+       return op1;
     }
   return node;
 }
@@ -6431,6 +6598,8 @@
   for (q = EXPR_WFL_QUALIFICATION (wfl); q; q = TREE_CHAIN (q))
     {
       tree qual_wfl = QUAL_WFL (q);
+      tree ret_decl;           /* for EH checking */
+      int location;            /* for EH checking */
 
       /* 15.10.1 Field Access Using a Primary */
       switch (TREE_CODE (qual_wfl))
@@ -6449,14 +6618,21 @@
 	  /* And code for the function call */
 	  if (complete_function_arguments (qual_wfl))
 	    return 1;
+         
 	  if (from_super && TREE_CODE (qual_wfl) == CALL_EXPR)
 	    CALL_USING_SUPER (qual_wfl) = 1;
-	  *where_found = 
-	    patch_method_invocation (qual_wfl, decl, type, &is_static, NULL);
+         location = (TREE_CODE (qual_wfl) == CALL_EXPR ?
+                     EXPR_WFL_LINECOL (TREE_OPERAND (qual_wfl, 0)) : 0);
+         *where_found = patch_method_invocation (qual_wfl, decl, type, 
+                                                 &is_static, &ret_decl);
 	  if (*where_found == error_mark_node)
 	    return 1;
 	  *type_found = type = QUAL_DECL_TYPE (*where_found);
 
+         /* EH check */
+         if (location)
+           check_thrown_exceptions (location, ret_decl);
+
 	  /* If the previous call was static and this one is too,
 	     build a compound expression to hold the two (because in
 	     that case, previous function calls aren't transported as
@@ -6491,6 +6667,7 @@
 
 	case CONDITIONAL_EXPR:
 	case STRING_CST:
+	case MODIFY_EXPR:
 	  *where_found = decl = java_complete_tree (qual_wfl);
 	  if (decl == error_mark_node)
 	    return 1;
@@ -7228,6 +7405,11 @@
     if (JPRIMITIVE_TYPE_P (TREE_TYPE (TREE_VALUE (ta))) &&
 	TREE_TYPE (TREE_VALUE (ta)) != TREE_VALUE (t))
       TREE_VALUE (ta) = convert (TREE_VALUE (t), TREE_VALUE (ta));
+
+  /* Resolve unresolved returned type isses */
+  t = TREE_TYPE (TREE_TYPE (method));
+  if (TREE_CODE (t) == POINTER_TYPE && !CLASS_LOADED_P (TREE_TYPE (t)))
+    resolve_and_layout (TREE_TYPE (t), NULL);
   
   if (flag_emit_class_files || flag_emit_xref)
     func = method;
@@ -7388,7 +7570,7 @@
   parse_error_context (cl, "Can't find %s `%s(%s)' in class `%s'%s",
 		       (lc ? "constructor" : "method"),
 		       (lc ? 
-			IDENTIFIER_POINTER(DECL_NAME (TYPE_NAME (class))) :
+                       IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (class))) :
 			IDENTIFIER_POINTER (name)),
 		       IDENTIFIER_POINTER (signature),
 		       IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (class))),
@@ -7407,7 +7589,8 @@
   tree list = NULL_TREE, all_list = NULL_TREE;
 
   /* Search interfaces */
-  if (CLASS_INTERFACE (TYPE_NAME (class)))
+  if (CLASS_INTERFACE (TYPE_NAME (class)) 
+      || CLASS_ABSTRACT (TYPE_NAME (class)))
     {
       static tree searched_interfaces = NULL_TREE;
       static int search_not_done = 0;
@@ -7638,7 +7821,7 @@
 	break;
       case NEW_ARRAY_EXPR:
 	qual = TREE_CHAIN (qual);
-	new_array_found = 1;
+       again = new_array_found = 1;
 	continue;
       case NEW_CLASS_EXPR:
       case CONVERT_EXPR:
@@ -7666,12 +7849,8 @@
 	&& TREE_CODE (TREE_TYPE (qual_wfl)) == EXPR_WITH_FILE_LOCATION)
       name = EXPR_WFL_NODE (TREE_TYPE (qual_wfl));
 
-    else if (code == ARRAY_REF &&
-	     TREE_CODE (TREE_OPERAND (qual_wfl, 0)) == EXPR_WITH_FILE_LOCATION)
-      name = EXPR_WFL_NODE (TREE_OPERAND (qual_wfl, 0));
-
-    else if (code == CALL_EXPR && 
-	     TREE_CODE (TREE_OPERAND (qual_wfl, 0)) == EXPR_WITH_FILE_LOCATION)
+    else if ((code == ARRAY_REF || code == CALL_EXPR || code == MODIFY_EXPR) &&
+    	TREE_CODE (TREE_OPERAND (qual_wfl, 0)) == EXPR_WITH_FILE_LOCATION)
       name = EXPR_WFL_NODE (TREE_OPERAND (qual_wfl, 0));
 
     else if (code == STRING_CST || code == CONDITIONAL_EXPR)
@@ -7681,8 +7860,15 @@
 	again = 1;
       }
     else 
-      name = EXPR_WFL_NODE (qual_wfl);
-    
+      {
+       name = EXPR_WFL_NODE (qual_wfl);
+       if (!name)
+         {
+           qual = EXPR_WFL_QUALIFICATION (qual_wfl);
+           again = 1;
+         }
+      }
+
     /* If we have a THIS (from a primary), we set the context accordingly */
     if (name == this_identifier_node)
       {
@@ -7716,7 +7902,8 @@
      declaration or parameter declaration, then it is an expression
      name. We don't carry this test out if we're in the context of the
      use of SUPER or THIS */
-  if (!this_found && !super_found && (decl = IDENTIFIER_LOCAL_VALUE (name)))
+  if (!this_found && !super_found && 
+      TREE_CODE (name) != STRING_CST && (decl = IDENTIFIER_LOCAL_VALUE (name)))
     {
       RESOLVE_EXPRESSION_NAME_P (qual_wfl) = 1;
       QUAL_RESOLUTION (qual) = decl;
@@ -7733,15 +7920,17 @@
       QUAL_RESOLUTION (qual) = (new_array_found ? NULL_TREE : decl);
     }
 
-  /* We reclassify NAME as a type name if:
+  /* We reclassify NAME as yielding to a type name resolution if:
      - NAME is a class/interface declared within the compilation
        unit containing NAME,
      - NAME is imported via a single-type-import declaration,
      - NAME is declared in an another compilation unit of the package
        of the compilation unit containing NAME,
      - NAME is declared by exactly on type-import-on-demand declaration
-     of the compilation unit containing NAME. */
-  else if ((decl = resolve_and_layout (name, NULL_TREE)))
+     of the compilation unit containing NAME. 
+     - NAME is actually a STRING_CST. */
+  else if (TREE_CODE (name) == STRING_CST ||
+          (decl = resolve_and_layout (name, NULL_TREE)))
     {
       RESOLVE_TYPE_NAME_P (qual_wfl) = 1;
       QUAL_RESOLUTION (qual) = decl;
@@ -7826,7 +8015,9 @@
     {
       tree value = DECL_INITIAL (node);
       DECL_INITIAL (node) = NULL_TREE;
+      push_obstacks (&permanent_obstack, &permanent_obstack);
       value = fold_constant_for_init (value, node);
+      pop_obstacks ();
       DECL_INITIAL (node) = value;
       if (value != NULL_TREE)
 	return value;
@@ -7846,8 +8037,7 @@
       TREE_OPERAND (node, 1) = java_stabilize_reference (op1);
       return node;
     }
-  else
-    return stabilize_reference (node);
+  return stabilize_reference (node);
 }
 
 /* Patch tree nodes in a function body. When a BLOCK is found, push
@@ -8029,8 +8219,12 @@
 	  && JDECL_P (TREE_OPERAND (cn, 1))
 	  && FIELD_FINAL (TREE_OPERAND (cn, 1))
 	  && DECL_INITIAL (TREE_OPERAND (cn, 1)))
-	cn = fold_constant_for_init (DECL_INITIAL (TREE_OPERAND (cn, 1)),
-				     TREE_OPERAND (cn, 1));
+       {
+         push_obstacks (&permanent_obstack, &permanent_obstack);
+         cn = fold_constant_for_init (DECL_INITIAL (TREE_OPERAND (cn, 1)),
+                                      TREE_OPERAND (cn, 1));
+         pop_obstacks ();
+       }
 
       if (!TREE_CONSTANT (cn) && !flag_emit_xref)
 	{
@@ -8283,7 +8477,11 @@
 	  && TREE_CODE (nn) == VAR_DECL && TREE_STATIC (nn)
 	  && DECL_INITIAL (nn) != NULL_TREE)
 	{
-	  tree value = fold_constant_for_init (nn, nn);
+         tree value;
+         
+         push_obstacks (&permanent_obstack, &permanent_obstack);
+         value = fold_constant_for_init (nn, nn);
+         pop_obstacks ();
 	  if (value != NULL_TREE)
 	    {
 	      tree type = TREE_TYPE (value);
@@ -8297,14 +8495,17 @@
       if (TREE_OPERAND (node, 0) == error_mark_node)
 	return error_mark_node;
 
-      if (COMPOUND_ASSIGN_P (wfl_op2))
+      flag = COMPOUND_ASSIGN_P (wfl_op2);
+      if (flag)
 	{
 	  tree lvalue = java_stabilize_reference (TREE_OPERAND (node, 0)); 
 
 	  /* Hand stablize the lhs on both places */
 	  TREE_OPERAND (node, 0) = lvalue;
-	  TREE_OPERAND (TREE_OPERAND (node, 1), 0) = lvalue;
+         TREE_OPERAND (TREE_OPERAND (node, 1), 0) = 
+           (flag_emit_class_files ? lvalue : save_expr (lvalue));
 
+         /* 15.25.2.a: Left hand is not an array access. FIXME */
 	  /* Now complete the RHS. We write it back later on. */
 	  nn = java_complete_tree (TREE_OPERAND (node, 1));
 
@@ -8315,6 +8516,8 @@
 	     E1 = (T)(E1 op E2), with T being the type of E1. */
 	  nn = java_complete_tree (build_cast (EXPR_WFL_LINECOL (wfl_op2), 
 					       TREE_TYPE (lvalue), nn));
+
+         /* 15.25.2.b: Left hand is an array access. FIXME */
 	}
 
       /* If we're about to patch a NEW_ARRAY_INIT, we call a special
@@ -8338,6 +8541,10 @@
       if ((nn = patch_string (TREE_OPERAND (node, 1))))
 	TREE_OPERAND (node, 1) = nn;
       node = patch_assignment (node, wfl_op1, wfl_op2);
+      /* Reorganize the tree if necessary. */
+      if (flag && (!JREFERENCE_TYPE_P (TREE_TYPE (node)) 
+                  || JSTRING_P (TREE_TYPE (node))))
+       node = java_refold (node);
       CAN_COMPLETE_NORMALLY (node) = 1;
       return node;
 
@@ -9346,6 +9553,81 @@
 #undef BUILD_OPERATOR_STRING
 }
 
+/* Return 1 if VAR_ACCESS1 is equivalent to VAR_ACCESS2.  */
+
+static int
+java_decl_equiv (var_acc1, var_acc2)
+     tree var_acc1, var_acc2;
+{
+  if (JDECL_P (var_acc1))
+    return (var_acc1 == var_acc2);
+  
+  return (TREE_CODE (var_acc1) == COMPONENT_REF
+         && TREE_CODE (var_acc2) == COMPONENT_REF
+         && TREE_OPERAND (TREE_OPERAND (var_acc1, 0), 0)
+            == TREE_OPERAND (TREE_OPERAND (var_acc2, 0), 0)
+         && TREE_OPERAND (var_acc1, 1) == TREE_OPERAND (var_acc2, 1));
+}
+
+/* Return a non zero value if CODE is one of the operators that can be
+   used in conjunction with the `=' operator in a compound assignment.  */
+
+static int
+binop_compound_p (code)
+    enum tree_code code;
+{
+  int i;
+  for (i = 0; i < BINOP_COMPOUND_CANDIDATES; i++)
+    if (binop_lookup [i] == code)
+      break;
+
+  return i < BINOP_COMPOUND_CANDIDATES;
+}
+
+/* Reorganize after a fold to get SAVE_EXPR to generate what we want.  */
+
+static tree
+java_refold (t)
+     tree t;
+{
+  tree c, b, ns, decl;
+
+  if (TREE_CODE (t) != MODIFY_EXPR)
+    return t;
+
+  c = TREE_OPERAND (t, 1);
+  if (! (c && TREE_CODE (c) == COMPOUND_EXPR
+        && TREE_CODE (TREE_OPERAND (c, 0)) == MODIFY_EXPR
+        && binop_compound_p (TREE_CODE (TREE_OPERAND (c, 1)))))
+    return t;
+
+  /* Now the left branch of the binary operator. */
+  b = TREE_OPERAND (TREE_OPERAND (c, 1), 0);
+  if (! (b && TREE_CODE (b) == NOP_EXPR 
+        && TREE_CODE (TREE_OPERAND (b, 0)) == SAVE_EXPR))
+    return t;
+
+  ns = TREE_OPERAND (TREE_OPERAND (b, 0), 0);
+  if (! (ns && TREE_CODE (ns) == NOP_EXPR
+        && TREE_CODE (TREE_OPERAND (ns, 0)) == SAVE_EXPR))
+    return t;
+
+  decl = TREE_OPERAND (TREE_OPERAND (ns, 0), 0);
+  if ((JDECL_P (decl) || TREE_CODE (decl) == COMPONENT_REF)
+      /* It's got to be the an equivalent decl */
+      && java_decl_equiv (decl, TREE_OPERAND (TREE_OPERAND (c, 0), 0)))
+    {
+      /* Shorten the NOP_EXPR/SAVE_EXPR path. */
+      TREE_OPERAND (TREE_OPERAND (c, 1), 0) = TREE_OPERAND (ns, 0);
+      /* Substitute the COMPOUND_EXPR by the BINOP_EXPR */
+      TREE_OPERAND (t, 1) = TREE_OPERAND (c, 1);
+      /* Change the right part of the BINOP_EXPR */
+      TREE_OPERAND (TREE_OPERAND (t, 1), 1) = TREE_OPERAND (c, 0);
+    }
+
+  return t;
+}
+
 /* Binary operators (15.16 up to 15.18). We return error_mark_node on
    errors but we modify NODE so that it contains the type computed
    according to the expression, when it's fixed. Otherwise, we write
@@ -9392,6 +9674,12 @@
       if (code == RDIV_EXPR && TREE_CODE (prom_type) == INTEGER_TYPE)
 	TREE_SET_CODE (node, TRUNC_DIV_EXPR);
 
+      if (TREE_CODE (prom_type) == INTEGER_TYPE
+        && flag_use_divide_subroutine
+        && ! flag_emit_class_files
+        && (code == RDIV_EXPR || code == TRUNC_MOD_EXPR))
+      return build_java_soft_divmod (TREE_CODE (node), prom_type, op1, op2);
+ 
       /* This one is more complicated. FLOATs are processed by a
 	 function call to soft_fmod. Duplicate the value of the
 	 COMPOUND_ASSIGN_P flag. */
@@ -10004,7 +10292,7 @@
     case PREINCREMENT_EXPR:
       /* 15.14.2 Prefix Decrement Operator -- */
     case PREDECREMENT_EXPR:
-      decl = strip_out_static_field_access_decl (op);
+      op = decl = strip_out_static_field_access_decl (op);
       /* We really should have a JAVA_ARRAY_EXPR to avoid this */
       if (!JDECL_P (decl) 
 	  && TREE_CODE (decl) != COMPONENT_REF
@@ -10043,15 +10331,28 @@
       else
 	{
 	  /* Before the addition, binary numeric promotion is performed on
-	     both operands */
-	  value = build_int_2 (1, 0);
-	  TREE_TYPE (node) = 
-	    binary_numeric_promotion (op_type, TREE_TYPE (value), &op, &value);
-	  /* And write the promoted incremented and increment */
+            both operands, if really necessary */
+         if (JINTEGRAL_TYPE_P (op_type))
+           {
+             value = build_int_2 (1, 0);
+             TREE_TYPE (value) = TREE_TYPE (node) = op_type;
+           }
+         else
+           {
+             value = build_int_2 (1, 0);
+             TREE_TYPE (node) = 
+               binary_numeric_promotion (op_type, 
+                                         TREE_TYPE (value), &op, &value);
+           }
+         /* And write back into the node. */
 	  TREE_OPERAND (node, 0) = op;
 	  TREE_OPERAND (node, 1) = value;
-	  /* Convert the overall back into its original type. */
-	  return fold (convert (op_type, node));
+         /* Convert the overall back into its original type, if
+             necessary, and return */
+         if (JINTEGRAL_TYPE_P (op_type))
+           return fold (node);
+         else
+           return fold (convert (op_type, node));
 	}
       break;
 
@@ -10556,6 +10857,7 @@
   new_value = NULL_TREE;
   wfl_value = TREE_VALUE (entry);
 
+  push_obstacks (&permanent_obstack, &permanent_obstack);
   value = java_complete_tree (TREE_VALUE (entry));
   /* patch_string return error_mark_node if arg is error_mark_node */
   if ((patched = patch_string (value)))
@@ -10571,7 +10873,8 @@
   new_value = try_builtin_assignconv (wfl_operator, type, value);
   if (!new_value && (new_value = try_reference_assignconv (type, value)))
     type_value = promote_type (type);
-  
+
+  pop_obstacks ();
   /* Check and report errors */
   if (!new_value)
     {
@@ -10910,6 +11213,54 @@
   return loop;
 }
 
+/* Try to find the loop a block might be related to. This comprises
+   the case where the LOOP_EXPR is found as the second operand of a
+   COMPOUND_EXPR, because the loop happens to have an initialization
+   part, then expressed as the first operand of the COMPOUND_EXPR. If
+   the search finds something, 1 is returned. Otherwise, 0 is
+   returned. The search is assumed to start from a
+   LABELED_BLOCK_EXPR's block.  */
+
+static tree
+search_loop (statement)
+    tree statement;
+{
+  if (TREE_CODE (statement) == LOOP_EXPR)
+    return statement;
+
+  if (TREE_CODE (statement) == BLOCK)
+    statement = BLOCK_SUBBLOCKS (statement);
+  else
+    return NULL_TREE;
+
+  if (statement && TREE_CODE (statement) == COMPOUND_EXPR)
+    while (statement && TREE_CODE (statement) == COMPOUND_EXPR)
+      statement = TREE_OPERAND (statement, 1);
+
+  return (TREE_CODE (statement) == LOOP_EXPR
+         && IS_FOR_LOOP_P (statement) ? statement : NULL_TREE);
+}
+
+/* Return 1 if LOOP can be found in the labeled block BLOCK. 0 is
+   returned otherwise.  */
+
+static int
+labeled_block_contains_loop_p (block, loop)
+    tree block, loop;
+{
+  if (!block)
+    return 0;
+
+  if (LABELED_BLOCK_BODY (block) == loop)
+    return 1;
+
+  if (IS_FOR_LOOP_P (loop) 
+      && search_loop (LABELED_BLOCK_BODY (block)) == loop)
+    return 1;
+
+  return 0;
+}
+
 /* If the loop isn't surrounded by a labeled statement, create one and
    insert LOOP as its body.  */
 
@@ -10918,33 +11269,17 @@
      tree loop;
 {
   tree loop_label;
-  tree block = ctxp->current_labeled_block;
+
   TREE_TYPE (loop) = void_type_node;
-  if (block != NULL_TREE)
-    {
-      tree block_body = LABELED_BLOCK_BODY (block);
-      if (IS_FOR_LOOP_P (loop))
-	{
-	  if (TREE_CODE (block_body) == BLOCK)
-	    {
-	      block_body = BLOCK_EXPR_BODY (block_body);
-	      if (block_body == loop
-		  || (TREE_CODE (block_body) == COMPOUND_EXPR
-		      && TREE_OPERAND (block_body, 1) == loop))
-		return loop;
-	    }
-	}
-      else
-	{
-	  if (block_body == loop)
-	    return loop;
-	}
-    }
+  if (labeled_block_contains_loop_p (ctxp->current_labeled_block, loop))
+    return loop;
+
   loop_label = build_labeled_block (0, NULL_TREE);
+  /* LOOP is an EXPR node, so it should have a valid EXPR_WFL_LINECOL
+     that LOOP_LABEL could enquire about, for a better accuracy. FIXME */
   LABELED_BLOCK_BODY (loop_label) = loop;
   PUSH_LABELED_BLOCK (loop_label);
-  loop = loop_label;
-  return loop;
+  return loop_label;
 }
 
 /* 14.13, 14.14: break and continue Statements */
@@ -11036,7 +11371,7 @@
 	    }
 	  target_stmt = LABELED_BLOCK_BODY (labeled_block);
 	  if (TREE_CODE (target_stmt) == SWITCH_EXPR
-	      || TREE_CODE (target_stmt) == LOOP_EXPR)
+             || search_loop (target_stmt))
 	    {
 	      bc_label = labeled_block;
 	      break;
@@ -11050,7 +11385,7 @@
   /* Our break/continue don't return values. */
   TREE_TYPE (node) = void_type_node;
   /* Encapsulate the break within a compound statement so that it's
-     expanded all the times by expand_expr (and not clobered
+     expanded all the times by expand_expr (and not clobbered
      sometimes, like after a if statement) */
   node = add_stmt_to_compound (NULL_TREE, void_type_node, node);
   TREE_SIDE_EFFECTS (node) = 1;
@@ -11445,11 +11780,20 @@
 	  continue;
 #endif
 	EXPR_WFL_LINECOL (wfl_operator) = location;
-	parse_error_context 
-	  (wfl_operator, "Exception `%s' must be caught, or it must be "
-	   "declared in the `throws' clause of `%s'", 
-	   lang_printable_name (TREE_VALUE (throws), 0),
-	   IDENTIFIER_POINTER (DECL_NAME (current_function_decl)));
+       if (DECL_NAME (current_function_decl) == finit_identifier_node)
+         parse_error_context
+            (wfl_operator, "Exception `%s' can't be thrown in initializer",
+            lang_printable_name (TREE_VALUE (throws), 0));
+       else 
+         {
+           parse_error_context 
+             (wfl_operator, "Exception `%s' must be caught, or it must be "
+              "declared in the `throws' clause of `%s'", 
+              lang_printable_name (TREE_VALUE (throws), 0),
+              (DECL_NAME (current_function_decl) == init_identifier_node ?
+               IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (current_class))) :
+               IDENTIFIER_POINTER (DECL_NAME (current_function_decl))));
+         }
       }
 }
 
Only in gcc-2.95.2/gcc/java: parse.y.orig
Only in gcc-2.95.2/gcc/java: parse.y.rej
Only in gcc-2.95.2/gcc/java: super.patch
diff -u -r gcc-2.95.2-orig/gcc/java/typeck.c gcc-2.95.2/gcc/java/typeck.c
--- gcc-2.95.2-orig/gcc/java/typeck.c	Fri May 14 02:33:34 1999
+++ gcc-2.95.2/gcc/java/typeck.c	Sat Oct 30 19:45:50 1999
@@ -55,23 +55,43 @@
 
 /* Convert an IEEE real to an integer type.  The result of such a
    conversion when the source operand is a NaN isn't defined by
-   IEEE754, but by the Java language standard: it must be zero.  This
-   conversion produces something like:
-   
-   ({ double tmp = expr; (tmp != tmp) ? 0 : (int)tmp; })
-
-   */
+   IEEE754, but by the Java language standard: it must be zero.  Also,
+   overflows must be clipped to within range.  This conversion
+   produces something like:
+
+      ((expr >= (float)MAX_INT)
+       ? MAX_INT 
+       : ((expr <= (float)MIN_INT)
+        ? MIN_INT
+        : ((expr != expr)
+           ? 0 
+           : (int)expr))) */
 
 static tree
 convert_ieee_real_to_integer (type, expr)
      tree type, expr;
 {
+  tree result;
   expr = save_expr (expr);
 
-  return build (COND_EXPR, type, 
-		build (NE_EXPR, boolean_type_node, expr, expr),
-		convert (type, integer_zero_node),
-		convert_to_integer (type, expr));
+  result = build (COND_EXPR, type,
+                build (NE_EXPR, boolean_type_node, expr, expr),
+                convert (type, integer_zero_node),
+                convert_to_integer (type, expr));
+                
+  result = build (COND_EXPR, type, 
+                build (LE_EXPR, boolean_type_node, expr, 
+                       convert (TREE_TYPE (expr), TYPE_MIN_VALUE (type))),
+                TYPE_MIN_VALUE (type),
+                result);
+
+  result = build (COND_EXPR, type,
+                build (GE_EXPR, boolean_type_node, expr, 
+                       convert (TREE_TYPE (expr), TYPE_MAX_VALUE (type))),    
+                TYPE_MAX_VALUE (type),
+                result);
+
+  return result;
 }  
 
 /* Create an expression whose value is that of EXPR,
@@ -100,12 +120,9 @@
     return fold (convert_to_boolean (type, expr));
   if (code == INTEGER_TYPE)
     {
-      if (TREE_CODE (TREE_TYPE (expr)) == REAL_TYPE
-#ifdef TARGET_SOFT_FLOAT
-	  && !TARGET_SOFT_FLOAT
-#endif
-	  && !flag_emit_class_files
-	  && !flag_fast_math
+      if (! flag_fast_math
+        && ! flag_emit_class_files
+        && TREE_CODE (TREE_TYPE (expr)) == REAL_TYPE
 	  && TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT)
 	return fold (convert_ieee_real_to_integer (type, expr));
       else
Only in gcc-2.95.2/gcc/java: typeck.c.orig
diff -u -r gcc-2.95.2-orig/gcc/java/verify.c gcc-2.95.2/gcc/java/verify.c
--- gcc-2.95.2-orig/gcc/java/verify.c	Wed Jun 23 11:33:10 1999
+++ gcc-2.95.2/gcc/java/verify.c	Sun Oct 31 14:53:38 1999
@@ -397,7 +397,8 @@
 	  || handler_pc < 0 || handler_pc >= length
 	  || (handler_pc >= start_pc && handler_pc < end_pc)
 	  || ! (instruction_bits [start_pc] & BCODE_INSTRUCTION_START)
-	  || ! (instruction_bits [end_pc] & BCODE_INSTRUCTION_START)
+         || (end_pc < length &&
+            ! (instruction_bits [end_pc] & BCODE_INSTRUCTION_START))
 	  || ! (instruction_bits [handler_pc] & BCODE_INSTRUCTION_START))
 	{
 	  error ("bad pc in exception_table");
