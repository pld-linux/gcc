The problem here is fold (build_range_check) converts
"-1073741824 <= n && n <= 1073741823" to "n + 1073741824 >= 0"
which makes depends on signed overflow being defined.  Fold later converts
it to "n >= -1073741824" by my recent patch which is wrong.
This patch fixes the problem by using unsigned types if signed overflow
is undefined.

OK? Bootstrapped and tested on x86_64-pc-linux-gnu with no regressions.

Thanks,
Andrew Pinski

	* fold-const.c (build_range_check): Use unsigned when signed
	overflow is undefined also.  If etype is subtype, make sure that
	the subtraction is in the supper type.

--- a/gcc/fold-const.c	2005-10-19 08:15:39.000000000 +0000
+++ b/gcc/fold-const.c	2005-10-19 08:29:46.574021728 +0000
@@ -4005,7 +4005,8 @@
     }
 
   value = const_binop (MINUS_EXPR, high, low, 0);
-  if (value != 0 && TREE_OVERFLOW (value) && ! TYPE_UNSIGNED (etype))
+  if (value != 0 && (!flag_wrapv || TREE_OVERFLOW (value))
+      && ! TYPE_UNSIGNED (etype))
     {
       tree utype, minv, maxv;
 
@@ -4016,6 +4017,11 @@
 	case INTEGER_TYPE:
 	case ENUMERAL_TYPE:
 	case CHAR_TYPE:
+	  /* There is no requirement that LOW be within the range of ETYPE
+	     if the latter is a subtype.  It must, however, be within the base
+	     type of ETYPE.  So be sure we do the subtraction in that type.  */
+	  if (TREE_TYPE (etype))
+	    etype = TREE_TYPE (etype);
 	  utype = lang_hooks.types.unsigned_type (etype);
 	  maxv = fold_convert (utype, TYPE_MAX_VALUE (etype));
 	  maxv = range_binop (PLUS_EXPR, NULL_TREE, maxv, 1,
