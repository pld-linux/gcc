--- gcc/gcc/gimplify.c	20 Jul 2005 01:18:18 -0000	2.142
+++ gcc/gcc/gimplify.c	20 Jul 2005 17:03:36 -0000
@@ -298,6 +298,28 @@ create_artificial_label (void)
   return lab;
 }
 
+/* Create an ADDR_EXPR for T,  if T is a CONSTRUCTOR, create a temporary
+   variable to hold the CONSTRUCTOR.  */
+
+static tree
+gimplify_build_fold_addr_expr (tree t)
+{
+  if (TREE_CODE (t) == CONSTRUCTOR)
+    {
+      tree new_t;
+      tree new_var
+	= create_tmp_var (TREE_TYPE (t), NULL);
+      TREE_ADDRESSABLE (new_var) = 1;
+      TREE_READONLY (new_var) = 1;
+      DECL_INITIAL (new_var) = t;
+      new_t = build1 (DECL_EXPR, void_type_node, new_var);
+      t = build_fold_addr_expr (new_var);
+      t = build2 (COMPOUND_EXPR, TREE_TYPE (t), new_t, t);
+      return t;
+    }
+  return build_fold_addr_expr (t); 
+}
+
 /* Create a new temporary name with PREFIX.  Returns an identifier.  */
 
 static GTY(()) unsigned int tmp_var_id_num;
@@ -3224,9 +3246,9 @@ gimplify_variable_sized_compare (tree *e
   t = unshare_expr (t);
   t = SUBSTITUTE_PLACEHOLDER_IN_EXPR (t, op0);
   args = tree_cons (NULL, t, NULL);
-  t = build_fold_addr_expr (op1);
+  t = gimplify_build_fold_addr_expr (op1);
   args = tree_cons (NULL, t, args);
-  dest = build_fold_addr_expr (op0);
+  dest = gimplify_build_fold_addr_expr (op0);
   args = tree_cons (NULL, dest, args);
   t = implicit_built_in_decls[BUILT_IN_MEMCMP];
   t = build_function_call_expr (t, args);
@@ -3441,9 +3463,9 @@ gimplify_addr_expr (tree *expr_p, tree *
 	 same type.  */
       if (tree_ssa_useless_type_conversion (TREE_OPERAND (op0, 0)))
 	op0 = TREE_OPERAND (op0, 0);
-
-      *expr_p = fold_convert (TREE_TYPE (expr),
-			      build_fold_addr_expr (TREE_OPERAND (op0, 0)));
+      
+      op0 = gimplify_build_fold_addr_expr (TREE_OPERAND (op0, 0));
+      *expr_p = fold_convert (TREE_TYPE (expr), op0);
       ret = GS_OK;
       break;
 
--- gcc/gcc/ada/trans.c	20 Jul 2005 01:18:53 -0000	1.101
+++ gcc/gcc/ada/trans.c	20 Jul 2005 17:03:39 -0000
@@ -4549,28 +4549,6 @@ gnat_gimplify_expr (tree *expr_p, tree *
       *expr_p = TREE_OPERAND (*expr_p, 0);
       return GS_OK;
 
-    case ADDR_EXPR:
-      /* If we're taking the address of a constant CONSTRUCTOR, force it to
-	 be put into static memory.  We know it's going to be readonly given
-	 the semantics we have and it's required to be static memory in
-	 the case when the reference is in an elaboration procedure.  */
-      if (TREE_CODE (TREE_OPERAND (expr, 0)) == CONSTRUCTOR
-	  && TREE_CONSTANT (TREE_OPERAND (expr, 0)))
-	{
-	  tree new_var
-	    = create_tmp_var (TREE_TYPE (TREE_OPERAND (expr, 0)), "C");
-
-	  TREE_READONLY (new_var) = 1;
-	  TREE_STATIC (new_var) = 1;
-	  TREE_ADDRESSABLE (new_var) = 1;
-	  DECL_INITIAL (new_var) = TREE_OPERAND (expr, 0);
-
-	  TREE_OPERAND (expr, 0) = new_var;
-	  recompute_tree_invarant_for_addr_expr (expr);
-	  return GS_ALL_DONE;
-	}
-      return GS_UNHANDLED;
-
     case COMPONENT_REF:
       /* We have a kludge here.  If the FIELD_DECL is from a fat pointer and is
 	 from an early dummy type, replace it with the proper FIELD_DECL.  */
@@ -5361,7 +5339,6 @@ addressable_p (tree gnu_expr)
 
     case UNCONSTRAINED_ARRAY_REF:
     case INDIRECT_REF:
-    case CONSTRUCTOR:
     case NULL_EXPR:
     case SAVE_EXPR:
       return true;
--- gcc/gcc/ada/utils2.c	20 Jul 2005 01:18:55 -0000	1.50
+++ gcc/gcc/ada/utils2.c	20 Jul 2005 17:03:39 -0000
@@ -45,6 +45,8 @@
 #include "einfo.h"
 #include "ada-tree.h"
 #include "gigi.h"
+#include "tree-gimple.h"
+#include "toplev.h"
 
 static tree find_common_type (tree, tree);
 static bool contains_save_expr_p (tree);
@@ -1032,6 +1034,7 @@ build_unary_op (enum tree_code op_code, 
   tree operation_type = result_type;
   tree result;
   bool side_effects = false;
+  tree before = NULL;
 
   if (operation_type
       && TREE_CODE (operation_type) == RECORD_TYPE
@@ -1150,6 +1153,22 @@ build_unary_op (enum tree_code op_code, 
 				result);
 	      break;
 	    }
+	  else
+	    {
+	      /* Create a temporary variable to hold the CONSTRUCTON.  */
+	      tree new_var = create_tmp_var_raw (type, NULL);
+	      TREE_ADDRESSABLE (new_var) = 1;
+	      TREE_READONLY (new_var) = 1;
+	      if (global_bindings_p ())
+		TREE_STATIC (new_var) = 1;
+	      DECL_INITIAL (new_var) = operand;
+	      gnat_pushdecl (new_var, Empty);
+	      if (global_bindings_p ())
+		rest_of_decl_compilation (new_var, 1, 0);
+	      else
+		before = build1 (DECL_EXPR, void_type_node, new_var);
+	      operand = new_var;
+	    }
 
 	  goto common;
 
@@ -1198,6 +1217,9 @@ build_unary_op (enum tree_code op_code, 
 	}
 
       TREE_CONSTANT (result) = staticp (operand) || TREE_CONSTANT (operand);
+      if (before)
+        result = build2 (COMPOUND_EXPR, TREE_TYPE (result), before,
+			      result);
       break;
 
     case INDIRECT_REF:
@@ -1964,10 +1986,6 @@ gnat_mark_addressable (tree expr_node)
 	expr_node = TREE_OPERAND (expr_node, 0);
 	break;
 
-      case CONSTRUCTOR:
-	TREE_ADDRESSABLE (expr_node) = 1;
-	return true;
-
       case VAR_DECL:
       case PARM_DECL:
       case RESULT_DECL:
